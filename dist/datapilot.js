#!/usr/bin/env node
import require$$0$2 from 'events';
import require$$1 from 'child_process';
import path$1, { basename } from 'path';
import fs, { existsSync, statSync, openSync, readSync, closeSync, readFileSync, createReadStream, writeFileSync, realpathSync as realpathSync$1, readlinkSync, readdirSync, readdir as readdir$1, lstatSync } from 'fs';
import require$$4 from 'process';
import process$1 from 'node:process';
import os from 'node:os';
import tty from 'node:tty';
import require$$0$3 from 'assert';
import readline from 'node:readline';
import require$$0$4, { Transform } from 'stream';
import require$$0$5 from 'buffer';
import require$$0$6 from 'util';
import os$1 from 'os';
import { pipeline } from 'stream/promises';
import 'crypto';
import fs$1 from 'fs/promises';
import require$$0$7 from 'readline';
import { fileURLToPath } from 'node:url';
import { win32, posix } from 'node:path';
import * as actualFS from 'node:fs';
import { realpath, readlink, readdir, lstat } from 'node:fs/promises';
import { EventEmitter } from 'node:events';
import Stream from 'node:stream';
import { StringDecoder } from 'node:string_decoder';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var commander$1 = {exports: {}};

var argument = {};

var error = {};

/**
 * CommanderError class
 * @class
 */

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	class CommanderError extends Error {
	  /**
	   * Constructs the CommanderError class
	   * @param {number} exitCode suggested exit code which could be used with process.exit
	   * @param {string} code an id string representing the error
	   * @param {string} message human-readable description of the error
	   * @constructor
	   */
	  constructor(exitCode, code, message) {
	    super(message);
	    // properly capture stack trace in Node.js
	    Error.captureStackTrace(this, this.constructor);
	    this.name = this.constructor.name;
	    this.code = code;
	    this.exitCode = exitCode;
	    this.nestedError = undefined;
	  }
	}

	/**
	 * InvalidArgumentError class
	 * @class
	 */
	class InvalidArgumentError extends CommanderError {
	  /**
	   * Constructs the InvalidArgumentError class
	   * @param {string} [message] explanation of why argument is invalid
	   * @constructor
	   */
	  constructor(message) {
	    super(1, 'commander.invalidArgument', message);
	    // properly capture stack trace in Node.js
	    Error.captureStackTrace(this, this.constructor);
	    this.name = this.constructor.name;
	  }
	}

	error.CommanderError = CommanderError;
	error.InvalidArgumentError = InvalidArgumentError;
	return error;
}

var hasRequiredArgument;

function requireArgument () {
	if (hasRequiredArgument) return argument;
	hasRequiredArgument = 1;
	const { InvalidArgumentError } = requireError();

	class Argument {
	  /**
	   * Initialize a new command argument with the given name and description.
	   * The default is that the argument is required, and you can explicitly
	   * indicate this with <> around the name. Put [] around the name for an optional argument.
	   *
	   * @param {string} name
	   * @param {string} [description]
	   */

	  constructor(name, description) {
	    this.description = description || '';
	    this.variadic = false;
	    this.parseArg = undefined;
	    this.defaultValue = undefined;
	    this.defaultValueDescription = undefined;
	    this.argChoices = undefined;

	    switch (name[0]) {
	      case '<': // e.g. <required>
	        this.required = true;
	        this._name = name.slice(1, -1);
	        break;
	      case '[': // e.g. [optional]
	        this.required = false;
	        this._name = name.slice(1, -1);
	        break;
	      default:
	        this.required = true;
	        this._name = name;
	        break;
	    }

	    if (this._name.length > 3 && this._name.slice(-3) === '...') {
	      this.variadic = true;
	      this._name = this._name.slice(0, -3);
	    }
	  }

	  /**
	   * Return argument name.
	   *
	   * @return {string}
	   */

	  name() {
	    return this._name;
	  }

	  /**
	   * @api private
	   */

	  _concatValue(value, previous) {
	    if (previous === this.defaultValue || !Array.isArray(previous)) {
	      return [value];
	    }

	    return previous.concat(value);
	  }

	  /**
	   * Set the default value, and optionally supply the description to be displayed in the help.
	   *
	   * @param {*} value
	   * @param {string} [description]
	   * @return {Argument}
	   */

	  default(value, description) {
	    this.defaultValue = value;
	    this.defaultValueDescription = description;
	    return this;
	  }

	  /**
	   * Set the custom handler for processing CLI command arguments into argument values.
	   *
	   * @param {Function} [fn]
	   * @return {Argument}
	   */

	  argParser(fn) {
	    this.parseArg = fn;
	    return this;
	  }

	  /**
	   * Only allow argument value to be one of choices.
	   *
	   * @param {string[]} values
	   * @return {Argument}
	   */

	  choices(values) {
	    this.argChoices = values.slice();
	    this.parseArg = (arg, previous) => {
	      if (!this.argChoices.includes(arg)) {
	        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
	      }
	      if (this.variadic) {
	        return this._concatValue(arg, previous);
	      }
	      return arg;
	    };
	    return this;
	  }

	  /**
	   * Make argument required.
	   */
	  argRequired() {
	    this.required = true;
	    return this;
	  }

	  /**
	   * Make argument optional.
	   */
	  argOptional() {
	    this.required = false;
	    return this;
	  }
	}

	/**
	 * Takes an argument and returns its human readable equivalent for help usage.
	 *
	 * @param {Argument} arg
	 * @return {string}
	 * @api private
	 */

	function humanReadableArgName(arg) {
	  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

	  return arg.required
	    ? '<' + nameOutput + '>'
	    : '[' + nameOutput + ']';
	}

	argument.Argument = Argument;
	argument.humanReadableArgName = humanReadableArgName;
	return argument;
}

var command = {};

var help = {};

var hasRequiredHelp;

function requireHelp () {
	if (hasRequiredHelp) return help;
	hasRequiredHelp = 1;
	const { humanReadableArgName } = requireArgument();

	/**
	 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
	 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
	 * @typedef { import("./argument.js").Argument } Argument
	 * @typedef { import("./command.js").Command } Command
	 * @typedef { import("./option.js").Option } Option
	 */

	// Although this is a class, methods are static in style to allow override using subclass or just functions.
	class Help {
	  constructor() {
	    this.helpWidth = undefined;
	    this.sortSubcommands = false;
	    this.sortOptions = false;
	    this.showGlobalOptions = false;
	  }

	  /**
	   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
	   *
	   * @param {Command} cmd
	   * @returns {Command[]}
	   */

	  visibleCommands(cmd) {
	    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
	    if (cmd._hasImplicitHelpCommand()) {
	      // Create a command matching the implicit help command.
	      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
	      const helpCommand = cmd.createCommand(helpName)
	        .helpOption(false);
	      helpCommand.description(cmd._helpCommandDescription);
	      if (helpArgs) helpCommand.arguments(helpArgs);
	      visibleCommands.push(helpCommand);
	    }
	    if (this.sortSubcommands) {
	      visibleCommands.sort((a, b) => {
	        // @ts-ignore: overloaded return type
	        return a.name().localeCompare(b.name());
	      });
	    }
	    return visibleCommands;
	  }

	  /**
	   * Compare options for sort.
	   *
	   * @param {Option} a
	   * @param {Option} b
	   * @returns number
	   */
	  compareOptions(a, b) {
	    const getSortKey = (option) => {
	      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
	      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
	    };
	    return getSortKey(a).localeCompare(getSortKey(b));
	  }

	  /**
	   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
	   *
	   * @param {Command} cmd
	   * @returns {Option[]}
	   */

	  visibleOptions(cmd) {
	    const visibleOptions = cmd.options.filter((option) => !option.hidden);
	    // Implicit help
	    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
	    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
	    if (showShortHelpFlag || showLongHelpFlag) {
	      let helpOption;
	      if (!showShortHelpFlag) {
	        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
	      } else if (!showLongHelpFlag) {
	        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
	      } else {
	        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
	      }
	      visibleOptions.push(helpOption);
	    }
	    if (this.sortOptions) {
	      visibleOptions.sort(this.compareOptions);
	    }
	    return visibleOptions;
	  }

	  /**
	   * Get an array of the visible global options. (Not including help.)
	   *
	   * @param {Command} cmd
	   * @returns {Option[]}
	   */

	  visibleGlobalOptions(cmd) {
	    if (!this.showGlobalOptions) return [];

	    const globalOptions = [];
	    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
	      const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
	      globalOptions.push(...visibleOptions);
	    }
	    if (this.sortOptions) {
	      globalOptions.sort(this.compareOptions);
	    }
	    return globalOptions;
	  }

	  /**
	   * Get an array of the arguments if any have a description.
	   *
	   * @param {Command} cmd
	   * @returns {Argument[]}
	   */

	  visibleArguments(cmd) {
	    // Side effect! Apply the legacy descriptions before the arguments are displayed.
	    if (cmd._argsDescription) {
	      cmd.registeredArguments.forEach(argument => {
	        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
	      });
	    }

	    // If there are any arguments with a description then return all the arguments.
	    if (cmd.registeredArguments.find(argument => argument.description)) {
	      return cmd.registeredArguments;
	    }
	    return [];
	  }

	  /**
	   * Get the command term to show in the list of subcommands.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  subcommandTerm(cmd) {
	    // Legacy. Ignores custom usage string, and nested commands.
	    const args = cmd.registeredArguments.map(arg => humanReadableArgName(arg)).join(' ');
	    return cmd._name +
	      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
	      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
	      (args ? ' ' + args : '');
	  }

	  /**
	   * Get the option term to show in the list of options.
	   *
	   * @param {Option} option
	   * @returns {string}
	   */

	  optionTerm(option) {
	    return option.flags;
	  }

	  /**
	   * Get the argument term to show in the list of arguments.
	   *
	   * @param {Argument} argument
	   * @returns {string}
	   */

	  argumentTerm(argument) {
	    return argument.name();
	  }

	  /**
	   * Get the longest command term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestSubcommandTermLength(cmd, helper) {
	    return helper.visibleCommands(cmd).reduce((max, command) => {
	      return Math.max(max, helper.subcommandTerm(command).length);
	    }, 0);
	  }

	  /**
	   * Get the longest option term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestOptionTermLength(cmd, helper) {
	    return helper.visibleOptions(cmd).reduce((max, option) => {
	      return Math.max(max, helper.optionTerm(option).length);
	    }, 0);
	  }

	  /**
	   * Get the longest global option term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestGlobalOptionTermLength(cmd, helper) {
	    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
	      return Math.max(max, helper.optionTerm(option).length);
	    }, 0);
	  }

	  /**
	   * Get the longest argument term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestArgumentTermLength(cmd, helper) {
	    return helper.visibleArguments(cmd).reduce((max, argument) => {
	      return Math.max(max, helper.argumentTerm(argument).length);
	    }, 0);
	  }

	  /**
	   * Get the command usage to be displayed at the top of the built-in help.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  commandUsage(cmd) {
	    // Usage
	    let cmdName = cmd._name;
	    if (cmd._aliases[0]) {
	      cmdName = cmdName + '|' + cmd._aliases[0];
	    }
	    let ancestorCmdNames = '';
	    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
	      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
	    }
	    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
	  }

	  /**
	   * Get the description for the command.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  commandDescription(cmd) {
	    // @ts-ignore: overloaded return type
	    return cmd.description();
	  }

	  /**
	   * Get the subcommand summary to show in the list of subcommands.
	   * (Fallback to description for backwards compatibility.)
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  subcommandDescription(cmd) {
	    // @ts-ignore: overloaded return type
	    return cmd.summary() || cmd.description();
	  }

	  /**
	   * Get the option description to show in the list of options.
	   *
	   * @param {Option} option
	   * @return {string}
	   */

	  optionDescription(option) {
	    const extraInfo = [];

	    if (option.argChoices) {
	      extraInfo.push(
	        // use stringify to match the display of the default value
	        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
	    }
	    if (option.defaultValue !== undefined) {
	      // default for boolean and negated more for programmer than end user,
	      // but show true/false for boolean option as may be for hand-rolled env or config processing.
	      const showDefault = option.required || option.optional ||
	        (option.isBoolean() && typeof option.defaultValue === 'boolean');
	      if (showDefault) {
	        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
	      }
	    }
	    // preset for boolean and negated are more for programmer than end user
	    if (option.presetArg !== undefined && option.optional) {
	      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
	    }
	    if (option.envVar !== undefined) {
	      extraInfo.push(`env: ${option.envVar}`);
	    }
	    if (extraInfo.length > 0) {
	      return `${option.description} (${extraInfo.join(', ')})`;
	    }

	    return option.description;
	  }

	  /**
	   * Get the argument description to show in the list of arguments.
	   *
	   * @param {Argument} argument
	   * @return {string}
	   */

	  argumentDescription(argument) {
	    const extraInfo = [];
	    if (argument.argChoices) {
	      extraInfo.push(
	        // use stringify to match the display of the default value
	        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
	    }
	    if (argument.defaultValue !== undefined) {
	      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
	    }
	    if (extraInfo.length > 0) {
	      const extraDescripton = `(${extraInfo.join(', ')})`;
	      if (argument.description) {
	        return `${argument.description} ${extraDescripton}`;
	      }
	      return extraDescripton;
	    }
	    return argument.description;
	  }

	  /**
	   * Generate the built-in help text.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {string}
	   */

	  formatHelp(cmd, helper) {
	    const termWidth = helper.padWidth(cmd, helper);
	    const helpWidth = helper.helpWidth || 80;
	    const itemIndentWidth = 2;
	    const itemSeparatorWidth = 2; // between term and description
	    function formatItem(term, description) {
	      if (description) {
	        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
	        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
	      }
	      return term;
	    }
	    function formatList(textArray) {
	      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
	    }

	    // Usage
	    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

	    // Description
	    const commandDescription = helper.commandDescription(cmd);
	    if (commandDescription.length > 0) {
	      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);
	    }

	    // Arguments
	    const argumentList = helper.visibleArguments(cmd).map((argument) => {
	      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
	    });
	    if (argumentList.length > 0) {
	      output = output.concat(['Arguments:', formatList(argumentList), '']);
	    }

	    // Options
	    const optionList = helper.visibleOptions(cmd).map((option) => {
	      return formatItem(helper.optionTerm(option), helper.optionDescription(option));
	    });
	    if (optionList.length > 0) {
	      output = output.concat(['Options:', formatList(optionList), '']);
	    }

	    if (this.showGlobalOptions) {
	      const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
	        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
	      });
	      if (globalOptionList.length > 0) {
	        output = output.concat(['Global Options:', formatList(globalOptionList), '']);
	      }
	    }

	    // Commands
	    const commandList = helper.visibleCommands(cmd).map((cmd) => {
	      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
	    });
	    if (commandList.length > 0) {
	      output = output.concat(['Commands:', formatList(commandList), '']);
	    }

	    return output.join('\n');
	  }

	  /**
	   * Calculate the pad width from the maximum term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  padWidth(cmd, helper) {
	    return Math.max(
	      helper.longestOptionTermLength(cmd, helper),
	      helper.longestGlobalOptionTermLength(cmd, helper),
	      helper.longestSubcommandTermLength(cmd, helper),
	      helper.longestArgumentTermLength(cmd, helper)
	    );
	  }

	  /**
	   * Wrap the given string to width characters per line, with lines after the first indented.
	   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
	   *
	   * @param {string} str
	   * @param {number} width
	   * @param {number} indent
	   * @param {number} [minColumnWidth=40]
	   * @return {string}
	   *
	   */

	  wrap(str, width, indent, minColumnWidth = 40) {
	    // Full \s characters, minus the linefeeds.
	    const indents = ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
	    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
	    const manualIndent = new RegExp(`[\\n][${indents}]+`);
	    if (str.match(manualIndent)) return str;
	    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
	    const columnWidth = width - indent;
	    if (columnWidth < minColumnWidth) return str;

	    const leadingStr = str.slice(0, indent);
	    const columnText = str.slice(indent).replace('\r\n', '\n');
	    const indentString = ' '.repeat(indent);
	    const zeroWidthSpace = '\u200B';
	    const breaks = `\\s${zeroWidthSpace}`;
	    // Match line end (so empty lines don't collapse),
	    // or as much text as will fit in column, or excess text up to first break.
	    const regex = new RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');
	    const lines = columnText.match(regex) || [];
	    return leadingStr + lines.map((line, i) => {
	      if (line === '\n') return ''; // preserve empty lines
	      return ((i > 0) ? indentString : '') + line.trimEnd();
	    }).join('\n');
	  }
	}

	help.Help = Help;
	return help;
}

var option = {};

var hasRequiredOption;

function requireOption () {
	if (hasRequiredOption) return option;
	hasRequiredOption = 1;
	const { InvalidArgumentError } = requireError();

	class Option {
	  /**
	   * Initialize a new `Option` with the given `flags` and `description`.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   */

	  constructor(flags, description) {
	    this.flags = flags;
	    this.description = description || '';

	    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
	    this.optional = flags.includes('['); // A value is optional when the option is specified.
	    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
	    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
	    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
	    const optionFlags = splitOptionFlags(flags);
	    this.short = optionFlags.shortFlag;
	    this.long = optionFlags.longFlag;
	    this.negate = false;
	    if (this.long) {
	      this.negate = this.long.startsWith('--no-');
	    }
	    this.defaultValue = undefined;
	    this.defaultValueDescription = undefined;
	    this.presetArg = undefined;
	    this.envVar = undefined;
	    this.parseArg = undefined;
	    this.hidden = false;
	    this.argChoices = undefined;
	    this.conflictsWith = [];
	    this.implied = undefined;
	  }

	  /**
	   * Set the default value, and optionally supply the description to be displayed in the help.
	   *
	   * @param {*} value
	   * @param {string} [description]
	   * @return {Option}
	   */

	  default(value, description) {
	    this.defaultValue = value;
	    this.defaultValueDescription = description;
	    return this;
	  }

	  /**
	   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
	   * The custom processing (parseArg) is called.
	   *
	   * @example
	   * new Option('--color').default('GREYSCALE').preset('RGB');
	   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
	   *
	   * @param {*} arg
	   * @return {Option}
	   */

	  preset(arg) {
	    this.presetArg = arg;
	    return this;
	  }

	  /**
	   * Add option name(s) that conflict with this option.
	   * An error will be displayed if conflicting options are found during parsing.
	   *
	   * @example
	   * new Option('--rgb').conflicts('cmyk');
	   * new Option('--js').conflicts(['ts', 'jsx']);
	   *
	   * @param {string | string[]} names
	   * @return {Option}
	   */

	  conflicts(names) {
	    this.conflictsWith = this.conflictsWith.concat(names);
	    return this;
	  }

	  /**
	   * Specify implied option values for when this option is set and the implied options are not.
	   *
	   * The custom processing (parseArg) is not called on the implied values.
	   *
	   * @example
	   * program
	   *   .addOption(new Option('--log', 'write logging information to file'))
	   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
	   *
	   * @param {Object} impliedOptionValues
	   * @return {Option}
	   */
	  implies(impliedOptionValues) {
	    let newImplied = impliedOptionValues;
	    if (typeof impliedOptionValues === 'string') {
	      // string is not documented, but easy mistake and we can do what user probably intended.
	      newImplied = { [impliedOptionValues]: true };
	    }
	    this.implied = Object.assign(this.implied || {}, newImplied);
	    return this;
	  }

	  /**
	   * Set environment variable to check for option value.
	   *
	   * An environment variable is only used if when processed the current option value is
	   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
	   *
	   * @param {string} name
	   * @return {Option}
	   */

	  env(name) {
	    this.envVar = name;
	    return this;
	  }

	  /**
	   * Set the custom handler for processing CLI option arguments into option values.
	   *
	   * @param {Function} [fn]
	   * @return {Option}
	   */

	  argParser(fn) {
	    this.parseArg = fn;
	    return this;
	  }

	  /**
	   * Whether the option is mandatory and must have a value after parsing.
	   *
	   * @param {boolean} [mandatory=true]
	   * @return {Option}
	   */

	  makeOptionMandatory(mandatory = true) {
	    this.mandatory = !!mandatory;
	    return this;
	  }

	  /**
	   * Hide option in help.
	   *
	   * @param {boolean} [hide=true]
	   * @return {Option}
	   */

	  hideHelp(hide = true) {
	    this.hidden = !!hide;
	    return this;
	  }

	  /**
	   * @api private
	   */

	  _concatValue(value, previous) {
	    if (previous === this.defaultValue || !Array.isArray(previous)) {
	      return [value];
	    }

	    return previous.concat(value);
	  }

	  /**
	   * Only allow option value to be one of choices.
	   *
	   * @param {string[]} values
	   * @return {Option}
	   */

	  choices(values) {
	    this.argChoices = values.slice();
	    this.parseArg = (arg, previous) => {
	      if (!this.argChoices.includes(arg)) {
	        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
	      }
	      if (this.variadic) {
	        return this._concatValue(arg, previous);
	      }
	      return arg;
	    };
	    return this;
	  }

	  /**
	   * Return option name.
	   *
	   * @return {string}
	   */

	  name() {
	    if (this.long) {
	      return this.long.replace(/^--/, '');
	    }
	    return this.short.replace(/^-/, '');
	  }

	  /**
	   * Return option name, in a camelcase format that can be used
	   * as a object attribute key.
	   *
	   * @return {string}
	   * @api private
	   */

	  attributeName() {
	    return camelcase(this.name().replace(/^no-/, ''));
	  }

	  /**
	   * Check if `arg` matches the short or long flag.
	   *
	   * @param {string} arg
	   * @return {boolean}
	   * @api private
	   */

	  is(arg) {
	    return this.short === arg || this.long === arg;
	  }

	  /**
	   * Return whether a boolean option.
	   *
	   * Options are one of boolean, negated, required argument, or optional argument.
	   *
	   * @return {boolean}
	   * @api private
	   */

	  isBoolean() {
	    return !this.required && !this.optional && !this.negate;
	  }
	}

	/**
	 * This class is to make it easier to work with dual options, without changing the existing
	 * implementation. We support separate dual options for separate positive and negative options,
	 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
	 * use cases, but is tricky for others where we want separate behaviours despite
	 * the single shared option value.
	 */
	class DualOptions {
	  /**
	   * @param {Option[]} options
	   */
	  constructor(options) {
	    this.positiveOptions = new Map();
	    this.negativeOptions = new Map();
	    this.dualOptions = new Set();
	    options.forEach(option => {
	      if (option.negate) {
	        this.negativeOptions.set(option.attributeName(), option);
	      } else {
	        this.positiveOptions.set(option.attributeName(), option);
	      }
	    });
	    this.negativeOptions.forEach((value, key) => {
	      if (this.positiveOptions.has(key)) {
	        this.dualOptions.add(key);
	      }
	    });
	  }

	  /**
	   * Did the value come from the option, and not from possible matching dual option?
	   *
	   * @param {*} value
	   * @param {Option} option
	   * @returns {boolean}
	   */
	  valueFromOption(value, option) {
	    const optionKey = option.attributeName();
	    if (!this.dualOptions.has(optionKey)) return true;

	    // Use the value to deduce if (probably) came from the option.
	    const preset = this.negativeOptions.get(optionKey).presetArg;
	    const negativeValue = (preset !== undefined) ? preset : false;
	    return option.negate === (negativeValue === value);
	  }
	}

	/**
	 * Convert string from kebab-case to camelCase.
	 *
	 * @param {string} str
	 * @return {string}
	 * @api private
	 */

	function camelcase(str) {
	  return str.split('-').reduce((str, word) => {
	    return str + word[0].toUpperCase() + word.slice(1);
	  });
	}

	/**
	 * Split the short and long flag out of something like '-m,--mixed <value>'
	 *
	 * @api private
	 */

	function splitOptionFlags(flags) {
	  let shortFlag;
	  let longFlag;
	  // Use original very loose parsing to maintain backwards compatibility for now,
	  // which allowed for example unintended `-sw, --short-word` [sic].
	  const flagParts = flags.split(/[ |,]+/);
	  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
	  longFlag = flagParts.shift();
	  // Add support for lone short flag without significantly changing parsing!
	  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
	    shortFlag = longFlag;
	    longFlag = undefined;
	  }
	  return { shortFlag, longFlag };
	}

	option.Option = Option;
	option.splitOptionFlags = splitOptionFlags;
	option.DualOptions = DualOptions;
	return option;
}

var suggestSimilar = {};

var hasRequiredSuggestSimilar;

function requireSuggestSimilar () {
	if (hasRequiredSuggestSimilar) return suggestSimilar;
	hasRequiredSuggestSimilar = 1;
	const maxDistance = 3;

	function editDistance(a, b) {
	  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
	  // Calculating optimal string alignment distance, no substring is edited more than once.
	  // (Simple implementation.)

	  // Quick early exit, return worst case.
	  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);

	  // distance between prefix substrings of a and b
	  const d = [];

	  // pure deletions turn a into empty string
	  for (let i = 0; i <= a.length; i++) {
	    d[i] = [i];
	  }
	  // pure insertions turn empty string into b
	  for (let j = 0; j <= b.length; j++) {
	    d[0][j] = j;
	  }

	  // fill matrix
	  for (let j = 1; j <= b.length; j++) {
	    for (let i = 1; i <= a.length; i++) {
	      let cost = 1;
	      if (a[i - 1] === b[j - 1]) {
	        cost = 0;
	      } else {
	        cost = 1;
	      }
	      d[i][j] = Math.min(
	        d[i - 1][j] + 1, // deletion
	        d[i][j - 1] + 1, // insertion
	        d[i - 1][j - 1] + cost // substitution
	      );
	      // transposition
	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
	      }
	    }
	  }

	  return d[a.length][b.length];
	}

	/**
	 * Find close matches, restricted to same number of edits.
	 *
	 * @param {string} word
	 * @param {string[]} candidates
	 * @returns {string}
	 */

	function suggestSimilar$1(word, candidates) {
	  if (!candidates || candidates.length === 0) return '';
	  // remove possible duplicates
	  candidates = Array.from(new Set(candidates));

	  const searchingOptions = word.startsWith('--');
	  if (searchingOptions) {
	    word = word.slice(2);
	    candidates = candidates.map(candidate => candidate.slice(2));
	  }

	  let similar = [];
	  let bestDistance = maxDistance;
	  const minSimilarity = 0.4;
	  candidates.forEach((candidate) => {
	    if (candidate.length <= 1) return; // no one character guesses

	    const distance = editDistance(word, candidate);
	    const length = Math.max(word.length, candidate.length);
	    const similarity = (length - distance) / length;
	    if (similarity > minSimilarity) {
	      if (distance < bestDistance) {
	        // better edit distance, throw away previous worse matches
	        bestDistance = distance;
	        similar = [candidate];
	      } else if (distance === bestDistance) {
	        similar.push(candidate);
	      }
	    }
	  });

	  similar.sort((a, b) => a.localeCompare(b));
	  if (searchingOptions) {
	    similar = similar.map(candidate => `--${candidate}`);
	  }

	  if (similar.length > 1) {
	    return `\n(Did you mean one of ${similar.join(', ')}?)`;
	  }
	  if (similar.length === 1) {
	    return `\n(Did you mean ${similar[0]}?)`;
	  }
	  return '';
	}

	suggestSimilar.suggestSimilar = suggestSimilar$1;
	return suggestSimilar;
}

var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	const EventEmitter = require$$0$2.EventEmitter;
	const childProcess = require$$1;
	const path = path$1;
	const fs$1 = fs;
	const process = require$$4;

	const { Argument, humanReadableArgName } = requireArgument();
	const { CommanderError } = requireError();
	const { Help } = requireHelp();
	const { Option, splitOptionFlags, DualOptions } = requireOption();
	const { suggestSimilar } = requireSuggestSimilar();

	class Command extends EventEmitter {
	  /**
	   * Initialize a new `Command`.
	   *
	   * @param {string} [name]
	   */

	  constructor(name) {
	    super();
	    /** @type {Command[]} */
	    this.commands = [];
	    /** @type {Option[]} */
	    this.options = [];
	    this.parent = null;
	    this._allowUnknownOption = false;
	    this._allowExcessArguments = true;
	    /** @type {Argument[]} */
	    this.registeredArguments = [];
	    this._args = this.registeredArguments; // deprecated old name
	    /** @type {string[]} */
	    this.args = []; // cli args with options removed
	    this.rawArgs = [];
	    this.processedArgs = []; // like .args but after custom processing and collecting variadic
	    this._scriptPath = null;
	    this._name = name || '';
	    this._optionValues = {};
	    this._optionValueSources = {}; // default, env, cli etc
	    this._storeOptionsAsProperties = false;
	    this._actionHandler = null;
	    this._executableHandler = false;
	    this._executableFile = null; // custom name for executable
	    this._executableDir = null; // custom search directory for subcommands
	    this._defaultCommandName = null;
	    this._exitCallback = null;
	    this._aliases = [];
	    this._combineFlagAndOptionalValue = true;
	    this._description = '';
	    this._summary = '';
	    this._argsDescription = undefined; // legacy
	    this._enablePositionalOptions = false;
	    this._passThroughOptions = false;
	    this._lifeCycleHooks = {}; // a hash of arrays
	    /** @type {boolean | string} */
	    this._showHelpAfterError = false;
	    this._showSuggestionAfterError = true;

	    // see .configureOutput() for docs
	    this._outputConfiguration = {
	      writeOut: (str) => process.stdout.write(str),
	      writeErr: (str) => process.stderr.write(str),
	      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
	      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
	      outputError: (str, write) => write(str)
	    };

	    this._hidden = false;
	    this._hasHelpOption = true;
	    this._helpFlags = '-h, --help';
	    this._helpDescription = 'display help for command';
	    this._helpShortFlag = '-h';
	    this._helpLongFlag = '--help';
	    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
	    this._helpCommandName = 'help';
	    this._helpCommandnameAndArgs = 'help [command]';
	    this._helpCommandDescription = 'display help for command';
	    this._helpConfiguration = {};
	  }

	  /**
	   * Copy settings that are useful to have in common across root command and subcommands.
	   *
	   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
	   *
	   * @param {Command} sourceCommand
	   * @return {Command} `this` command for chaining
	   */
	  copyInheritedSettings(sourceCommand) {
	    this._outputConfiguration = sourceCommand._outputConfiguration;
	    this._hasHelpOption = sourceCommand._hasHelpOption;
	    this._helpFlags = sourceCommand._helpFlags;
	    this._helpDescription = sourceCommand._helpDescription;
	    this._helpShortFlag = sourceCommand._helpShortFlag;
	    this._helpLongFlag = sourceCommand._helpLongFlag;
	    this._helpCommandName = sourceCommand._helpCommandName;
	    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
	    this._helpCommandDescription = sourceCommand._helpCommandDescription;
	    this._helpConfiguration = sourceCommand._helpConfiguration;
	    this._exitCallback = sourceCommand._exitCallback;
	    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
	    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
	    this._allowExcessArguments = sourceCommand._allowExcessArguments;
	    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
	    this._showHelpAfterError = sourceCommand._showHelpAfterError;
	    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

	    return this;
	  }

	  /**
	   * @returns {Command[]}
	   * @api private
	   */

	  _getCommandAndAncestors() {
	    const result = [];
	    for (let command = this; command; command = command.parent) {
	      result.push(command);
	    }
	    return result;
	  }

	  /**
	   * Define a command.
	   *
	   * There are two styles of command: pay attention to where to put the description.
	   *
	   * @example
	   * // Command implemented using action handler (description is supplied separately to `.command`)
	   * program
	   *   .command('clone <source> [destination]')
	   *   .description('clone a repository into a newly created directory')
	   *   .action((source, destination) => {
	   *     console.log('clone command called');
	   *   });
	   *
	   * // Command implemented using separate executable file (description is second parameter to `.command`)
	   * program
	   *   .command('start <service>', 'start named service')
	   *   .command('stop [service]', 'stop named service, or all if no name supplied');
	   *
	   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
	   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
	   * @param {Object} [execOpts] - configuration options (for executable)
	   * @return {Command} returns new command for action handler, or `this` for executable command
	   */

	  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
	    let desc = actionOptsOrExecDesc;
	    let opts = execOpts;
	    if (typeof desc === 'object' && desc !== null) {
	      opts = desc;
	      desc = null;
	    }
	    opts = opts || {};
	    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

	    const cmd = this.createCommand(name);
	    if (desc) {
	      cmd.description(desc);
	      cmd._executableHandler = true;
	    }
	    if (opts.isDefault) this._defaultCommandName = cmd._name;
	    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
	    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
	    if (args) cmd.arguments(args);
	    this.commands.push(cmd);
	    cmd.parent = this;
	    cmd.copyInheritedSettings(this);

	    if (desc) return this;
	    return cmd;
	  }

	  /**
	   * Factory routine to create a new unattached command.
	   *
	   * See .command() for creating an attached subcommand, which uses this routine to
	   * create the command. You can override createCommand to customise subcommands.
	   *
	   * @param {string} [name]
	   * @return {Command} new command
	   */

	  createCommand(name) {
	    return new Command(name);
	  }

	  /**
	   * You can customise the help with a subclass of Help by overriding createHelp,
	   * or by overriding Help properties using configureHelp().
	   *
	   * @return {Help}
	   */

	  createHelp() {
	    return Object.assign(new Help(), this.configureHelp());
	  }

	  /**
	   * You can customise the help by overriding Help properties using configureHelp(),
	   * or with a subclass of Help by overriding createHelp().
	   *
	   * @param {Object} [configuration] - configuration options
	   * @return {Command|Object} `this` command for chaining, or stored configuration
	   */

	  configureHelp(configuration) {
	    if (configuration === undefined) return this._helpConfiguration;

	    this._helpConfiguration = configuration;
	    return this;
	  }

	  /**
	   * The default output goes to stdout and stderr. You can customise this for special
	   * applications. You can also customise the display of errors by overriding outputError.
	   *
	   * The configuration properties are all functions:
	   *
	   *     // functions to change where being written, stdout and stderr
	   *     writeOut(str)
	   *     writeErr(str)
	   *     // matching functions to specify width for wrapping help
	   *     getOutHelpWidth()
	   *     getErrHelpWidth()
	   *     // functions based on what is being written out
	   *     outputError(str, write) // used for displaying errors, and not used for displaying help
	   *
	   * @param {Object} [configuration] - configuration options
	   * @return {Command|Object} `this` command for chaining, or stored configuration
	   */

	  configureOutput(configuration) {
	    if (configuration === undefined) return this._outputConfiguration;

	    Object.assign(this._outputConfiguration, configuration);
	    return this;
	  }

	  /**
	   * Display the help or a custom message after an error occurs.
	   *
	   * @param {boolean|string} [displayHelp]
	   * @return {Command} `this` command for chaining
	   */
	  showHelpAfterError(displayHelp = true) {
	    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
	    this._showHelpAfterError = displayHelp;
	    return this;
	  }

	  /**
	   * Display suggestion of similar commands for unknown commands, or options for unknown options.
	   *
	   * @param {boolean} [displaySuggestion]
	   * @return {Command} `this` command for chaining
	   */
	  showSuggestionAfterError(displaySuggestion = true) {
	    this._showSuggestionAfterError = !!displaySuggestion;
	    return this;
	  }

	  /**
	   * Add a prepared subcommand.
	   *
	   * See .command() for creating an attached subcommand which inherits settings from its parent.
	   *
	   * @param {Command} cmd - new subcommand
	   * @param {Object} [opts] - configuration options
	   * @return {Command} `this` command for chaining
	   */

	  addCommand(cmd, opts) {
	    if (!cmd._name) {
	      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
	    }

	    opts = opts || {};
	    if (opts.isDefault) this._defaultCommandName = cmd._name;
	    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

	    this.commands.push(cmd);
	    cmd.parent = this;
	    return this;
	  }

	  /**
	   * Factory routine to create a new unattached argument.
	   *
	   * See .argument() for creating an attached argument, which uses this routine to
	   * create the argument. You can override createArgument to return a custom argument.
	   *
	   * @param {string} name
	   * @param {string} [description]
	   * @return {Argument} new argument
	   */

	  createArgument(name, description) {
	    return new Argument(name, description);
	  }

	  /**
	   * Define argument syntax for command.
	   *
	   * The default is that the argument is required, and you can explicitly
	   * indicate this with <> around the name. Put [] around the name for an optional argument.
	   *
	   * @example
	   * program.argument('<input-file>');
	   * program.argument('[output-file]');
	   *
	   * @param {string} name
	   * @param {string} [description]
	   * @param {Function|*} [fn] - custom argument processing function
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */
	  argument(name, description, fn, defaultValue) {
	    const argument = this.createArgument(name, description);
	    if (typeof fn === 'function') {
	      argument.default(defaultValue).argParser(fn);
	    } else {
	      argument.default(fn);
	    }
	    this.addArgument(argument);
	    return this;
	  }

	  /**
	   * Define argument syntax for command, adding multiple at once (without descriptions).
	   *
	   * See also .argument().
	   *
	   * @example
	   * program.arguments('<cmd> [env]');
	   *
	   * @param {string} names
	   * @return {Command} `this` command for chaining
	   */

	  arguments(names) {
	    names.trim().split(/ +/).forEach((detail) => {
	      this.argument(detail);
	    });
	    return this;
	  }

	  /**
	   * Define argument syntax for command, adding a prepared argument.
	   *
	   * @param {Argument} argument
	   * @return {Command} `this` command for chaining
	   */
	  addArgument(argument) {
	    const previousArgument = this.registeredArguments.slice(-1)[0];
	    if (previousArgument && previousArgument.variadic) {
	      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
	    }
	    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
	      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
	    }
	    this.registeredArguments.push(argument);
	    return this;
	  }

	  /**
	   * Override default decision whether to add implicit help command.
	   *
	   *    addHelpCommand() // force on
	   *    addHelpCommand(false); // force off
	   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
	   *
	   * @return {Command} `this` command for chaining
	   */

	  addHelpCommand(enableOrNameAndArgs, description) {
	    if (enableOrNameAndArgs === false) {
	      this._addImplicitHelpCommand = false;
	    } else {
	      this._addImplicitHelpCommand = true;
	      if (typeof enableOrNameAndArgs === 'string') {
	        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
	        this._helpCommandnameAndArgs = enableOrNameAndArgs;
	      }
	      this._helpCommandDescription = description || this._helpCommandDescription;
	    }
	    return this;
	  }

	  /**
	   * @return {boolean}
	   * @api private
	   */

	  _hasImplicitHelpCommand() {
	    if (this._addImplicitHelpCommand === undefined) {
	      return this.commands.length && !this._actionHandler && !this._findCommand('help');
	    }
	    return this._addImplicitHelpCommand;
	  }

	  /**
	   * Add hook for life cycle event.
	   *
	   * @param {string} event
	   * @param {Function} listener
	   * @return {Command} `this` command for chaining
	   */

	  hook(event, listener) {
	    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
	    if (!allowedValues.includes(event)) {
	      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
	    }
	    if (this._lifeCycleHooks[event]) {
	      this._lifeCycleHooks[event].push(listener);
	    } else {
	      this._lifeCycleHooks[event] = [listener];
	    }
	    return this;
	  }

	  /**
	   * Register callback to use as replacement for calling process.exit.
	   *
	   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
	   * @return {Command} `this` command for chaining
	   */

	  exitOverride(fn) {
	    if (fn) {
	      this._exitCallback = fn;
	    } else {
	      this._exitCallback = (err) => {
	        if (err.code !== 'commander.executeSubCommandAsync') {
	          throw err;
	        }
	      };
	    }
	    return this;
	  }

	  /**
	   * Call process.exit, and _exitCallback if defined.
	   *
	   * @param {number} exitCode exit code for using with process.exit
	   * @param {string} code an id string representing the error
	   * @param {string} message human-readable description of the error
	   * @return never
	   * @api private
	   */

	  _exit(exitCode, code, message) {
	    if (this._exitCallback) {
	      this._exitCallback(new CommanderError(exitCode, code, message));
	      // Expecting this line is not reached.
	    }
	    process.exit(exitCode);
	  }

	  /**
	   * Register callback `fn` for the command.
	   *
	   * @example
	   * program
	   *   .command('serve')
	   *   .description('start service')
	   *   .action(function() {
	   *      // do work here
	   *   });
	   *
	   * @param {Function} fn
	   * @return {Command} `this` command for chaining
	   */

	  action(fn) {
	    const listener = (args) => {
	      // The .action callback takes an extra parameter which is the command or options.
	      const expectedArgsCount = this.registeredArguments.length;
	      const actionArgs = args.slice(0, expectedArgsCount);
	      if (this._storeOptionsAsProperties) {
	        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
	      } else {
	        actionArgs[expectedArgsCount] = this.opts();
	      }
	      actionArgs.push(this);

	      return fn.apply(this, actionArgs);
	    };
	    this._actionHandler = listener;
	    return this;
	  }

	  /**
	   * Factory routine to create a new unattached option.
	   *
	   * See .option() for creating an attached option, which uses this routine to
	   * create the option. You can override createOption to return a custom option.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @return {Option} new option
	   */

	  createOption(flags, description) {
	    return new Option(flags, description);
	  }

	  /**
	   * Wrap parseArgs to catch 'commander.invalidArgument'.
	   *
	   * @param {Option | Argument} target
	   * @param {string} value
	   * @param {*} previous
	   * @param {string} invalidArgumentMessage
	   * @api private
	   */

	  _callParseArg(target, value, previous, invalidArgumentMessage) {
	    try {
	      return target.parseArg(value, previous);
	    } catch (err) {
	      if (err.code === 'commander.invalidArgument') {
	        const message = `${invalidArgumentMessage} ${err.message}`;
	        this.error(message, { exitCode: err.exitCode, code: err.code });
	      }
	      throw err;
	    }
	  }

	  /**
	   * Add an option.
	   *
	   * @param {Option} option
	   * @return {Command} `this` command for chaining
	   */
	  addOption(option) {
	    const oname = option.name();
	    const name = option.attributeName();

	    // store default value
	    if (option.negate) {
	      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
	      const positiveLongFlag = option.long.replace(/^--no-/, '--');
	      if (!this._findOption(positiveLongFlag)) {
	        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');
	      }
	    } else if (option.defaultValue !== undefined) {
	      this.setOptionValueWithSource(name, option.defaultValue, 'default');
	    }

	    // register the option
	    this.options.push(option);

	    // handler for cli and env supplied values
	    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
	      // val is null for optional option used without an optional-argument.
	      // val is undefined for boolean and negated option.
	      if (val == null && option.presetArg !== undefined) {
	        val = option.presetArg;
	      }

	      // custom processing
	      const oldValue = this.getOptionValue(name);
	      if (val !== null && option.parseArg) {
	        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
	      } else if (val !== null && option.variadic) {
	        val = option._concatValue(val, oldValue);
	      }

	      // Fill-in appropriate missing values. Long winded but easy to follow.
	      if (val == null) {
	        if (option.negate) {
	          val = false;
	        } else if (option.isBoolean() || option.optional) {
	          val = true;
	        } else {
	          val = ''; // not normal, parseArg might have failed or be a mock function for testing
	        }
	      }
	      this.setOptionValueWithSource(name, val, valueSource);
	    };

	    this.on('option:' + oname, (val) => {
	      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
	      handleOptionValue(val, invalidValueMessage, 'cli');
	    });

	    if (option.envVar) {
	      this.on('optionEnv:' + oname, (val) => {
	        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
	        handleOptionValue(val, invalidValueMessage, 'env');
	      });
	    }

	    return this;
	  }

	  /**
	   * Internal implementation shared by .option() and .requiredOption()
	   *
	   * @api private
	   */
	  _optionEx(config, flags, description, fn, defaultValue) {
	    if (typeof flags === 'object' && flags instanceof Option) {
	      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
	    }
	    const option = this.createOption(flags, description);
	    option.makeOptionMandatory(!!config.mandatory);
	    if (typeof fn === 'function') {
	      option.default(defaultValue).argParser(fn);
	    } else if (fn instanceof RegExp) {
	      // deprecated
	      const regex = fn;
	      fn = (val, def) => {
	        const m = regex.exec(val);
	        return m ? m[0] : def;
	      };
	      option.default(defaultValue).argParser(fn);
	    } else {
	      option.default(fn);
	    }

	    return this.addOption(option);
	  }

	  /**
	   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
	   *
	   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
	   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
	   *
	   * See the README for more details, and see also addOption() and requiredOption().
	   *
	   * @example
	   * program
	   *     .option('-p, --pepper', 'add pepper')
	   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
	   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
	   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @param {Function|*} [parseArg] - custom option processing function or default value
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */

	  option(flags, description, parseArg, defaultValue) {
	    return this._optionEx({}, flags, description, parseArg, defaultValue);
	  }

	  /**
	  * Add a required option which must have a value after parsing. This usually means
	  * the option must be specified on the command line. (Otherwise the same as .option().)
	  *
	  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
	  *
	  * @param {string} flags
	  * @param {string} [description]
	  * @param {Function|*} [parseArg] - custom option processing function or default value
	  * @param {*} [defaultValue]
	  * @return {Command} `this` command for chaining
	  */

	  requiredOption(flags, description, parseArg, defaultValue) {
	    return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
	  }

	  /**
	   * Alter parsing of short flags with optional values.
	   *
	   * @example
	   * // for `.option('-f,--flag [value]'):
	   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
	   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
	   *
	   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
	   */
	  combineFlagAndOptionalValue(combine = true) {
	    this._combineFlagAndOptionalValue = !!combine;
	    return this;
	  }

	  /**
	   * Allow unknown options on the command line.
	   *
	   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
	   * for unknown options.
	   */
	  allowUnknownOption(allowUnknown = true) {
	    this._allowUnknownOption = !!allowUnknown;
	    return this;
	  }

	  /**
	   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
	   *
	   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
	   * for excess arguments.
	   */
	  allowExcessArguments(allowExcess = true) {
	    this._allowExcessArguments = !!allowExcess;
	    return this;
	  }

	  /**
	   * Enable positional options. Positional means global options are specified before subcommands which lets
	   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
	   * The default behaviour is non-positional and global options may appear anywhere on the command line.
	   *
	   * @param {Boolean} [positional=true]
	   */
	  enablePositionalOptions(positional = true) {
	    this._enablePositionalOptions = !!positional;
	    return this;
	  }

	  /**
	   * Pass through options that come after command-arguments rather than treat them as command-options,
	   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
	   * positional options to have been enabled on the program (parent commands).
	   * The default behaviour is non-positional and options may appear before or after command-arguments.
	   *
	   * @param {Boolean} [passThrough=true]
	   * for unknown options.
	   */
	  passThroughOptions(passThrough = true) {
	    this._passThroughOptions = !!passThrough;
	    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
	      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
	    }
	    return this;
	  }

	  /**
	    * Whether to store option values as properties on command object,
	    * or store separately (specify false). In both cases the option values can be accessed using .opts().
	    *
	    * @param {boolean} [storeAsProperties=true]
	    * @return {Command} `this` command for chaining
	    */

	  storeOptionsAsProperties(storeAsProperties = true) {
	    if (this.options.length) {
	      throw new Error('call .storeOptionsAsProperties() before adding options');
	    }
	    // if (Object.keys(this._optionValues).length) {
	    //   throw new Error('call .storeOptionsAsProperties() before setting option values');
	    // }
	    this._storeOptionsAsProperties = !!storeAsProperties;
	    return this;
	  }

	  /**
	   * Retrieve option value.
	   *
	   * @param {string} key
	   * @return {Object} value
	   */

	  getOptionValue(key) {
	    if (this._storeOptionsAsProperties) {
	      return this[key];
	    }
	    return this._optionValues[key];
	  }

	  /**
	   * Store option value.
	   *
	   * @param {string} key
	   * @param {Object} value
	   * @return {Command} `this` command for chaining
	   */

	  setOptionValue(key, value) {
	    return this.setOptionValueWithSource(key, value, undefined);
	  }

	  /**
	    * Store option value and where the value came from.
	    *
	    * @param {string} key
	    * @param {Object} value
	    * @param {string} source - expected values are default/config/env/cli/implied
	    * @return {Command} `this` command for chaining
	    */

	  setOptionValueWithSource(key, value, source) {
	    if (this._storeOptionsAsProperties) {
	      this[key] = value;
	    } else {
	      this._optionValues[key] = value;
	    }
	    this._optionValueSources[key] = source;
	    return this;
	  }

	  /**
	    * Get source of option value.
	    * Expected values are default | config | env | cli | implied
	    *
	    * @param {string} key
	    * @return {string}
	    */

	  getOptionValueSource(key) {
	    return this._optionValueSources[key];
	  }

	  /**
	    * Get source of option value. See also .optsWithGlobals().
	    * Expected values are default | config | env | cli | implied
	    *
	    * @param {string} key
	    * @return {string}
	    */

	  getOptionValueSourceWithGlobals(key) {
	    // global overwrites local, like optsWithGlobals
	    let source;
	    this._getCommandAndAncestors().forEach((cmd) => {
	      if (cmd.getOptionValueSource(key) !== undefined) {
	        source = cmd.getOptionValueSource(key);
	      }
	    });
	    return source;
	  }

	  /**
	   * Get user arguments from implied or explicit arguments.
	   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
	   *
	   * @api private
	   */

	  _prepareUserArgs(argv, parseOptions) {
	    if (argv !== undefined && !Array.isArray(argv)) {
	      throw new Error('first parameter to parse must be array or undefined');
	    }
	    parseOptions = parseOptions || {};

	    // Default to using process.argv
	    if (argv === undefined) {
	      argv = process.argv;
	      // @ts-ignore: unknown property
	      if (process.versions && process.versions.electron) {
	        parseOptions.from = 'electron';
	      }
	    }
	    this.rawArgs = argv.slice();

	    // make it a little easier for callers by supporting various argv conventions
	    let userArgs;
	    switch (parseOptions.from) {
	      case undefined:
	      case 'node':
	        this._scriptPath = argv[1];
	        userArgs = argv.slice(2);
	        break;
	      case 'electron':
	        // @ts-ignore: unknown property
	        if (process.defaultApp) {
	          this._scriptPath = argv[1];
	          userArgs = argv.slice(2);
	        } else {
	          userArgs = argv.slice(1);
	        }
	        break;
	      case 'user':
	        userArgs = argv.slice(0);
	        break;
	      default:
	        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
	    }

	    // Find default name for program from arguments.
	    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
	    this._name = this._name || 'program';

	    return userArgs;
	  }

	  /**
	   * Parse `argv`, setting options and invoking commands when defined.
	   *
	   * The default expectation is that the arguments are from node and have the application as argv[0]
	   * and the script being run in argv[1], with user parameters after that.
	   *
	   * @example
	   * program.parse(process.argv);
	   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
	   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
	   *
	   * @param {string[]} [argv] - optional, defaults to process.argv
	   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
	   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
	   * @return {Command} `this` command for chaining
	   */

	  parse(argv, parseOptions) {
	    const userArgs = this._prepareUserArgs(argv, parseOptions);
	    this._parseCommand([], userArgs);

	    return this;
	  }

	  /**
	   * Parse `argv`, setting options and invoking commands when defined.
	   *
	   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
	   *
	   * The default expectation is that the arguments are from node and have the application as argv[0]
	   * and the script being run in argv[1], with user parameters after that.
	   *
	   * @example
	   * await program.parseAsync(process.argv);
	   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
	   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
	   *
	   * @param {string[]} [argv]
	   * @param {Object} [parseOptions]
	   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
	   * @return {Promise}
	   */

	  async parseAsync(argv, parseOptions) {
	    const userArgs = this._prepareUserArgs(argv, parseOptions);
	    await this._parseCommand([], userArgs);

	    return this;
	  }

	  /**
	   * Execute a sub-command executable.
	   *
	   * @api private
	   */

	  _executeSubCommand(subcommand, args) {
	    args = args.slice();
	    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
	    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

	    function findFile(baseDir, baseName) {
	      // Look for specified file
	      const localBin = path.resolve(baseDir, baseName);
	      if (fs$1.existsSync(localBin)) return localBin;

	      // Stop looking if candidate already has an expected extension.
	      if (sourceExt.includes(path.extname(baseName))) return undefined;

	      // Try all the extensions.
	      const foundExt = sourceExt.find(ext => fs$1.existsSync(`${localBin}${ext}`));
	      if (foundExt) return `${localBin}${foundExt}`;

	      return undefined;
	    }

	    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
	    this._checkForMissingMandatoryOptions();
	    this._checkForConflictingOptions();

	    // executableFile and executableDir might be full path, or just a name
	    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
	    let executableDir = this._executableDir || '';
	    if (this._scriptPath) {
	      let resolvedScriptPath; // resolve possible symlink for installed npm binary
	      try {
	        resolvedScriptPath = fs$1.realpathSync(this._scriptPath);
	      } catch (err) {
	        resolvedScriptPath = this._scriptPath;
	      }
	      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
	    }

	    // Look for a local file in preference to a command in PATH.
	    if (executableDir) {
	      let localFile = findFile(executableDir, executableFile);

	      // Legacy search using prefix of script name instead of command name
	      if (!localFile && !subcommand._executableFile && this._scriptPath) {
	        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
	        if (legacyName !== this._name) {
	          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
	        }
	      }
	      executableFile = localFile || executableFile;
	    }

	    launchWithNode = sourceExt.includes(path.extname(executableFile));

	    let proc;
	    if (process.platform !== 'win32') {
	      if (launchWithNode) {
	        args.unshift(executableFile);
	        // add executable arguments to spawn
	        args = incrementNodeInspectorPort(process.execArgv).concat(args);

	        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
	      } else {
	        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
	      }
	    } else {
	      args.unshift(executableFile);
	      // add executable arguments to spawn
	      args = incrementNodeInspectorPort(process.execArgv).concat(args);
	      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
	    }

	    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn
	      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
	      signals.forEach((signal) => {
	        // @ts-ignore
	        process.on(signal, () => {
	          if (proc.killed === false && proc.exitCode === null) {
	            proc.kill(signal);
	          }
	        });
	      });
	    }

	    // By default terminate process when spawned process terminates.
	    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
	    const exitCallback = this._exitCallback;
	    if (!exitCallback) {
	      proc.on('close', process.exit.bind(process));
	    } else {
	      proc.on('close', () => {
	        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
	      });
	    }
	    proc.on('error', (err) => {
	      // @ts-ignore
	      if (err.code === 'ENOENT') {
	        const executableDirMessage = executableDir
	          ? `searched for local subcommand relative to directory '${executableDir}'`
	          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
	        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
	        throw new Error(executableMissing);
	      // @ts-ignore
	      } else if (err.code === 'EACCES') {
	        throw new Error(`'${executableFile}' not executable`);
	      }
	      if (!exitCallback) {
	        process.exit(1);
	      } else {
	        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
	        wrappedError.nestedError = err;
	        exitCallback(wrappedError);
	      }
	    });

	    // Store the reference to the child process
	    this.runningCommand = proc;
	  }

	  /**
	   * @api private
	   */

	  _dispatchSubcommand(commandName, operands, unknown) {
	    const subCommand = this._findCommand(commandName);
	    if (!subCommand) this.help({ error: true });

	    let promiseChain;
	    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');
	    promiseChain = this._chainOrCall(promiseChain, () => {
	      if (subCommand._executableHandler) {
	        this._executeSubCommand(subCommand, operands.concat(unknown));
	      } else {
	        return subCommand._parseCommand(operands, unknown);
	      }
	    });
	    return promiseChain;
	  }

	  /**
	   * Invoke help directly if possible, or dispatch if necessary.
	   * e.g. help foo
	   *
	   * @api private
	   */

	  _dispatchHelpCommand(subcommandName) {
	    if (!subcommandName) {
	      this.help();
	    }
	    const subCommand = this._findCommand(subcommandName);
	    if (subCommand && !subCommand._executableHandler) {
	      subCommand.help();
	    }

	    // Fallback to parsing the help flag to invoke the help.
	    return this._dispatchSubcommand(subcommandName, [], [
	      this._helpLongFlag || this._helpShortFlag
	    ]);
	  }

	  /**
	   * Check this.args against expected this.registeredArguments.
	   *
	   * @api private
	   */

	  _checkNumberOfArguments() {
	    // too few
	    this.registeredArguments.forEach((arg, i) => {
	      if (arg.required && this.args[i] == null) {
	        this.missingArgument(arg.name());
	      }
	    });
	    // too many
	    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
	      return;
	    }
	    if (this.args.length > this.registeredArguments.length) {
	      this._excessArguments(this.args);
	    }
	  }

	  /**
	   * Process this.args using this.registeredArguments and save as this.processedArgs!
	   *
	   * @api private
	   */

	  _processArguments() {
	    const myParseArg = (argument, value, previous) => {
	      // Extra processing for nice error message on parsing failure.
	      let parsedValue = value;
	      if (value !== null && argument.parseArg) {
	        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
	        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
	      }
	      return parsedValue;
	    };

	    this._checkNumberOfArguments();

	    const processedArgs = [];
	    this.registeredArguments.forEach((declaredArg, index) => {
	      let value = declaredArg.defaultValue;
	      if (declaredArg.variadic) {
	        // Collect together remaining arguments for passing together as an array.
	        if (index < this.args.length) {
	          value = this.args.slice(index);
	          if (declaredArg.parseArg) {
	            value = value.reduce((processed, v) => {
	              return myParseArg(declaredArg, v, processed);
	            }, declaredArg.defaultValue);
	          }
	        } else if (value === undefined) {
	          value = [];
	        }
	      } else if (index < this.args.length) {
	        value = this.args[index];
	        if (declaredArg.parseArg) {
	          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
	        }
	      }
	      processedArgs[index] = value;
	    });
	    this.processedArgs = processedArgs;
	  }

	  /**
	   * Once we have a promise we chain, but call synchronously until then.
	   *
	   * @param {Promise|undefined} promise
	   * @param {Function} fn
	   * @return {Promise|undefined}
	   * @api private
	   */

	  _chainOrCall(promise, fn) {
	    // thenable
	    if (promise && promise.then && typeof promise.then === 'function') {
	      // already have a promise, chain callback
	      return promise.then(() => fn());
	    }
	    // callback might return a promise
	    return fn();
	  }

	  /**
	   *
	   * @param {Promise|undefined} promise
	   * @param {string} event
	   * @return {Promise|undefined}
	   * @api private
	   */

	  _chainOrCallHooks(promise, event) {
	    let result = promise;
	    const hooks = [];
	    this._getCommandAndAncestors()
	      .reverse()
	      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)
	      .forEach(hookedCommand => {
	        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
	          hooks.push({ hookedCommand, callback });
	        });
	      });
	    if (event === 'postAction') {
	      hooks.reverse();
	    }

	    hooks.forEach((hookDetail) => {
	      result = this._chainOrCall(result, () => {
	        return hookDetail.callback(hookDetail.hookedCommand, this);
	      });
	    });
	    return result;
	  }

	  /**
	   *
	   * @param {Promise|undefined} promise
	   * @param {Command} subCommand
	   * @param {string} event
	   * @return {Promise|undefined}
	   * @api private
	   */

	  _chainOrCallSubCommandHook(promise, subCommand, event) {
	    let result = promise;
	    if (this._lifeCycleHooks[event] !== undefined) {
	      this._lifeCycleHooks[event].forEach((hook) => {
	        result = this._chainOrCall(result, () => {
	          return hook(this, subCommand);
	        });
	      });
	    }
	    return result;
	  }

	  /**
	   * Process arguments in context of this command.
	   * Returns action result, in case it is a promise.
	   *
	   * @api private
	   */

	  _parseCommand(operands, unknown) {
	    const parsed = this.parseOptions(unknown);
	    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
	    this._parseOptionsImplied();
	    operands = operands.concat(parsed.operands);
	    unknown = parsed.unknown;
	    this.args = operands.concat(unknown);

	    if (operands && this._findCommand(operands[0])) {
	      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
	    }
	    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
	      return this._dispatchHelpCommand(operands[1]);
	    }
	    if (this._defaultCommandName) {
	      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
	      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
	    }
	    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
	      // probably missing subcommand and no handler, user needs help (and exit)
	      this.help({ error: true });
	    }

	    outputHelpIfRequested(this, parsed.unknown);
	    this._checkForMissingMandatoryOptions();
	    this._checkForConflictingOptions();

	    // We do not always call this check to avoid masking a "better" error, like unknown command.
	    const checkForUnknownOptions = () => {
	      if (parsed.unknown.length > 0) {
	        this.unknownOption(parsed.unknown[0]);
	      }
	    };

	    const commandEvent = `command:${this.name()}`;
	    if (this._actionHandler) {
	      checkForUnknownOptions();
	      this._processArguments();

	      let promiseChain;
	      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
	      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
	      if (this.parent) {
	        promiseChain = this._chainOrCall(promiseChain, () => {
	          this.parent.emit(commandEvent, operands, unknown); // legacy
	        });
	      }
	      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
	      return promiseChain;
	    }
	    if (this.parent && this.parent.listenerCount(commandEvent)) {
	      checkForUnknownOptions();
	      this._processArguments();
	      this.parent.emit(commandEvent, operands, unknown); // legacy
	    } else if (operands.length) {
	      if (this._findCommand('*')) { // legacy default command
	        return this._dispatchSubcommand('*', operands, unknown);
	      }
	      if (this.listenerCount('command:*')) {
	        // skip option check, emit event for possible misspelling suggestion
	        this.emit('command:*', operands, unknown);
	      } else if (this.commands.length) {
	        this.unknownCommand();
	      } else {
	        checkForUnknownOptions();
	        this._processArguments();
	      }
	    } else if (this.commands.length) {
	      checkForUnknownOptions();
	      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
	      this.help({ error: true });
	    } else {
	      checkForUnknownOptions();
	      this._processArguments();
	      // fall through for caller to handle after calling .parse()
	    }
	  }

	  /**
	   * Find matching command.
	   *
	   * @api private
	   */
	  _findCommand(name) {
	    if (!name) return undefined;
	    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
	  }

	  /**
	   * Return an option matching `arg` if any.
	   *
	   * @param {string} arg
	   * @return {Option}
	   * @api private
	   */

	  _findOption(arg) {
	    return this.options.find(option => option.is(arg));
	  }

	  /**
	   * Display an error message if a mandatory option does not have a value.
	   * Called after checking for help flags in leaf subcommand.
	   *
	   * @api private
	   */

	  _checkForMissingMandatoryOptions() {
	    // Walk up hierarchy so can call in subcommand after checking for displaying help.
	    this._getCommandAndAncestors().forEach((cmd) => {
	      cmd.options.forEach((anOption) => {
	        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {
	          cmd.missingMandatoryOptionValue(anOption);
	        }
	      });
	    });
	  }

	  /**
	   * Display an error message if conflicting options are used together in this.
	   *
	   * @api private
	   */
	  _checkForConflictingLocalOptions() {
	    const definedNonDefaultOptions = this.options.filter(
	      (option) => {
	        const optionKey = option.attributeName();
	        if (this.getOptionValue(optionKey) === undefined) {
	          return false;
	        }
	        return this.getOptionValueSource(optionKey) !== 'default';
	      }
	    );

	    const optionsWithConflicting = definedNonDefaultOptions.filter(
	      (option) => option.conflictsWith.length > 0
	    );

	    optionsWithConflicting.forEach((option) => {
	      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
	        option.conflictsWith.includes(defined.attributeName())
	      );
	      if (conflictingAndDefined) {
	        this._conflictingOption(option, conflictingAndDefined);
	      }
	    });
	  }

	  /**
	   * Display an error message if conflicting options are used together.
	   * Called after checking for help flags in leaf subcommand.
	   *
	   * @api private
	   */
	  _checkForConflictingOptions() {
	    // Walk up hierarchy so can call in subcommand after checking for displaying help.
	    this._getCommandAndAncestors().forEach((cmd) => {
	      cmd._checkForConflictingLocalOptions();
	    });
	  }

	  /**
	   * Parse options from `argv` removing known options,
	   * and return argv split into operands and unknown arguments.
	   *
	   * Examples:
	   *
	   *     argv => operands, unknown
	   *     --known kkk op => [op], []
	   *     op --known kkk => [op], []
	   *     sub --unknown uuu op => [sub], [--unknown uuu op]
	   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
	   *
	   * @param {String[]} argv
	   * @return {{operands: String[], unknown: String[]}}
	   */

	  parseOptions(argv) {
	    const operands = []; // operands, not options or values
	    const unknown = []; // first unknown option and remaining unknown args
	    let dest = operands;
	    const args = argv.slice();

	    function maybeOption(arg) {
	      return arg.length > 1 && arg[0] === '-';
	    }

	    // parse options
	    let activeVariadicOption = null;
	    while (args.length) {
	      const arg = args.shift();

	      // literal
	      if (arg === '--') {
	        if (dest === unknown) dest.push(arg);
	        dest.push(...args);
	        break;
	      }

	      if (activeVariadicOption && !maybeOption(arg)) {
	        this.emit(`option:${activeVariadicOption.name()}`, arg);
	        continue;
	      }
	      activeVariadicOption = null;

	      if (maybeOption(arg)) {
	        const option = this._findOption(arg);
	        // recognised option, call listener to assign value with possible custom processing
	        if (option) {
	          if (option.required) {
	            const value = args.shift();
	            if (value === undefined) this.optionMissingArgument(option);
	            this.emit(`option:${option.name()}`, value);
	          } else if (option.optional) {
	            let value = null;
	            // historical behaviour is optional value is following arg unless an option
	            if (args.length > 0 && !maybeOption(args[0])) {
	              value = args.shift();
	            }
	            this.emit(`option:${option.name()}`, value);
	          } else { // boolean flag
	            this.emit(`option:${option.name()}`);
	          }
	          activeVariadicOption = option.variadic ? option : null;
	          continue;
	        }
	      }

	      // Look for combo options following single dash, eat first one if known.
	      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
	        const option = this._findOption(`-${arg[1]}`);
	        if (option) {
	          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
	            // option with value following in same argument
	            this.emit(`option:${option.name()}`, arg.slice(2));
	          } else {
	            // boolean option, emit and put back remainder of arg for further processing
	            this.emit(`option:${option.name()}`);
	            args.unshift(`-${arg.slice(2)}`);
	          }
	          continue;
	        }
	      }

	      // Look for known long flag with value, like --foo=bar
	      if (/^--[^=]+=/.test(arg)) {
	        const index = arg.indexOf('=');
	        const option = this._findOption(arg.slice(0, index));
	        if (option && (option.required || option.optional)) {
	          this.emit(`option:${option.name()}`, arg.slice(index + 1));
	          continue;
	        }
	      }

	      // Not a recognised option by this command.
	      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

	      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
	      if (maybeOption(arg)) {
	        dest = unknown;
	      }

	      // If using positionalOptions, stop processing our options at subcommand.
	      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
	        if (this._findCommand(arg)) {
	          operands.push(arg);
	          if (args.length > 0) unknown.push(...args);
	          break;
	        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
	          operands.push(arg);
	          if (args.length > 0) operands.push(...args);
	          break;
	        } else if (this._defaultCommandName) {
	          unknown.push(arg);
	          if (args.length > 0) unknown.push(...args);
	          break;
	        }
	      }

	      // If using passThroughOptions, stop processing options at first command-argument.
	      if (this._passThroughOptions) {
	        dest.push(arg);
	        if (args.length > 0) dest.push(...args);
	        break;
	      }

	      // add arg
	      dest.push(arg);
	    }

	    return { operands, unknown };
	  }

	  /**
	   * Return an object containing local option values as key-value pairs.
	   *
	   * @return {Object}
	   */
	  opts() {
	    if (this._storeOptionsAsProperties) {
	      // Preserve original behaviour so backwards compatible when still using properties
	      const result = {};
	      const len = this.options.length;

	      for (let i = 0; i < len; i++) {
	        const key = this.options[i].attributeName();
	        result[key] = key === this._versionOptionName ? this._version : this[key];
	      }
	      return result;
	    }

	    return this._optionValues;
	  }

	  /**
	   * Return an object containing merged local and global option values as key-value pairs.
	   *
	   * @return {Object}
	   */
	  optsWithGlobals() {
	    // globals overwrite locals
	    return this._getCommandAndAncestors().reduce(
	      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
	      {}
	    );
	  }

	  /**
	   * Display error message and exit (or call exitOverride).
	   *
	   * @param {string} message
	   * @param {Object} [errorOptions]
	   * @param {string} [errorOptions.code] - an id string representing the error
	   * @param {number} [errorOptions.exitCode] - used with process.exit
	   */
	  error(message, errorOptions) {
	    // output handling
	    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
	    if (typeof this._showHelpAfterError === 'string') {
	      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
	    } else if (this._showHelpAfterError) {
	      this._outputConfiguration.writeErr('\n');
	      this.outputHelp({ error: true });
	    }

	    // exit handling
	    const config = errorOptions || {};
	    const exitCode = config.exitCode || 1;
	    const code = config.code || 'commander.error';
	    this._exit(exitCode, code, message);
	  }

	  /**
	   * Apply any option related environment variables, if option does
	   * not have a value from cli or client code.
	   *
	   * @api private
	   */
	  _parseOptionsEnv() {
	    this.options.forEach((option) => {
	      if (option.envVar && option.envVar in process.env) {
	        const optionKey = option.attributeName();
	        // Priority check. Do not overwrite cli or options from unknown source (client-code).
	        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
	          if (option.required || option.optional) { // option can take a value
	            // keep very simple, optional always takes value
	            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
	          } else { // boolean
	            // keep very simple, only care that envVar defined and not the value
	            this.emit(`optionEnv:${option.name()}`);
	          }
	        }
	      }
	    });
	  }

	  /**
	   * Apply any implied option values, if option is undefined or default value.
	   *
	   * @api private
	   */
	  _parseOptionsImplied() {
	    const dualHelper = new DualOptions(this.options);
	    const hasCustomOptionValue = (optionKey) => {
	      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));
	    };
	    this.options
	      .filter(option => (option.implied !== undefined) &&
	        hasCustomOptionValue(option.attributeName()) &&
	        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))
	      .forEach((option) => {
	        Object.keys(option.implied)
	          .filter(impliedKey => !hasCustomOptionValue(impliedKey))
	          .forEach(impliedKey => {
	            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');
	          });
	      });
	  }

	  /**
	   * Argument `name` is missing.
	   *
	   * @param {string} name
	   * @api private
	   */

	  missingArgument(name) {
	    const message = `error: missing required argument '${name}'`;
	    this.error(message, { code: 'commander.missingArgument' });
	  }

	  /**
	   * `Option` is missing an argument.
	   *
	   * @param {Option} option
	   * @api private
	   */

	  optionMissingArgument(option) {
	    const message = `error: option '${option.flags}' argument missing`;
	    this.error(message, { code: 'commander.optionMissingArgument' });
	  }

	  /**
	   * `Option` does not have a value, and is a mandatory option.
	   *
	   * @param {Option} option
	   * @api private
	   */

	  missingMandatoryOptionValue(option) {
	    const message = `error: required option '${option.flags}' not specified`;
	    this.error(message, { code: 'commander.missingMandatoryOptionValue' });
	  }

	  /**
	   * `Option` conflicts with another option.
	   *
	   * @param {Option} option
	   * @param {Option} conflictingOption
	   * @api private
	   */
	  _conflictingOption(option, conflictingOption) {
	    // The calling code does not know whether a negated option is the source of the
	    // value, so do some work to take an educated guess.
	    const findBestOptionFromValue = (option) => {
	      const optionKey = option.attributeName();
	      const optionValue = this.getOptionValue(optionKey);
	      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());
	      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());
	      if (negativeOption && (
	        (negativeOption.presetArg === undefined && optionValue === false) ||
	        (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)
	      )) {
	        return negativeOption;
	      }
	      return positiveOption || option;
	    };

	    const getErrorMessage = (option) => {
	      const bestOption = findBestOptionFromValue(option);
	      const optionKey = bestOption.attributeName();
	      const source = this.getOptionValueSource(optionKey);
	      if (source === 'env') {
	        return `environment variable '${bestOption.envVar}'`;
	      }
	      return `option '${bestOption.flags}'`;
	    };

	    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
	    this.error(message, { code: 'commander.conflictingOption' });
	  }

	  /**
	   * Unknown option `flag`.
	   *
	   * @param {string} flag
	   * @api private
	   */

	  unknownOption(flag) {
	    if (this._allowUnknownOption) return;
	    let suggestion = '';

	    if (flag.startsWith('--') && this._showSuggestionAfterError) {
	      // Looping to pick up the global options too
	      let candidateFlags = [];
	      let command = this;
	      do {
	        const moreFlags = command.createHelp().visibleOptions(command)
	          .filter(option => option.long)
	          .map(option => option.long);
	        candidateFlags = candidateFlags.concat(moreFlags);
	        command = command.parent;
	      } while (command && !command._enablePositionalOptions);
	      suggestion = suggestSimilar(flag, candidateFlags);
	    }

	    const message = `error: unknown option '${flag}'${suggestion}`;
	    this.error(message, { code: 'commander.unknownOption' });
	  }

	  /**
	   * Excess arguments, more than expected.
	   *
	   * @param {string[]} receivedArgs
	   * @api private
	   */

	  _excessArguments(receivedArgs) {
	    if (this._allowExcessArguments) return;

	    const expected = this.registeredArguments.length;
	    const s = (expected === 1) ? '' : 's';
	    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
	    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
	    this.error(message, { code: 'commander.excessArguments' });
	  }

	  /**
	   * Unknown command.
	   *
	   * @api private
	   */

	  unknownCommand() {
	    const unknownName = this.args[0];
	    let suggestion = '';

	    if (this._showSuggestionAfterError) {
	      const candidateNames = [];
	      this.createHelp().visibleCommands(this).forEach((command) => {
	        candidateNames.push(command.name());
	        // just visible alias
	        if (command.alias()) candidateNames.push(command.alias());
	      });
	      suggestion = suggestSimilar(unknownName, candidateNames);
	    }

	    const message = `error: unknown command '${unknownName}'${suggestion}`;
	    this.error(message, { code: 'commander.unknownCommand' });
	  }

	  /**
	   * Get or set the program version.
	   *
	   * This method auto-registers the "-V, --version" option which will print the version number.
	   *
	   * You can optionally supply the flags and description to override the defaults.
	   *
	   * @param {string} [str]
	   * @param {string} [flags]
	   * @param {string} [description]
	   * @return {this | string | undefined} `this` command for chaining, or version string if no arguments
	   */

	  version(str, flags, description) {
	    if (str === undefined) return this._version;
	    this._version = str;
	    flags = flags || '-V, --version';
	    description = description || 'output the version number';
	    const versionOption = this.createOption(flags, description);
	    this._versionOptionName = versionOption.attributeName(); // [sic] not defined in constructor, partly legacy, partly only needed at root
	    this.options.push(versionOption);
	    this.on('option:' + versionOption.name(), () => {
	      this._outputConfiguration.writeOut(`${str}\n`);
	      this._exit(0, 'commander.version', str);
	    });
	    return this;
	  }

	  /**
	   * Set the description.
	   *
	   * @param {string} [str]
	   * @param {Object} [argsDescription]
	   * @return {string|Command}
	   */
	  description(str, argsDescription) {
	    if (str === undefined && argsDescription === undefined) return this._description;
	    this._description = str;
	    if (argsDescription) {
	      this._argsDescription = argsDescription;
	    }
	    return this;
	  }

	  /**
	   * Set the summary. Used when listed as subcommand of parent.
	   *
	   * @param {string} [str]
	   * @return {string|Command}
	   */
	  summary(str) {
	    if (str === undefined) return this._summary;
	    this._summary = str;
	    return this;
	  }

	  /**
	   * Set an alias for the command.
	   *
	   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
	   *
	   * @param {string} [alias]
	   * @return {string|Command}
	   */

	  alias(alias) {
	    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

	    /** @type {Command} */
	    let command = this;
	    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
	      // assume adding alias for last added executable subcommand, rather than this
	      command = this.commands[this.commands.length - 1];
	    }

	    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

	    command._aliases.push(alias);
	    return this;
	  }

	  /**
	   * Set aliases for the command.
	   *
	   * Only the first alias is shown in the auto-generated help.
	   *
	   * @param {string[]} [aliases]
	   * @return {string[]|Command}
	   */

	  aliases(aliases) {
	    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
	    if (aliases === undefined) return this._aliases;

	    aliases.forEach((alias) => this.alias(alias));
	    return this;
	  }

	  /**
	   * Set / get the command usage `str`.
	   *
	   * @param {string} [str]
	   * @return {String|Command}
	   */

	  usage(str) {
	    if (str === undefined) {
	      if (this._usage) return this._usage;

	      const args = this.registeredArguments.map((arg) => {
	        return humanReadableArgName(arg);
	      });
	      return [].concat(
	        (this.options.length || this._hasHelpOption ? '[options]' : []),
	        (this.commands.length ? '[command]' : []),
	        (this.registeredArguments.length ? args : [])
	      ).join(' ');
	    }

	    this._usage = str;
	    return this;
	  }

	  /**
	   * Get or set the name of the command.
	   *
	   * @param {string} [str]
	   * @return {string|Command}
	   */

	  name(str) {
	    if (str === undefined) return this._name;
	    this._name = str;
	    return this;
	  }

	  /**
	   * Set the name of the command from script filename, such as process.argv[1],
	   * or require.main.filename, or __filename.
	   *
	   * (Used internally and public although not documented in README.)
	   *
	   * @example
	   * program.nameFromFilename(require.main.filename);
	   *
	   * @param {string} filename
	   * @return {Command}
	   */

	  nameFromFilename(filename) {
	    this._name = path.basename(filename, path.extname(filename));

	    return this;
	  }

	  /**
	   * Get or set the directory for searching for executable subcommands of this command.
	   *
	   * @example
	   * program.executableDir(__dirname);
	   * // or
	   * program.executableDir('subcommands');
	   *
	   * @param {string} [path]
	   * @return {string|null|Command}
	   */

	  executableDir(path) {
	    if (path === undefined) return this._executableDir;
	    this._executableDir = path;
	    return this;
	  }

	  /**
	   * Return program help documentation.
	   *
	   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
	   * @return {string}
	   */

	  helpInformation(contextOptions) {
	    const helper = this.createHelp();
	    if (helper.helpWidth === undefined) {
	      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
	    }
	    return helper.formatHelp(this, helper);
	  }

	  /**
	   * @api private
	   */

	  _getHelpContext(contextOptions) {
	    contextOptions = contextOptions || {};
	    const context = { error: !!contextOptions.error };
	    let write;
	    if (context.error) {
	      write = (arg) => this._outputConfiguration.writeErr(arg);
	    } else {
	      write = (arg) => this._outputConfiguration.writeOut(arg);
	    }
	    context.write = contextOptions.write || write;
	    context.command = this;
	    return context;
	  }

	  /**
	   * Output help information for this command.
	   *
	   * Outputs built-in help, and custom text added using `.addHelpText()`.
	   *
	   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
	   */

	  outputHelp(contextOptions) {
	    let deprecatedCallback;
	    if (typeof contextOptions === 'function') {
	      deprecatedCallback = contextOptions;
	      contextOptions = undefined;
	    }
	    const context = this._getHelpContext(contextOptions);

	    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));
	    this.emit('beforeHelp', context);

	    let helpInformation = this.helpInformation(context);
	    if (deprecatedCallback) {
	      helpInformation = deprecatedCallback(helpInformation);
	      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
	        throw new Error('outputHelp callback must return a string or a Buffer');
	      }
	    }
	    context.write(helpInformation);

	    if (this._helpLongFlag) {
	      this.emit(this._helpLongFlag); // deprecated
	    }
	    this.emit('afterHelp', context);
	    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));
	  }

	  /**
	   * You can pass in flags and a description to override the help
	   * flags and help description for your command. Pass in false to
	   * disable the built-in help option.
	   *
	   * @param {string | boolean} [flags]
	   * @param {string} [description]
	   * @return {Command} `this` command for chaining
	   */

	  helpOption(flags, description) {
	    if (typeof flags === 'boolean') {
	      this._hasHelpOption = flags;
	      return this;
	    }
	    this._helpFlags = flags || this._helpFlags;
	    this._helpDescription = description || this._helpDescription;

	    const helpFlags = splitOptionFlags(this._helpFlags);
	    this._helpShortFlag = helpFlags.shortFlag;
	    this._helpLongFlag = helpFlags.longFlag;

	    return this;
	  }

	  /**
	   * Output help information and exit.
	   *
	   * Outputs built-in help, and custom text added using `.addHelpText()`.
	   *
	   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
	   */

	  help(contextOptions) {
	    this.outputHelp(contextOptions);
	    let exitCode = process.exitCode || 0;
	    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
	      exitCode = 1;
	    }
	    // message: do not have all displayed text available so only passing placeholder.
	    this._exit(exitCode, 'commander.help', '(outputHelp)');
	  }

	  /**
	   * Add additional text to be displayed with the built-in help.
	   *
	   * Position is 'before' or 'after' to affect just this command,
	   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
	   *
	   * @param {string} position - before or after built-in help
	   * @param {string | Function} text - string to add, or a function returning a string
	   * @return {Command} `this` command for chaining
	   */
	  addHelpText(position, text) {
	    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
	    if (!allowedValues.includes(position)) {
	      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
	    }
	    const helpEvent = `${position}Help`;
	    this.on(helpEvent, (context) => {
	      let helpStr;
	      if (typeof text === 'function') {
	        helpStr = text({ error: context.error, command: context.command });
	      } else {
	        helpStr = text;
	      }
	      // Ignore falsy value when nothing to output.
	      if (helpStr) {
	        context.write(`${helpStr}\n`);
	      }
	    });
	    return this;
	  }
	}

	/**
	 * Output help information if help flags specified
	 *
	 * @param {Command} cmd - command to output help for
	 * @param {Array} args - array of options to search for help flags
	 * @api private
	 */

	function outputHelpIfRequested(cmd, args) {
	  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
	  if (helpOption) {
	    cmd.outputHelp();
	    // (Do not have all displayed text available so only passing placeholder.)
	    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
	  }
	}

	/**
	 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
	 *
	 * @param {string[]} args - array of arguments from node.execArgv
	 * @returns {string[]}
	 * @api private
	 */

	function incrementNodeInspectorPort(args) {
	  // Testing for these options:
	  //  --inspect[=[host:]port]
	  //  --inspect-brk[=[host:]port]
	  //  --inspect-port=[host:]port
	  return args.map((arg) => {
	    if (!arg.startsWith('--inspect')) {
	      return arg;
	    }
	    let debugOption;
	    let debugHost = '127.0.0.1';
	    let debugPort = '9229';
	    let match;
	    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
	      // e.g. --inspect
	      debugOption = match[1];
	    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
	      debugOption = match[1];
	      if (/^\d+$/.test(match[3])) {
	        // e.g. --inspect=1234
	        debugPort = match[3];
	      } else {
	        // e.g. --inspect=localhost
	        debugHost = match[3];
	      }
	    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
	      // e.g. --inspect=localhost:1234
	      debugOption = match[1];
	      debugHost = match[3];
	      debugPort = match[4];
	    }

	    if (debugOption && debugPort !== '0') {
	      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
	    }
	    return arg;
	  });
	}

	command.Command = Command;
	return command;
}

var hasRequiredCommander;

function requireCommander () {
	if (hasRequiredCommander) return commander$1.exports;
	hasRequiredCommander = 1;
	(function (module, exports) {
		const { Argument } = requireArgument();
		const { Command } = requireCommand();
		const { CommanderError, InvalidArgumentError } = requireError();
		const { Help } = requireHelp();
		const { Option } = requireOption();

		/**
		 * Expose the root command.
		 */

		exports = module.exports = new Command();
		exports.program = exports; // More explicit access to global command.
		// createArgument, createCommand, and createOption are implicitly available as they are methods on program.

		/**
		 * Expose classes
		 */

		exports.Command = Command;
		exports.Option = Option;
		exports.Argument = Argument;
		exports.Help = Help;

		exports.CommanderError = CommanderError;
		exports.InvalidArgumentError = InvalidArgumentError;
		exports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated 
	} (commander$1, commander$1.exports));
	return commander$1.exports;
}

var commanderExports = requireCommander();
var commander = /*@__PURE__*/getDefaultExportFromCjs(commanderExports);

// wrapper to provide named exports for ESM.
const {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError, // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = commander;

const ANSI_BACKGROUND_OFFSET$1 = 10;

const wrapAnsi16$1 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256$1 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m$1 = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles$2 = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

Object.keys(styles$2.modifier);
const foregroundColorNames$1 = Object.keys(styles$2.color);
const backgroundColorNames$1 = Object.keys(styles$2.bgColor);
[...foregroundColorNames$1, ...backgroundColorNames$1];

function assembleStyles$1() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles$2)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$2[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles$2[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles$2, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles$2, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles$2.color.close = '\u001B[39m';
	styles$2.bgColor.close = '\u001B[49m';

	styles$2.color.ansi = wrapAnsi16$1();
	styles$2.color.ansi256 = wrapAnsi256$1();
	styles$2.color.ansi16m = wrapAnsi16m$1();
	styles$2.bgColor.ansi = wrapAnsi16$1(ANSI_BACKGROUND_OFFSET$1);
	styles$2.bgColor.ansi256 = wrapAnsi256$1(ANSI_BACKGROUND_OFFSET$1);
	styles$2.bgColor.ansi16m = wrapAnsi16m$1(ANSI_BACKGROUND_OFFSET$1);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles$2, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles$2.rgbToAnsi256(...styles$2.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$2.ansi256ToAnsi(styles$2.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles$2.ansi256ToAnsi(styles$2.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles$2;
}

const ansiStyles$1 = assembleStyles$1();

// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process$1.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = process$1;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process$1.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['GITHUB_ACTIONS', 'GITEA_ACTIONS', 'CIRCLECI'].some(key => key in env)) {
			return 3;
		}

		if (['TRAVIS', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: tty.isatty(1)}),
	stderr: createSupportsColor({isTTY: tty.isatty(2)}),
};

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

const {stdout: stdoutColor, stderr: stderrColor} = supportsColor;

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const styles$1 = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansiStyles$1)) {
	styles$1[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

styles$1.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return ansiStyles$1[type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return ansiStyles$1[type].ansi256(ansiStyles$1.rgbToAnsi256(...arguments_));
		}

		return ansiStyles$1[type].ansi(ansiStyles$1.rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ...ansiStyles$1.hexToRgb(...arguments_));
	}

	return ansiStyles$1[type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	styles$1[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansiStyles$1.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles$1[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansiStyles$1.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles$1,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles$1);

const chalk = createChalk();
createChalk({level: stderrColor ? stderrColor.level : 0});

var onetime$1 = {exports: {}};

var mimicFn = {exports: {}};

var hasRequiredMimicFn;

function requireMimicFn () {
	if (hasRequiredMimicFn) return mimicFn.exports;
	hasRequiredMimicFn = 1;

	const mimicFn$1 = (to, from) => {
		for (const prop of Reflect.ownKeys(from)) {
			Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
		}

		return to;
	};

	mimicFn.exports = mimicFn$1;
	// TODO: Remove this for the next major release
	mimicFn.exports.default = mimicFn$1;
	return mimicFn.exports;
}

var hasRequiredOnetime;

function requireOnetime () {
	if (hasRequiredOnetime) return onetime$1.exports;
	hasRequiredOnetime = 1;
	const mimicFn = requireMimicFn();

	const calledFunctions = new WeakMap();

	const onetime = (function_, options = {}) => {
		if (typeof function_ !== 'function') {
			throw new TypeError('Expected a function');
		}

		let returnValue;
		let callCount = 0;
		const functionName = function_.displayName || function_.name || '<anonymous>';

		const onetime = function (...arguments_) {
			calledFunctions.set(onetime, ++callCount);

			if (callCount === 1) {
				returnValue = function_.apply(this, arguments_);
				function_ = null;
			} else if (options.throw === true) {
				throw new Error(`Function \`${functionName}\` can only be called once`);
			}

			return returnValue;
		};

		mimicFn(onetime, function_);
		calledFunctions.set(onetime, callCount);

		return onetime;
	};

	onetime$1.exports = onetime;
	// TODO: Remove this for the next major release
	onetime$1.exports.default = onetime;

	onetime$1.exports.callCount = function_ => {
		if (!calledFunctions.has(function_)) {
			throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
		}

		return calledFunctions.get(function_);
	};
	return onetime$1.exports;
}

var onetimeExports = requireOnetime();
var onetime = /*@__PURE__*/getDefaultExportFromCjs(onetimeExports);

var signalExit$1 = {exports: {}};

var signals = {exports: {}};

var hasRequiredSignals;

function requireSignals () {
	if (hasRequiredSignals) return signals.exports;
	hasRequiredSignals = 1;
	(function (module) {
		// This is not the set of all possible signals.
		//
		// It IS, however, the set of all signals that trigger
		// an exit on either Linux or BSD systems.  Linux is a
		// superset of the signal names supported on BSD, and
		// the unknown signals just fail to register, so we can
		// catch that easily enough.
		//
		// Don't bother with SIGKILL.  It's uncatchable, which
		// means that we can't fire any callbacks anyway.
		//
		// If a user does happen to register a handler on a non-
		// fatal signal like SIGWINCH or something, and then
		// exit, it'll end up firing `process.emit('exit')`, so
		// the handler will be fired anyway.
		//
		// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
		// artificially, inherently leave the process in a
		// state from which it is not safe to try and enter JS
		// listeners.
		module.exports = [
		  'SIGABRT',
		  'SIGALRM',
		  'SIGHUP',
		  'SIGINT',
		  'SIGTERM'
		];

		if (process.platform !== 'win32') {
		  module.exports.push(
		    'SIGVTALRM',
		    'SIGXCPU',
		    'SIGXFSZ',
		    'SIGUSR2',
		    'SIGTRAP',
		    'SIGSYS',
		    'SIGQUIT',
		    'SIGIOT'
		    // should detect profiler and enable/disable accordingly.
		    // see #21
		    // 'SIGPROF'
		  );
		}

		if (process.platform === 'linux') {
		  module.exports.push(
		    'SIGIO',
		    'SIGPOLL',
		    'SIGPWR',
		    'SIGSTKFLT',
		    'SIGUNUSED'
		  );
		} 
	} (signals));
	return signals.exports;
}

var hasRequiredSignalExit;

function requireSignalExit () {
	if (hasRequiredSignalExit) return signalExit$1.exports;
	hasRequiredSignalExit = 1;
	// Note: since nyc uses this module to output coverage, any lines
	// that are in the direct sync flow of nyc's outputCoverage are
	// ignored, since we can never get coverage for them.
	// grab a reference to node's real process object right away
	var process = commonjsGlobal.process;

	const processOk = function (process) {
	  return process &&
	    typeof process === 'object' &&
	    typeof process.removeListener === 'function' &&
	    typeof process.emit === 'function' &&
	    typeof process.reallyExit === 'function' &&
	    typeof process.listeners === 'function' &&
	    typeof process.kill === 'function' &&
	    typeof process.pid === 'number' &&
	    typeof process.on === 'function'
	};

	// some kind of non-node environment, just no-op
	/* istanbul ignore if */
	if (!processOk(process)) {
	  signalExit$1.exports = function () {
	    return function () {}
	  };
	} else {
	  var assert = require$$0$3;
	  var signals = requireSignals();
	  var isWin = /^win/i.test(process.platform);

	  var EE = require$$0$2;
	  /* istanbul ignore if */
	  if (typeof EE !== 'function') {
	    EE = EE.EventEmitter;
	  }

	  var emitter;
	  if (process.__signal_exit_emitter__) {
	    emitter = process.__signal_exit_emitter__;
	  } else {
	    emitter = process.__signal_exit_emitter__ = new EE();
	    emitter.count = 0;
	    emitter.emitted = {};
	  }

	  // Because this emitter is a global, we have to check to see if a
	  // previous version of this library failed to enable infinite listeners.
	  // I know what you're about to say.  But literally everything about
	  // signal-exit is a compromise with evil.  Get used to it.
	  if (!emitter.infinite) {
	    emitter.setMaxListeners(Infinity);
	    emitter.infinite = true;
	  }

	  signalExit$1.exports = function (cb, opts) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return function () {}
	    }
	    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');

	    if (loaded === false) {
	      load();
	    }

	    var ev = 'exit';
	    if (opts && opts.alwaysLast) {
	      ev = 'afterexit';
	    }

	    var remove = function () {
	      emitter.removeListener(ev, cb);
	      if (emitter.listeners('exit').length === 0 &&
	          emitter.listeners('afterexit').length === 0) {
	        unload();
	      }
	    };
	    emitter.on(ev, cb);

	    return remove
	  };

	  var unload = function unload () {
	    if (!loaded || !processOk(commonjsGlobal.process)) {
	      return
	    }
	    loaded = false;

	    signals.forEach(function (sig) {
	      try {
	        process.removeListener(sig, sigListeners[sig]);
	      } catch (er) {}
	    });
	    process.emit = originalProcessEmit;
	    process.reallyExit = originalProcessReallyExit;
	    emitter.count -= 1;
	  };
	  signalExit$1.exports.unload = unload;

	  var emit = function emit (event, code, signal) {
	    /* istanbul ignore if */
	    if (emitter.emitted[event]) {
	      return
	    }
	    emitter.emitted[event] = true;
	    emitter.emit(event, code, signal);
	  };

	  // { <signal>: <listener fn>, ... }
	  var sigListeners = {};
	  signals.forEach(function (sig) {
	    sigListeners[sig] = function listener () {
	      /* istanbul ignore if */
	      if (!processOk(commonjsGlobal.process)) {
	        return
	      }
	      // If there are no other listeners, an exit is coming!
	      // Simplest way: remove us and then re-send the signal.
	      // We know that this will kill the process, so we can
	      // safely emit now.
	      var listeners = process.listeners(sig);
	      if (listeners.length === emitter.count) {
	        unload();
	        emit('exit', null, sig);
	        /* istanbul ignore next */
	        emit('afterexit', null, sig);
	        /* istanbul ignore next */
	        if (isWin && sig === 'SIGHUP') {
	          // "SIGHUP" throws an `ENOSYS` error on Windows,
	          // so use a supported signal instead
	          sig = 'SIGINT';
	        }
	        /* istanbul ignore next */
	        process.kill(process.pid, sig);
	      }
	    };
	  });

	  signalExit$1.exports.signals = function () {
	    return signals
	  };

	  var loaded = false;

	  var load = function load () {
	    if (loaded || !processOk(commonjsGlobal.process)) {
	      return
	    }
	    loaded = true;

	    // This is the number of onSignalExit's that are in play.
	    // It's important so that we can count the correct number of
	    // listeners on signals, and don't wait for the other one to
	    // handle it instead of us.
	    emitter.count += 1;

	    signals = signals.filter(function (sig) {
	      try {
	        process.on(sig, sigListeners[sig]);
	        return true
	      } catch (er) {
	        return false
	      }
	    });

	    process.emit = processEmit;
	    process.reallyExit = processReallyExit;
	  };
	  signalExit$1.exports.load = load;

	  var originalProcessReallyExit = process.reallyExit;
	  var processReallyExit = function processReallyExit (code) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return
	    }
	    process.exitCode = code || /* istanbul ignore next */ 0;
	    emit('exit', process.exitCode, null);
	    /* istanbul ignore next */
	    emit('afterexit', process.exitCode, null);
	    /* istanbul ignore next */
	    originalProcessReallyExit.call(process, process.exitCode);
	  };

	  var originalProcessEmit = process.emit;
	  var processEmit = function processEmit (ev, arg) {
	    if (ev === 'exit' && processOk(commonjsGlobal.process)) {
	      /* istanbul ignore else */
	      if (arg !== undefined) {
	        process.exitCode = arg;
	      }
	      var ret = originalProcessEmit.apply(this, arguments);
	      /* istanbul ignore next */
	      emit('exit', process.exitCode, null);
	      /* istanbul ignore next */
	      emit('afterexit', process.exitCode, null);
	      /* istanbul ignore next */
	      return ret
	    } else {
	      return originalProcessEmit.apply(this, arguments)
	    }
	  };
	}
	return signalExit$1.exports;
}

var signalExitExports = requireSignalExit();
var signalExit = /*@__PURE__*/getDefaultExportFromCjs(signalExitExports);

const restoreCursor = onetime(() => {
	signalExit(() => {
		process$1.stderr.write('\u001B[?25h');
	}, {alwaysLast: true});
});

let isHidden = false;

const cliCursor = {};

cliCursor.show = (writableStream = process$1.stderr) => {
	if (!writableStream.isTTY) {
		return;
	}

	isHidden = false;
	writableStream.write('\u001B[?25h');
};

cliCursor.hide = (writableStream = process$1.stderr) => {
	if (!writableStream.isTTY) {
		return;
	}

	restoreCursor();
	isHidden = true;
	writableStream.write('\u001B[?25l');
};

cliCursor.toggle = (force, writableStream) => {
	if (force !== undefined) {
		isHidden = force;
	}

	if (isHidden) {
		cliCursor.show(writableStream);
	} else {
		cliCursor.hide(writableStream);
	}
};

var dots = {
	interval: 80,
	frames: [
		"⠋",
		"⠙",
		"⠹",
		"⠸",
		"⠼",
		"⠴",
		"⠦",
		"⠧",
		"⠇",
		"⠏"
	]
};
var dots2 = {
	interval: 80,
	frames: [
		"⣾",
		"⣽",
		"⣻",
		"⢿",
		"⡿",
		"⣟",
		"⣯",
		"⣷"
	]
};
var dots3 = {
	interval: 80,
	frames: [
		"⠋",
		"⠙",
		"⠚",
		"⠞",
		"⠖",
		"⠦",
		"⠴",
		"⠲",
		"⠳",
		"⠓"
	]
};
var dots4 = {
	interval: 80,
	frames: [
		"⠄",
		"⠆",
		"⠇",
		"⠋",
		"⠙",
		"⠸",
		"⠰",
		"⠠",
		"⠰",
		"⠸",
		"⠙",
		"⠋",
		"⠇",
		"⠆"
	]
};
var dots5 = {
	interval: 80,
	frames: [
		"⠋",
		"⠙",
		"⠚",
		"⠒",
		"⠂",
		"⠂",
		"⠒",
		"⠲",
		"⠴",
		"⠦",
		"⠖",
		"⠒",
		"⠐",
		"⠐",
		"⠒",
		"⠓",
		"⠋"
	]
};
var dots6 = {
	interval: 80,
	frames: [
		"⠁",
		"⠉",
		"⠙",
		"⠚",
		"⠒",
		"⠂",
		"⠂",
		"⠒",
		"⠲",
		"⠴",
		"⠤",
		"⠄",
		"⠄",
		"⠤",
		"⠴",
		"⠲",
		"⠒",
		"⠂",
		"⠂",
		"⠒",
		"⠚",
		"⠙",
		"⠉",
		"⠁"
	]
};
var dots7 = {
	interval: 80,
	frames: [
		"⠈",
		"⠉",
		"⠋",
		"⠓",
		"⠒",
		"⠐",
		"⠐",
		"⠒",
		"⠖",
		"⠦",
		"⠤",
		"⠠",
		"⠠",
		"⠤",
		"⠦",
		"⠖",
		"⠒",
		"⠐",
		"⠐",
		"⠒",
		"⠓",
		"⠋",
		"⠉",
		"⠈"
	]
};
var dots8 = {
	interval: 80,
	frames: [
		"⠁",
		"⠁",
		"⠉",
		"⠙",
		"⠚",
		"⠒",
		"⠂",
		"⠂",
		"⠒",
		"⠲",
		"⠴",
		"⠤",
		"⠄",
		"⠄",
		"⠤",
		"⠠",
		"⠠",
		"⠤",
		"⠦",
		"⠖",
		"⠒",
		"⠐",
		"⠐",
		"⠒",
		"⠓",
		"⠋",
		"⠉",
		"⠈",
		"⠈"
	]
};
var dots9 = {
	interval: 80,
	frames: [
		"⢹",
		"⢺",
		"⢼",
		"⣸",
		"⣇",
		"⡧",
		"⡗",
		"⡏"
	]
};
var dots10 = {
	interval: 80,
	frames: [
		"⢄",
		"⢂",
		"⢁",
		"⡁",
		"⡈",
		"⡐",
		"⡠"
	]
};
var dots11 = {
	interval: 100,
	frames: [
		"⠁",
		"⠂",
		"⠄",
		"⡀",
		"⢀",
		"⠠",
		"⠐",
		"⠈"
	]
};
var dots12 = {
	interval: 80,
	frames: [
		"⢀⠀",
		"⡀⠀",
		"⠄⠀",
		"⢂⠀",
		"⡂⠀",
		"⠅⠀",
		"⢃⠀",
		"⡃⠀",
		"⠍⠀",
		"⢋⠀",
		"⡋⠀",
		"⠍⠁",
		"⢋⠁",
		"⡋⠁",
		"⠍⠉",
		"⠋⠉",
		"⠋⠉",
		"⠉⠙",
		"⠉⠙",
		"⠉⠩",
		"⠈⢙",
		"⠈⡙",
		"⢈⠩",
		"⡀⢙",
		"⠄⡙",
		"⢂⠩",
		"⡂⢘",
		"⠅⡘",
		"⢃⠨",
		"⡃⢐",
		"⠍⡐",
		"⢋⠠",
		"⡋⢀",
		"⠍⡁",
		"⢋⠁",
		"⡋⠁",
		"⠍⠉",
		"⠋⠉",
		"⠋⠉",
		"⠉⠙",
		"⠉⠙",
		"⠉⠩",
		"⠈⢙",
		"⠈⡙",
		"⠈⠩",
		"⠀⢙",
		"⠀⡙",
		"⠀⠩",
		"⠀⢘",
		"⠀⡘",
		"⠀⠨",
		"⠀⢐",
		"⠀⡐",
		"⠀⠠",
		"⠀⢀",
		"⠀⡀"
	]
};
var dots13 = {
	interval: 80,
	frames: [
		"⣼",
		"⣹",
		"⢻",
		"⠿",
		"⡟",
		"⣏",
		"⣧",
		"⣶"
	]
};
var dots8Bit = {
	interval: 80,
	frames: [
		"⠀",
		"⠁",
		"⠂",
		"⠃",
		"⠄",
		"⠅",
		"⠆",
		"⠇",
		"⡀",
		"⡁",
		"⡂",
		"⡃",
		"⡄",
		"⡅",
		"⡆",
		"⡇",
		"⠈",
		"⠉",
		"⠊",
		"⠋",
		"⠌",
		"⠍",
		"⠎",
		"⠏",
		"⡈",
		"⡉",
		"⡊",
		"⡋",
		"⡌",
		"⡍",
		"⡎",
		"⡏",
		"⠐",
		"⠑",
		"⠒",
		"⠓",
		"⠔",
		"⠕",
		"⠖",
		"⠗",
		"⡐",
		"⡑",
		"⡒",
		"⡓",
		"⡔",
		"⡕",
		"⡖",
		"⡗",
		"⠘",
		"⠙",
		"⠚",
		"⠛",
		"⠜",
		"⠝",
		"⠞",
		"⠟",
		"⡘",
		"⡙",
		"⡚",
		"⡛",
		"⡜",
		"⡝",
		"⡞",
		"⡟",
		"⠠",
		"⠡",
		"⠢",
		"⠣",
		"⠤",
		"⠥",
		"⠦",
		"⠧",
		"⡠",
		"⡡",
		"⡢",
		"⡣",
		"⡤",
		"⡥",
		"⡦",
		"⡧",
		"⠨",
		"⠩",
		"⠪",
		"⠫",
		"⠬",
		"⠭",
		"⠮",
		"⠯",
		"⡨",
		"⡩",
		"⡪",
		"⡫",
		"⡬",
		"⡭",
		"⡮",
		"⡯",
		"⠰",
		"⠱",
		"⠲",
		"⠳",
		"⠴",
		"⠵",
		"⠶",
		"⠷",
		"⡰",
		"⡱",
		"⡲",
		"⡳",
		"⡴",
		"⡵",
		"⡶",
		"⡷",
		"⠸",
		"⠹",
		"⠺",
		"⠻",
		"⠼",
		"⠽",
		"⠾",
		"⠿",
		"⡸",
		"⡹",
		"⡺",
		"⡻",
		"⡼",
		"⡽",
		"⡾",
		"⡿",
		"⢀",
		"⢁",
		"⢂",
		"⢃",
		"⢄",
		"⢅",
		"⢆",
		"⢇",
		"⣀",
		"⣁",
		"⣂",
		"⣃",
		"⣄",
		"⣅",
		"⣆",
		"⣇",
		"⢈",
		"⢉",
		"⢊",
		"⢋",
		"⢌",
		"⢍",
		"⢎",
		"⢏",
		"⣈",
		"⣉",
		"⣊",
		"⣋",
		"⣌",
		"⣍",
		"⣎",
		"⣏",
		"⢐",
		"⢑",
		"⢒",
		"⢓",
		"⢔",
		"⢕",
		"⢖",
		"⢗",
		"⣐",
		"⣑",
		"⣒",
		"⣓",
		"⣔",
		"⣕",
		"⣖",
		"⣗",
		"⢘",
		"⢙",
		"⢚",
		"⢛",
		"⢜",
		"⢝",
		"⢞",
		"⢟",
		"⣘",
		"⣙",
		"⣚",
		"⣛",
		"⣜",
		"⣝",
		"⣞",
		"⣟",
		"⢠",
		"⢡",
		"⢢",
		"⢣",
		"⢤",
		"⢥",
		"⢦",
		"⢧",
		"⣠",
		"⣡",
		"⣢",
		"⣣",
		"⣤",
		"⣥",
		"⣦",
		"⣧",
		"⢨",
		"⢩",
		"⢪",
		"⢫",
		"⢬",
		"⢭",
		"⢮",
		"⢯",
		"⣨",
		"⣩",
		"⣪",
		"⣫",
		"⣬",
		"⣭",
		"⣮",
		"⣯",
		"⢰",
		"⢱",
		"⢲",
		"⢳",
		"⢴",
		"⢵",
		"⢶",
		"⢷",
		"⣰",
		"⣱",
		"⣲",
		"⣳",
		"⣴",
		"⣵",
		"⣶",
		"⣷",
		"⢸",
		"⢹",
		"⢺",
		"⢻",
		"⢼",
		"⢽",
		"⢾",
		"⢿",
		"⣸",
		"⣹",
		"⣺",
		"⣻",
		"⣼",
		"⣽",
		"⣾",
		"⣿"
	]
};
var sand = {
	interval: 80,
	frames: [
		"⠁",
		"⠂",
		"⠄",
		"⡀",
		"⡈",
		"⡐",
		"⡠",
		"⣀",
		"⣁",
		"⣂",
		"⣄",
		"⣌",
		"⣔",
		"⣤",
		"⣥",
		"⣦",
		"⣮",
		"⣶",
		"⣷",
		"⣿",
		"⡿",
		"⠿",
		"⢟",
		"⠟",
		"⡛",
		"⠛",
		"⠫",
		"⢋",
		"⠋",
		"⠍",
		"⡉",
		"⠉",
		"⠑",
		"⠡",
		"⢁"
	]
};
var line = {
	interval: 130,
	frames: [
		"-",
		"\\",
		"|",
		"/"
	]
};
var line2 = {
	interval: 100,
	frames: [
		"⠂",
		"-",
		"–",
		"—",
		"–",
		"-"
	]
};
var pipe = {
	interval: 100,
	frames: [
		"┤",
		"┘",
		"┴",
		"└",
		"├",
		"┌",
		"┬",
		"┐"
	]
};
var simpleDots = {
	interval: 400,
	frames: [
		".  ",
		".. ",
		"...",
		"   "
	]
};
var simpleDotsScrolling = {
	interval: 200,
	frames: [
		".  ",
		".. ",
		"...",
		" ..",
		"  .",
		"   "
	]
};
var star$2 = {
	interval: 70,
	frames: [
		"✶",
		"✸",
		"✹",
		"✺",
		"✹",
		"✷"
	]
};
var star2 = {
	interval: 80,
	frames: [
		"+",
		"x",
		"*"
	]
};
var flip = {
	interval: 70,
	frames: [
		"_",
		"_",
		"_",
		"-",
		"`",
		"`",
		"'",
		"´",
		"-",
		"_",
		"_",
		"_"
	]
};
var hamburger = {
	interval: 100,
	frames: [
		"☱",
		"☲",
		"☴"
	]
};
var growVertical = {
	interval: 120,
	frames: [
		"▁",
		"▃",
		"▄",
		"▅",
		"▆",
		"▇",
		"▆",
		"▅",
		"▄",
		"▃"
	]
};
var growHorizontal = {
	interval: 120,
	frames: [
		"▏",
		"▎",
		"▍",
		"▌",
		"▋",
		"▊",
		"▉",
		"▊",
		"▋",
		"▌",
		"▍",
		"▎"
	]
};
var balloon = {
	interval: 140,
	frames: [
		" ",
		".",
		"o",
		"O",
		"@",
		"*",
		" "
	]
};
var balloon2 = {
	interval: 120,
	frames: [
		".",
		"o",
		"O",
		"°",
		"O",
		"o",
		"."
	]
};
var noise = {
	interval: 100,
	frames: [
		"▓",
		"▒",
		"░"
	]
};
var bounce = {
	interval: 120,
	frames: [
		"⠁",
		"⠂",
		"⠄",
		"⠂"
	]
};
var boxBounce = {
	interval: 120,
	frames: [
		"▖",
		"▘",
		"▝",
		"▗"
	]
};
var boxBounce2 = {
	interval: 100,
	frames: [
		"▌",
		"▀",
		"▐",
		"▄"
	]
};
var triangle = {
	interval: 50,
	frames: [
		"◢",
		"◣",
		"◤",
		"◥"
	]
};
var binary$1 = {
	interval: 80,
	frames: [
		"010010",
		"001100",
		"100101",
		"111010",
		"111101",
		"010111",
		"101011",
		"111000",
		"110011",
		"110101"
	]
};
var arc = {
	interval: 100,
	frames: [
		"◜",
		"◠",
		"◝",
		"◞",
		"◡",
		"◟"
	]
};
var circle = {
	interval: 120,
	frames: [
		"◡",
		"⊙",
		"◠"
	]
};
var squareCorners = {
	interval: 180,
	frames: [
		"◰",
		"◳",
		"◲",
		"◱"
	]
};
var circleQuarters = {
	interval: 120,
	frames: [
		"◴",
		"◷",
		"◶",
		"◵"
	]
};
var circleHalves = {
	interval: 50,
	frames: [
		"◐",
		"◓",
		"◑",
		"◒"
	]
};
var squish = {
	interval: 100,
	frames: [
		"╫",
		"╪"
	]
};
var toggle$1 = {
	interval: 250,
	frames: [
		"⊶",
		"⊷"
	]
};
var toggle2 = {
	interval: 80,
	frames: [
		"▫",
		"▪"
	]
};
var toggle3 = {
	interval: 120,
	frames: [
		"□",
		"■"
	]
};
var toggle4 = {
	interval: 100,
	frames: [
		"■",
		"□",
		"▪",
		"▫"
	]
};
var toggle5 = {
	interval: 100,
	frames: [
		"▮",
		"▯"
	]
};
var toggle6 = {
	interval: 300,
	frames: [
		"ဝ",
		"၀"
	]
};
var toggle7 = {
	interval: 80,
	frames: [
		"⦾",
		"⦿"
	]
};
var toggle8 = {
	interval: 100,
	frames: [
		"◍",
		"◌"
	]
};
var toggle9 = {
	interval: 100,
	frames: [
		"◉",
		"◎"
	]
};
var toggle10 = {
	interval: 100,
	frames: [
		"㊂",
		"㊀",
		"㊁"
	]
};
var toggle11 = {
	interval: 50,
	frames: [
		"⧇",
		"⧆"
	]
};
var toggle12 = {
	interval: 120,
	frames: [
		"☗",
		"☖"
	]
};
var toggle13 = {
	interval: 80,
	frames: [
		"=",
		"*",
		"-"
	]
};
var arrow$1 = {
	interval: 100,
	frames: [
		"←",
		"↖",
		"↑",
		"↗",
		"→",
		"↘",
		"↓",
		"↙"
	]
};
var arrow2 = {
	interval: 80,
	frames: [
		"⬆️ ",
		"↗️ ",
		"➡️ ",
		"↘️ ",
		"⬇️ ",
		"↙️ ",
		"⬅️ ",
		"↖️ "
	]
};
var arrow3 = {
	interval: 120,
	frames: [
		"▹▹▹▹▹",
		"▸▹▹▹▹",
		"▹▸▹▹▹",
		"▹▹▸▹▹",
		"▹▹▹▸▹",
		"▹▹▹▹▸"
	]
};
var bouncingBar = {
	interval: 80,
	frames: [
		"[    ]",
		"[=   ]",
		"[==  ]",
		"[=== ]",
		"[====]",
		"[ ===]",
		"[  ==]",
		"[   =]",
		"[    ]",
		"[   =]",
		"[  ==]",
		"[ ===]",
		"[====]",
		"[=== ]",
		"[==  ]",
		"[=   ]"
	]
};
var bouncingBall = {
	interval: 80,
	frames: [
		"( ●    )",
		"(  ●   )",
		"(   ●  )",
		"(    ● )",
		"(     ●)",
		"(    ● )",
		"(   ●  )",
		"(  ●   )",
		"( ●    )",
		"(●     )"
	]
};
var smiley = {
	interval: 200,
	frames: [
		"😄 ",
		"😝 "
	]
};
var monkey = {
	interval: 300,
	frames: [
		"🙈 ",
		"🙈 ",
		"🙉 ",
		"🙊 "
	]
};
var hearts = {
	interval: 100,
	frames: [
		"💛 ",
		"💙 ",
		"💜 ",
		"💚 ",
		"❤️ "
	]
};
var clock = {
	interval: 100,
	frames: [
		"🕛 ",
		"🕐 ",
		"🕑 ",
		"🕒 ",
		"🕓 ",
		"🕔 ",
		"🕕 ",
		"🕖 ",
		"🕗 ",
		"🕘 ",
		"🕙 ",
		"🕚 "
	]
};
var earth = {
	interval: 180,
	frames: [
		"🌍 ",
		"🌎 ",
		"🌏 "
	]
};
var material = {
	interval: 17,
	frames: [
		"█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"███▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"████▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"███████▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"████████▁▁▁▁▁▁▁▁▁▁▁▁",
		"█████████▁▁▁▁▁▁▁▁▁▁▁",
		"█████████▁▁▁▁▁▁▁▁▁▁▁",
		"██████████▁▁▁▁▁▁▁▁▁▁",
		"███████████▁▁▁▁▁▁▁▁▁",
		"█████████████▁▁▁▁▁▁▁",
		"██████████████▁▁▁▁▁▁",
		"██████████████▁▁▁▁▁▁",
		"▁██████████████▁▁▁▁▁",
		"▁██████████████▁▁▁▁▁",
		"▁██████████████▁▁▁▁▁",
		"▁▁██████████████▁▁▁▁",
		"▁▁▁██████████████▁▁▁",
		"▁▁▁▁█████████████▁▁▁",
		"▁▁▁▁██████████████▁▁",
		"▁▁▁▁██████████████▁▁",
		"▁▁▁▁▁██████████████▁",
		"▁▁▁▁▁██████████████▁",
		"▁▁▁▁▁██████████████▁",
		"▁▁▁▁▁▁██████████████",
		"▁▁▁▁▁▁██████████████",
		"▁▁▁▁▁▁▁█████████████",
		"▁▁▁▁▁▁▁█████████████",
		"▁▁▁▁▁▁▁▁████████████",
		"▁▁▁▁▁▁▁▁████████████",
		"▁▁▁▁▁▁▁▁▁███████████",
		"▁▁▁▁▁▁▁▁▁███████████",
		"▁▁▁▁▁▁▁▁▁▁██████████",
		"▁▁▁▁▁▁▁▁▁▁██████████",
		"▁▁▁▁▁▁▁▁▁▁▁▁████████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁███████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁██████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████",
		"█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
		"██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
		"██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
		"███▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
		"████▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
		"█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
		"█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
		"██████▁▁▁▁▁▁▁▁▁▁▁▁▁█",
		"████████▁▁▁▁▁▁▁▁▁▁▁▁",
		"█████████▁▁▁▁▁▁▁▁▁▁▁",
		"█████████▁▁▁▁▁▁▁▁▁▁▁",
		"█████████▁▁▁▁▁▁▁▁▁▁▁",
		"█████████▁▁▁▁▁▁▁▁▁▁▁",
		"███████████▁▁▁▁▁▁▁▁▁",
		"████████████▁▁▁▁▁▁▁▁",
		"████████████▁▁▁▁▁▁▁▁",
		"██████████████▁▁▁▁▁▁",
		"██████████████▁▁▁▁▁▁",
		"▁██████████████▁▁▁▁▁",
		"▁██████████████▁▁▁▁▁",
		"▁▁▁█████████████▁▁▁▁",
		"▁▁▁▁▁████████████▁▁▁",
		"▁▁▁▁▁████████████▁▁▁",
		"▁▁▁▁▁▁███████████▁▁▁",
		"▁▁▁▁▁▁▁▁█████████▁▁▁",
		"▁▁▁▁▁▁▁▁█████████▁▁▁",
		"▁▁▁▁▁▁▁▁▁█████████▁▁",
		"▁▁▁▁▁▁▁▁▁█████████▁▁",
		"▁▁▁▁▁▁▁▁▁▁█████████▁",
		"▁▁▁▁▁▁▁▁▁▁▁████████▁",
		"▁▁▁▁▁▁▁▁▁▁▁████████▁",
		"▁▁▁▁▁▁▁▁▁▁▁▁███████▁",
		"▁▁▁▁▁▁▁▁▁▁▁▁███████▁",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁███████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁███████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
		"▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁"
	]
};
var moon = {
	interval: 80,
	frames: [
		"🌑 ",
		"🌒 ",
		"🌓 ",
		"🌔 ",
		"🌕 ",
		"🌖 ",
		"🌗 ",
		"🌘 "
	]
};
var runner = {
	interval: 140,
	frames: [
		"🚶 ",
		"🏃 "
	]
};
var pong = {
	interval: 80,
	frames: [
		"▐⠂       ▌",
		"▐⠈       ▌",
		"▐ ⠂      ▌",
		"▐ ⠠      ▌",
		"▐  ⡀     ▌",
		"▐  ⠠     ▌",
		"▐   ⠂    ▌",
		"▐   ⠈    ▌",
		"▐    ⠂   ▌",
		"▐    ⠠   ▌",
		"▐     ⡀  ▌",
		"▐     ⠠  ▌",
		"▐      ⠂ ▌",
		"▐      ⠈ ▌",
		"▐       ⠂▌",
		"▐       ⠠▌",
		"▐       ⡀▌",
		"▐      ⠠ ▌",
		"▐      ⠂ ▌",
		"▐     ⠈  ▌",
		"▐     ⠂  ▌",
		"▐    ⠠   ▌",
		"▐    ⡀   ▌",
		"▐   ⠠    ▌",
		"▐   ⠂    ▌",
		"▐  ⠈     ▌",
		"▐  ⠂     ▌",
		"▐ ⠠      ▌",
		"▐ ⡀      ▌",
		"▐⠠       ▌"
	]
};
var shark = {
	interval: 120,
	frames: [
		"▐|\\____________▌",
		"▐_|\\___________▌",
		"▐__|\\__________▌",
		"▐___|\\_________▌",
		"▐____|\\________▌",
		"▐_____|\\_______▌",
		"▐______|\\______▌",
		"▐_______|\\_____▌",
		"▐________|\\____▌",
		"▐_________|\\___▌",
		"▐__________|\\__▌",
		"▐___________|\\_▌",
		"▐____________|\\▌",
		"▐____________/|▌",
		"▐___________/|_▌",
		"▐__________/|__▌",
		"▐_________/|___▌",
		"▐________/|____▌",
		"▐_______/|_____▌",
		"▐______/|______▌",
		"▐_____/|_______▌",
		"▐____/|________▌",
		"▐___/|_________▌",
		"▐__/|__________▌",
		"▐_/|___________▌",
		"▐/|____________▌"
	]
};
var dqpb = {
	interval: 100,
	frames: [
		"d",
		"q",
		"p",
		"b"
	]
};
var weather = {
	interval: 100,
	frames: [
		"☀️ ",
		"☀️ ",
		"☀️ ",
		"🌤 ",
		"⛅️ ",
		"🌥 ",
		"☁️ ",
		"🌧 ",
		"🌨 ",
		"🌧 ",
		"🌨 ",
		"🌧 ",
		"🌨 ",
		"⛈ ",
		"🌨 ",
		"🌧 ",
		"🌨 ",
		"☁️ ",
		"🌥 ",
		"⛅️ ",
		"🌤 ",
		"☀️ ",
		"☀️ "
	]
};
var christmas = {
	interval: 400,
	frames: [
		"🌲",
		"🎄"
	]
};
var grenade = {
	interval: 80,
	frames: [
		"،  ",
		"′  ",
		" ´ ",
		" ‾ ",
		"  ⸌",
		"  ⸊",
		"  |",
		"  ⁎",
		"  ⁕",
		" ෴ ",
		"  ⁓",
		"   ",
		"   ",
		"   "
	]
};
var point = {
	interval: 125,
	frames: [
		"∙∙∙",
		"●∙∙",
		"∙●∙",
		"∙∙●",
		"∙∙∙"
	]
};
var layer = {
	interval: 150,
	frames: [
		"-",
		"=",
		"≡"
	]
};
var betaWave = {
	interval: 80,
	frames: [
		"ρββββββ",
		"βρβββββ",
		"ββρββββ",
		"βββρβββ",
		"ββββρββ",
		"βββββρβ",
		"ββββββρ"
	]
};
var fingerDance = {
	interval: 160,
	frames: [
		"🤘 ",
		"🤟 ",
		"🖖 ",
		"✋ ",
		"🤚 ",
		"👆 "
	]
};
var fistBump = {
	interval: 80,
	frames: [
		"🤜　　　　🤛 ",
		"🤜　　　　🤛 ",
		"🤜　　　　🤛 ",
		"　🤜　　🤛　 ",
		"　　🤜🤛　　 ",
		"　🤜✨🤛　　 ",
		"🤜　✨　🤛　 "
	]
};
var soccerHeader = {
	interval: 80,
	frames: [
		" 🧑⚽️       🧑 ",
		"🧑  ⚽️      🧑 ",
		"🧑   ⚽️     🧑 ",
		"🧑    ⚽️    🧑 ",
		"🧑     ⚽️   🧑 ",
		"🧑      ⚽️  🧑 ",
		"🧑       ⚽️🧑  ",
		"🧑      ⚽️  🧑 ",
		"🧑     ⚽️   🧑 ",
		"🧑    ⚽️    🧑 ",
		"🧑   ⚽️     🧑 ",
		"🧑  ⚽️      🧑 "
	]
};
var mindblown = {
	interval: 160,
	frames: [
		"😐 ",
		"😐 ",
		"😮 ",
		"😮 ",
		"😦 ",
		"😦 ",
		"😧 ",
		"😧 ",
		"🤯 ",
		"💥 ",
		"✨ ",
		"　 ",
		"　 ",
		"　 "
	]
};
var speaker = {
	interval: 160,
	frames: [
		"🔈 ",
		"🔉 ",
		"🔊 ",
		"🔉 "
	]
};
var orangePulse = {
	interval: 100,
	frames: [
		"🔸 ",
		"🔶 ",
		"🟠 ",
		"🟠 ",
		"🔶 "
	]
};
var bluePulse = {
	interval: 100,
	frames: [
		"🔹 ",
		"🔷 ",
		"🔵 ",
		"🔵 ",
		"🔷 "
	]
};
var orangeBluePulse = {
	interval: 100,
	frames: [
		"🔸 ",
		"🔶 ",
		"🟠 ",
		"🟠 ",
		"🔶 ",
		"🔹 ",
		"🔷 ",
		"🔵 ",
		"🔵 ",
		"🔷 "
	]
};
var timeTravel = {
	interval: 100,
	frames: [
		"🕛 ",
		"🕚 ",
		"🕙 ",
		"🕘 ",
		"🕗 ",
		"🕖 ",
		"🕕 ",
		"🕔 ",
		"🕓 ",
		"🕒 ",
		"🕑 ",
		"🕐 "
	]
};
var aesthetic = {
	interval: 80,
	frames: [
		"▰▱▱▱▱▱▱",
		"▰▰▱▱▱▱▱",
		"▰▰▰▱▱▱▱",
		"▰▰▰▰▱▱▱",
		"▰▰▰▰▰▱▱",
		"▰▰▰▰▰▰▱",
		"▰▰▰▰▰▰▰",
		"▰▱▱▱▱▱▱"
	]
};
var dwarfFortress = {
	interval: 80,
	frames: [
		" ██████£££  ",
		"☺██████£££  ",
		"☺██████£££  ",
		"☺▓█████£££  ",
		"☺▓█████£££  ",
		"☺▒█████£££  ",
		"☺▒█████£££  ",
		"☺░█████£££  ",
		"☺░█████£££  ",
		"☺ █████£££  ",
		" ☺█████£££  ",
		" ☺█████£££  ",
		" ☺▓████£££  ",
		" ☺▓████£££  ",
		" ☺▒████£££  ",
		" ☺▒████£££  ",
		" ☺░████£££  ",
		" ☺░████£££  ",
		" ☺ ████£££  ",
		"  ☺████£££  ",
		"  ☺████£££  ",
		"  ☺▓███£££  ",
		"  ☺▓███£££  ",
		"  ☺▒███£££  ",
		"  ☺▒███£££  ",
		"  ☺░███£££  ",
		"  ☺░███£££  ",
		"  ☺ ███£££  ",
		"   ☺███£££  ",
		"   ☺███£££  ",
		"   ☺▓██£££  ",
		"   ☺▓██£££  ",
		"   ☺▒██£££  ",
		"   ☺▒██£££  ",
		"   ☺░██£££  ",
		"   ☺░██£££  ",
		"   ☺ ██£££  ",
		"    ☺██£££  ",
		"    ☺██£££  ",
		"    ☺▓█£££  ",
		"    ☺▓█£££  ",
		"    ☺▒█£££  ",
		"    ☺▒█£££  ",
		"    ☺░█£££  ",
		"    ☺░█£££  ",
		"    ☺ █£££  ",
		"     ☺█£££  ",
		"     ☺█£££  ",
		"     ☺▓£££  ",
		"     ☺▓£££  ",
		"     ☺▒£££  ",
		"     ☺▒£££  ",
		"     ☺░£££  ",
		"     ☺░£££  ",
		"     ☺ £££  ",
		"      ☺£££  ",
		"      ☺£££  ",
		"      ☺▓££  ",
		"      ☺▓££  ",
		"      ☺▒££  ",
		"      ☺▒££  ",
		"      ☺░££  ",
		"      ☺░££  ",
		"      ☺ ££  ",
		"       ☺££  ",
		"       ☺££  ",
		"       ☺▓£  ",
		"       ☺▓£  ",
		"       ☺▒£  ",
		"       ☺▒£  ",
		"       ☺░£  ",
		"       ☺░£  ",
		"       ☺ £  ",
		"        ☺£  ",
		"        ☺£  ",
		"        ☺▓  ",
		"        ☺▓  ",
		"        ☺▒  ",
		"        ☺▒  ",
		"        ☺░  ",
		"        ☺░  ",
		"        ☺   ",
		"        ☺  &",
		"        ☺ ☼&",
		"       ☺ ☼ &",
		"       ☺☼  &",
		"      ☺☼  & ",
		"      ‼   & ",
		"     ☺   &  ",
		"    ‼    &  ",
		"   ☺    &   ",
		"  ‼     &   ",
		" ☺     &    ",
		"‼      &    ",
		"      &     ",
		"      &     ",
		"     &   ░  ",
		"     &   ▒  ",
		"    &    ▓  ",
		"    &    £  ",
		"   &    ░£  ",
		"   &    ▒£  ",
		"  &     ▓£  ",
		"  &     ££  ",
		" &     ░££  ",
		" &     ▒££  ",
		"&      ▓££  ",
		"&      £££  ",
		"      ░£££  ",
		"      ▒£££  ",
		"      ▓£££  ",
		"      █£££  ",
		"     ░█£££  ",
		"     ▒█£££  ",
		"     ▓█£££  ",
		"     ██£££  ",
		"    ░██£££  ",
		"    ▒██£££  ",
		"    ▓██£££  ",
		"    ███£££  ",
		"   ░███£££  ",
		"   ▒███£££  ",
		"   ▓███£££  ",
		"   ████£££  ",
		"  ░████£££  ",
		"  ▒████£££  ",
		"  ▓████£££  ",
		"  █████£££  ",
		" ░█████£££  ",
		" ▒█████£££  ",
		" ▓█████£££  ",
		" ██████£££  ",
		" ██████£££  "
	]
};
var require$$0$1 = {
	dots: dots,
	dots2: dots2,
	dots3: dots3,
	dots4: dots4,
	dots5: dots5,
	dots6: dots6,
	dots7: dots7,
	dots8: dots8,
	dots9: dots9,
	dots10: dots10,
	dots11: dots11,
	dots12: dots12,
	dots13: dots13,
	dots8Bit: dots8Bit,
	sand: sand,
	line: line,
	line2: line2,
	pipe: pipe,
	simpleDots: simpleDots,
	simpleDotsScrolling: simpleDotsScrolling,
	star: star$2,
	star2: star2,
	flip: flip,
	hamburger: hamburger,
	growVertical: growVertical,
	growHorizontal: growHorizontal,
	balloon: balloon,
	balloon2: balloon2,
	noise: noise,
	bounce: bounce,
	boxBounce: boxBounce,
	boxBounce2: boxBounce2,
	triangle: triangle,
	binary: binary$1,
	arc: arc,
	circle: circle,
	squareCorners: squareCorners,
	circleQuarters: circleQuarters,
	circleHalves: circleHalves,
	squish: squish,
	toggle: toggle$1,
	toggle2: toggle2,
	toggle3: toggle3,
	toggle4: toggle4,
	toggle5: toggle5,
	toggle6: toggle6,
	toggle7: toggle7,
	toggle8: toggle8,
	toggle9: toggle9,
	toggle10: toggle10,
	toggle11: toggle11,
	toggle12: toggle12,
	toggle13: toggle13,
	arrow: arrow$1,
	arrow2: arrow2,
	arrow3: arrow3,
	bouncingBar: bouncingBar,
	bouncingBall: bouncingBall,
	smiley: smiley,
	monkey: monkey,
	hearts: hearts,
	clock: clock,
	earth: earth,
	material: material,
	moon: moon,
	runner: runner,
	pong: pong,
	shark: shark,
	dqpb: dqpb,
	weather: weather,
	christmas: christmas,
	grenade: grenade,
	point: point,
	layer: layer,
	betaWave: betaWave,
	fingerDance: fingerDance,
	fistBump: fistBump,
	soccerHeader: soccerHeader,
	mindblown: mindblown,
	speaker: speaker,
	orangePulse: orangePulse,
	bluePulse: bluePulse,
	orangeBluePulse: orangeBluePulse,
	timeTravel: timeTravel,
	aesthetic: aesthetic,
	dwarfFortress: dwarfFortress
};

var cliSpinners$1;
var hasRequiredCliSpinners;

function requireCliSpinners () {
	if (hasRequiredCliSpinners) return cliSpinners$1;
	hasRequiredCliSpinners = 1;

	const spinners = Object.assign({}, require$$0$1); // eslint-disable-line import/extensions

	const spinnersList = Object.keys(spinners);

	Object.defineProperty(spinners, 'random', {
		get() {
			const randomIndex = Math.floor(Math.random() * spinnersList.length);
			const spinnerName = spinnersList[randomIndex];
			return spinners[spinnerName];
		}
	});

	cliSpinners$1 = spinners;
	return cliSpinners$1;
}

var cliSpinnersExports = requireCliSpinners();
var cliSpinners = /*@__PURE__*/getDefaultExportFromCjs(cliSpinnersExports);

function isUnicodeSupported() {
	if (process$1.platform !== 'win32') {
		return process$1.env.TERM !== 'linux'; // Linux console (kernel)
	}

	return Boolean(process$1.env.CI)
		|| Boolean(process$1.env.WT_SESSION) // Windows Terminal
		|| Boolean(process$1.env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
		|| process$1.env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder
		|| process$1.env.TERM_PROGRAM === 'Terminus-Sublime'
		|| process$1.env.TERM_PROGRAM === 'vscode'
		|| process$1.env.TERM === 'xterm-256color'
		|| process$1.env.TERM === 'alacritty'
		|| process$1.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
}

const main = {
	info: chalk.blue('ℹ'),
	success: chalk.green('✔'),
	warning: chalk.yellow('⚠'),
	error: chalk.red('✖'),
};

const fallback = {
	info: chalk.blue('i'),
	success: chalk.green('√'),
	warning: chalk.yellow('‼'),
	error: chalk.red('×'),
};

const logSymbols = isUnicodeSupported() ? main : fallback;

function ansiRegex$3({onlyFirst = false} = {}) {
	// Valid string terminator sequences are BEL, ESC\, and 0x9c
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const pattern = [
		`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

const regex$2 = ansiRegex$3();

function stripAnsi$3(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex$2, '');
}

var eastasianwidth = {exports: {}};

var hasRequiredEastasianwidth;

function requireEastasianwidth () {
	if (hasRequiredEastasianwidth) return eastasianwidth.exports;
	hasRequiredEastasianwidth = 1;
	(function (module) {
		var eaw = {};

		{
		  module.exports = eaw;
		}

		eaw.eastAsianWidth = function(character) {
		  var x = character.charCodeAt(0);
		  var y = (character.length == 2) ? character.charCodeAt(1) : 0;
		  var codePoint = x;
		  if ((0xD800 <= x && x <= 0xDBFF) && (0xDC00 <= y && y <= 0xDFFF)) {
		    x &= 0x3FF;
		    y &= 0x3FF;
		    codePoint = (x << 10) | y;
		    codePoint += 0x10000;
		  }

		  if ((0x3000 == codePoint) ||
		      (0xFF01 <= codePoint && codePoint <= 0xFF60) ||
		      (0xFFE0 <= codePoint && codePoint <= 0xFFE6)) {
		    return 'F';
		  }
		  if ((0x20A9 == codePoint) ||
		      (0xFF61 <= codePoint && codePoint <= 0xFFBE) ||
		      (0xFFC2 <= codePoint && codePoint <= 0xFFC7) ||
		      (0xFFCA <= codePoint && codePoint <= 0xFFCF) ||
		      (0xFFD2 <= codePoint && codePoint <= 0xFFD7) ||
		      (0xFFDA <= codePoint && codePoint <= 0xFFDC) ||
		      (0xFFE8 <= codePoint && codePoint <= 0xFFEE)) {
		    return 'H';
		  }
		  if ((0x1100 <= codePoint && codePoint <= 0x115F) ||
		      (0x11A3 <= codePoint && codePoint <= 0x11A7) ||
		      (0x11FA <= codePoint && codePoint <= 0x11FF) ||
		      (0x2329 <= codePoint && codePoint <= 0x232A) ||
		      (0x2E80 <= codePoint && codePoint <= 0x2E99) ||
		      (0x2E9B <= codePoint && codePoint <= 0x2EF3) ||
		      (0x2F00 <= codePoint && codePoint <= 0x2FD5) ||
		      (0x2FF0 <= codePoint && codePoint <= 0x2FFB) ||
		      (0x3001 <= codePoint && codePoint <= 0x303E) ||
		      (0x3041 <= codePoint && codePoint <= 0x3096) ||
		      (0x3099 <= codePoint && codePoint <= 0x30FF) ||
		      (0x3105 <= codePoint && codePoint <= 0x312D) ||
		      (0x3131 <= codePoint && codePoint <= 0x318E) ||
		      (0x3190 <= codePoint && codePoint <= 0x31BA) ||
		      (0x31C0 <= codePoint && codePoint <= 0x31E3) ||
		      (0x31F0 <= codePoint && codePoint <= 0x321E) ||
		      (0x3220 <= codePoint && codePoint <= 0x3247) ||
		      (0x3250 <= codePoint && codePoint <= 0x32FE) ||
		      (0x3300 <= codePoint && codePoint <= 0x4DBF) ||
		      (0x4E00 <= codePoint && codePoint <= 0xA48C) ||
		      (0xA490 <= codePoint && codePoint <= 0xA4C6) ||
		      (0xA960 <= codePoint && codePoint <= 0xA97C) ||
		      (0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
		      (0xD7B0 <= codePoint && codePoint <= 0xD7C6) ||
		      (0xD7CB <= codePoint && codePoint <= 0xD7FB) ||
		      (0xF900 <= codePoint && codePoint <= 0xFAFF) ||
		      (0xFE10 <= codePoint && codePoint <= 0xFE19) ||
		      (0xFE30 <= codePoint && codePoint <= 0xFE52) ||
		      (0xFE54 <= codePoint && codePoint <= 0xFE66) ||
		      (0xFE68 <= codePoint && codePoint <= 0xFE6B) ||
		      (0x1B000 <= codePoint && codePoint <= 0x1B001) ||
		      (0x1F200 <= codePoint && codePoint <= 0x1F202) ||
		      (0x1F210 <= codePoint && codePoint <= 0x1F23A) ||
		      (0x1F240 <= codePoint && codePoint <= 0x1F248) ||
		      (0x1F250 <= codePoint && codePoint <= 0x1F251) ||
		      (0x20000 <= codePoint && codePoint <= 0x2F73F) ||
		      (0x2B740 <= codePoint && codePoint <= 0x2FFFD) ||
		      (0x30000 <= codePoint && codePoint <= 0x3FFFD)) {
		    return 'W';
		  }
		  if ((0x0020 <= codePoint && codePoint <= 0x007E) ||
		      (0x00A2 <= codePoint && codePoint <= 0x00A3) ||
		      (0x00A5 <= codePoint && codePoint <= 0x00A6) ||
		      (0x00AC == codePoint) ||
		      (0x00AF == codePoint) ||
		      (0x27E6 <= codePoint && codePoint <= 0x27ED) ||
		      (0x2985 <= codePoint && codePoint <= 0x2986)) {
		    return 'Na';
		  }
		  if ((0x00A1 == codePoint) ||
		      (0x00A4 == codePoint) ||
		      (0x00A7 <= codePoint && codePoint <= 0x00A8) ||
		      (0x00AA == codePoint) ||
		      (0x00AD <= codePoint && codePoint <= 0x00AE) ||
		      (0x00B0 <= codePoint && codePoint <= 0x00B4) ||
		      (0x00B6 <= codePoint && codePoint <= 0x00BA) ||
		      (0x00BC <= codePoint && codePoint <= 0x00BF) ||
		      (0x00C6 == codePoint) ||
		      (0x00D0 == codePoint) ||
		      (0x00D7 <= codePoint && codePoint <= 0x00D8) ||
		      (0x00DE <= codePoint && codePoint <= 0x00E1) ||
		      (0x00E6 == codePoint) ||
		      (0x00E8 <= codePoint && codePoint <= 0x00EA) ||
		      (0x00EC <= codePoint && codePoint <= 0x00ED) ||
		      (0x00F0 == codePoint) ||
		      (0x00F2 <= codePoint && codePoint <= 0x00F3) ||
		      (0x00F7 <= codePoint && codePoint <= 0x00FA) ||
		      (0x00FC == codePoint) ||
		      (0x00FE == codePoint) ||
		      (0x0101 == codePoint) ||
		      (0x0111 == codePoint) ||
		      (0x0113 == codePoint) ||
		      (0x011B == codePoint) ||
		      (0x0126 <= codePoint && codePoint <= 0x0127) ||
		      (0x012B == codePoint) ||
		      (0x0131 <= codePoint && codePoint <= 0x0133) ||
		      (0x0138 == codePoint) ||
		      (0x013F <= codePoint && codePoint <= 0x0142) ||
		      (0x0144 == codePoint) ||
		      (0x0148 <= codePoint && codePoint <= 0x014B) ||
		      (0x014D == codePoint) ||
		      (0x0152 <= codePoint && codePoint <= 0x0153) ||
		      (0x0166 <= codePoint && codePoint <= 0x0167) ||
		      (0x016B == codePoint) ||
		      (0x01CE == codePoint) ||
		      (0x01D0 == codePoint) ||
		      (0x01D2 == codePoint) ||
		      (0x01D4 == codePoint) ||
		      (0x01D6 == codePoint) ||
		      (0x01D8 == codePoint) ||
		      (0x01DA == codePoint) ||
		      (0x01DC == codePoint) ||
		      (0x0251 == codePoint) ||
		      (0x0261 == codePoint) ||
		      (0x02C4 == codePoint) ||
		      (0x02C7 == codePoint) ||
		      (0x02C9 <= codePoint && codePoint <= 0x02CB) ||
		      (0x02CD == codePoint) ||
		      (0x02D0 == codePoint) ||
		      (0x02D8 <= codePoint && codePoint <= 0x02DB) ||
		      (0x02DD == codePoint) ||
		      (0x02DF == codePoint) ||
		      (0x0300 <= codePoint && codePoint <= 0x036F) ||
		      (0x0391 <= codePoint && codePoint <= 0x03A1) ||
		      (0x03A3 <= codePoint && codePoint <= 0x03A9) ||
		      (0x03B1 <= codePoint && codePoint <= 0x03C1) ||
		      (0x03C3 <= codePoint && codePoint <= 0x03C9) ||
		      (0x0401 == codePoint) ||
		      (0x0410 <= codePoint && codePoint <= 0x044F) ||
		      (0x0451 == codePoint) ||
		      (0x2010 == codePoint) ||
		      (0x2013 <= codePoint && codePoint <= 0x2016) ||
		      (0x2018 <= codePoint && codePoint <= 0x2019) ||
		      (0x201C <= codePoint && codePoint <= 0x201D) ||
		      (0x2020 <= codePoint && codePoint <= 0x2022) ||
		      (0x2024 <= codePoint && codePoint <= 0x2027) ||
		      (0x2030 == codePoint) ||
		      (0x2032 <= codePoint && codePoint <= 0x2033) ||
		      (0x2035 == codePoint) ||
		      (0x203B == codePoint) ||
		      (0x203E == codePoint) ||
		      (0x2074 == codePoint) ||
		      (0x207F == codePoint) ||
		      (0x2081 <= codePoint && codePoint <= 0x2084) ||
		      (0x20AC == codePoint) ||
		      (0x2103 == codePoint) ||
		      (0x2105 == codePoint) ||
		      (0x2109 == codePoint) ||
		      (0x2113 == codePoint) ||
		      (0x2116 == codePoint) ||
		      (0x2121 <= codePoint && codePoint <= 0x2122) ||
		      (0x2126 == codePoint) ||
		      (0x212B == codePoint) ||
		      (0x2153 <= codePoint && codePoint <= 0x2154) ||
		      (0x215B <= codePoint && codePoint <= 0x215E) ||
		      (0x2160 <= codePoint && codePoint <= 0x216B) ||
		      (0x2170 <= codePoint && codePoint <= 0x2179) ||
		      (0x2189 == codePoint) ||
		      (0x2190 <= codePoint && codePoint <= 0x2199) ||
		      (0x21B8 <= codePoint && codePoint <= 0x21B9) ||
		      (0x21D2 == codePoint) ||
		      (0x21D4 == codePoint) ||
		      (0x21E7 == codePoint) ||
		      (0x2200 == codePoint) ||
		      (0x2202 <= codePoint && codePoint <= 0x2203) ||
		      (0x2207 <= codePoint && codePoint <= 0x2208) ||
		      (0x220B == codePoint) ||
		      (0x220F == codePoint) ||
		      (0x2211 == codePoint) ||
		      (0x2215 == codePoint) ||
		      (0x221A == codePoint) ||
		      (0x221D <= codePoint && codePoint <= 0x2220) ||
		      (0x2223 == codePoint) ||
		      (0x2225 == codePoint) ||
		      (0x2227 <= codePoint && codePoint <= 0x222C) ||
		      (0x222E == codePoint) ||
		      (0x2234 <= codePoint && codePoint <= 0x2237) ||
		      (0x223C <= codePoint && codePoint <= 0x223D) ||
		      (0x2248 == codePoint) ||
		      (0x224C == codePoint) ||
		      (0x2252 == codePoint) ||
		      (0x2260 <= codePoint && codePoint <= 0x2261) ||
		      (0x2264 <= codePoint && codePoint <= 0x2267) ||
		      (0x226A <= codePoint && codePoint <= 0x226B) ||
		      (0x226E <= codePoint && codePoint <= 0x226F) ||
		      (0x2282 <= codePoint && codePoint <= 0x2283) ||
		      (0x2286 <= codePoint && codePoint <= 0x2287) ||
		      (0x2295 == codePoint) ||
		      (0x2299 == codePoint) ||
		      (0x22A5 == codePoint) ||
		      (0x22BF == codePoint) ||
		      (0x2312 == codePoint) ||
		      (0x2460 <= codePoint && codePoint <= 0x24E9) ||
		      (0x24EB <= codePoint && codePoint <= 0x254B) ||
		      (0x2550 <= codePoint && codePoint <= 0x2573) ||
		      (0x2580 <= codePoint && codePoint <= 0x258F) ||
		      (0x2592 <= codePoint && codePoint <= 0x2595) ||
		      (0x25A0 <= codePoint && codePoint <= 0x25A1) ||
		      (0x25A3 <= codePoint && codePoint <= 0x25A9) ||
		      (0x25B2 <= codePoint && codePoint <= 0x25B3) ||
		      (0x25B6 <= codePoint && codePoint <= 0x25B7) ||
		      (0x25BC <= codePoint && codePoint <= 0x25BD) ||
		      (0x25C0 <= codePoint && codePoint <= 0x25C1) ||
		      (0x25C6 <= codePoint && codePoint <= 0x25C8) ||
		      (0x25CB == codePoint) ||
		      (0x25CE <= codePoint && codePoint <= 0x25D1) ||
		      (0x25E2 <= codePoint && codePoint <= 0x25E5) ||
		      (0x25EF == codePoint) ||
		      (0x2605 <= codePoint && codePoint <= 0x2606) ||
		      (0x2609 == codePoint) ||
		      (0x260E <= codePoint && codePoint <= 0x260F) ||
		      (0x2614 <= codePoint && codePoint <= 0x2615) ||
		      (0x261C == codePoint) ||
		      (0x261E == codePoint) ||
		      (0x2640 == codePoint) ||
		      (0x2642 == codePoint) ||
		      (0x2660 <= codePoint && codePoint <= 0x2661) ||
		      (0x2663 <= codePoint && codePoint <= 0x2665) ||
		      (0x2667 <= codePoint && codePoint <= 0x266A) ||
		      (0x266C <= codePoint && codePoint <= 0x266D) ||
		      (0x266F == codePoint) ||
		      (0x269E <= codePoint && codePoint <= 0x269F) ||
		      (0x26BE <= codePoint && codePoint <= 0x26BF) ||
		      (0x26C4 <= codePoint && codePoint <= 0x26CD) ||
		      (0x26CF <= codePoint && codePoint <= 0x26E1) ||
		      (0x26E3 == codePoint) ||
		      (0x26E8 <= codePoint && codePoint <= 0x26FF) ||
		      (0x273D == codePoint) ||
		      (0x2757 == codePoint) ||
		      (0x2776 <= codePoint && codePoint <= 0x277F) ||
		      (0x2B55 <= codePoint && codePoint <= 0x2B59) ||
		      (0x3248 <= codePoint && codePoint <= 0x324F) ||
		      (0xE000 <= codePoint && codePoint <= 0xF8FF) ||
		      (0xFE00 <= codePoint && codePoint <= 0xFE0F) ||
		      (0xFFFD == codePoint) ||
		      (0x1F100 <= codePoint && codePoint <= 0x1F10A) ||
		      (0x1F110 <= codePoint && codePoint <= 0x1F12D) ||
		      (0x1F130 <= codePoint && codePoint <= 0x1F169) ||
		      (0x1F170 <= codePoint && codePoint <= 0x1F19A) ||
		      (0xE0100 <= codePoint && codePoint <= 0xE01EF) ||
		      (0xF0000 <= codePoint && codePoint <= 0xFFFFD) ||
		      (0x100000 <= codePoint && codePoint <= 0x10FFFD)) {
		    return 'A';
		  }

		  return 'N';
		};

		eaw.characterLength = function(character) {
		  var code = this.eastAsianWidth(character);
		  if (code == 'F' || code == 'W' || code == 'A') {
		    return 2;
		  } else {
		    return 1;
		  }
		};

		// Split a string considering surrogate-pairs.
		function stringToArray(string) {
		  return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
		}

		eaw.length = function(string) {
		  var characters = stringToArray(string);
		  var len = 0;
		  for (var i = 0; i < characters.length; i++) {
		    len = len + this.characterLength(characters[i]);
		  }
		  return len;
		};

		eaw.slice = function(text, start, end) {
		  textLen = eaw.length(text);
		  start = start ? start : 0;
		  end = end ? end : 1;
		  if (start < 0) {
		      start = textLen + start;
		  }
		  if (end < 0) {
		      end = textLen + end;
		  }
		  var result = '';
		  var eawLen = 0;
		  var chars = stringToArray(text);
		  for (var i = 0; i < chars.length; i++) {
		    var char = chars[i];
		    var charLen = eaw.length(char);
		    if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
		        if (eawLen + charLen <= end) {
		            result += char;
		        } else {
		            break;
		        }
		    }
		    eawLen += charLen;
		  }
		  return result;
		}; 
	} (eastasianwidth));
	return eastasianwidth.exports;
}

var eastasianwidthExports = requireEastasianwidth();
var eastAsianWidth$1 = /*@__PURE__*/getDefaultExportFromCjs(eastasianwidthExports);

var emojiRegex$1 = () => {
	// https://mths.be/emoji
	return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

function stringWidth$2(string, options) {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	options = {
		ambiguousIsNarrow: true,
		countAnsiEscapeCodes: false,
		...options,
	};

	if (!options.countAnsiEscapeCodes) {
		string = stripAnsi$3(string);
	}

	if (string.length === 0) {
		return 0;
	}

	const ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2;
	let width = 0;

	for (const {segment: character} of new Intl.Segmenter().segment(string)) {
		const codePoint = character.codePointAt(0);

		// Ignore control characters
		if (codePoint <= 0x1F || (codePoint >= 0x7F && codePoint <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (codePoint >= 0x3_00 && codePoint <= 0x3_6F) {
			continue;
		}

		if (emojiRegex$1().test(character)) {
			width += 2;
			continue;
		}

		const code = eastAsianWidth$1.eastAsianWidth(character);
		switch (code) {
			case 'F':
			case 'W': {
				width += 2;
				break;
			}

			case 'A': {
				width += ambiguousCharacterWidth;
				break;
			}

			default: {
				width += 1;
			}
		}
	}

	return width;
}

function isInteractive({stream = process.stdout} = {}) {
	return Boolean(
		stream && stream.isTTY &&
		process.env.TERM !== 'dumb' &&
		!('CI' in process.env)
	);
}

var bl = {exports: {}};

var readable = {exports: {}};

var stream$1;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream$1;
	hasRequiredStream = 1;
	stream$1 = require$$0$4;
	return stream$1;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(input); }
	var _require = require$$0$5,
	  Buffer = _require.Buffer;
	var _require2 = require$$0$6,
	  inspect = _require2.inspect;
	var custom = inspect && inspect.custom || 'inspect';
	function copyBuffer(src, target, offset) {
	  Buffer.prototype.copy.call(src, target, offset);
	}
	buffer_list = /*#__PURE__*/function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;
	      while (p = p.next) ret += s + p.data;
	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer.alloc(0);
	      var ret = Buffer.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;
	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }
	      return ret;
	    }

	    // Consumes a specified amount of bytes or characters from the buffered data.
	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;
	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }
	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    }

	    // Consumes a specified amount of characters from the buffered data.
	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;
	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;
	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Consumes a specified amount of bytes from the buffered data.
	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;
	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;
	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Make sure the linked list only shows the minimal necessary information.
	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);
	  return BufferList;
	}();
	return buffer_list;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};
	return destroy_1;
}

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	const codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage (arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message
	    } else {
	      return message(arg1, arg2, arg3)
	    }
	  }

	  class NodeError extends Base {
	    constructor (arg1, arg2, arg3) {
	      super(getMessage(arg1, arg2, arg3));
	    }
	  }

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;

	  codes[code] = NodeError;
	}

	// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    const len = expected.length;
	    expected = expected.map((i) => String(i));
	    if (len > 2) {
	      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
	             expected[len - 1];
	    } else if (len === 2) {
	      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
	    } else {
	      return `of ${thing} ${expected[0]}`;
	    }
	  } else {
	    return `of ${thing} ${String(expected)}`;
	  }
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
	function startsWith(str, search, pos) {
		return str.substr(0 , search.length) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	function endsWith(str, search, this_len) {
		if (this_len === undefined || this_len > str.length) {
			this_len = str.length;
		}
		return str.substring(this_len - search.length, this_len) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"'
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  let determiner;
	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  let msg;
	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
	  } else {
	    const type = includes(name, '.') ? 'property' : 'argument';
	    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
	  }

	  msg += `. Received type ${typeof actual}`;
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented'
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

	errors.codes = codes;
	return errors;
}

var state$1;
var hasRequiredState$1;

function requireState$1 () {
	if (hasRequiredState$1) return state$1;
	hasRequiredState$1 = 1;

	var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	state$1 = {
	  getHighWaterMark: getHighWaterMark
	};
	return state$1;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	node = require$$0$6.deprecate;
	return node;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireNode()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream();
	/*</replacement>*/

	var Buffer = require$$0$5.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = requireDestroy();
	var _require = requireState$1(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	requireInherits()(Writable, Stream);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end')
	  this.autoDestroy = !!options.autoDestroy;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}
	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END();
	  // TODO: defer error events consistently everywhere, not just the cb
	  errorOrDestroy(stream, er);
	  process.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var er;
	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }
	  if (er) {
	    errorOrDestroy(stream, er);
	    process.nextTick(cb, er);
	    return false;
	  }
	  return true;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    process.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      process.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      errorOrDestroy(stream, err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;
	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;
	var Readable = require_stream_readable();
	var Writable = require_stream_writable();
	requireInherits()(Duplex, Readable);
	{
	  // Allow the keys array to be GC'ed.
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  this.allowHalfOpen = true;
	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;
	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	return _stream_duplex;
}

var string_decoder = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$5;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;

	var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop() {}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	endOfStream = eos;
	return endOfStream;
}

var async_iterator;
var hasRequiredAsync_iterator;

function requireAsync_iterator () {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;

	var _Object$setPrototypeO;
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var finished = requireEndOfStream();
	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');
	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}
	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];
	  if (resolve !== null) {
	    var data = iter[kStream].read();
	    // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'
	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}
	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }
	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },
	  next: function next() {
	    var _this = this;
	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];
	    if (error !== null) {
	      return Promise.reject(error);
	    }
	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }
	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    }

	    // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time
	    var lastPromise = this[kLastPromise];
	    var promise;
	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();
	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }
	      promise = new Promise(this[kHandlePromise]);
	    }
	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;
	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }
	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();
	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  finished(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject];
	      // reject if we are waiting for data in the Promise
	      // returned by next() and store the error
	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }
	      iterator[kError] = err;
	      return;
	    }
	    var resolve = iterator[kLastResolve];
	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }
	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};
	async_iterator = createReadableStreamAsyncIterator;
	return async_iterator;
}

var from_1;
var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from_1;
	hasRequiredFrom = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
	function from(Readable, iterable, opts) {
	  var iterator;
	  if (iterable && typeof iterable.next === 'function') {
	    iterator = iterable;
	  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
	  var readable = new Readable(_objectSpread({
	    objectMode: true
	  }, opts));
	  // Reading boolean to protect against _read
	  // being called before last iteration completion.
	  var reading = false;
	  readable._read = function () {
	    if (!reading) {
	      reading = true;
	      next();
	    }
	  };
	  function next() {
	    return _next2.apply(this, arguments);
	  }
	  function _next2() {
	    _next2 = _asyncToGenerator(function* () {
	      try {
	        var _yield$iterator$next = yield iterator.next(),
	          value = _yield$iterator$next.value,
	          done = _yield$iterator$next.done;
	        if (done) {
	          readable.push(null);
	        } else if (readable.push(yield value)) {
	          next();
	        } else {
	          reading = false;
	        }
	      } catch (err) {
	        readable.destroy(err);
	      }
	    });
	    return _next2.apply(this, arguments);
	  }
	  return readable;
	}
	from_1 = from;
	return from_1;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	_stream_readable = Readable;

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	require$$0$2.EventEmitter;
	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream();
	/*</replacement>*/

	var Buffer = require$$0$5.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*<replacement>*/
	var debugUtil = require$$0$6;
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	var BufferList = requireBuffer_list();
	var destroyImpl = requireDestroy();
	var _require = requireState$1(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	// Lazy loaded to improve the startup performance.
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	requireInherits()(Readable, Stream);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'end' (and potentially 'finish')
	  this.autoDestroy = !!options.autoDestroy;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();
	  if (!(this instanceof Readable)) return new Readable(options);

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  this._readableState = new ReadableState(options, this, isDuplex);

	  // legacy
	  this.readable = true;
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	  Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      errorOrDestroy(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }
	  return er;
	}
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  var decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8
	  this._readableState.encoding = this._readableState.decoder.encoding;

	  // Iterate over current buffer to convert already stored Buffers:
	  var p = this._readableState.buffer.head;
	  var content = '';
	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }
	  this._readableState.buffer.clear();
	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	};

	// Don't raise the hwm > 1GB
	var MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	      hasUnpiped: false
	    });
	    return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	  var state = this._readableState;
	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  var res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	Readable.prototype.removeAllListeners = function (ev) {
	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state.paused = false;
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState.paused = true;
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return this;
	};
	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator === undefined) {
	      createReadableStreamAsyncIterator = requireAsync_iterator();
	    }
	    return createReadableStreamAsyncIterator(this);
	  };
	}
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	});

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;
	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}
	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = requireFrom();
	    }
	    return from(Readable, iterable, opts);
	  };
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;
	var _require$codes = requireErrors().codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex();
	requireInherits()(Transform, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;
	var Transform = require_stream_transform();
	requireInherits()(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = requireErrors().codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = requireEndOfStream();
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	pipeline_1 = pipeline;
	return pipeline_1;
}

var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable.exports;
	hasRequiredReadable = 1;
	(function (module, exports) {
		var Stream = require$$0$4;
		if (process.env.READABLE_STREAM === 'disable' && Stream) {
		  module.exports = Stream.Readable;
		  Object.assign(module.exports, Stream);
		  module.exports.Stream = Stream;
		} else {
		  exports = module.exports = require_stream_readable();
		  exports.Stream = Stream || exports;
		  exports.Readable = exports;
		  exports.Writable = require_stream_writable();
		  exports.Duplex = require_stream_duplex();
		  exports.Transform = require_stream_transform();
		  exports.PassThrough = require_stream_passthrough();
		  exports.finished = requireEndOfStream();
		  exports.pipeline = requirePipeline();
		} 
	} (readable, readable.exports));
	return readable.exports;
}

var BufferList_1;
var hasRequiredBufferList;

function requireBufferList () {
	if (hasRequiredBufferList) return BufferList_1;
	hasRequiredBufferList = 1;

	const { Buffer } = require$$0$5;
	const symbol = Symbol.for('BufferList');

	function BufferList (buf) {
	  if (!(this instanceof BufferList)) {
	    return new BufferList(buf)
	  }

	  BufferList._init.call(this, buf);
	}

	BufferList._init = function _init (buf) {
	  Object.defineProperty(this, symbol, { value: true });

	  this._bufs = [];
	  this.length = 0;

	  if (buf) {
	    this.append(buf);
	  }
	};

	BufferList.prototype._new = function _new (buf) {
	  return new BufferList(buf)
	};

	BufferList.prototype._offset = function _offset (offset) {
	  if (offset === 0) {
	    return [0, 0]
	  }

	  let tot = 0;

	  for (let i = 0; i < this._bufs.length; i++) {
	    const _t = tot + this._bufs[i].length;
	    if (offset < _t || i === this._bufs.length - 1) {
	      return [i, offset - tot]
	    }
	    tot = _t;
	  }
	};

	BufferList.prototype._reverseOffset = function (blOffset) {
	  const bufferId = blOffset[0];
	  let offset = blOffset[1];

	  for (let i = 0; i < bufferId; i++) {
	    offset += this._bufs[i].length;
	  }

	  return offset
	};

	BufferList.prototype.get = function get (index) {
	  if (index > this.length || index < 0) {
	    return undefined
	  }

	  const offset = this._offset(index);

	  return this._bufs[offset[0]][offset[1]]
	};

	BufferList.prototype.slice = function slice (start, end) {
	  if (typeof start === 'number' && start < 0) {
	    start += this.length;
	  }

	  if (typeof end === 'number' && end < 0) {
	    end += this.length;
	  }

	  return this.copy(null, 0, start, end)
	};

	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart !== 'number' || srcStart < 0) {
	    srcStart = 0;
	  }

	  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
	    srcEnd = this.length;
	  }

	  if (srcStart >= this.length) {
	    return dst || Buffer.alloc(0)
	  }

	  if (srcEnd <= 0) {
	    return dst || Buffer.alloc(0)
	  }

	  const copy = !!dst;
	  const off = this._offset(srcStart);
	  const len = srcEnd - srcStart;
	  let bytes = len;
	  let bufoff = (copy && dstStart) || 0;
	  let start = off[1];

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd === this.length) {
	    if (!copy) {
	      // slice, but full concat if multiple buffers
	      return this._bufs.length === 1
	        ? this._bufs[0]
	        : Buffer.concat(this._bufs, this.length)
	    }

	    // copy, need to copy individual buffers
	    for (let i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff);
	      bufoff += this._bufs[i].length;
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) {
	    // a slice, we need something to copy in to
	    dst = Buffer.allocUnsafe(len);
	  }

	  for (let i = off[0]; i < this._bufs.length; i++) {
	    const l = this._bufs[i].length - start;

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start);
	      bufoff += l;
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes);
	      bufoff += l;
	      break
	    }

	    bytes -= l;

	    if (start) {
	      start = 0;
	    }
	  }

	  // safeguard so that we don't return uninitialized memory
	  if (dst.length > bufoff) return dst.slice(0, bufoff)

	  return dst
	};

	BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
	  start = start || 0;
	  end = typeof end !== 'number' ? this.length : end;

	  if (start < 0) {
	    start += this.length;
	  }

	  if (end < 0) {
	    end += this.length;
	  }

	  if (start === end) {
	    return this._new()
	  }

	  const startOffset = this._offset(start);
	  const endOffset = this._offset(end);
	  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

	  if (endOffset[1] === 0) {
	    buffers.pop();
	  } else {
	    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
	  }

	  if (startOffset[1] !== 0) {
	    buffers[0] = buffers[0].slice(startOffset[1]);
	  }

	  return this._new(buffers)
	};

	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	};

	BufferList.prototype.consume = function consume (bytes) {
	  // first, normalize the argument, in accordance with how Buffer does it
	  bytes = Math.trunc(bytes);
	  // do nothing if not a positive number
	  if (Number.isNaN(bytes) || bytes <= 0) return this

	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length;
	      this.length -= this._bufs[0].length;
	      this._bufs.shift();
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes);
	      this.length -= bytes;
	      break
	    }
	  }

	  return this
	};

	BufferList.prototype.duplicate = function duplicate () {
	  const copy = this._new();

	  for (let i = 0; i < this._bufs.length; i++) {
	    copy.append(this._bufs[i]);
	  }

	  return copy
	};

	BufferList.prototype.append = function append (buf) {
	  if (buf == null) {
	    return this
	  }

	  if (buf.buffer) {
	    // append a view of the underlying ArrayBuffer
	    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
	  } else if (Array.isArray(buf)) {
	    for (let i = 0; i < buf.length; i++) {
	      this.append(buf[i]);
	    }
	  } else if (this._isBufferList(buf)) {
	    // unwrap argument into individual BufferLists
	    for (let i = 0; i < buf._bufs.length; i++) {
	      this.append(buf._bufs[i]);
	    }
	  } else {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf === 'number') {
	      buf = buf.toString();
	    }

	    this._appendBuffer(Buffer.from(buf));
	  }

	  return this
	};

	BufferList.prototype._appendBuffer = function appendBuffer (buf) {
	  this._bufs.push(buf);
	  this.length += buf.length;
	};

	BufferList.prototype.indexOf = function (search, offset, encoding) {
	  if (encoding === undefined && typeof offset === 'string') {
	    encoding = offset;
	    offset = undefined;
	  }

	  if (typeof search === 'function' || Array.isArray(search)) {
	    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
	  } else if (typeof search === 'number') {
	    search = Buffer.from([search]);
	  } else if (typeof search === 'string') {
	    search = Buffer.from(search, encoding);
	  } else if (this._isBufferList(search)) {
	    search = search.slice();
	  } else if (Array.isArray(search.buffer)) {
	    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
	  } else if (!Buffer.isBuffer(search)) {
	    search = Buffer.from(search);
	  }

	  offset = Number(offset || 0);

	  if (isNaN(offset)) {
	    offset = 0;
	  }

	  if (offset < 0) {
	    offset = this.length + offset;
	  }

	  if (offset < 0) {
	    offset = 0;
	  }

	  if (search.length === 0) {
	    return offset > this.length ? this.length : offset
	  }

	  const blOffset = this._offset(offset);
	  let blIndex = blOffset[0]; // index of which internal buffer we're working on
	  let buffOffset = blOffset[1]; // offset of the internal buffer we're working on

	  // scan over each buffer
	  for (; blIndex < this._bufs.length; blIndex++) {
	    const buff = this._bufs[blIndex];

	    while (buffOffset < buff.length) {
	      const availableWindow = buff.length - buffOffset;

	      if (availableWindow >= search.length) {
	        const nativeSearchResult = buff.indexOf(search, buffOffset);

	        if (nativeSearchResult !== -1) {
	          return this._reverseOffset([blIndex, nativeSearchResult])
	        }

	        buffOffset = buff.length - search.length + 1; // end of native search window
	      } else {
	        const revOffset = this._reverseOffset([blIndex, buffOffset]);

	        if (this._match(revOffset, search)) {
	          return revOffset
	        }

	        buffOffset++;
	      }
	    }

	    buffOffset = 0;
	  }

	  return -1
	};

	BufferList.prototype._match = function (offset, search) {
	  if (this.length - offset < search.length) {
	    return false
	  }

	  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
	    if (this.get(offset + searchOffset) !== search[searchOffset]) {
	      return false
	    }
	  }
	  return true
	}

	;(function () {
	  const methods = {
	    readDoubleBE: 8,
	    readDoubleLE: 8,
	    readFloatBE: 4,
	    readFloatLE: 4,
	    readInt32BE: 4,
	    readInt32LE: 4,
	    readUInt32BE: 4,
	    readUInt32LE: 4,
	    readInt16BE: 2,
	    readInt16LE: 2,
	    readUInt16BE: 2,
	    readUInt16LE: 2,
	    readInt8: 1,
	    readUInt8: 1,
	    readIntBE: null,
	    readIntLE: null,
	    readUIntBE: null,
	    readUIntLE: null
	  };

	  for (const m in methods) {
	    (function (m) {
	      if (methods[m] === null) {
	        BufferList.prototype[m] = function (offset, byteLength) {
	          return this.slice(offset, offset + byteLength)[m](0, byteLength)
	        };
	      } else {
	        BufferList.prototype[m] = function (offset = 0) {
	          return this.slice(offset, offset + methods[m])[m](0)
	        };
	      }
	    }(m));
	  }
	}());

	// Used internally by the class and also as an indicator of this object being
	// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
	// environment because there could be multiple different copies of the
	// BufferList class and some `BufferList`s might be `BufferList`s.
	BufferList.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferList || BufferList.isBufferList(b)
	};

	BufferList.isBufferList = function isBufferList (b) {
	  return b != null && b[symbol]
	};

	BufferList_1 = BufferList;
	return BufferList_1;
}

var hasRequiredBl;

function requireBl () {
	if (hasRequiredBl) return bl.exports;
	hasRequiredBl = 1;

	const DuplexStream = requireReadable().Duplex;
	const inherits = requireInherits();
	const BufferList = requireBufferList();

	function BufferListStream (callback) {
	  if (!(this instanceof BufferListStream)) {
	    return new BufferListStream(callback)
	  }

	  if (typeof callback === 'function') {
	    this._callback = callback;

	    const piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err);
	        this._callback = null;
	      }
	    }.bind(this);

	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper);
	    });
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper);
	    });

	    callback = null;
	  }

	  BufferList._init.call(this, callback);
	  DuplexStream.call(this);
	}

	inherits(BufferListStream, DuplexStream);
	Object.assign(BufferListStream.prototype, BufferList.prototype);

	BufferListStream.prototype._new = function _new (callback) {
	  return new BufferListStream(callback)
	};

	BufferListStream.prototype._write = function _write (buf, encoding, callback) {
	  this._appendBuffer(buf);

	  if (typeof callback === 'function') {
	    callback();
	  }
	};

	BufferListStream.prototype._read = function _read (size) {
	  if (!this.length) {
	    return this.push(null)
	  }

	  size = Math.min(size, this.length);
	  this.push(this.slice(0, size));
	  this.consume(size);
	};

	BufferListStream.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk);

	  if (this._callback) {
	    this._callback(null, this.slice());
	    this._callback = null;
	  }
	};

	BufferListStream.prototype._destroy = function _destroy (err, cb) {
	  this._bufs.length = 0;
	  this.length = 0;
	  cb(err);
	};

	BufferListStream.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
	};

	BufferListStream.isBufferList = BufferList.isBufferList;

	bl.exports = BufferListStream;
	bl.exports.BufferListStream = BufferListStream;
	bl.exports.BufferList = BufferList;
	return bl.exports;
}

var blExports = requireBl();

const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code

class StdinDiscarder {
	#requests = 0;
	#mutedStream = new blExports.BufferListStream();
	#ourEmit;
	#rl;

	constructor() {
		this.#mutedStream.pipe(process$1.stdout);

		const self = this; // eslint-disable-line unicorn/no-this-assignment
		this.#ourEmit = function (event, data, ...arguments_) {
			const {stdin} = process$1;
			if (self.#requests > 0 || stdin.emit === self.#ourEmit) {
				if (event === 'keypress') { // Fixes readline behavior
					return;
				}

				if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
					process$1.emit('SIGINT');
				}

				Reflect.apply(self.#ourEmit, this, [event, data, ...arguments_]);
			} else {
				Reflect.apply(process$1.stdin.emit, this, [event, data, ...arguments_]);
			}
		};
	}

	start() {
		this.#requests++;

		if (this.#requests === 1) {
			this._realStart();
		}
	}

	stop() {
		if (this.#requests <= 0) {
			throw new Error('`stop` called more times than `start`');
		}

		this.#requests--;

		if (this.#requests === 0) {
			this._realStop();
		}
	}

	// TODO: Use private methods when targeting Node.js 14.
	_realStart() {
		// No known way to make it work reliably on Windows
		if (process$1.platform === 'win32') {
			return;
		}

		this.#rl = readline.createInterface({
			input: process$1.stdin,
			output: this.#mutedStream,
		});

		this.#rl.on('SIGINT', () => {
			if (process$1.listenerCount('SIGINT') === 0) {
				process$1.emit('SIGINT');
			} else {
				this.#rl.close();
				process$1.kill(process$1.pid, 'SIGINT');
			}
		});
	}

	_realStop() {
		if (process$1.platform === 'win32') {
			return;
		}

		this.#rl.close();
		this.#rl = undefined;
	}
}

const stdinDiscarder = new StdinDiscarder();

class Ora {
	#linesToClear = 0;
	#isDiscardingStdin = false;
	#lineCount = 0;
	#frameIndex = 0;
	#options;
	#spinner;
	#stream;
	#id;
	#initialInterval;
	#isEnabled;
	#isSilent;
	#indent;
	#text;
	#prefixText;
	#suffixText;

	color;

	constructor(options) {
		if (typeof options === 'string') {
			options = {
				text: options,
			};
		}

		this.#options = {
			color: 'cyan',
			stream: process$1.stderr,
			discardStdin: true,
			hideCursor: true,
			...options,
		};

		// Public
		this.color = this.#options.color;

		// It's important that these use the public setters.
		this.spinner = this.#options.spinner;

		this.#initialInterval = this.#options.interval;
		this.#stream = this.#options.stream;
		this.#isEnabled = typeof this.#options.isEnabled === 'boolean' ? this.#options.isEnabled : isInteractive({stream: this.#stream});
		this.#isSilent = typeof this.#options.isSilent === 'boolean' ? this.#options.isSilent : false;

		// Set *after* `this.#stream`.
		// It's important that these use the public setters.
		this.text = this.#options.text;
		this.prefixText = this.#options.prefixText;
		this.suffixText = this.#options.suffixText;
		this.indent = this.#options.indent;

		if (process$1.env.NODE_ENV === 'test') {
			this._stream = this.#stream;
			this._isEnabled = this.#isEnabled;

			Object.defineProperty(this, '_linesToClear', {
				get() {
					return this.#linesToClear;
				},
				set(newValue) {
					this.#linesToClear = newValue;
				},
			});

			Object.defineProperty(this, '_frameIndex', {
				get() {
					return this.#frameIndex;
				},
			});

			Object.defineProperty(this, '_lineCount', {
				get() {
					return this.#lineCount;
				},
			});
		}
	}

	get indent() {
		return this.#indent;
	}

	set indent(indent = 0) {
		if (!(indent >= 0 && Number.isInteger(indent))) {
			throw new Error('The `indent` option must be an integer from 0 and up');
		}

		this.#indent = indent;
		this.#updateLineCount();
	}

	get interval() {
		return this.#initialInterval ?? this.#spinner.interval ?? 100;
	}

	get spinner() {
		return this.#spinner;
	}

	set spinner(spinner) {
		this.#frameIndex = 0;
		this.#initialInterval = undefined;

		if (typeof spinner === 'object') {
			if (spinner.frames === undefined) {
				throw new Error('The given spinner must have a `frames` property');
			}

			this.#spinner = spinner;
		} else if (!isUnicodeSupported()) {
			this.#spinner = cliSpinners.line;
		} else if (spinner === undefined) {
			// Set default spinner
			this.#spinner = cliSpinners.dots;
		} else if (spinner !== 'default' && cliSpinners[spinner]) {
			this.#spinner = cliSpinners[spinner];
		} else {
			throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
		}
	}

	get text() {
		return this.#text;
	}

	set text(value = '') {
		this.#text = value;
		this.#updateLineCount();
	}

	get prefixText() {
		return this.#prefixText;
	}

	set prefixText(value = '') {
		this.#prefixText = value;
		this.#updateLineCount();
	}

	get suffixText() {
		return this.#suffixText;
	}

	set suffixText(value = '') {
		this.#suffixText = value;
		this.#updateLineCount();
	}

	get isSpinning() {
		return this.#id !== undefined;
	}

	#getFullPrefixText(prefixText = this.#prefixText, postfix = ' ') {
		if (typeof prefixText === 'string' && prefixText !== '') {
			return prefixText + postfix;
		}

		if (typeof prefixText === 'function') {
			return prefixText() + postfix;
		}

		return '';
	}

	#getFullSuffixText(suffixText = this.#suffixText, prefix = ' ') {
		if (typeof suffixText === 'string' && suffixText !== '') {
			return prefix + suffixText;
		}

		if (typeof suffixText === 'function') {
			return prefix + suffixText();
		}

		return '';
	}

	#updateLineCount() {
		const columns = this.#stream.columns ?? 80;
		const fullPrefixText = this.#getFullPrefixText(this.#prefixText, '-');
		const fullSuffixText = this.#getFullSuffixText(this.#suffixText, '-');
		const fullText = ' '.repeat(this.#indent) + fullPrefixText + '--' + this.#text + '--' + fullSuffixText;

		this.#lineCount = 0;
		for (const line of stripAnsi$3(fullText).split('\n')) {
			this.#lineCount += Math.max(1, Math.ceil(stringWidth$2(line, {countAnsiEscapeCodes: true}) / columns));
		}
	}

	get isEnabled() {
		return this.#isEnabled && !this.#isSilent;
	}

	set isEnabled(value) {
		if (typeof value !== 'boolean') {
			throw new TypeError('The `isEnabled` option must be a boolean');
		}

		this.#isEnabled = value;
	}

	get isSilent() {
		return this.#isSilent;
	}

	set isSilent(value) {
		if (typeof value !== 'boolean') {
			throw new TypeError('The `isSilent` option must be a boolean');
		}

		this.#isSilent = value;
	}

	frame() {
		const {frames} = this.#spinner;
		let frame = frames[this.#frameIndex];

		if (this.color) {
			frame = chalk[this.color](frame);
		}

		this.#frameIndex = ++this.#frameIndex % frames.length;
		const fullPrefixText = (typeof this.#prefixText === 'string' && this.#prefixText !== '') ? this.#prefixText + ' ' : '';
		const fullText = typeof this.text === 'string' ? ' ' + this.text : '';
		const fullSuffixText = (typeof this.#suffixText === 'string' && this.#suffixText !== '') ? ' ' + this.#suffixText : '';

		return fullPrefixText + frame + fullText + fullSuffixText;
	}

	clear() {
		if (!this.#isEnabled || !this.#stream.isTTY) {
			return this;
		}

		this.#stream.cursorTo(0);

		for (let index = 0; index < this.#linesToClear; index++) {
			if (index > 0) {
				this.#stream.moveCursor(0, -1);
			}

			this.#stream.clearLine(1);
		}

		if (this.#indent || this.lastIndent !== this.#indent) {
			this.#stream.cursorTo(this.#indent);
		}

		this.lastIndent = this.#indent;
		this.#linesToClear = 0;

		return this;
	}

	render() {
		if (this.#isSilent) {
			return this;
		}

		this.clear();
		this.#stream.write(this.frame());
		this.#linesToClear = this.#lineCount;

		return this;
	}

	start(text) {
		if (text) {
			this.text = text;
		}

		if (this.#isSilent) {
			return this;
		}

		if (!this.#isEnabled) {
			if (this.text) {
				this.#stream.write(`- ${this.text}\n`);
			}

			return this;
		}

		if (this.isSpinning) {
			return this;
		}

		if (this.#options.hideCursor) {
			cliCursor.hide(this.#stream);
		}

		if (this.#options.discardStdin && process$1.stdin.isTTY) {
			this.#isDiscardingStdin = true;
			stdinDiscarder.start();
		}

		this.render();
		this.#id = setInterval(this.render.bind(this), this.interval);

		return this;
	}

	stop() {
		if (!this.#isEnabled) {
			return this;
		}

		clearInterval(this.#id);
		this.#id = undefined;
		this.#frameIndex = 0;
		this.clear();
		if (this.#options.hideCursor) {
			cliCursor.show(this.#stream);
		}

		if (this.#options.discardStdin && process$1.stdin.isTTY && this.#isDiscardingStdin) {
			stdinDiscarder.stop();
			this.#isDiscardingStdin = false;
		}

		return this;
	}

	succeed(text) {
		return this.stopAndPersist({symbol: logSymbols.success, text});
	}

	fail(text) {
		return this.stopAndPersist({symbol: logSymbols.error, text});
	}

	warn(text) {
		return this.stopAndPersist({symbol: logSymbols.warning, text});
	}

	info(text) {
		return this.stopAndPersist({symbol: logSymbols.info, text});
	}

	stopAndPersist(options = {}) {
		if (this.#isSilent) {
			return this;
		}

		const prefixText = options.prefixText ?? this.#prefixText;
		const fullPrefixText = this.#getFullPrefixText(prefixText, ' ');

		const symbolText = options.symbol ?? ' ';

		const text = options.text ?? this.text;
		const fullText = (typeof text === 'string') ? ' ' + text : '';

		const suffixText = options.suffixText ?? this.#suffixText;
		const fullSuffixText = this.#getFullSuffixText(suffixText, ' ');

		const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + '\n';

		this.stop();
		this.#stream.write(textToWrite);

		return this;
	}
}

function ora(options) {
	return new Ora(options);
}

function detectAnalysisNeeds(records, columnTypes) {
  
  const analyses = {
    regression: false,
    timeSeries: false,
    cart: false,
    australianData: false,
    mlReadiness: false,
    advancedStats: true, // Always run advanced stats
    distributionTesting: true,
    outlierAnalysis: true,
    correlationAnalysis: false,
    patternDetection: true
  };

  const columns = Object.keys(columnTypes);
  
  // Sample records for analysis detection on large datasets
  
  const sampleSize = Math.min(1000, records.length);
  const sampledRecords = records.length > 1000 ? records.slice(0, sampleSize) : records;
  
  
  // Check for regression analysis (continuous variable with high uniqueness)
  const numericColumns = columns.filter(col => 
    ['integer', 'float'].includes(columnTypes[col].type)
  );
  
  numericColumns.forEach(col => {
    
    try {
      const values = sampledRecords.map(r => r[col]).filter(v => v !== null && v !== undefined);
      
      const uniqueRatio = new Set(values).size / values.length;
      if (uniqueRatio > 0.7 && values.length > 30) {
        analyses.regression = true;
      }
    } catch (error) {
    }
  });

  // Check for time series analysis
  const dateColumns = columns.filter(col => columnTypes[col].type === 'date');
  if (dateColumns.length > 0 && sampledRecords.length > 30) {
    // Check for regular intervals
    const dateCol = dateColumns[0];
    const dates = sampledRecords
      .map(r => r[dateCol])
      .filter(d => d instanceof Date)
      .sort((a, b) => a - b);
    
    if (dates.length > 20) {
      const intervals = [];
      for (let i = 1; i < Math.min(dates.length, 10); i++) {
        intervals.push(dates[i] - dates[i-1]);
      }
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      const intervalVariance = intervals.reduce((sum, int) => sum + Math.pow(int - avgInterval, 2), 0) / intervals.length;
      const cv = Math.sqrt(intervalVariance) / avgInterval;
      
      if (cv < 0.3) {
        analyses.timeSeries = true;
      }
    }
  }

  // Check for CART analysis (mixed data types)
  const categoricalColumns = columns.filter(col => 
    columnTypes[col].type === 'categorical'
  );
  
  if (numericColumns.length > 0 && categoricalColumns.length > 0 && records.length > 100) {
    analyses.cart = true;
  }

  // Check for Australian data patterns
  const australianPatterns = [
    /^(0[2-478]\d{8}|04\d{8})$/, // Australian phone
    /^[0-9]{4}$/, // Australian postcode
    /\b(NSW|VIC|QLD|WA|SA|TAS|ACT|NT)\b/i, // State codes
    /\$[\d,]+\.?\d*/, // Currency
    /\b\d{2} \d{3} \d{3} \d{3}\b/, // ABN format
  ];

  for (const col of columns) {
    const sampleValues = records
      .slice(0, 100)
      .map(r => String(r[col] || ''))
      .filter(v => v);
    
    for (const pattern of australianPatterns) {
      const matches = sampleValues.filter(v => pattern.test(v)).length;
      if (matches > sampleValues.length * 0.1) {
        analyses.australianData = true;
        break;
      }
    }
    if (analyses.australianData) break;
  }

  // Check ML readiness
  if (columns.length > 5 && records.length > 1000) {
    analyses.mlReadiness = true;
  }

  // Enable correlation analysis if multiple numeric columns
  if (numericColumns.length >= 2) {
    analyses.correlationAnalysis = true;
  }

  return analyses;
}

function findPotentialTargets(records, columnTypes) {
  const columns = Object.keys(columnTypes);
  const targets = [];
  
  // Sample for large datasets
  const sampleSize = Math.min(1000, records.length);
  const sampledRecords = records.length > 1000 ? records.slice(0, sampleSize) : records;

  columns.forEach(col => {
    const type = columnTypes[col];
    const values = sampledRecords.map(r => r[col]).filter(v => v !== null && v !== undefined);
    const uniqueRatio = new Set(values).size / values.length;

    // Good regression target: continuous with high variance
    if (['integer', 'float'].includes(type.type) && uniqueRatio > 0.5) {
      targets.push({
        column: col,
        type: 'regression',
        score: uniqueRatio,
        reason: 'Continuous variable with high variance'
      });
    }

    // Good classification target: categorical with 2-10 classes
    if (type.type === 'categorical') {
      const uniqueCount = type.categories.length;
      if (uniqueCount >= 2 && uniqueCount <= 10) {
        targets.push({
          column: col,
          type: 'classification',
          score: 1 - Math.abs(5 - uniqueCount) / 5,
          reason: `Categorical with ${uniqueCount} classes`
        });
      }
    }
  });

  return targets.sort((a, b) => b.score - a.score);
}

function detectPatterns$1(records, columns, columnTypes) {
  const patterns = {
    benfordLaw: [],
    businessRules: [],
    temporalPatterns: [],
    duplicatePatterns: [],
    anomalies: []
  };

  columns.forEach(col => {
    const type = columnTypes[col];
    const values = records.map(r => r[col]);

    // Benford's Law for financial data
    if (['integer', 'float'].includes(type.type)) {
      const benfordResult = checkBenfordLaw(values);
      if (benfordResult.applicable) {
        patterns.benfordLaw.push({
          column: col,
          ...benfordResult
        });
      }
    }

    // Business rule detection
    const rules = detectBusinessRules$1(values, type);
    if (rules.length > 0) {
      patterns.businessRules.push({
        column: col,
        rules
      });
    }

    // Temporal patterns for date columns
    if (type.type === 'date') {
      const temporal = detectTemporalPatterns(records, col);
      if (temporal.patterns.length > 0) {
        patterns.temporalPatterns.push({
          column: col,
          ...temporal
        });
      }
    }
  });

  // Detect row-level duplicates
  patterns.duplicatePatterns = detectDuplicatePatterns(records, columns);

  // Detect multivariate anomalies
  patterns.anomalies = detectAnomalies$3(records, columns);

  return patterns;
}

function checkBenfordLaw(values) {
  const numbers = values.filter(v => typeof v === 'number' && v > 0);
  
  if (numbers.length < 100) {
    return { applicable: false, reason: 'Too few positive numbers' };
  }

  // Count first digits
  const firstDigitCounts = Array(9).fill(0);
  numbers.forEach(num => {
    const firstDigit = parseInt(String(Math.abs(num))[0]);
    if (firstDigit >= 1 && firstDigit <= 9) {
      firstDigitCounts[firstDigit - 1]++;
    }
  });

  // Calculate expected vs actual
  const expectedFreq = [0.301, 0.176, 0.125, 0.097, 0.079, 0.067, 0.058, 0.051, 0.046];
  const actualFreq = firstDigitCounts.map(count => count / numbers.length);
  
  // Chi-square test
  let chiSquare = 0;
  for (let i = 0; i < 9; i++) {
    if (expectedFreq[i] > 0) {
      chiSquare += Math.pow(actualFreq[i] - expectedFreq[i], 2) / expectedFreq[i];
    }
  }

  const criticalValue = 15.507; // Chi-square critical value at 0.05 significance, 8 df
  const followsBenford = chiSquare < criticalValue;

  return {
    applicable: true,
    followsBenford,
    chiSquare: chiSquare.toFixed(3),
    firstDigitDistribution: actualFreq.map((f, i) => ({
      digit: i + 1,
      expected: (expectedFreq[i] * 100).toFixed(1) + '%',
      actual: (f * 100).toFixed(1) + '%'
    })),
    interpretation: followsBenford 
      ? 'Data follows Benford\'s Law (typical of natural financial data)'
      : 'Data deviates from Benford\'s Law (may indicate artificial or manipulated data)'
  };
}

function detectBusinessRules$1(values, type) {
  const rules = [];
  const nonNull = values.filter(v => v !== null && v !== undefined);

  if (nonNull.length === 0) return rules;

  // Numeric constraints
  if (['integer', 'float'].includes(type.type)) {
    const numbers = nonNull.filter(v => typeof v === 'number');
    const min = Math.min(...numbers);
    const max = Math.max(...numbers);
    
    // Check for common constraints
    if (min >= 0) rules.push('Non-negative values only');
    if (min >= 1) rules.push('Positive values only');
    if (max <= 100 && min >= 0) rules.push('Percentage values (0-100)');
    if (max <= 1 && min >= 0) rules.push('Probability values (0-1)');
    
    // Check for integer multiples
    if (type.type === 'integer' && numbers.length > 10) {
      const gcd = numbers.reduce((a, b) => {
        while (b) {
          const temp = b;
          b = a % b;
          a = temp;
        }
        return a;
      });
      if (gcd > 1) rules.push(`Values are multiples of ${gcd}`);
    }
  }

  // String patterns
  if (type.type === 'categorical') {
    const lengths = nonNull.map(v => String(v).length);
    const uniqueLengths = new Set(lengths);
    
    if (uniqueLengths.size === 1) {
      rules.push(`Fixed length: ${lengths[0]} characters`);
    }
    
    // Check for common prefixes/suffixes
    if (nonNull.length > 10) {
      const strings = nonNull.map(v => String(v));
      const commonPrefix = strings.reduce((prefix, str) => {
        while (str.indexOf(prefix) !== 0) {
          prefix = prefix.substring(0, prefix.length - 1);
        }
        return prefix;
      });
      
      if (commonPrefix.length > 2) {
        rules.push(`Common prefix: "${commonPrefix}"`);
      }
    }
  }

  return rules;
}

function detectTemporalPatterns(records, dateColumn) {
  const dates = records
    .map(r => r[dateColumn])
    .filter(d => d instanceof Date);

  if (dates.length < 30) {
    return { patterns: [] };
  }

  const patterns = [];
  
  // Day of week distribution
  const dayOfWeekCounts = Array(7).fill(0);
  dates.forEach(date => {
    dayOfWeekCounts[date.getDay()]++;
  });
  
  const avgPerDay = dates.length / 7;
  const peakDay = dayOfWeekCounts.indexOf(Math.max(...dayOfWeekCounts));
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  
  if (Math.max(...dayOfWeekCounts) > avgPerDay * 1.5) {
    patterns.push(`Peak activity on ${dayNames[peakDay]}`);
  }

  // Hour distribution (if time component exists)
  const hasTime = dates.some(d => d.getHours() !== 0 || d.getMinutes() !== 0);
  if (hasTime) {
    const hourCounts = Array(24).fill(0);
    dates.forEach(date => {
      hourCounts[date.getHours()]++;
    });
    
    const peakHour = hourCounts.indexOf(Math.max(...hourCounts));
    patterns.push(`Peak hour: ${peakHour}:00`);
    
    // Business hours check
    const businessHours = hourCounts.slice(9, 17).reduce((a, b) => a + b, 0);
    dates.length - businessHours;
    if (businessHours > dates.length * 0.8) {
      patterns.push('Primarily business hours activity');
    }
  }

  return { patterns };
}

function detectDuplicatePatterns(records, columns) {
  const patterns = [];
  
  // Full row duplicates
  const rowStrings = records.map(r => JSON.stringify(r));
  const duplicateRows = rowStrings.filter((row, index) => 
    rowStrings.indexOf(row) !== index
  ).length;
  
  if (duplicateRows > 0) {
    patterns.push({
      type: 'full_row',
      count: duplicateRows,
      percentage: (duplicateRows / records.length * 100).toFixed(1)
    });
  }

  // Subset duplicates (excluding likely ID columns)
  const nonIdColumns = columns.filter(col => {
    const values = records.map(r => r[col]);
    const uniqueRatio = new Set(values).size / values.length;
    return uniqueRatio < 0.95;
  });

  if (nonIdColumns.length > 2) {
    const subsetStrings = records.map(r => 
      JSON.stringify(nonIdColumns.reduce((obj, col) => {
        obj[col] = r[col];
        return obj;
      }, {}))
    );
    
    const subsetDuplicates = subsetStrings.filter((row, index) => 
      subsetStrings.indexOf(row) !== index
    ).length;
    
    if (subsetDuplicates > duplicateRows) {
      patterns.push({
        type: 'subset',
        count: subsetDuplicates - duplicateRows,
        percentage: ((subsetDuplicates - duplicateRows) / records.length * 100).toFixed(1),
        note: 'Duplicates when ignoring potential ID columns'
      });
    }
  }

  return patterns;
}

function detectAnomalies$3(records, columns, columnTypes) {
  const anomalies = [];
  columns.forEach(col => {
    records.filter(r => r[col] === null || r[col] === undefined).length;
  });
  
  // Find rows with many nulls
  const suspiciousRows = [];
  records.forEach((record, index) => {
    const nullCount = columns.filter(col => 
      record[col] === null || record[col] === undefined
    ).length;
    
    if (nullCount > columns.length * 0.5) {
      suspiciousRows.push(index);
    }
  });
  
  if (suspiciousRows.length > 0) {
    anomalies.push({
      type: 'sparse_rows',
      count: suspiciousRows.length,
      indices: suspiciousRows.slice(0, 5),
      description: 'Rows with >50% missing values'
    });
  }

  return anomalies;
}

/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m;
    var b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0;
        var sumY = 0;
        var sumXX = 0;
        var sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point;
        var x;
        var y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum$1(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    if (typeof sum !== "number") {
        return Number.NaN;
    }

    for (var i = 1; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean$2(x) {
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum$1(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean$2(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    }
    if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0];
    // store the mode as we find new modes
    var value = Number.NaN;
    // store how many times we've seen the mode
    var maxSeen = 0;
    // how many times the current candidate for the mode
    // has been seen
    var seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n log(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/**
 * The min is the lowest number in the array.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min$1(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max$1(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare$1);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare$1(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_covariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean$2(x);
    var ymean = mean$2(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean$2(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

function calculateEnhancedStats(values) {
  // Handle null string values and filter safely
  const cleanedValues = values.map(v => {
    if (typeof v === 'string' && (v.toLowerCase() === 'null' || v === 'NULL')) {
      return null;
    }
    return v;
  });
  
  const numbers = cleanedValues.filter(v => typeof v === 'number' && !isNaN(v) && isFinite(v));
  
  if (numbers.length === 0) {
    return { 
      count: 0, 
      nullCount: cleanedValues.length,
      hasData: false 
    };
  }
  
  const sorted = [...numbers].sort((a, b) => a - b);
  
  // Calculate all percentiles
  const percentiles = [5, 10, 25, 50, 75, 90, 95].reduce((acc, p) => {
    acc[`p${p}`] = quantile(sorted, p / 100);
    return acc;
  }, {});
  
  // Basic stats
  const basicStats = {
    count: numbers.length,
    nullCount: values.length - numbers.length,
    nullPercentage: ((values.length - numbers.length) / values.length) * 100,
    hasData: true,
    
    // Central tendency
    mean: mean$2(numbers),
    median: median(sorted),
    mode: mode(numbers),
    
    // Spread
    min: min$1(numbers),
    max: max$1(numbers),
    range: max$1(numbers) - min$1(numbers),
    sum: sum$1(numbers),
    standardDeviation: numbers.length > 1 ? standardDeviation(numbers) : 0,
    variance: numbers.length > 1 ? variance(numbers) : 0,
    coefficientOfVariation: 0,
    
    // Quartiles and IQR
    q1: percentiles.p25,
    q3: percentiles.p75,
    iqr: percentiles.p75 - percentiles.p25,
    
    // Percentiles
    ...percentiles,
    
    // Shape
    skewness: numbers.length > 2 ? calculateSkewness$2(numbers) : 0,
    kurtosis: numbers.length > 3 ? calculateKurtosis$2(numbers) : 0,
    
    // Additional metrics
    uniqueCount: new Set(numbers).size,
    uniqueRatio: new Set(numbers).size / numbers.length,
    zeroCount: numbers.filter(v => v === 0).length,
    positiveCount: numbers.filter(v => v > 0).length,
    negativeCount: numbers.filter(v => v < 0).length
  };
  
  // Coefficient of variation (only for positive mean)
  if (basicStats.mean > 0) {
    basicStats.coefficientOfVariation = (basicStats.standardDeviation / basicStats.mean) * 100;
  }
  
  // Outliers using multiple methods
  basicStats.outliers = detectOutliers$1(sorted, basicStats);
  
  // Distribution characteristics
  basicStats.distribution = analyzeDistributionShape(basicStats);
  
  return basicStats;
}

function calculateCategoricalStats(values) {
  const nonNull = values.filter(v => v !== null && v !== undefined);
  
  if (nonNull.length === 0) {
    return {
      count: 0,
      nullCount: values.length,
      hasData: false
    };
  }
  
  // Value counts
  const valueCounts = {};
  nonNull.forEach(v => {
    const key = String(v);
    valueCounts[key] = (valueCounts[key] || 0) + 1;
  });
  
  const sortedValues = Object.entries(valueCounts)
    .sort((a, b) => b[1] - a[1]);
  
  const uniqueCount = sortedValues.length;
  
  // Calculate entropy (diversity measure)
  const entropy = sortedValues.reduce((sum, [_, count]) => {
    const p = count / nonNull.length;
    return sum - (p > 0 ? p * Math.log2(p) : 0);
  }, 0);
  
  // Find rare categories
  const rareThreshold = nonNull.length * 0.01;
  const rareCategories = sortedValues.filter(([_, count]) => count < rareThreshold);
  
  return {
    count: nonNull.length,
    nullCount: values.length - nonNull.length,
    nullPercentage: ((values.length - nonNull.length) / values.length) * 100,
    hasData: true,
    
    uniqueCount,
    uniqueRatio: uniqueCount / nonNull.length,
    
    // Top values
    topValues: sortedValues.slice(0, 10).map(([value, count]) => ({
      value,
      count,
      percentage: (count / nonNull.length) * 100
    })),
    
    // Mode
    mode: sortedValues[0][0],
    modeCount: sortedValues[0][1],
    modePercentage: (sortedValues[0][1] / nonNull.length) * 100,
    
    // Diversity metrics
    entropy,
    normalizedEntropy: uniqueCount > 1 ? entropy / Math.log2(uniqueCount) : 0,
    
    // Rare categories
    rareCount: rareCategories.length,
    rarePercentage: (rareCategories.reduce((sum, [_, count]) => sum + count, 0) / nonNull.length) * 100,
    
    // Category length stats (for string values)
    lengthStats: calculateStringLengthStats(nonNull)
  };
}

function calculateSkewness$2(values) {
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  const n = values.length;
  
  if (stdDev === 0) return 0;
  
  const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / stdDev, 3), 0);
  return (n / ((n - 1) * (n - 2))) * sum;
}

function calculateKurtosis$2(values) {
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  const n = values.length;
  
  if (stdDev === 0) return 0;
  
  const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / stdDev, 4), 0);
  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sum - 
         (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));
}

function detectOutliers$1(sortedValues, stats) {
  const outliers = {
    iqr: [],
    zscore: [],
    modifiedZscore: [],
    extreme: []
  };
  
  if (sortedValues.length < 4) return outliers;
  
  // IQR method
  const lowerBound = stats.q1 - 1.5 * stats.iqr;
  const upperBound = stats.q3 + 1.5 * stats.iqr;
  const extremeLower = stats.q1 - 3 * stats.iqr;
  const extremeUpper = stats.q3 + 3 * stats.iqr;
  
  sortedValues.forEach(v => {
    if (v < lowerBound || v > upperBound) {
      outliers.iqr.push(v);
      if (v < extremeLower || v > extremeUpper) {
        outliers.extreme.push(v);
      }
    }
  });
  
  // Z-score method
  if (stats.standardDeviation > 0) {
    sortedValues.forEach(v => {
      const zscore = Math.abs((v - stats.mean) / stats.standardDeviation);
      if (zscore > 3) {
        outliers.zscore.push(v);
      }
    });
  }
  
  // Modified Z-score (Iglewicz-Hoaglin method)
  const mad = medianAbsoluteDeviation(sortedValues);
  if (mad > 0) {
    sortedValues.forEach(v => {
      const modifiedZscore = 0.6745 * Math.abs(v - stats.median) / mad;
      if (modifiedZscore > 3.5) {
        outliers.modifiedZscore.push(v);
      }
    });
  }
  
  return outliers;
}

function analyzeDistributionShape(stats) {
  const shape = {
    type: 'unknown',
    description: '',
    characteristics: []
  };
  
  // Skewness interpretation
  if (Math.abs(stats.skewness) < 0.5) {
    shape.characteristics.push('symmetric');
  } else if (stats.skewness > 2) {
    shape.characteristics.push('highly right-skewed');
    shape.type = 'right-skewed';
  } else if (stats.skewness > 1) {
    shape.characteristics.push('moderately right-skewed');
    shape.type = 'right-skewed';
  } else if (stats.skewness < -2) {
    shape.characteristics.push('highly left-skewed');
    shape.type = 'left-skewed';
  } else if (stats.skewness < -1) {
    shape.characteristics.push('moderately left-skewed');
    shape.type = 'left-skewed';
  }
  
  // Kurtosis interpretation
  if (Math.abs(stats.kurtosis) < 0.5) {
    shape.characteristics.push('mesokurtic (normal-like tails)');
  } else if (stats.kurtosis > 1) {
    shape.characteristics.push('leptokurtic (heavy tails)');
  } else if (stats.kurtosis < -1) {
    shape.characteristics.push('platykurtic (light tails)');
  }
  
  // Overall shape determination
  if (Math.abs(stats.skewness) < 0.5 && Math.abs(stats.kurtosis) < 0.5) {
    shape.type = 'normal';
    shape.description = 'Approximately normal distribution';
  } else if (stats.skewness > 2 && stats.min > 0) {
    shape.type = 'log-normal';
    shape.description = 'Possible log-normal distribution';
  } else if (stats.uniqueCount < 10) {
    shape.type = 'discrete';
    shape.description = 'Discrete distribution with limited values';
  } else {
    shape.description = `Distribution is ${shape.characteristics.join(', ')}`;
  }
  
  return shape;
}

function calculateStringLengthStats(values) {
  const lengths = values.map(v => String(v).length);
  
  if (lengths.length === 0) return null;
  
  return {
    minLength: Math.min(...lengths),
    maxLength: Math.max(...lengths),
    avgLength: mean$2(lengths),
    stdLength: lengths.length > 1 ? standardDeviation(lengths) : 0,
    fixedLength: new Set(lengths).size === 1
  };
}

var jstat$2 = {exports: {}};

var jstat$1 = jstat$2.exports;

var hasRequiredJstat;

function requireJstat () {
	if (hasRequiredJstat) return jstat$2.exports;
	hasRequiredJstat = 1;
	(function (module, exports) {
		(function (window, factory) {
		    {
		        module.exports = factory();
		    }
		})(jstat$1, function () {
		var jStat = (function(Math, undefined$1) {

		// For quick reference.
		var concat = Array.prototype.concat;
		var slice = Array.prototype.slice;
		var toString = Object.prototype.toString;

		// Calculate correction for IEEE error
		// TODO: This calculation can be improved.
		function calcRdx(n, m) {
		  var val = n > m ? n : m;
		  return Math.pow(10,
		                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
		}


		var isArray = Array.isArray || function isArray(arg) {
		  return toString.call(arg) === '[object Array]';
		};


		function isFunction(arg) {
		  return toString.call(arg) === '[object Function]';
		}


		function isNumber(num) {
		  return (typeof num === 'number') ? num - num === 0 : false;
		}


		// Converts the jStat matrix to vector.
		function toVector(arr) {
		  return concat.apply([], arr);
		}


		// The one and only jStat constructor.
		function jStat() {
		  return new jStat._init(arguments);
		}


		// TODO: Remove after all references in src files have been removed.
		jStat.fn = jStat.prototype;


		// By separating the initializer from the constructor it's easier to handle
		// always returning a new instance whether "new" was used or not.
		jStat._init = function _init(args) {
		  // If first argument is an array, must be vector or matrix.
		  if (isArray(args[0])) {
		    // Check if matrix.
		    if (isArray(args[0][0])) {
		      // See if a mapping function was also passed.
		      if (isFunction(args[1]))
		        args[0] = jStat.map(args[0], args[1]);
		      // Iterate over each is faster than this.push.apply(this, args[0].
		      for (var i = 0; i < args[0].length; i++)
		        this[i] = args[0][i];
		      this.length = args[0].length;

		    // Otherwise must be a vector.
		    } else {
		      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
		      this.length = 1;
		    }

		  // If first argument is number, assume creation of sequence.
		  } else if (isNumber(args[0])) {
		    this[0] = jStat.seq.apply(null, args);
		    this.length = 1;

		  // Handle case when jStat object is passed to jStat.
		  } else if (args[0] instanceof jStat) {
		    // Duplicate the object and pass it back.
		    return jStat(args[0].toArray());

		  // Unexpected argument value, return empty jStat object.
		  // TODO: This is strange behavior. Shouldn't this throw or some such to let
		  // the user know they had bad arguments?
		  } else {
		    this[0] = [];
		    this.length = 1;
		  }

		  return this;
		};
		jStat._init.prototype = jStat.prototype;
		jStat._init.constructor = jStat;


		// Utility functions.
		// TODO: for internal use only?
		jStat.utils = {
		  calcRdx: calcRdx,
		  isArray: isArray,
		  isFunction: isFunction,
		  isNumber: isNumber,
		  toVector: toVector
		};


		jStat._random_fn = Math.random;
		jStat.setRandom = function setRandom(fn) {
		  if (typeof fn !== 'function')
		    throw new TypeError('fn is not a function');
		  jStat._random_fn = fn;
		};


		// Easily extend the jStat object.
		// TODO: is this seriously necessary?
		jStat.extend = function extend(obj) {
		  var i, j;

		  if (arguments.length === 1) {
		    for (j in obj)
		      jStat[j] = obj[j];
		    return this;
		  }

		  for (i = 1; i < arguments.length; i++) {
		    for (j in arguments[i])
		      obj[j] = arguments[i][j];
		  }

		  return obj;
		};


		// Returns the number of rows in the matrix.
		jStat.rows = function rows(arr) {
		  return arr.length || 1;
		};


		// Returns the number of columns in the matrix.
		jStat.cols = function cols(arr) {
		  return arr[0].length || 1;
		};


		// Returns the dimensions of the object { rows: i, cols: j }
		jStat.dimensions = function dimensions(arr) {
		  return {
		    rows: jStat.rows(arr),
		    cols: jStat.cols(arr)
		  };
		};


		// Returns a specified row as a vector or return a sub matrix by pick some rows
		jStat.row = function row(arr, index) {
		  if (isArray(index)) {
		    return index.map(function(i) {
		      return jStat.row(arr, i);
		    })
		  }
		  return arr[index];
		};


		// return row as array
		// rowa([[1,2],[3,4]],0) -> [1,2]
		jStat.rowa = function rowa(arr, i) {
		  return jStat.row(arr, i);
		};


		// Returns the specified column as a vector or return a sub matrix by pick some
		// columns
		jStat.col = function col(arr, index) {
		  if (isArray(index)) {
		    var submat = jStat.arange(arr.length).map(function() {
		      return new Array(index.length);
		    });
		    index.forEach(function(ind, i){
		      jStat.arange(arr.length).forEach(function(j) {
		        submat[j][i] = arr[j][ind];
		      });
		    });
		    return submat;
		  }
		  var column = new Array(arr.length);
		  for (var i = 0; i < arr.length; i++)
		    column[i] = [arr[i][index]];
		  return column;
		};


		// return column as array
		// cola([[1,2],[3,4]],0) -> [1,3]
		jStat.cola = function cola(arr, i) {
		  return jStat.col(arr, i).map(function(a){ return a[0] });
		};


		// Returns the diagonal of the matrix
		jStat.diag = function diag(arr) {
		  var nrow = jStat.rows(arr);
		  var res = new Array(nrow);
		  for (var row = 0; row < nrow; row++)
		    res[row] = [arr[row][row]];
		  return res;
		};


		// Returns the anti-diagonal of the matrix
		jStat.antidiag = function antidiag(arr) {
		  var nrow = jStat.rows(arr) - 1;
		  var res = new Array(nrow);
		  for (var i = 0; nrow >= 0; nrow--, i++)
		    res[i] = [arr[i][nrow]];
		  return res;
		};

		// Transpose a matrix or array.
		jStat.transpose = function transpose(arr) {
		  var obj = [];
		  var objArr, rows, cols, j, i;

		  // Make sure arr is in matrix format.
		  if (!isArray(arr[0]))
		    arr = [arr];

		  rows = arr.length;
		  cols = arr[0].length;

		  for (i = 0; i < cols; i++) {
		    objArr = new Array(rows);
		    for (j = 0; j < rows; j++)
		      objArr[j] = arr[j][i];
		    obj.push(objArr);
		  }

		  // If obj is vector, return only single array.
		  return obj.length === 1 ? obj[0] : obj;
		};


		// Map a function to an array or array of arrays.
		// "toAlter" is an internal variable.
		jStat.map = function map(arr, func, toAlter) {
		  var row, nrow, ncol, res, col;

		  if (!isArray(arr[0]))
		    arr = [arr];

		  nrow = arr.length;
		  ncol = arr[0].length;
		  res = toAlter ? arr : new Array(nrow);

		  for (row = 0; row < nrow; row++) {
		    // if the row doesn't exist, create it
		    if (!res[row])
		      res[row] = new Array(ncol);
		    for (col = 0; col < ncol; col++)
		      res[row][col] = func(arr[row][col], row, col);
		  }

		  return res.length === 1 ? res[0] : res;
		};


		// Cumulatively combine the elements of an array or array of arrays using a function.
		jStat.cumreduce = function cumreduce(arr, func, toAlter) {
		  var row, nrow, ncol, res, col;

		  if (!isArray(arr[0]))
		    arr = [arr];

		  nrow = arr.length;
		  ncol = arr[0].length;
		  res = toAlter ? arr : new Array(nrow);

		  for (row = 0; row < nrow; row++) {
		    // if the row doesn't exist, create it
		    if (!res[row])
		      res[row] = new Array(ncol);
		    if (ncol > 0)
		      res[row][0] = arr[row][0];
		    for (col = 1; col < ncol; col++)
		      res[row][col] = func(res[row][col-1], arr[row][col]);
		  }
		  return res.length === 1 ? res[0] : res;
		};


		// Destructively alter an array.
		jStat.alter = function alter(arr, func) {
		  return jStat.map(arr, func, true);
		};


		// Generate a rows x cols matrix according to the supplied function.
		jStat.create = function  create(rows, cols, func) {
		  var res = new Array(rows);
		  var i, j;

		  if (isFunction(cols)) {
		    func = cols;
		    cols = rows;
		  }

		  for (i = 0; i < rows; i++) {
		    res[i] = new Array(cols);
		    for (j = 0; j < cols; j++)
		      res[i][j] = func(i, j);
		  }

		  return res;
		};


		function retZero() { return 0; }


		// Generate a rows x cols matrix of zeros.
		jStat.zeros = function zeros(rows, cols) {
		  if (!isNumber(cols))
		    cols = rows;
		  return jStat.create(rows, cols, retZero);
		};


		function retOne() { return 1; }


		// Generate a rows x cols matrix of ones.
		jStat.ones = function ones(rows, cols) {
		  if (!isNumber(cols))
		    cols = rows;
		  return jStat.create(rows, cols, retOne);
		};


		// Generate a rows x cols matrix of uniformly random numbers.
		jStat.rand = function rand(rows, cols) {
		  if (!isNumber(cols))
		    cols = rows;
		  return jStat.create(rows, cols, jStat._random_fn);
		};


		function retIdent(i, j) { return i === j ? 1 : 0; }


		// Generate an identity matrix of size row x cols.
		jStat.identity = function identity(rows, cols) {
		  if (!isNumber(cols))
		    cols = rows;
		  return jStat.create(rows, cols, retIdent);
		};


		// Tests whether a matrix is symmetric
		jStat.symmetric = function symmetric(arr) {
		  var size = arr.length;
		  var row, col;

		  if (arr.length !== arr[0].length)
		    return false;

		  for (row = 0; row < size; row++) {
		    for (col = 0; col < size; col++)
		      if (arr[col][row] !== arr[row][col])
		        return false;
		  }

		  return true;
		};


		// Set all values to zero.
		jStat.clear = function clear(arr) {
		  return jStat.alter(arr, retZero);
		};


		// Generate sequence.
		jStat.seq = function seq(min, max, length, func) {
		  if (!isFunction(func))
		    func = false;

		  var arr = [];
		  var hival = calcRdx(min, max);
		  var step = (max * hival - min * hival) / ((length - 1) * hival);
		  var current = min;
		  var cnt;

		  // Current is assigned using a technique to compensate for IEEE error.
		  // TODO: Needs better implementation.
		  for (cnt = 0;
		       current <= max && cnt < length;
		       cnt++, current = (min * hival + step * hival * cnt) / hival) {
		    arr.push((func ? func(current, cnt) : current));
		  }

		  return arr;
		};


		// arange(5) -> [0,1,2,3,4]
		// arange(1,5) -> [1,2,3,4]
		// arange(5,1,-1) -> [5,4,3,2]
		jStat.arange = function arange(start, end, step) {
		  var rl = [];
		  var i;
		  step = step || 1;
		  if (end === undefined$1) {
		    end = start;
		    start = 0;
		  }
		  if (start === end || step === 0) {
		    return [];
		  }
		  if (start < end && step < 0) {
		    return [];
		  }
		  if (start > end && step > 0) {
		    return [];
		  }
		  if (step > 0) {
		    for (i = start; i < end; i += step) {
		      rl.push(i);
		    }
		  } else {
		    for (i = start; i > end; i += step) {
		      rl.push(i);
		    }
		  }
		  return rl;
		};


		// A=[[1,2,3],[4,5,6],[7,8,9]]
		// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]
		// slice(A,1,{start:1}) -> [5,6]
		// as numpy code A[:2,1:]
		jStat.slice = (function(){
		  function _slice(list, start, end, step) {
		    // note it's not equal to range.map mode it's a bug
		    var i;
		    var rl = [];
		    var length = list.length;
		    if (start === undefined$1 && end === undefined$1 && step === undefined$1) {
		      return jStat.copy(list);
		    }

		    start = start || 0;
		    end = end || list.length;
		    start = start >= 0 ? start : length + start;
		    end = end >= 0 ? end : length + end;
		    step = step || 1;
		    if (start === end || step === 0) {
		      return [];
		    }
		    if (start < end && step < 0) {
		      return [];
		    }
		    if (start > end && step > 0) {
		      return [];
		    }
		    if (step > 0) {
		      for (i = start; i < end; i += step) {
		        rl.push(list[i]);
		      }
		    } else {
		      for (i = start; i > end;i += step) {
		        rl.push(list[i]);
		      }
		    }
		    return rl;
		  }

		  function slice(list, rcSlice) {
		    var colSlice, rowSlice;
		    rcSlice = rcSlice || {};
		    if (isNumber(rcSlice.row)) {
		      if (isNumber(rcSlice.col))
		        return list[rcSlice.row][rcSlice.col];
		      var row = jStat.rowa(list, rcSlice.row);
		      colSlice = rcSlice.col || {};
		      return _slice(row, colSlice.start, colSlice.end, colSlice.step);
		    }

		    if (isNumber(rcSlice.col)) {
		      var col = jStat.cola(list, rcSlice.col);
		      rowSlice = rcSlice.row || {};
		      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
		    }

		    rowSlice = rcSlice.row || {};
		    colSlice = rcSlice.col || {};
		    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
		    return rows.map(function(row) {
		      return _slice(row, colSlice.start, colSlice.end, colSlice.step);
		    });
		  }

		  return slice;
		}());


		// A=[[1,2,3],[4,5,6],[7,8,9]]
		// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])
		// A=[[1,2,3],[4,0,0],[7,0,0]]
		jStat.sliceAssign = function sliceAssign(A, rcSlice, B) {
		  var nl, ml;
		  if (isNumber(rcSlice.row)) {
		    if (isNumber(rcSlice.col))
		      return A[rcSlice.row][rcSlice.col] = B;
		    rcSlice.col = rcSlice.col || {};
		    rcSlice.col.start = rcSlice.col.start || 0;
		    rcSlice.col.end = rcSlice.col.end || A[0].length;
		    rcSlice.col.step = rcSlice.col.step || 1;
		    nl = jStat.arange(rcSlice.col.start,
		                          Math.min(A.length, rcSlice.col.end),
		                          rcSlice.col.step);
		    var m = rcSlice.row;
		    nl.forEach(function(n, i) {
		      A[m][n] = B[i];
		    });
		    return A;
		  }

		  if (isNumber(rcSlice.col)) {
		    rcSlice.row = rcSlice.row || {};
		    rcSlice.row.start = rcSlice.row.start || 0;
		    rcSlice.row.end = rcSlice.row.end || A.length;
		    rcSlice.row.step = rcSlice.row.step || 1;
		    ml = jStat.arange(rcSlice.row.start,
		                          Math.min(A[0].length, rcSlice.row.end),
		                          rcSlice.row.step);
		    var n = rcSlice.col;
		    ml.forEach(function(m, j) {
		      A[m][n] = B[j];
		    });
		    return A;
		  }

		  if (B[0].length === undefined$1) {
		    B = [B];
		  }
		  rcSlice.row.start = rcSlice.row.start || 0;
		  rcSlice.row.end = rcSlice.row.end || A.length;
		  rcSlice.row.step = rcSlice.row.step || 1;
		  rcSlice.col.start = rcSlice.col.start || 0;
		  rcSlice.col.end = rcSlice.col.end || A[0].length;
		  rcSlice.col.step = rcSlice.col.step || 1;
		  ml = jStat.arange(rcSlice.row.start,
		                        Math.min(A.length, rcSlice.row.end),
		                        rcSlice.row.step);
		  nl = jStat.arange(rcSlice.col.start,
		                        Math.min(A[0].length, rcSlice.col.end),
		                        rcSlice.col.step);
		  ml.forEach(function(m, i) {
		    nl.forEach(function(n, j) {
		      A[m][n] = B[i][j];
		    });
		  });
		  return A;
		};


		// [1,2,3] ->
		// [[1,0,0],[0,2,0],[0,0,3]]
		jStat.diagonal = function diagonal(diagArray) {
		  var mat = jStat.zeros(diagArray.length, diagArray.length);
		  diagArray.forEach(function(t, i) {
		    mat[i][i] = t;
		  });
		  return mat;
		};


		// return copy of A
		jStat.copy = function copy(A) {
		  return A.map(function(row) {
		    if (isNumber(row))
		      return row;
		    return row.map(function(t) {
		      return t;
		    });
		  });
		};


		// TODO: Go over this entire implementation. Seems a tragic waste of resources
		// doing all this work. Instead, and while ugly, use new Function() to generate
		// a custom function for each static method.

		// Quick reference.
		var jProto = jStat.prototype;

		// Default length.
		jProto.length = 0;

		// For internal use only.
		// TODO: Check if they're actually used, and if they are then rename them
		// to _*
		jProto.push = Array.prototype.push;
		jProto.sort = Array.prototype.sort;
		jProto.splice = Array.prototype.splice;
		jProto.slice = Array.prototype.slice;


		// Return a clean array.
		jProto.toArray = function toArray() {
		  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
		};


		// Map a function to a matrix or vector.
		jProto.map = function map(func, toAlter) {
		  return jStat(jStat.map(this, func, toAlter));
		};


		// Cumulatively combine the elements of a matrix or vector using a function.
		jProto.cumreduce = function cumreduce(func, toAlter) {
		  return jStat(jStat.cumreduce(this, func, toAlter));
		};


		// Destructively alter an array.
		jProto.alter = function alter(func) {
		  jStat.alter(this, func);
		  return this;
		};


		// Extend prototype with methods that have no argument.
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jProto[passfunc] = function(func) {
		      var self = this,
		      results;
		      // Check for callback.
		      if (func) {
		        setTimeout(function() {
		          func.call(self, jProto[passfunc].call(self));
		        });
		        return this;
		      }
		      results = jStat[passfunc](this);
		      return isArray(results) ? jStat(results) : results;
		    };
		  })(funcs[i]);
		})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


		// Extend prototype with methods that have one argument.
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jProto[passfunc] = function(index, func) {
		      var self = this;
		      // check for callback
		      if (func) {
		        setTimeout(function() {
		          func.call(self, jProto[passfunc].call(self, index));
		        });
		        return this;
		      }
		      return jStat(jStat[passfunc](this, index));
		    };
		  })(funcs[i]);
		})('row col'.split(' '));


		// Extend prototype with simple shortcut methods.
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jProto[passfunc] = function() {
		      return jStat(jStat[passfunc].apply(null, arguments));
		    };
		  })(funcs[i]);
		})('create zeros ones rand identity'.split(' '));


		// Exposing jStat.
		return jStat;

		}(Math));
		(function(jStat, Math) {

		var isFunction = jStat.utils.isFunction;

		// Ascending functions for sort
		function ascNum(a, b) { return a - b; }

		function clip(arg, min, max) {
		  return Math.max(min, Math.min(arg, max));
		}


		// sum of an array
		jStat.sum = function sum(arr) {
		  var sum = 0;
		  var i = arr.length;
		  while (--i >= 0)
		    sum += arr[i];
		  return sum;
		};


		// sum squared
		jStat.sumsqrd = function sumsqrd(arr) {
		  var sum = 0;
		  var i = arr.length;
		  while (--i >= 0)
		    sum += arr[i] * arr[i];
		  return sum;
		};


		// sum of squared errors of prediction (SSE)
		jStat.sumsqerr = function sumsqerr(arr) {
		  var mean = jStat.mean(arr);
		  var sum = 0;
		  var i = arr.length;
		  var tmp;
		  while (--i >= 0) {
		    tmp = arr[i] - mean;
		    sum += tmp * tmp;
		  }
		  return sum;
		};

		// sum of an array in each row
		jStat.sumrow = function sumrow(arr) {
		  var sum = 0;
		  var i = arr.length;
		  while (--i >= 0)
		    sum += arr[i];
		  return sum;
		};

		// product of an array
		jStat.product = function product(arr) {
		  var prod = 1;
		  var i = arr.length;
		  while (--i >= 0)
		    prod *= arr[i];
		  return prod;
		};


		// minimum value of an array
		jStat.min = function min(arr) {
		  var low = arr[0];
		  var i = 0;
		  while (++i < arr.length)
		    if (arr[i] < low)
		      low = arr[i];
		  return low;
		};


		// maximum value of an array
		jStat.max = function max(arr) {
		  var high = arr[0];
		  var i = 0;
		  while (++i < arr.length)
		    if (arr[i] > high)
		      high = arr[i];
		  return high;
		};


		// unique values of an array
		jStat.unique = function unique(arr) {
		  var hash = {}, _arr = [];
		  for(var i = 0; i < arr.length; i++) {
		    if (!hash[arr[i]]) {
		      hash[arr[i]] = true;
		      _arr.push(arr[i]);
		    }
		  }
		  return _arr;
		};


		// mean value of an array
		jStat.mean = function mean(arr) {
		  return jStat.sum(arr) / arr.length;
		};


		// mean squared error (MSE)
		jStat.meansqerr = function meansqerr(arr) {
		  return jStat.sumsqerr(arr) / arr.length;
		};


		// geometric mean of an array
		jStat.geomean = function geomean(arr) {
		  var logs = arr.map(Math.log);
		  var meanOfLogs = jStat.mean(logs);
		  return Math.exp(meanOfLogs)
		};


		// median of an array
		jStat.median = function median(arr) {
		  var arrlen = arr.length;
		  var _arr = arr.slice().sort(ascNum);
		  // check if array is even or odd, then return the appropriate
		  return !(arrlen & 1)
		    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
		    : _arr[(arrlen / 2) | 0 ];
		};


		// cumulative sum of an array
		jStat.cumsum = function cumsum(arr) {
		  return jStat.cumreduce(arr, function (a, b) { return a + b; });
		};


		// cumulative product of an array
		jStat.cumprod = function cumprod(arr) {
		  return jStat.cumreduce(arr, function (a, b) { return a * b; });
		};


		// successive differences of a sequence
		jStat.diff = function diff(arr) {
		  var diffs = [];
		  var arrLen = arr.length;
		  var i;
		  for (i = 1; i < arrLen; i++)
		    diffs.push(arr[i] - arr[i - 1]);
		  return diffs;
		};


		// ranks of an array
		jStat.rank = function (arr) {
		  var i;
		  var distinctNumbers = [];
		  var numberCounts = {};
		  for (i = 0; i < arr.length; i++) {
		    var number = arr[i];
		    if (numberCounts[number]) {
		      numberCounts[number]++;
		    } else {
		      numberCounts[number] = 1;
		      distinctNumbers.push(number);
		    }
		  }

		  var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
		  var numberRanks = {};
		  var currentRank = 1;
		  for (i = 0; i < sortedDistinctNumbers.length; i++) {
		    var number = sortedDistinctNumbers[i];
		    var count = numberCounts[number];
		    var first = currentRank;
		    var last = currentRank + count - 1;
		    var rank = (first + last) / 2;
		    numberRanks[number] = rank;
		    currentRank += count;
		  }

		  return arr.map(function (number) {
		    return numberRanks[number];
		  });
		};


		// mode of an array
		// if there are multiple modes of an array, return all of them
		// is this the appropriate way of handling it?
		jStat.mode = function mode(arr) {
		  var arrLen = arr.length;
		  var _arr = arr.slice().sort(ascNum);
		  var count = 1;
		  var maxCount = 0;
		  var numMaxCount = 0;
		  var mode_arr = [];
		  var i;

		  for (i = 0; i < arrLen; i++) {
		    if (_arr[i] === _arr[i + 1]) {
		      count++;
		    } else {
		      if (count > maxCount) {
		        mode_arr = [_arr[i]];
		        maxCount = count;
		        numMaxCount = 0;
		      }
		      // are there multiple max counts
		      else if (count === maxCount) {
		        mode_arr.push(_arr[i]);
		        numMaxCount++;
		      }
		      // resetting count for new value in array
		      count = 1;
		    }
		  }

		  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
		};


		// range of an array
		jStat.range = function range(arr) {
		  return jStat.max(arr) - jStat.min(arr);
		};

		// variance of an array
		// flag = true indicates sample instead of population
		jStat.variance = function variance(arr, flag) {
		  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
		};

		// pooled variance of an array of arrays
		jStat.pooledvariance = function pooledvariance(arr) {
		  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);
		  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);
		  return sumsqerr / (count - arr.length);
		};

		// deviation of an array
		jStat.deviation = function (arr) {
		  var mean = jStat.mean(arr);
		  var arrlen = arr.length;
		  var dev = new Array(arrlen);
		  for (var i = 0; i < arrlen; i++) {
		    dev[i] = arr[i] - mean;
		  }
		  return dev;
		};

		// standard deviation of an array
		// flag = true indicates sample instead of population
		jStat.stdev = function stdev(arr, flag) {
		  return Math.sqrt(jStat.variance(arr, flag));
		};

		// pooled standard deviation of an array of arrays
		jStat.pooledstdev = function pooledstdev(arr) {
		  return Math.sqrt(jStat.pooledvariance(arr));
		};

		// mean deviation (mean absolute deviation) of an array
		jStat.meandev = function meandev(arr) {
		  var mean = jStat.mean(arr);
		  var a = [];
		  for (var i = arr.length - 1; i >= 0; i--) {
		    a.push(Math.abs(arr[i] - mean));
		  }
		  return jStat.mean(a);
		};


		// median deviation (median absolute deviation) of an array
		jStat.meddev = function meddev(arr) {
		  var median = jStat.median(arr);
		  var a = [];
		  for (var i = arr.length - 1; i >= 0; i--) {
		    a.push(Math.abs(arr[i] - median));
		  }
		  return jStat.median(a);
		};


		// coefficient of variation
		jStat.coeffvar = function coeffvar(arr) {
		  return jStat.stdev(arr) / jStat.mean(arr);
		};


		// quartiles of an array
		jStat.quartiles = function quartiles(arr) {
		  var arrlen = arr.length;
		  var _arr = arr.slice().sort(ascNum);
		  return [
		    _arr[ Math.round((arrlen) / 4) - 1 ],
		    _arr[ Math.round((arrlen) / 2) - 1 ],
		    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
		  ];
		};


		// Arbitary quantiles of an array. Direct port of the scipy.stats
		// implementation by Pierre GF Gerard-Marchant.
		jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
		  var sortedArray = arr.slice().sort(ascNum);
		  var quantileVals = [quantilesArray.length];
		  var n = arr.length;
		  var i, p, m, aleph, k, gamma;

		  if (typeof alphap === 'undefined')
		    alphap = 3 / 8;
		  if (typeof betap === 'undefined')
		    betap = 3 / 8;

		  for (i = 0; i < quantilesArray.length; i++) {
		    p = quantilesArray[i];
		    m = alphap + p * (1 - alphap - betap);
		    aleph = n * p + m;
		    k = Math.floor(clip(aleph, 1, n - 1));
		    gamma = clip(aleph - k, 0, 1);
		    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
		  }

		  return quantileVals;
		};

		// Return the k-th percentile of values in a range, where k is in the range 0..1, inclusive.
		// Passing true for the exclusive parameter excludes both endpoints of the range.
		jStat.percentile = function percentile(arr, k, exclusive) {
		  var _arr = arr.slice().sort(ascNum);
		  var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
		  var index = parseInt(realIndex);
		  var frac = realIndex - index;
		  if (index + 1 < _arr.length) {
		    return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);
		  } else {
		    return _arr[index - 1];
		  }
		};

		// The percentile rank of score in a given array. Returns the percentage
		// of all values in the input array that are less than (kind='strict') or
		// less or equal than (kind='weak') score. Default is weak.
		jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
		  var counter = 0;
		  var len = arr.length;
		  var strict = false;
		  var value, i;

		  if (kind === 'strict')
		    strict = true;

		  for (i = 0; i < len; i++) {
		    value = arr[i];
		    if ((strict && value < score) ||
		        (!strict && value <= score)) {
		      counter++;
		    }
		  }

		  return counter / len;
		};


		// Histogram (bin count) data
		jStat.histogram = function histogram(arr, binCnt) {
		  binCnt = binCnt || 4;
		  var first = jStat.min(arr);
		  var binWidth = (jStat.max(arr) - first) / binCnt;
		  var len = arr.length;
		  var bins = [];
		  var i;

		  for (i = 0; i < binCnt; i++)
		    bins[i] = 0;
		  for (i = 0; i < len; i++)
		    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;

		  return bins;
		};


		// covariance of two arrays
		jStat.covariance = function covariance(arr1, arr2) {
		  var u = jStat.mean(arr1);
		  var v = jStat.mean(arr2);
		  var arr1Len = arr1.length;
		  var sq_dev = new Array(arr1Len);
		  var i;

		  for (i = 0; i < arr1Len; i++)
		    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

		  return jStat.sum(sq_dev) / (arr1Len - 1);
		};


		// (pearson's) population correlation coefficient, rho
		jStat.corrcoeff = function corrcoeff(arr1, arr2) {
		  return jStat.covariance(arr1, arr2) /
		      jStat.stdev(arr1, 1) /
		      jStat.stdev(arr2, 1);
		};

		  // (spearman's) rank correlation coefficient, sp
		jStat.spearmancoeff =  function (arr1, arr2) {
		  arr1 = jStat.rank(arr1);
		  arr2 = jStat.rank(arr2);
		  //return pearson's correlation of the ranks:
		  return jStat.corrcoeff(arr1, arr2);
		};


		// statistical standardized moments (general form of skew/kurt)
		jStat.stanMoment = function stanMoment(arr, n) {
		  var mu = jStat.mean(arr);
		  var sigma = jStat.stdev(arr);
		  var len = arr.length;
		  var skewSum = 0;

		  for (var i = 0; i < len; i++)
		    skewSum += Math.pow((arr[i] - mu) / sigma, n);

		  return skewSum / arr.length;
		};

		// (pearson's) moment coefficient of skewness
		jStat.skewness = function skewness(arr) {
		  return jStat.stanMoment(arr, 3);
		};

		// (pearson's) (excess) kurtosis
		jStat.kurtosis = function kurtosis(arr) {
		  return jStat.stanMoment(arr, 4) - 3;
		};


		var jProto = jStat.prototype;


		// Extend jProto with method for calculating cumulative sums and products.
		// This differs from the similar extension below as cumsum and cumprod should
		// not be run again in the case fullbool === true.
		// If a matrix is passed, automatically assume operation should be done on the
		// columns.
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    // If a matrix is passed, automatically assume operation should be done on
		    // the columns.
		    jProto[passfunc] = function(fullbool, func) {
		      var arr = [];
		      var i = 0;
		      var tmpthis = this;
		      // Assignment reassignation depending on how parameters were passed in.
		      if (isFunction(fullbool)) {
		        func = fullbool;
		        fullbool = false;
		      }
		      // Check if a callback was passed with the function.
		      if (func) {
		        setTimeout(function() {
		          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
		        });
		        return this;
		      }
		      // Check if matrix and run calculations.
		      if (this.length > 1) {
		        tmpthis = fullbool === true ? this : this.transpose();
		        for (; i < tmpthis.length; i++)
		          arr[i] = jStat[passfunc](tmpthis[i]);
		        return arr;
		      }
		      // Pass fullbool if only vector, not a matrix. for variance and stdev.
		      return jStat[passfunc](this[0], fullbool);
		    };
		  })(funcs[i]);
		})(('cumsum cumprod').split(' '));


		// Extend jProto with methods which don't require arguments and work on columns.
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    // If a matrix is passed, automatically assume operation should be done on
		    // the columns.
		    jProto[passfunc] = function(fullbool, func) {
		      var arr = [];
		      var i = 0;
		      var tmpthis = this;
		      // Assignment reassignation depending on how parameters were passed in.
		      if (isFunction(fullbool)) {
		        func = fullbool;
		        fullbool = false;
		      }
		      // Check if a callback was passed with the function.
		      if (func) {
		        setTimeout(function() {
		          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
		        });
		        return this;
		      }
		      // Check if matrix and run calculations.
		      if (this.length > 1) {
		        if (passfunc !== 'sumrow')
		          tmpthis = fullbool === true ? this : this.transpose();
		        for (; i < tmpthis.length; i++)
		          arr[i] = jStat[passfunc](tmpthis[i]);
		        return fullbool === true
		            ? jStat[passfunc](jStat.utils.toVector(arr))
		            : arr;
		      }
		      // Pass fullbool if only vector, not a matrix. for variance and stdev.
		      return jStat[passfunc](this[0], fullbool);
		    };
		  })(funcs[i]);
		})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +
		    'geomean median diff rank mode range variance deviation stdev meandev ' +
		    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));


		// Extend jProto with functions that take arguments. Operations on matrices are
		// done on columns.
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jProto[passfunc] = function() {
		      var arr = [];
		      var i = 0;
		      var tmpthis = this;
		      var args = Array.prototype.slice.call(arguments);
		      var callbackFunction;

		      // If the last argument is a function, we assume it's a callback; we
		      // strip the callback out and call the function again.
		      if (isFunction(args[args.length - 1])) {
		        callbackFunction = args[args.length - 1];
		        var argsToPass = args.slice(0, args.length - 1);

		        setTimeout(function() {
		          callbackFunction.call(tmpthis,
		                                jProto[passfunc].apply(tmpthis, argsToPass));
		        });
		        return this;

		      // Otherwise we curry the function args and call normally.
		      } else {
		        callbackFunction = undefined;
		        var curriedFunction = function curriedFunction(vector) {
		          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
		        };
		      }

		      // If this is a matrix, run column-by-column.
		      if (this.length > 1) {
		        tmpthis = tmpthis.transpose();
		        for (; i < tmpthis.length; i++)
		          arr[i] = curriedFunction(tmpthis[i]);
		        return arr;
		      }

		      // Otherwise run on the vector.
		      return curriedFunction(this[0]);
		    };
		  })(funcs[i]);
		})('quantiles percentileOfScore'.split(' '));

		}(jStat, Math));
		// Special functions //
		(function(jStat, Math) {

		// Log-gamma function
		jStat.gammaln = function gammaln(x) {
		  var j = 0;
		  var cof = [
		    76.18009172947146, -86.50532032941678, 24.01409824083091,
		    -1.231739572450155, 0.1208650973866179e-2, -5395239384953e-18
		  ];
		  var ser = 1.000000000190015;
		  var xx, y, tmp;
		  tmp = (y = xx = x) + 5.5;
		  tmp -= (xx + 0.5) * Math.log(tmp);
		  for (; j < 6; j++)
		    ser += cof[j] / ++y;
		  return Math.log(2.5066282746310005 * ser / xx) - tmp;
		};

		/*
		 * log-gamma function to support poisson distribution sampling. The
		 * algorithm comes from SPECFUN by Shanjie Zhang and Jianming Jin and their
		 * book "Computation of Special Functions", 1996, John Wiley & Sons, Inc.
		 */
		jStat.loggam = function loggam(x) {
		  var x0, x2, xp, gl, gl0;
		  var k, n;

		  var a = [8.333333333333333e-02, -0.002777777777777778,
		          7.936507936507937e-04, -5952380952380952e-19,
		          8.417508417508418e-04, -0.001917526917526918,
		          6.410256410256410e-03, -0.02955065359477124,
		          1.796443723688307e-01, -1.3924322169059];
		  x0 = x;
		  n = 0;
		  if ((x == 1.0) || (x == 2.0)) {
		      return 0.0;
		  }
		  if (x <= 7.0) {
		      n = Math.floor(7 - x);
		      x0 = x + n;
		  }
		  x2 = 1.0 / (x0 * x0);
		  xp = 2 * Math.PI;
		  gl0 = a[9];
		  for (k = 8; k >= 0; k--) {
		      gl0 *= x2;
		      gl0 += a[k];
		  }
		  gl = gl0 / x0 + 0.5 * Math.log(xp) + (x0 - 0.5) * Math.log(x0) - x0;
		  if (x <= 7.0) {
		      for (k = 1; k <= n; k++) {
		          gl -= Math.log(x0 - 1.0);
		          x0 -= 1.0;
		      }
		  }
		  return gl;
		};

		// gamma of x
		jStat.gammafn = function gammafn(x) {
		  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
		           629.3311553128184, 866.9662027904133, -31451.272968848367,
		           -36144.413418691176, 66456.14382024054
		  ];
		  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
		           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
		           -134659.9598649693, -115132.2596755535];
		  var fact = false;
		  var n = 0;
		  var xden = 0;
		  var xnum = 0;
		  var y = x;
		  var i, z, yi, res;
		  if (x > 171.6243769536076) {
		    return Infinity;
		  }
		  if (y <= 0) {
		    res = y % 1 + 3.6e-16;
		    if (res) {
		      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
		      y = 1 - y;
		    } else {
		      return Infinity;
		    }
		  }
		  yi = y;
		  if (y < 1) {
		    z = y++;
		  } else {
		    z = (y -= n = (y | 0) - 1) - 1;
		  }
		  for (i = 0; i < 8; ++i) {
		    xnum = (xnum + p[i]) * z;
		    xden = xden * z + q[i];
		  }
		  res = xnum / xden + 1;
		  if (yi < y) {
		    res /= yi;
		  } else if (yi > y) {
		    for (i = 0; i < n; ++i) {
		      res *= y;
		      y++;
		    }
		  }
		  if (fact) {
		    res = fact / res;
		  }
		  return res;
		};


		// lower incomplete gamma function, which is usually typeset with a
		// lower-case greek gamma as the function symbol
		jStat.gammap = function gammap(a, x) {
		  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);
		};


		// The lower regularized incomplete gamma function, usually written P(a,x)
		jStat.lowRegGamma = function lowRegGamma(a, x) {
		  var aln = jStat.gammaln(a);
		  var ap = a;
		  var sum = 1 / a;
		  var del = sum;
		  var b = x + 1 - a;
		  var c = 1 / 1.0e-30;
		  var d = 1 / b;
		  var h = d;
		  var i = 1;
		  // calculate maximum number of itterations required for a
		  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
		  var an;

		  if (x < 0 || a <= 0) {
		    return NaN;
		  } else if (x < a + 1) {
		    for (; i <= ITMAX; i++) {
		      sum += del *= x / ++ap;
		    }
		    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));
		  }

		  for (; i <= ITMAX; i++) {
		    an = -i * (i - a);
		    b += 2;
		    d = an * d + b;
		    c = b + an / c;
		    d = 1 / d;
		    h *= d * c;
		  }

		  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));
		};

		// natural log factorial of n
		jStat.factorialln = function factorialln(n) {
		  return n < 0 ? NaN : jStat.gammaln(n + 1);
		};

		// factorial of n
		jStat.factorial = function factorial(n) {
		  return n < 0 ? NaN : jStat.gammafn(n + 1);
		};

		// combinations of n, m
		jStat.combination = function combination(n, m) {
		  // make sure n or m don't exceed the upper limit of usable values
		  return (n > 170 || m > 170)
		      ? Math.exp(jStat.combinationln(n, m))
		      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
		};


		jStat.combinationln = function combinationln(n, m){
		  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
		};


		// permutations of n, m
		jStat.permutation = function permutation(n, m) {
		  return jStat.factorial(n) / jStat.factorial(n - m);
		};


		// beta function
		jStat.betafn = function betafn(x, y) {
		  // ensure arguments are positive
		  if (x <= 0 || y <= 0)
		    return undefined;
		  // make sure x + y doesn't exceed the upper limit of usable values
		  return (x + y > 170)
		      ? Math.exp(jStat.betaln(x, y))
		      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
		};


		// natural logarithm of beta function
		jStat.betaln = function betaln(x, y) {
		  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
		};


		// Evaluates the continued fraction for incomplete beta function by modified
		// Lentz's method.
		jStat.betacf = function betacf(x, a, b) {
		  var fpmin = 1e-30;
		  var m = 1;
		  var qab = a + b;
		  var qap = a + 1;
		  var qam = a - 1;
		  var c = 1;
		  var d = 1 - qab * x / qap;
		  var m2, aa, del, h;

		  // These q's will be used in factors that occur in the coefficients
		  if (Math.abs(d) < fpmin)
		    d = fpmin;
		  d = 1 / d;
		  h = d;

		  for (; m <= 100; m++) {
		    m2 = 2 * m;
		    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
		    // One step (the even one) of the recurrence
		    d = 1 + aa * d;
		    if (Math.abs(d) < fpmin)
		      d = fpmin;
		    c = 1 + aa / c;
		    if (Math.abs(c) < fpmin)
		      c = fpmin;
		    d = 1 / d;
		    h *= d * c;
		    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
		    // Next step of the recurrence (the odd one)
		    d = 1 + aa * d;
		    if (Math.abs(d) < fpmin)
		      d = fpmin;
		    c = 1 + aa / c;
		    if (Math.abs(c) < fpmin)
		      c = fpmin;
		    d = 1 / d;
		    del = d * c;
		    h *= del;
		    if (Math.abs(del - 1.0) < 3e-7)
		      break;
		  }

		  return h;
		};


		// Returns the inverse of the lower regularized inomplete gamma function
		jStat.gammapinv = function gammapinv(p, a) {
		  var j = 0;
		  var a1 = a - 1;
		  var EPS = 1e-8;
		  var gln = jStat.gammaln(a);
		  var x, err, t, u, pp, lna1, afac;

		  if (p >= 1)
		    return Math.max(100, a + 100 * Math.sqrt(a));
		  if (p <= 0)
		    return 0;
		  if (a > 1) {
		    lna1 = Math.log(a1);
		    afac = Math.exp(a1 * (lna1 - 1) - gln);
		    pp = (p < 0.5) ? p : 1 - p;
		    t = Math.sqrt(-2 * Math.log(pp));
		    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
		    if (p < 0.5)
		      x = -x;
		    x = Math.max(1e-3,
		                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
		  } else {
		    t = 1 - a * (0.253 + a * 0.12);
		    if (p < t)
		      x = Math.pow(p / t, 1 / a);
		    else
		      x = 1 - Math.log(1 - (p - t) / (1 - t));
		  }

		  for(; j < 12; j++) {
		    if (x <= 0)
		      return 0;
		    err = jStat.lowRegGamma(a, x) - p;
		    if (a > 1)
		      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
		    else
		      t = Math.exp(-x + a1 * Math.log(x) - gln);
		    u = err / t;
		    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
		    if (x <= 0)
		      x = 0.5 * (x + t);
		    if (Math.abs(t) < EPS * x)
		      break;
		  }

		  return x;
		};


		// Returns the error function erf(x)
		jStat.erf = function erf(x) {
		  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
		             -0.00956151478680863, -946595344482036e-18, 3.66839497852761e-4,
		             4.2523324806907e-5, -20278578112534e-18, -1624290004647e-18,
		             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
		             6.529054439e-9, 5.059343495e-9, -991364156e-18,
		             -227365122e-18, 9.6467911e-11, 2.394038e-12,
		             -6886027e-18, 8.94487e-13, 3.13092e-13,
		             -112708e-18, 3.81e-16, 7.106e-15,
		             -1523e-18, -94e-18, 1.21e-16,
		             -28e-18];
		  var j = cof.length - 1;
		  var isneg = false;
		  var d = 0;
		  var dd = 0;
		  var t, ty, tmp, res;

		  if (x < 0) {
		    x = -x;
		    isneg = true;
		  }

		  t = 2 / (2 + x);
		  ty = 4 * t - 2;

		  for(; j > 0; j--) {
		    tmp = d;
		    d = ty * d - dd + cof[j];
		    dd = tmp;
		  }

		  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
		  return isneg ? res - 1 : 1 - res;
		};


		// Returns the complmentary error function erfc(x)
		jStat.erfc = function erfc(x) {
		  return 1 - jStat.erf(x);
		};


		// Returns the inverse of the complementary error function
		jStat.erfcinv = function erfcinv(p) {
		  var j = 0;
		  var x, err, t, pp;
		  if (p >= 2)
		    return -100;
		  if (p <= 0)
		    return 100;
		  pp = (p < 1) ? p : 2 - p;
		  t = Math.sqrt(-2 * Math.log(pp / 2));
		  x = -0.70711 * ((2.30753 + t * 0.27061) /
		                  (1 + t * (0.99229 + t * 0.04481)) - t);
		  for (; j < 2; j++) {
		    err = jStat.erfc(x) - pp;
		    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
		  }
		  return (p < 1) ? x : -x;
		};


		// Returns the inverse of the incomplete beta function
		jStat.ibetainv = function ibetainv(p, a, b) {
		  var EPS = 1e-8;
		  var a1 = a - 1;
		  var b1 = b - 1;
		  var j = 0;
		  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
		  if (p <= 0)
		    return 0;
		  if (p >= 1)
		    return 1;
		  if (a >= 1 && b >= 1) {
		    pp = (p < 0.5) ? p : 1 - p;
		    t = Math.sqrt(-2 * Math.log(pp));
		    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
		    if (p < 0.5)
		      x = -x;
		    al = (x * x - 3) / 6;
		    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
		    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
		        (al + 5 / 6 - 2 / (3 * h));
		    x = a / (a + b * Math.exp(2 * w));
		  } else {
		    lna = Math.log(a / (a + b));
		    lnb = Math.log(b / (a + b));
		    t = Math.exp(a * lna) / a;
		    u = Math.exp(b * lnb) / b;
		    w = t + u;
		    if (p < t / w)
		      x = Math.pow(a * w * p, 1 / a);
		    else
		      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
		  }
		  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
		  for(; j < 10; j++) {
		    if (x === 0 || x === 1)
		      return x;
		    err = jStat.ibeta(x, a, b) - p;
		    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
		    u = err / t;
		    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
		    if (x <= 0)
		      x = 0.5 * (x + t);
		    if (x >= 1)
		      x = 0.5 * (x + t + 1);
		    if (Math.abs(t) < EPS * x && j > 0)
		      break;
		  }
		  return x;
		};


		// Returns the incomplete beta function I_x(a,b)
		jStat.ibeta = function ibeta(x, a, b) {
		  // Factors in front of the continued fraction.
		  var bt = (x === 0 || x === 1) ?  0 :
		    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
		             jStat.gammaln(b) + a * Math.log(x) + b *
		             Math.log(1 - x));
		  if (x < 0 || x > 1)
		    return false;
		  if (x < (a + 1) / (a + b + 2))
		    // Use continued fraction directly.
		    return bt * jStat.betacf(x, a, b) / a;
		  // else use continued fraction after making the symmetry transformation.
		  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
		};


		// Returns a normal deviate (mu=0, sigma=1).
		// If n and m are specified it returns a object of normal deviates.
		jStat.randn = function randn(n, m) {
		  var u, v, x, y, q;
		  if (!m)
		    m = n;
		  if (n)
		    return jStat.create(n, m, function() { return jStat.randn(); });
		  do {
		    u = jStat._random_fn();
		    v = 1.7156 * (jStat._random_fn() - 0.5);
		    x = u - 0.449871;
		    y = Math.abs(v) + 0.386595;
		    q = x * x + y * (0.19600 * y - 0.25472 * x);
		  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
		  return v / u;
		};


		// Returns a gamma deviate by the method of Marsaglia and Tsang.
		jStat.randg = function randg(shape, n, m) {
		  var oalph = shape;
		  var a1, a2, u, v, x, mat;
		  if (!m)
		    m = n;
		  if (!shape)
		    shape = 1;
		  if (n) {
		    mat = jStat.zeros(n,m);
		    mat.alter(function() { return jStat.randg(shape); });
		    return mat;
		  }
		  if (shape < 1)
		    shape += 1;
		  a1 = shape - 1 / 3;
		  a2 = 1 / Math.sqrt(9 * a1);
		  do {
		    do {
		      x = jStat.randn();
		      v = 1 + a2 * x;
		    } while(v <= 0);
		    v = v * v * v;
		    u = jStat._random_fn();
		  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
		          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
		  // alpha > 1
		  if (shape == oalph)
		    return a1 * v;
		  // alpha < 1
		  do {
		    u = jStat._random_fn();
		  } while(u === 0);
		  return Math.pow(u, 1 / oalph) * a1 * v;
		};


		// making use of static methods on the instance
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jStat.fn[passfunc] = function() {
		      return jStat(
		          jStat.map(this, function(value) { return jStat[passfunc](value); }));
		    };
		  })(funcs[i]);
		})('gammaln gammafn factorial factorialln'.split(' '));


		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jStat.fn[passfunc] = function() {
		      return jStat(jStat[passfunc].apply(null, arguments));
		    };
		  })(funcs[i]);
		})('randn'.split(' '));

		}(jStat, Math));
		(function(jStat, Math) {

		// generate all distribution instance methods
		(function(list) {
		  for (var i = 0; i < list.length; i++) (function(func) {
		    // distribution instance method
		    jStat[func] = function f(a, b, c) {
		      if (!(this instanceof f))
		        return new f(a, b, c);
		      this._a = a;
		      this._b = b;
		      this._c = c;
		      return this;
		    };
		    // distribution method to be used on a jStat instance
		    jStat.fn[func] = function(a, b, c) {
		      var newthis = jStat[func](a, b, c);
		      newthis.data = this;
		      return newthis;
		    };
		    // sample instance method
		    jStat[func].prototype.sample = function(arr) {
		      var a = this._a;
		      var b = this._b;
		      var c = this._c;
		      if (arr)
		        return jStat.alter(arr, function() {
		          return jStat[func].sample(a, b, c);
		        });
		      else
		        return jStat[func].sample(a, b, c);
		    };
		    // generate the pdf, cdf and inv instance methods
		    (function(vals) {
		      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
		        jStat[func].prototype[fnfunc] = function(x) {
		          var a = this._a;
		          var b = this._b;
		          var c = this._c;
		          if (!x && x !== 0)
		            x = this.data;
		          if (typeof x !== 'number') {
		            return jStat.fn.map.call(x, function(x) {
		              return jStat[func][fnfunc](x, a, b, c);
		            });
		          }
		          return jStat[func][fnfunc](x, a, b, c);
		        };
		      })(vals[i]);
		    })('pdf cdf inv'.split(' '));
		    // generate the mean, median, mode and variance instance methods
		    (function(vals) {
		      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
		        jStat[func].prototype[fnfunc] = function() {
		          return jStat[func][fnfunc](this._a, this._b, this._c);
		        };
		      })(vals[i]);
		    })('mean median mode variance'.split(' '));
		  })(list[i]);
		})((
		  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
		  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +
		  'binomial negbin hypgeom poisson triangular tukey arcsine'
		).split(' '));



		// extend beta function with static methods
		jStat.extend(jStat.beta, {
		  pdf: function pdf(x, alpha, beta) {
		    // PDF is zero outside the support
		    if (x > 1 || x < 0)
		      return 0;
		    // PDF is one for the uniform case
		    if (alpha == 1 && beta == 1)
		      return 1;

		    if (alpha < 512 && beta < 512) {
		      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
		          jStat.betafn(alpha, beta);
		    } else {
		      return Math.exp((alpha - 1) * Math.log(x) +
		                      (beta - 1) * Math.log(1 - x) -
		                      jStat.betaln(alpha, beta));
		    }
		  },

		  cdf: function cdf(x, alpha, beta) {
		    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
		  },

		  inv: function inv(x, alpha, beta) {
		    return jStat.ibetainv(x, alpha, beta);
		  },

		  mean: function mean(alpha, beta) {
		    return alpha / (alpha + beta);
		  },

		  median: function median(alpha, beta) {
		    return jStat.ibetainv(0.5, alpha, beta);
		  },

		  mode: function mode(alpha, beta) {
		    return (alpha - 1 ) / ( alpha + beta - 2);
		  },

		  // return a random sample
		  sample: function sample(alpha, beta) {
		    var u = jStat.randg(alpha);
		    return u / (u + jStat.randg(beta));
		  },

		  variance: function variance(alpha, beta) {
		    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
		  }
		});

		// extend F function with static methods
		jStat.extend(jStat.centralF, {
		  // This implementation of the pdf function avoids float overflow
		  // See the way that R calculates this value:
		  // https://svn.r-project.org/R/trunk/src/nmath/df.c
		  pdf: function pdf(x, df1, df2) {
		    var p, q, f;

		    if (x < 0)
		      return 0;

		    if (df1 <= 2) {
		      if (x === 0 && df1 < 2) {
		        return Infinity;
		      }
		      if (x === 0 && df1 === 2) {
		        return 1;
		      }
		      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *
		              Math.pow(df1 / df2, df1 / 2) *
		              Math.pow(x, (df1/2) - 1) *
		              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);
		    }

		    p = (df1 * x) / (df2 + x * df1);
		    q = df2 / (df2 + x * df1);
		    f = df1 * q / 2.0;
		    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
		  },

		  cdf: function cdf(x, df1, df2) {
		    if (x < 0)
		      return 0;
		    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
		  },

		  inv: function inv(x, df1, df2) {
		    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
		  },

		  mean: function mean(df1, df2) {
		    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
		  },

		  mode: function mode(df1, df2) {
		    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
		  },

		  // return a random sample
		  sample: function sample(df1, df2) {
		    var x1 = jStat.randg(df1 / 2) * 2;
		    var x2 = jStat.randg(df2 / 2) * 2;
		    return (x1 / df1) / (x2 / df2);
		  },

		  variance: function variance(df1, df2) {
		    if (df2 <= 4)
		      return undefined;
		    return 2 * df2 * df2 * (df1 + df2 - 2) /
		        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
		  }
		});


		// extend cauchy function with static methods
		jStat.extend(jStat.cauchy, {
		  pdf: function pdf(x, local, scale) {
		    if (scale < 0) { return 0; }

		    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
		  },

		  cdf: function cdf(x, local, scale) {
		    return Math.atan((x - local) / scale) / Math.PI + 0.5;
		  },

		  inv: function(p, local, scale) {
		    return local + scale * Math.tan(Math.PI * (p - 0.5));
		  },

		  median: function median(local/*, scale*/) {
		    return local;
		  },

		  mode: function mode(local/*, scale*/) {
		    return local;
		  },

		  sample: function sample(local, scale) {
		    return jStat.randn() *
		        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
		  }
		});



		// extend chisquare function with static methods
		jStat.extend(jStat.chisquare, {
		  pdf: function pdf(x, dof) {
		    if (x < 0)
		      return 0;
		    return (x === 0 && dof === 2) ? 0.5 :
		        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
		                 Math.log(2) - jStat.gammaln(dof / 2));
		  },

		  cdf: function cdf(x, dof) {
		    if (x < 0)
		      return 0;
		    return jStat.lowRegGamma(dof / 2, x / 2);
		  },

		  inv: function(p, dof) {
		    return 2 * jStat.gammapinv(p, 0.5 * dof);
		  },

		  mean : function(dof) {
		    return dof;
		  },

		  // TODO: this is an approximation (is there a better way?)
		  median: function median(dof) {
		    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
		  },

		  mode: function mode(dof) {
		    return (dof - 2 > 0) ? dof - 2 : 0;
		  },

		  sample: function sample(dof) {
		    return jStat.randg(dof / 2) * 2;
		  },

		  variance: function variance(dof) {
		    return 2 * dof;
		  }
		});



		// extend exponential function with static methods
		jStat.extend(jStat.exponential, {
		  pdf: function pdf(x, rate) {
		    return x < 0 ? 0 : rate * Math.exp(-rate * x);
		  },

		  cdf: function cdf(x, rate) {
		    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
		  },

		  inv: function(p, rate) {
		    return -Math.log(1 - p) / rate;
		  },

		  mean : function(rate) {
		    return 1 / rate;
		  },

		  median: function (rate) {
		    return (1 / rate) * Math.log(2);
		  },

		  mode: function mode(/*rate*/) {
		    return 0;
		  },

		  sample: function sample(rate) {
		    return -1 / rate * Math.log(jStat._random_fn());
		  },

		  variance : function(rate) {
		    return Math.pow(rate, -2);
		  }
		});



		// extend gamma function with static methods
		jStat.extend(jStat.gamma, {
		  pdf: function pdf(x, shape, scale) {
		    if (x < 0)
		      return 0;
		    return (x === 0 && shape === 1) ? 1 / scale :
		            Math.exp((shape - 1) * Math.log(x) - x / scale -
		                    jStat.gammaln(shape) - shape * Math.log(scale));
		  },

		  cdf: function cdf(x, shape, scale) {
		    if (x < 0)
		      return 0;
		    return jStat.lowRegGamma(shape, x / scale);
		  },

		  inv: function(p, shape, scale) {
		    return jStat.gammapinv(p, shape) * scale;
		  },

		  mean : function(shape, scale) {
		    return shape * scale;
		  },

		  mode: function mode(shape, scale) {
		    if(shape > 1) return (shape - 1) * scale;
		    return undefined;
		  },

		  sample: function sample(shape, scale) {
		    return jStat.randg(shape) * scale;
		  },

		  variance: function variance(shape, scale) {
		    return shape * scale * scale;
		  }
		});

		// extend inverse gamma function with static methods
		jStat.extend(jStat.invgamma, {
		  pdf: function pdf(x, shape, scale) {
		    if (x <= 0)
		      return 0;
		    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
		                    jStat.gammaln(shape) + shape * Math.log(scale));
		  },

		  cdf: function cdf(x, shape, scale) {
		    if (x <= 0)
		      return 0;
		    return 1 - jStat.lowRegGamma(shape, scale / x);
		  },

		  inv: function(p, shape, scale) {
		    return scale / jStat.gammapinv(1 - p, shape);
		  },

		  mean : function(shape, scale) {
		    return (shape > 1) ? scale / (shape - 1) : undefined;
		  },

		  mode: function mode(shape, scale) {
		    return scale / (shape + 1);
		  },

		  sample: function sample(shape, scale) {
		    return scale / jStat.randg(shape);
		  },

		  variance: function variance(shape, scale) {
		    if (shape <= 2)
		      return undefined;
		    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
		  }
		});


		// extend kumaraswamy function with static methods
		jStat.extend(jStat.kumaraswamy, {
		  pdf: function pdf(x, alpha, beta) {
		    if (x === 0 && alpha === 1)
		      return beta;
		    else if (x === 1 && beta === 1)
		      return alpha;
		    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
		                    Math.log(x) + (beta - 1) *
		                    Math.log(1 - Math.pow(x, alpha)));
		  },

		  cdf: function cdf(x, alpha, beta) {
		    if (x < 0)
		      return 0;
		    else if (x > 1)
		      return 1;
		    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
		  },

		  inv: function inv(p, alpha, beta) {
		    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);
		  },

		  mean : function(alpha, beta) {
		    return (beta * jStat.gammafn(1 + 1 / alpha) *
		            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
		  },

		  median: function median(alpha, beta) {
		    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
		  },

		  mode: function mode(alpha, beta) {
		    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
		      return undefined;
		    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
		  },

		  variance: function variance(/*alpha, beta*/) {
		    throw new Error('variance not yet implemented');
		    // TODO: complete this
		  }
		});



		// extend lognormal function with static methods
		jStat.extend(jStat.lognormal, {
		  pdf: function pdf(x, mu, sigma) {
		    if (x <= 0)
		      return 0;
		    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
		                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
		                    (2 * sigma * sigma));
		  },

		  cdf: function cdf(x, mu, sigma) {
		    if (x < 0)
		      return 0;
		    return 0.5 +
		        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
		  },

		  inv: function(p, mu, sigma) {
		    return Math.exp(-1.4142135623730951 * sigma * jStat.erfcinv(2 * p) + mu);
		  },

		  mean: function mean(mu, sigma) {
		    return Math.exp(mu + sigma * sigma / 2);
		  },

		  median: function median(mu/*, sigma*/) {
		    return Math.exp(mu);
		  },

		  mode: function mode(mu, sigma) {
		    return Math.exp(mu - sigma * sigma);
		  },

		  sample: function sample(mu, sigma) {
		    return Math.exp(jStat.randn() * sigma + mu);
		  },

		  variance: function variance(mu, sigma) {
		    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
		  }
		});



		// extend noncentralt function with static methods
		jStat.extend(jStat.noncentralt, {
		  pdf: function pdf(x, dof, ncp) {
		    var tol = 1e-14;
		    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
		      return jStat.studentt.pdf(x, dof)

		    if (Math.abs(x) < tol) {  // different formula for x == 0
		      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -
		                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));
		    }

		    // formula for x != 0
		    return dof / x *
		        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -
		         jStat.noncentralt.cdf(x, dof, ncp));
		  },

		  cdf: function cdf(x, dof, ncp) {
		    var tol = 1e-14;
		    var min_iterations = 200;

		    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
		      return jStat.studentt.cdf(x, dof);

		    // turn negative x into positive and flip result afterwards
		    var flip = false;
		    if (x < 0) {
		      flip = true;
		      ncp = -ncp;
		    }

		    var prob = jStat.normal.cdf(-ncp, 0, 1);
		    var value = tol + 1;
		    // use value at last two steps to determine convergence
		    var lastvalue = value;
		    var y = x * x / (x * x + dof);
		    var j = 0;
		    var p = Math.exp(-ncp * ncp / 2);
		    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -
		                     jStat.gammaln(3 / 2)) * ncp;
		    while (j < min_iterations || lastvalue > tol || value > tol) {
		      lastvalue = value;
		      if (j > 0) {
		        p *= (ncp * ncp) / (2 * j);
		        q *= (ncp * ncp) / (2 * (j + 1 / 2));
		      }
		      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +
		          q * jStat.beta.cdf(y, j+1, dof/2);
		      prob += 0.5 * value;
		      j++;
		    }

		    return flip ? (1 - prob) : prob;
		  }
		});


		// extend normal function with static methods
		jStat.extend(jStat.normal, {
		  pdf: function pdf(x, mean, std) {
		    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
		                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
		  },

		  cdf: function cdf(x, mean, std) {
		    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
		  },

		  inv: function(p, mean, std) {
		    return -1.4142135623730951 * std * jStat.erfcinv(2 * p) + mean;
		  },

		  mean : function(mean/*, std*/) {
		    return mean;
		  },

		  median: function median(mean/*, std*/) {
		    return mean;
		  },

		  mode: function (mean/*, std*/) {
		    return mean;
		  },

		  sample: function sample(mean, std) {
		    return jStat.randn() * std + mean;
		  },

		  variance : function(mean, std) {
		    return std * std;
		  }
		});



		// extend pareto function with static methods
		jStat.extend(jStat.pareto, {
		  pdf: function pdf(x, scale, shape) {
		    if (x < scale)
		      return 0;
		    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
		  },

		  cdf: function cdf(x, scale, shape) {
		    if (x < scale)
		      return 0;
		    return 1 - Math.pow(scale / x, shape);
		  },

		  inv: function inv(p, scale, shape) {
		    return scale / Math.pow(1 - p, 1 / shape);
		  },

		  mean: function mean(scale, shape) {
		    if (shape <= 1)
		      return undefined;
		    return (shape * Math.pow(scale, shape)) / (shape - 1);
		  },

		  median: function median(scale, shape) {
		    return scale * (shape * Math.SQRT2);
		  },

		  mode: function mode(scale/*, shape*/) {
		    return scale;
		  },

		  variance : function(scale, shape) {
		    if (shape <= 2)
		      return undefined;
		    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
		  }
		});



		// extend studentt function with static methods
		jStat.extend(jStat.studentt, {
		  pdf: function pdf(x, dof) {
		    dof = dof > 1e100 ? 1e100 : dof;
		    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *
		        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
		  },

		  cdf: function cdf(x, dof) {
		    var dof2 = dof / 2;
		    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
		                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
		  },

		  inv: function(p, dof) {
		    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
		    x = Math.sqrt(dof * (1 - x) / x);
		    return (p > 0.5) ? x : -x;
		  },

		  mean: function mean(dof) {
		    return (dof > 1) ? 0 : undefined;
		  },

		  median: function median(/*dof*/) {
		    return 0;
		  },

		  mode: function mode(/*dof*/) {
		    return 0;
		  },

		  sample: function sample(dof) {
		    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
		  },

		  variance: function variance(dof) {
		    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
		  }
		});



		// extend weibull function with static methods
		jStat.extend(jStat.weibull, {
		  pdf: function pdf(x, scale, shape) {
		    if (x < 0 || scale < 0 || shape < 0)
		      return 0;
		    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
		        Math.exp(-(Math.pow((x / scale), shape)));
		  },

		  cdf: function cdf(x, scale, shape) {
		    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
		  },

		  inv: function(p, scale, shape) {
		    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
		  },

		  mean : function(scale, shape) {
		    return scale * jStat.gammafn(1 + 1 / shape);
		  },

		  median: function median(scale, shape) {
		    return scale * Math.pow(Math.log(2), 1 / shape);
		  },

		  mode: function mode(scale, shape) {
		    if (shape <= 1)
		      return 0;
		    return scale * Math.pow((shape - 1) / shape, 1 / shape);
		  },

		  sample: function sample(scale, shape) {
		    return scale * Math.pow(-Math.log(jStat._random_fn()), 1 / shape);
		  },

		  variance: function variance(scale, shape) {
		    return scale * scale * jStat.gammafn(1 + 2 / shape) -
		        Math.pow(jStat.weibull.mean(scale, shape), 2);
		  }
		});



		// extend uniform function with static methods
		jStat.extend(jStat.uniform, {
		  pdf: function pdf(x, a, b) {
		    return (x < a || x > b) ? 0 : 1 / (b - a);
		  },

		  cdf: function cdf(x, a, b) {
		    if (x < a)
		      return 0;
		    else if (x < b)
		      return (x - a) / (b - a);
		    return 1;
		  },

		  inv: function(p, a, b) {
		    return a + (p * (b - a));
		  },

		  mean: function mean(a, b) {
		    return 0.5 * (a + b);
		  },

		  median: function median(a, b) {
		    return jStat.mean(a, b);
		  },

		  mode: function mode(/*a, b*/) {
		    throw new Error('mode is not yet implemented');
		  },

		  sample: function sample(a, b) {
		    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * jStat._random_fn() - 1);
		  },

		  variance: function variance(a, b) {
		    return Math.pow(b - a, 2) / 12;
		  }
		});


		// Got this from http://www.math.ucla.edu/~tom/distributions/binomial.html
		function betinc(x, a, b, eps) {
		  var a0 = 0;
		  var b0 = 1;
		  var a1 = 1;
		  var b1 = 1;
		  var m9 = 0;
		  var a2 = 0;
		  var c9;

		  while (Math.abs((a1 - a2) / a1) > eps) {
		    a2 = a1;
		    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
		    a0 = a1 + c9 * a0;
		    b0 = b1 + c9 * b0;
		    m9 = m9 + 1;
		    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
		    a1 = a0 + c9 * a1;
		    b1 = b0 + c9 * b1;
		    a0 = a0 / b1;
		    b0 = b0 / b1;
		    a1 = a1 / b1;
		    b1 = 1;
		  }

		  return a1 / a;
		}


		// extend uniform function with static methods
		jStat.extend(jStat.binomial, {
		  pdf: function pdf(k, n, p) {
		    return (p === 0 || p === 1) ?
		      ((n * p) === k ? 1 : 0) :
		      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
		  },

		  cdf: function cdf(x, n, p) {
		    var betacdf;
		    var eps = 1e-10;

		    if (x < 0)
		      return 0;
		    if (x >= n)
		      return 1;
		    if (p < 0 || p > 1 || n <= 0)
		      return NaN;

		    x = Math.floor(x);
		    var z = p;
		    var a = x + 1;
		    var b = n - x;
		    var s = a + b;
		    var bt = Math.exp(jStat.gammaln(s) - jStat.gammaln(b) -
		                      jStat.gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));

		    if (z < (a + 1) / (s + 2))
		      betacdf = bt * betinc(z, a, b, eps);
		    else
		      betacdf = 1 - bt * betinc(1 - z, b, a, eps);

		    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);
		  }
		});



		// extend uniform function with static methods
		jStat.extend(jStat.negbin, {
		  pdf: function pdf(k, r, p) {
		    if (k !== k >>> 0)
		      return false;
		    if (k < 0)
		      return 0;
		    return jStat.combination(k + r - 1, r - 1) *
		        Math.pow(1 - p, k) * Math.pow(p, r);
		  },

		  cdf: function cdf(x, r, p) {
		    var sum = 0,
		    k = 0;
		    if (x < 0) return 0;
		    for (; k <= x; k++) {
		      sum += jStat.negbin.pdf(k, r, p);
		    }
		    return sum;
		  }
		});



		// extend uniform function with static methods
		jStat.extend(jStat.hypgeom, {
		  pdf: function pdf(k, N, m, n) {
		    // Hypergeometric PDF.

		    // A simplification of the CDF algorithm below.

		    // k = number of successes drawn
		    // N = population size
		    // m = number of successes in population
		    // n = number of items drawn from population

		    if(k !== k | 0) {
		      return false;
		    } else if(k < 0 || k < m - (N - n)) {
		      // It's impossible to have this few successes drawn.
		      return 0;
		    } else if(k > n || k > m) {
		      // It's impossible to have this many successes drawn.
		      return 0;
		    } else if (m * 2 > N) {
		      // More than half the population is successes.

		      if(n * 2 > N) {
		        // More than half the population is sampled.

		        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
		      } else {
		        // Half or less of the population is sampled.

		        return jStat.hypgeom.pdf(n - k, N, N - m, n);
		      }

		    } else if(n * 2 > N) {
		      // Half or less is successes.

		      return jStat.hypgeom.pdf(m - k, N, m, N - n);

		    } else if(m < n) {
		      // We want to have the number of things sampled to be less than the
		      // successes available. So swap the definitions of successful and sampled.
		      return jStat.hypgeom.pdf(k, N, n, m);
		    } else {
		      // If we get here, half or less of the population was sampled, half or
		      // less of it was successes, and we had fewer sampled things than
		      // successes. Now we can do this complicated iterative algorithm in an
		      // efficient way.

		      // The basic premise of the algorithm is that we partially normalize our
		      // intermediate product to keep it in a numerically good region, and then
		      // finish the normalization at the end.

		      // This variable holds the scaled probability of the current number of
		      // successes.
		      var scaledPDF = 1;

		      // This keeps track of how much we have normalized.
		      var samplesDone = 0;

		      for(var i = 0; i < k; i++) {
		        // For every possible number of successes up to that observed...

		        while(scaledPDF > 1 && samplesDone < n) {
		          // Intermediate result is growing too big. Apply some of the
		          // normalization to shrink everything.

		          scaledPDF *= 1 - (m / (N - samplesDone));

		          // Say we've normalized by this sample already.
		          samplesDone++;
		        }

		        // Work out the partially-normalized hypergeometric PDF for the next
		        // number of successes
		        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
		      }

		      for(; samplesDone < n; samplesDone++) {
		        // Apply all the rest of the normalization
		        scaledPDF *= 1 - (m / (N - samplesDone));
		      }

		      // Bound answer sanely before returning.
		      return Math.min(1, Math.max(0, scaledPDF));
		    }
		  },

		  cdf: function cdf(x, N, m, n) {
		    // Hypergeometric CDF.

		    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
		    // and comes from his hypergeometric test calculator at
		    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

		    // x = number of successes drawn
		    // N = population size
		    // m = number of successes in population
		    // n = number of items drawn from population

		    if(x < 0 || x < m - (N - n)) {
		      // It's impossible to have this few successes drawn or fewer.
		      return 0;
		    } else if(x >= n || x >= m) {
		      // We will always have this many successes or fewer.
		      return 1;
		    } else if (m * 2 > N) {
		      // More than half the population is successes.

		      if(n * 2 > N) {
		        // More than half the population is sampled.

		        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
		      } else {
		        // Half or less of the population is sampled.

		        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
		      }

		    } else if(n * 2 > N) {
		      // Half or less is successes.

		      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

		    } else if(m < n) {
		      // We want to have the number of things sampled to be less than the
		      // successes available. So swap the definitions of successful and sampled.
		      return jStat.hypgeom.cdf(x, N, n, m);
		    } else {
		      // If we get here, half or less of the population was sampled, half or
		      // less of it was successes, and we had fewer sampled things than
		      // successes. Now we can do this complicated iterative algorithm in an
		      // efficient way.

		      // The basic premise of the algorithm is that we partially normalize our
		      // intermediate sum to keep it in a numerically good region, and then
		      // finish the normalization at the end.

		      // Holds the intermediate, scaled total CDF.
		      var scaledCDF = 1;

		      // This variable holds the scaled probability of the current number of
		      // successes.
		      var scaledPDF = 1;

		      // This keeps track of how much we have normalized.
		      var samplesDone = 0;

		      for(var i = 0; i < x; i++) {
		        // For every possible number of successes up to that observed...

		        while(scaledCDF > 1 && samplesDone < n) {
		          // Intermediate result is growing too big. Apply some of the
		          // normalization to shrink everything.

		          var factor = 1 - (m / (N - samplesDone));

		          scaledPDF *= factor;
		          scaledCDF *= factor;

		          // Say we've normalized by this sample already.
		          samplesDone++;
		        }

		        // Work out the partially-normalized hypergeometric PDF for the next
		        // number of successes
		        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

		        // Add to the CDF answer.
		        scaledCDF += scaledPDF;
		      }

		      for(; samplesDone < n; samplesDone++) {
		        // Apply all the rest of the normalization
		        scaledCDF *= 1 - (m / (N - samplesDone));
		      }

		      // Bound answer sanely before returning.
		      return Math.min(1, Math.max(0, scaledCDF));
		    }
		  }
		});



		// extend uniform function with static methods
		jStat.extend(jStat.poisson, {
		  pdf: function pdf(k, l) {
		    if (l < 0 || (k % 1) !== 0 || k < 0) {
		      return 0;
		    }

		    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
		  },

		  cdf: function cdf(x, l) {
		    var sumarr = [],
		    k = 0;
		    if (x < 0) return 0;
		    for (; k <= x; k++) {
		      sumarr.push(jStat.poisson.pdf(k, l));
		    }
		    return jStat.sum(sumarr);
		  },

		  mean : function(l) {
		    return l;
		  },

		  variance : function(l) {
		    return l;
		  },

		  sampleSmall: function sampleSmall(l) {
		    var p = 1, k = 0, L = Math.exp(-l);
		    do {
		      k++;
		      p *= jStat._random_fn();
		    } while (p > L);
		    return k - 1;
		  },

		  sampleLarge: function sampleLarge(l) {
		    var lam = l;
		    var k;
		    var U, V, slam, loglam, a, b, invalpha, vr, us;

		    slam = Math.sqrt(lam);
		    loglam = Math.log(lam);
		    b = 0.931 + 2.53 * slam;
		    a = -0.059 + 0.02483 * b;
		    invalpha = 1.1239 + 1.1328 / (b - 3.4);
		    vr = 0.9277 - 3.6224 / (b - 2);

		    while (1) {
		      U = Math.random() - 0.5;
		      V = Math.random();
		      us = 0.5 - Math.abs(U);
		      k = Math.floor((2 * a / us + b) * U + lam + 0.43);
		      if ((us >= 0.07) && (V <= vr)) {
		          return k;
		      }
		      if ((k < 0) || ((us < 0.013) && (V > us))) {
		          continue;
		      }
		      /* log(V) == log(0.0) ok here */
		      /* if U==0.0 so that us==0.0, log is ok since always returns */
		      if ((Math.log(V) + Math.log(invalpha) - Math.log(a / (us * us) + b)) <= (-lam + k * loglam - jStat.loggam(k + 1))) {
		          return k;
		      }
		    }
		  },

		  sample: function sample(l) {
		    if (l < 10)
		      return this.sampleSmall(l);
		    else
		      return this.sampleLarge(l);
		  }
		});

		// extend triangular function with static methods
		jStat.extend(jStat.triangular, {
		  pdf: function pdf(x, a, b, c) {
		    if (b <= a || c < a || c > b) {
		      return NaN;
		    } else {
		      if (x < a || x > b) {
		        return 0;
		      } else if (x < c) {
		          return (2 * (x - a)) / ((b - a) * (c - a));
		      } else if (x === c) {
		          return (2 / (b - a));
		      } else { // x > c
		          return (2 * (b - x)) / ((b - a) * (b - c));
		      }
		    }
		  },

		  cdf: function cdf(x, a, b, c) {
		    if (b <= a || c < a || c > b)
		      return NaN;
		    if (x <= a)
		      return 0;
		    else if (x >= b)
		      return 1;
		    if (x <= c)
		      return Math.pow(x - a, 2) / ((b - a) * (c - a));
		    else // x > c
		      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
		  },

		  inv: function inv(p, a, b, c) {
		    if (b <= a || c < a || c > b) {
		      return NaN;
		    } else {
		      if (p <= ((c - a) / (b - a))) {
		        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));
		      } else { // p > ((c - a) / (b - a))
		        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));
		      }
		    }
		  },

		  mean: function mean(a, b, c) {
		    return (a + b + c) / 3;
		  },

		  median: function median(a, b, c) {
		    if (c <= (a + b) / 2) {
		      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
		    } else if (c > (a + b) / 2) {
		      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
		    }
		  },

		  mode: function mode(a, b, c) {
		    return c;
		  },

		  sample: function sample(a, b, c) {
		    var u = jStat._random_fn();
		    if (u < ((c - a) / (b - a)))
		      return a + Math.sqrt(u * (b - a) * (c - a))
		    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
		  },

		  variance: function variance(a, b, c) {
		    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
		  }
		});


		// extend arcsine function with static methods
		jStat.extend(jStat.arcsine, {
		  pdf: function pdf(x, a, b) {
		    if (b <= a) return NaN;

		    return (x <= a || x >= b) ? 0 :
		      (2 / Math.PI) *
		        Math.pow(Math.pow(b - a, 2) -
		                  Math.pow(2 * x - a - b, 2), -0.5);
		  },

		  cdf: function cdf(x, a, b) {
		    if (x < a)
		      return 0;
		    else if (x < b)
		      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));
		    return 1;
		  },

		  inv: function(p, a, b) {
		    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);
		  },

		  mean: function mean(a, b) {
		    if (b <= a) return NaN;
		    return (a + b) / 2;
		  },

		  median: function median(a, b) {
		    if (b <= a) return NaN;
		    return (a + b) / 2;
		  },

		  mode: function mode(/*a, b*/) {
		    throw new Error('mode is not yet implemented');
		  },

		  sample: function sample(a, b) {
		    return ((a + b) / 2) + ((b - a) / 2) *
		      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));
		  },

		  variance: function variance(a, b) {
		    if (b <= a) return NaN;
		    return Math.pow(b - a, 2) / 8;
		  }
		});


		function laplaceSign(x) { return x / Math.abs(x); }

		jStat.extend(jStat.laplace, {
		  pdf: function pdf(x, mu, b) {
		    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);
		  },

		  cdf: function cdf(x, mu, b) {
		    if (b <= 0) { return 0; }

		    if(x < mu) {
		      return 0.5 * Math.exp((x - mu) / b);
		    } else {
		      return 1 - 0.5 * Math.exp(- (x - mu) / b);
		    }
		  },

		  mean: function(mu/*, b*/) {
		    return mu;
		  },

		  median: function(mu/*, b*/) {
		    return mu;
		  },

		  mode: function(mu/*, b*/) {
		    return mu;
		  },

		  variance: function(mu, b) {
		    return 2 * b * b;
		  },

		  sample: function sample(mu, b) {
		    var u = jStat._random_fn() - 0.5;

		    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));
		  }
		});

		function tukeyWprob(w, rr, cc) {
		  var nleg = 12;
		  var ihalf = 6;

		  var C1 = -30;
		  var C2 = -50;
		  var C3 = 60;
		  var bb   = 8;
		  var wlar = 3;
		  var wincr1 = 2;
		  var wincr2 = 3;
		  var xleg = [
		    0.981560634246719250690549090149,
		    0.904117256370474856678465866119,
		    0.769902674194304687036893833213,
		    0.587317954286617447296702418941,
		    0.367831498998180193752691536644,
		    0.125233408511468915472441369464
		  ];
		  var aleg = [
		    0.047175336386511827194615961485,
		    0.106939325995318430960254718194,
		    0.160078328543346226334652529543,
		    0.203167426723065921749064455810,
		    0.233492536538354808760849898925,
		    0.249147045813402785000562436043
		  ];

		  var qsqz = w * 0.5;

		  // if w >= 16 then the integral lower bound (occurs for c=20)
		  // is 0.99999999999995 so return a value of 1.

		  if (qsqz >= bb)
		    return 1.0;

		  // find (f(w/2) - 1) ^ cc
		  // (first term in integral of hartley's form).

		  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)
		  // if pr_w ^ cc < 2e-22 then set pr_w = 0
		  if (pr_w >= Math.exp(C2 / cc))
		    pr_w = Math.pow(pr_w, cc);
		  else
		    pr_w = 0.0;

		  // if w is large then the second component of the
		  // integral is small, so fewer intervals are needed.

		  var wincr;
		  if (w > wlar)
		    wincr = wincr1;
		  else
		    wincr = wincr2;

		  // find the integral of second term of hartley's form
		  // for the integral of the range for equal-length
		  // intervals using legendre quadrature.  limits of
		  // integration are from (w/2, 8).  two or three
		  // equal-length intervals are used.

		  // blb and bub are lower and upper limits of integration.

		  var blb = qsqz;
		  var binc = (bb - qsqz) / wincr;
		  var bub = blb + binc;
		  var einsum = 0.0;

		  // integrate over each interval

		  var cc1 = cc - 1.0;
		  for (var wi = 1; wi <= wincr; wi++) {
		    var elsum = 0.0;
		    var a = 0.5 * (bub + blb);

		    // legendre quadrature with order = nleg

		    var b = 0.5 * (bub - blb);

		    for (var jj = 1; jj <= nleg; jj++) {
		      var j, xx;
		      if (ihalf < jj) {
		        j = (nleg - jj) + 1;
		        xx = xleg[j-1];
		      } else {
		        j = jj;
		        xx = -xleg[j-1];
		      }
		      var c = b * xx;
		      var ac = a + c;

		      // if exp(-qexpo/2) < 9e-14,
		      // then doesn't contribute to integral

		      var qexpo = ac * ac;
		      if (qexpo > C3)
		        break;

		      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);
		      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);

		      // if rinsum ^ (cc-1) < 9e-14,
		      // then doesn't contribute to integral

		      var rinsum = (pplus * 0.5) - (pminus * 0.5);
		      if (rinsum >= Math.exp(C1 / cc1)) {
		        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);
		        elsum += rinsum;
		      }
		    }
		    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));
		    einsum += elsum;
		    blb = bub;
		    bub += binc;
		  }

		  // if pr_w ^ rr < 9e-14, then return 0
		  pr_w += einsum;
		  if (pr_w <= Math.exp(C1 / rr))
		    return 0;

		  pr_w = Math.pow(pr_w, rr);
		  if (pr_w >= 1) // 1 was iMax was eps
		    return 1;
		  return pr_w;
		}

		function tukeyQinv(p, c, v) {
		  var p0 = 0.322232421088;
		  var q0 = 0.993484626060e-01;
		  var p1 = -1;
		  var q1 = 0.588581570495;
		  var p2 = -0.342242088547;
		  var q2 = 0.531103462366;
		  var p3 = -0.204231210125;
		  var q3 = 0.103537752850;
		  var p4 = -453642210148e-16;
		  var q4 = 0.38560700634e-02;
		  var c1 = 0.8832;
		  var c2 = 0.2368;
		  var c4 = 1.208;
		  var c5 = 1.4142;
		  var vmax = 120.0;

		  var ps = 0.5 - 0.5 * p;
		  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));
		  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)
		     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
		  if (v < vmax) t += (t * t * t + t) / v / 4.0;
		  var q = c1 - c2 * t;
		  if (v < vmax) q += -1.214 / v + c4 * t / v;
		  return t * (q * Math.log(c - 1.0) + c5);
		}

		jStat.extend(jStat.tukey, {
		  cdf: function cdf(q, nmeans, df) {
		    // Identical implementation as the R ptukey() function as of commit 68947
		    var rr = 1;
		    var cc = nmeans;

		    var nlegq = 16;
		    var ihalfq = 8;

		    var eps1 = -30;
		    var eps2 = 1.0e-14;
		    var dhaf  = 100.0;
		    var dquar = 800.0;
		    var deigh = 5000.0;
		    var dlarg = 25000.0;
		    var ulen1 = 1.0;
		    var ulen2 = 0.5;
		    var ulen3 = 0.25;
		    var ulen4 = 0.125;
		    var xlegq = [
		      0.989400934991649932596154173450,
		      0.944575023073232576077988415535,
		      0.865631202387831743880467897712,
		      0.755404408355003033895101194847,
		      0.617876244402643748446671764049,
		      0.458016777657227386342419442984,
		      0.281603550779258913230460501460,
		      0.950125098376374401853193354250e-1
		    ];
		    var alegq = [
		      0.271524594117540948517805724560e-1,
		      0.622535239386478928628438369944e-1,
		      0.951585116824927848099251076022e-1,
		      0.124628971255533872052476282192,
		      0.149595988816576732081501730547,
		      0.169156519395002538189312079030,
		      0.182603415044923588866763667969,
		      0.189450610455068496285396723208
		    ];

		    if (q <= 0)
		      return 0;

		    // df must be > 1
		    // there must be at least two values

		    if (df < 2 || rr < 1 || cc < 2) return NaN;

		    if (!Number.isFinite(q))
		      return 1;

		    if (df > dlarg)
		      return tukeyWprob(q, rr, cc);

		    // calculate leading constant

		    var f2 = df * 0.5;
		    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);
		    var f21 = f2 - 1.0;

		    // integral is divided into unit, half-unit, quarter-unit, or
		    // eighth-unit length intervals depending on the value of the
		    // degrees of freedom.

		    var ff4 = df * 0.25;
		    var ulen;
		    if      (df <= dhaf)  ulen = ulen1;
		    else if (df <= dquar) ulen = ulen2;
		    else if (df <= deigh) ulen = ulen3;
		    else                  ulen = ulen4;

		    f2lf += Math.log(ulen);

		    // integrate over each subinterval

		    var ans = 0.0;

		    for (var i = 1; i <= 50; i++) {
		      var otsum = 0.0;

		      // legendre quadrature with order = nlegq
		      // nodes (stored in xlegq) are symmetric around zero.

		      var twa1 = (2 * i - 1) * ulen;

		      for (var jj = 1; jj <= nlegq; jj++) {
		        var j, t1;
		        if (ihalfq < jj) {
		          j = jj - ihalfq - 1;
		          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))
		              - (((xlegq[j] * ulen) + twa1) * ff4);
		        } else {
		          j = jj - 1;
		          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))
		              + (((xlegq[j] * ulen) - twa1) * ff4);
		        }

		        // if exp(t1) < 9e-14, then doesn't contribute to integral
		        var qsqz;
		        if (t1 >= eps1) {
		          if (ihalfq < jj) {
		            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);
		          } else {
		            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);
		          }

		          // call wprob to find integral of range portion

		          var wprb = tukeyWprob(qsqz, rr, cc);
		          var rotsum = (wprb * alegq[j]) * Math.exp(t1);
		          otsum += rotsum;
		        }
		        // end legendre integral for interval i
		        // L200:
		      }

		      // if integral for interval i < 1e-14, then stop.
		      // However, in order to avoid small area under left tail,
		      // at least  1 / ulen  intervals are calculated.
		      if (i * ulen >= 1.0 && otsum <= eps2)
		        break;

		      // end of interval i
		      // L330:

		      ans += otsum;
		    }

		    if (otsum > eps2) { // not converged
		      throw new Error('tukey.cdf failed to converge');
		    }
		    if (ans > 1)
		      ans = 1;
		    return ans;
		  },

		  inv: function(p, nmeans, df) {
		    // Identical implementation as the R qtukey() function as of commit 68947
		    var rr = 1;
		    var cc = nmeans;

		    var eps = 0.0001;
		    var maxiter = 50;

		    // df must be > 1 ; there must be at least two values
		    if (df < 2 || rr < 1 || cc < 2) return NaN;

		    if (p < 0 || p > 1) return NaN;
		    if (p === 0) return 0;
		    if (p === 1) return Infinity;

		    // Initial value

		    var x0 = tukeyQinv(p, cc, df);

		    // Find prob(value < x0)

		    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;

		    // Find the second iterate and prob(value < x1).
		    // If the first iterate has probability value
		    // exceeding p then second iterate is 1 less than
		    // first iterate; otherwise it is 1 greater.

		    var x1;
		    if (valx0 > 0.0)
		      x1 = Math.max(0.0, x0 - 1.0);
		    else
		      x1 = x0 + 1.0;
		    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;

		    // Find new iterate

		    var ans;
		    for(var iter = 1; iter < maxiter; iter++) {
		      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));
		      valx0 = valx1;

		      // New iterate must be >= 0

		      x0 = x1;
		      if (ans < 0.0) {
		        ans = 0.0;
		        valx1 = -p;
		      }
		      // Find prob(value < new iterate)

		      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;
		      x1 = ans;

		      // If the difference between two successive
		      // iterates is less than eps, stop

		      var xabs = Math.abs(x1 - x0);
		      if (xabs < eps)
		        return ans;
		    }

		    throw new Error('tukey.inv failed to converge');
		  }
		});

		}(jStat, Math));
		/* Provides functions for the solution of linear system of equations, integration, extrapolation,
		 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

		(function(jStat, Math) {

		var push = Array.prototype.push;
		var isArray = jStat.utils.isArray;

		function isUsable(arg) {
		  return isArray(arg) || arg instanceof jStat;
		}

		jStat.extend({

		  // add a vector/matrix to a vector/matrix or scalar
		  add: function add(arr, arg) {
		    // check if arg is a vector or scalar
		    if (isUsable(arg)) {
		      if (!isUsable(arg[0])) arg = [ arg ];
		      return jStat.map(arr, function(value, row, col) {
		        return value + arg[row][col];
		      });
		    }
		    return jStat.map(arr, function(value) { return value + arg; });
		  },

		  // subtract a vector or scalar from the vector
		  subtract: function subtract(arr, arg) {
		    // check if arg is a vector or scalar
		    if (isUsable(arg)) {
		      if (!isUsable(arg[0])) arg = [ arg ];
		      return jStat.map(arr, function(value, row, col) {
		        return value - arg[row][col] || 0;
		      });
		    }
		    return jStat.map(arr, function(value) { return value - arg; });
		  },

		  // matrix division
		  divide: function divide(arr, arg) {
		    if (isUsable(arg)) {
		      if (!isUsable(arg[0])) arg = [ arg ];
		      return jStat.multiply(arr, jStat.inv(arg));
		    }
		    return jStat.map(arr, function(value) { return value / arg; });
		  },

		  // matrix multiplication
		  multiply: function multiply(arr, arg) {
		    var row, col, nrescols, sum, nrow, ncol, res, rescols;
		    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure
		    if (arr.length === undefined && arg.length === undefined) {
		      return arr * arg;
		    }
		    nrow = arr.length,
		    ncol = arr[0].length,
		    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),
		    rescols = 0;
		    if (isUsable(arg)) {
		      for (; rescols < nrescols; rescols++) {
		        for (row = 0; row < nrow; row++) {
		          sum = 0;
		          for (col = 0; col < ncol; col++)
		          sum += arr[row][col] * arg[col][rescols];
		          res[row][rescols] = sum;
		        }
		      }
		      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
		    }
		    return jStat.map(arr, function(value) { return value * arg; });
		  },

		  // outer([1,2,3],[4,5,6])
		  // ===
		  // [[1],[2],[3]] times [[4,5,6]]
		  // ->
		  // [[4,5,6],[8,10,12],[12,15,18]]
		  outer:function outer(A, B) {
		    return jStat.multiply(A.map(function(t){ return [t] }), [B]);
		  },


		  // Returns the dot product of two matricies
		  dot: function dot(arr, arg) {
		    if (!isUsable(arr[0])) arr = [ arr ];
		    if (!isUsable(arg[0])) arg = [ arg ];
		    // convert column to row vector
		    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
		    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
		    res = [],
		    row = 0,
		    nrow = left.length,
		    ncol = left[0].length,
		    sum, col;
		    for (; row < nrow; row++) {
		      res[row] = [];
		      sum = 0;
		      for (col = 0; col < ncol; col++)
		      sum += left[row][col] * right[row][col];
		      res[row] = sum;
		    }
		    return (res.length === 1) ? res[0] : res;
		  },

		  // raise every element by a scalar
		  pow: function pow(arr, arg) {
		    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
		  },

		  // exponentiate every element
		  exp: function exp(arr) {
		    return jStat.map(arr, function(value) { return Math.exp(value); });
		  },

		  // generate the natural log of every element
		  log: function exp(arr) {
		    return jStat.map(arr, function(value) { return Math.log(value); });
		  },

		  // generate the absolute values of the vector
		  abs: function abs(arr) {
		    return jStat.map(arr, function(value) { return Math.abs(value); });
		  },

		  // computes the p-norm of the vector
		  // In the case that a matrix is passed, uses the first row as the vector
		  norm: function norm(arr, p) {
		    var nnorm = 0,
		    i = 0;
		    // check the p-value of the norm, and set for most common case
		    if (isNaN(p)) p = 2;
		    // check if multi-dimensional array, and make vector correction
		    if (isUsable(arr[0])) arr = arr[0];
		    // vector norm
		    for (; i < arr.length; i++) {
		      nnorm += Math.pow(Math.abs(arr[i]), p);
		    }
		    return Math.pow(nnorm, 1 / p);
		  },

		  // computes the angle between two vectors in rads
		  // In case a matrix is passed, this uses the first row as the vector
		  angle: function angle(arr, arg) {
		    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
		  },

		  // augment one matrix by another
		  // Note: this function returns a matrix, not a jStat object
		  aug: function aug(a, b) {
		    var newarr = [];
		    var i;
		    for (i = 0; i < a.length; i++) {
		      newarr.push(a[i].slice());
		    }
		    for (i = 0; i < newarr.length; i++) {
		      push.apply(newarr[i], b[i]);
		    }
		    return newarr;
		  },

		  // The inv() function calculates the inverse of a matrix
		  // Create the inverse by augmenting the matrix by the identity matrix of the
		  // appropriate size, and then use G-J elimination on the augmented matrix.
		  inv: function inv(a) {
		    var rows = a.length;
		    var cols = a[0].length;
		    var b = jStat.identity(rows, cols);
		    var c = jStat.gauss_jordan(a, b);
		    var result = [];
		    var i = 0;
		    var j;

		    //We need to copy the inverse portion to a new matrix to rid G-J artifacts
		    for (; i < rows; i++) {
		      result[i] = [];
		      for (j = cols; j < c[0].length; j++)
		        result[i][j - cols] = c[i][j];
		    }
		    return result;
		  },

		  // calculate the determinant of a matrix
		  det: function det(a) {
		    if (a.length === 2) {
		      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
		    }

		    var determinant = 0;
		    for (var i = 0; i < a.length; i++) {
		      // build a sub matrix without column `i`
		      var submatrix = [];
		      for (var row = 1; row < a.length; row++) {
		        submatrix[row - 1] = [];
		        for (var col = 0; col < a.length; col++) {
		          if (col < i) {
		            submatrix[row - 1][col] = a[row][col];
		          } else if (col > i) {
		            submatrix[row - 1][col - 1] = a[row][col];
		          }
		        }
		      }

		      // alternate between + and - between determinants
		      var sign = i % 2 ? -1 : 1;
		      determinant += det(submatrix) * a[0][i] * sign;
		    }

		    return determinant
		  },

		  gauss_elimination: function gauss_elimination(a, b) {
		    var i = 0,
		    j = 0,
		    n = a.length,
		    m = a[0].length,
		    factor = 1,
		    sum = 0,
		    x = [],
		    maug, pivot, temp, k;
		    a = jStat.aug(a, b);
		    maug = a[0].length;
		    for(i = 0; i < n; i++) {
		      pivot = a[i][i];
		      j = i;
		      for (k = i + 1; k < m; k++) {
		        if (pivot < Math.abs(a[k][i])) {
		          pivot = a[k][i];
		          j = k;
		        }
		      }
		      if (j != i) {
		        for(k = 0; k < maug; k++) {
		          temp = a[i][k];
		          a[i][k] = a[j][k];
		          a[j][k] = temp;
		        }
		      }
		      for (j = i + 1; j < n; j++) {
		        factor = a[j][i] / a[i][i];
		        for(k = i; k < maug; k++) {
		          a[j][k] = a[j][k] - factor * a[i][k];
		        }
		      }
		    }
		    for (i = n - 1; i >= 0; i--) {
		      sum = 0;
		      for (j = i + 1; j<= n - 1; j++) {
		        sum = sum + x[j] * a[i][j];
		      }
		      x[i] =(a[i][maug - 1] - sum) / a[i][i];
		    }
		    return x;
		  },

		  gauss_jordan: function gauss_jordan(a, b) {
		    var m = jStat.aug(a, b);
		    var h = m.length;
		    var w = m[0].length;
		    var c = 0;
		    var x, y, y2;
		    // find max pivot
		    for (y = 0; y < h; y++) {
		      var maxrow = y;
		      for (y2 = y+1; y2 < h; y2++) {
		        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
		          maxrow = y2;
		      }
		      var tmp = m[y];
		      m[y] = m[maxrow];
		      m[maxrow] = tmp;
		      for (y2 = y+1; y2 < h; y2++) {
		        c = m[y2][y] / m[y][y];
		        for (x = y; x < w; x++) {
		          m[y2][x] -= m[y][x] * c;
		        }
		      }
		    }
		    // backsubstitute
		    for (y = h-1; y >= 0; y--) {
		      c = m[y][y];
		      for (y2 = 0; y2 < y; y2++) {
		        for (x = w-1; x > y-1; x--) {
		          m[y2][x] -= m[y][x] * m[y2][y] / c;
		        }
		      }
		      m[y][y] /= c;
		      for (x = h; x < w; x++) {
		        m[y][x] /= c;
		      }
		    }
		    return m;
		  },

		  // solve equation
		  // Ax=b
		  // A is upper triangular matrix
		  // A=[[1,2,3],[0,4,5],[0,6,7]]
		  // b=[1,2,3]
		  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
		  // if you use matrix style
		  // A=[[1,2,3],[0,4,5],[0,6,7]]
		  // b=[[1],[2],[3]]
		  // will return [[2.666],[0.1666],[1.666]]
		  triaUpSolve: function triaUpSolve(A, b) {
		    var size = A[0].length;
		    var x = jStat.zeros(1, size)[0];
		    var parts;
		    var matrix_mode = false;

		    if (b[0].length != undefined) {
		      b = b.map(function(i){ return i[0] });
		      matrix_mode = true;
		    }

		    jStat.arange(size - 1, -1, -1).forEach(function(i) {
		      parts = jStat.arange(i + 1, size).map(function(j) {
		        return x[j] * A[i][j];
		      });
		      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];
		    });

		    if (matrix_mode)
		      return x.map(function(i){ return [i] });
		    return x;
		  },

		  triaLowSolve: function triaLowSolve(A, b) {
		    // like to triaUpSolve but A is lower triangular matrix
		    var size = A[0].length;
		    var x = jStat.zeros(1, size)[0];
		    var parts;

		    var matrix_mode=false;
		    if (b[0].length != undefined) {
		      b = b.map(function(i){ return i[0] });
		      matrix_mode = true;
		    }

		    jStat.arange(size).forEach(function(i) {
		      parts = jStat.arange(i).map(function(j) {
		        return A[i][j] * x[j];
		      });
		      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];
		    });

		    if (matrix_mode)
		      return x.map(function(i){ return [i] });
		    return x;
		  },


		  // A -> [L,U]
		  // A=LU
		  // L is lower triangular matrix
		  // U is upper triangular matrix
		  lu: function lu(A) {
		    var size = A.length;
		    //var L=jStat.diagonal(jStat.ones(1,size)[0]);
		    var L = jStat.identity(size);
		    var R = jStat.zeros(A.length, A[0].length);
		    var parts;
		    jStat.arange(size).forEach(function(t) {
		      R[0][t] = A[0][t];
		    });
		    jStat.arange(1, size).forEach(function(l) {
		      jStat.arange(l).forEach(function(i) {
		        parts = jStat.arange(i).map(function(jj) {
		          return L[l][jj] * R[jj][i];
		        });
		        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];
		      });
		      jStat.arange(l, size).forEach(function(j) {
		        parts = jStat.arange(l).map(function(jj) {
		          return L[l][jj] * R[jj][j];
		        });
		        R[l][j] = A[parts.length][j] - jStat.sum(parts);
		      });
		    });
		    return [L, R];
		  },

		  // A -> T
		  // A=TT'
		  // T is lower triangular matrix
		  cholesky: function cholesky(A) {
		    var size = A.length;
		    var T = jStat.zeros(A.length, A[0].length);
		    var parts;
		    jStat.arange(size).forEach(function(i) {
		      parts = jStat.arange(i).map(function(t) {
		        return Math.pow(T[i][t],2);
		      });
		      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));
		      jStat.arange(i + 1, size).forEach(function(j) {
		        parts = jStat.arange(i).map(function(t) {
		          return T[i][t] * T[j][t];
		        });
		        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];
		      });
		    });
		    return T;
		  },


		  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
		    var i = 0;
		    var j = 0;
		    var n = a.length;
		    var l = [];
		    var u = [];
		    var d = [];
		    var xv, c, h, xk;
		    for (; i < n; i++) {
		      l[i] = [];
		      u[i] = [];
		      d[i] = [];
		      for (j = 0; j < n; j++) {
		        if (i > j) {
		          l[i][j] = a[i][j];
		          u[i][j] = d[i][j] = 0;
		        } else if (i < j) {
		          u[i][j] = a[i][j];
		          l[i][j] = d[i][j] = 0;
		        } else {
		          d[i][j] = a[i][j];
		          l[i][j] = u[i][j] = 0;
		        }
		      }
		    }
		    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
		    c = jStat.multiply(jStat.inv(d), b);
		    xv = x;
		    xk = jStat.add(jStat.multiply(h, x), c);
		    i = 2;
		    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
		      xv = xk;
		      xk = jStat.add(jStat.multiply(h, xv), c);
		      i++;
		    }
		    return xk;
		  },

		  gauss_seidel: function gauss_seidel(a, b, x, r) {
		    var i = 0;
		    var n = a.length;
		    var l = [];
		    var u = [];
		    var d = [];
		    var j, xv, c, h, xk;
		    for (; i < n; i++) {
		      l[i] = [];
		      u[i] = [];
		      d[i] = [];
		      for (j = 0; j < n; j++) {
		        if (i > j) {
		          l[i][j] = a[i][j];
		          u[i][j] = d[i][j] = 0;
		        } else if (i < j) {
		          u[i][j] = a[i][j];
		          l[i][j] = d[i][j] = 0;
		        } else {
		          d[i][j] = a[i][j];
		          l[i][j] = u[i][j] = 0;
		        }
		      }
		    }
		    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
		    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
		    xv = x;
		    xk = jStat.add(jStat.multiply(h, x), c);
		    i = 2;
		    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
		      xv = xk;
		      xk = jStat.add(jStat.multiply(h, xv), c);
		      i = i + 1;
		    }
		    return xk;
		  },

		  SOR: function SOR(a, b, x, r, w) {
		    var i = 0;
		    var n = a.length;
		    var l = [];
		    var u = [];
		    var d = [];
		    var j, xv, c, h, xk;
		    for (; i < n; i++) {
		      l[i] = [];
		      u[i] = [];
		      d[i] = [];
		      for (j = 0; j < n; j++) {
		        if (i > j) {
		          l[i][j] = a[i][j];
		          u[i][j] = d[i][j] = 0;
		        } else if (i < j) {
		          u[i][j] = a[i][j];
		          l[i][j] = d[i][j] = 0;
		        } else {
		          d[i][j] = a[i][j];
		          l[i][j] = u[i][j] = 0;
		        }
		      }
		    }
		    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
		                       jStat.subtract(jStat.multiply(d, 1 - w),
		                                      jStat.multiply(u, w)));
		    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
		        jStat.multiply(l, w))), b), w);
		    xv = x;
		    xk = jStat.add(jStat.multiply(h, x), c);
		    i = 2;
		    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
		      xv = xk;
		      xk = jStat.add(jStat.multiply(h, xv), c);
		      i++;
		    }
		    return xk;
		  },

		  householder: function householder(a) {
		    var m = a.length;
		    var n = a[0].length;
		    var i = 0;
		    var w = [];
		    var p = [];
		    var alpha, r, k, j, factor;
		    for (; i < m - 1; i++) {
		      alpha = 0;
		      for (j = i + 1; j < n; j++)
		      alpha += (a[j][i] * a[j][i]);
		      factor = (a[i + 1][i] > 0) ? -1 : 1;
		      alpha = factor * Math.sqrt(alpha);
		      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
		      w = jStat.zeros(m, 1);
		      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
		      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
		      p = jStat.subtract(jStat.identity(m, n),
		          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
		      a = jStat.multiply(p, jStat.multiply(a, p));
		    }
		    return a;
		  },

		  // A -> [Q,R]
		  // Q is orthogonal matrix
		  // R is upper triangular
		  QR: (function() {
		    // x -> Q
		    // find a orthogonal matrix Q st.
		    // Qx=y
		    // y is [||x||,0,0,...]

		    // quick ref
		    var sum   = jStat.sum;
		    var range = jStat.arange;

		    function qr2(x) {
		      // quick impletation
		      // https://www.stat.wisc.edu/~larget/math496/qr.html

		      var n = x.length;
		      var p = x[0].length;

		      var r = jStat.zeros(p, p);
		      x = jStat.copy(x);

		      var i,j,k;
		      for(j = 0; j < p; j++){
		        r[j][j] = Math.sqrt(sum(range(n).map(function(i){
		          return x[i][j] * x[i][j];
		        })));
		        for(i = 0; i < n; i++){
		          x[i][j] = x[i][j] / r[j][j];
		        }
		        for(k = j+1; k < p; k++){
		          r[j][k] = sum(range(n).map(function(i){
		            return x[i][j] * x[i][k];
		          }));
		          for(i = 0; i < n; i++){
		            x[i][k] = x[i][k] - x[i][j]*r[j][k];
		          }
		        }
		      }
		      return [x, r];
		    }

		    return qr2;
		  }()),

		  lstsq: (function() {
		    // solve least squard problem for Ax=b as QR decomposition way if b is
		    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution
		    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution
		    function R_I(A) {
		      A = jStat.copy(A);
		      var size = A.length;
		      var I = jStat.identity(size);
		      jStat.arange(size - 1, -1, -1).forEach(function(i) {
		        jStat.sliceAssign(
		            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));
		        jStat.sliceAssign(
		            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));
		        jStat.arange(i).forEach(function(j) {
		          var c = jStat.multiply(A[j][i], -1);
		          var Aj = jStat.slice(A, { row: j });
		          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);
		          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));
		          var Ij = jStat.slice(I, { row: j });
		          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);
		          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));
		        });
		      });
		      return I;
		    }

		    function qr_solve(A, b){
		      var array_mode = false;
		      if (b[0].length === undefined) {
		        // [c1,c2,c3] mode
		        b = b.map(function(x){ return [x] });
		        array_mode = true;
		      }
		      var QR = jStat.QR(A);
		      var Q = QR[0];
		      var R = QR[1];
		      var attrs = A[0].length;
		      var Q1 = jStat.slice(Q,{col:{end:attrs}});
		      var R1 = jStat.slice(R,{row:{end:attrs}});
		      var RI = R_I(R1);
		      var Q2 = jStat.transpose(Q1);

		      if(Q2[0].length === undefined){
		        Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.
		      }

		      var x = jStat.multiply(jStat.multiply(RI, Q2), b);

		      if(x.length === undefined){
		        x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.
		      }


		      if (array_mode)
		        return x.map(function(i){ return i[0] });
		      return x;
		    }

		    return qr_solve;
		  }()),

		  jacobi: function jacobi(a) {
		    var condition = 1;
		    var n = a.length;
		    var e = jStat.identity(n, n);
		    var ev = [];
		    var b, i, j, p, q, maxim, theta, s;
		    // condition === 1 only if tolerance is not reached
		    while (condition === 1) {
		      maxim = a[0][1];
		      p = 0;
		      q = 1;
		      for (i = 0; i < n; i++) {
		        for (j = 0; j < n; j++) {
		          if (i != j) {
		            if (maxim < Math.abs(a[i][j])) {
		              maxim = Math.abs(a[i][j]);
		              p = i;
		              q = j;
		            }
		          }
		        }
		      }
		      if (a[p][p] === a[q][q])
		        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
		      else
		        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
		      s = jStat.identity(n, n);
		      s[p][p] = Math.cos(theta);
		      s[p][q] = -Math.sin(theta);
		      s[q][p] = Math.sin(theta);
		      s[q][q] = Math.cos(theta);
		      // eigen vector matrix
		      e = jStat.multiply(e, s);
		      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
		      a = b;
		      condition = 0;
		      for (i = 1; i < n; i++) {
		        for (j = 1; j < n; j++) {
		          if (i != j && Math.abs(a[i][j]) > 0.001) {
		            condition = 1;
		          }
		        }
		      }
		    }
		    for (i = 0; i < n; i++) ev.push(a[i][i]);
		    //returns both the eigenvalue and eigenmatrix
		    return [e, ev];
		  },

		  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
		    var k1, k2, u_j1, k3, k4;
		    if (order === 2) {
		      while (t_j <= p) {
		        k1 = h * f(t_j, u_j);
		        k2 = h * f(t_j + h, u_j + k1);
		        u_j1 = u_j + (k1 + k2) / 2;
		        u_j = u_j1;
		        t_j = t_j + h;
		      }
		    }
		    if (order === 4) {
		      while (t_j <= p) {
		        k1 = h * f(t_j, u_j);
		        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
		        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
		        k4 = h * f(t_j +h, u_j + k3);
		        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
		        u_j = u_j1;
		        t_j = t_j + h;
		      }
		    }
		    return u_j;
		  },

		  romberg: function romberg(f, a, b, order) {
		    var i = 0;
		    var h = (b - a) / 2;
		    var x = [];
		    var h1 = [];
		    var g = [];
		    var m, a1, j, k, I;
		    while (i < order / 2) {
		      I = f(a);
		      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
		      m = x.length;
		      for (j = 1; j < m - 1; j++) {
		        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
		      }
		      I = (h / 3) * (I + f(b));
		      g[i] = I;
		      h /= 2;
		      i++;
		    }
		    a1 = g.length;
		    m = 1;
		    while (a1 !== 1) {
		      for (j = 0; j < a1 - 1; j++)
		      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
		      a1 = h1.length;
		      g = h1;
		      h1 = [];
		      m++;
		    }
		    return g;
		  },

		  richardson: function richardson(X, f, x, h) {
		    function pos(X, x) {
		      var i = 0;
		      var n = X.length;
		      var p;
		      for (; i < n; i++)
		        if (X[i] === x) p = i;
		      return p;
		    }
		    var h_min = Math.abs(x - X[pos(X, x) + 1]);
		    var i = 0;
		    var g = [];
		    var h1 = [];
		    var y1, y2, m, a, j;
		    while (h >= h_min) {
		      y1 = pos(X, x + h);
		      y2 = pos(X, x);
		      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
		      h /= 2;
		      i++;
		    }
		    a = g.length;
		    m = 1;
		    while (a != 1) {
		      for (j = 0; j < a - 1; j++)
		        h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
		      a = h1.length;
		      g = h1;
		      h1 = [];
		      m++;
		    }
		    return g;
		  },

		  simpson: function simpson(f, a, b, n) {
		    var h = (b - a) / n;
		    var I = f(a);
		    var x = [];
		    var j = a;
		    var k = 0;
		    var i = 1;
		    var m;
		    for (; j <= b; j = j + h, k++)
		      x[k] = j;
		    m = x.length;
		    for (; i < m - 1; i++) {
		      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
		    }
		    return (h / 3) * (I + f(b));
		  },

		  hermite: function hermite(X, F, dF, value) {
		    var n = X.length;
		    var p = 0;
		    var i = 0;
		    var l = [];
		    var dl = [];
		    var A = [];
		    var B = [];
		    var j;
		    for (; i < n; i++) {
		      l[i] = 1;
		      for (j = 0; j < n; j++) {
		        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
		      }
		      dl[i] = 0;
		      for (j = 0; j < n; j++) {
		        if (i != j) dl[i] += 1 / (X [i] - X[j]);
		      }
		      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
		      B[i] = (value - X[i]) * (l[i] * l[i]);
		      p += (A[i] * F[i] + B[i] * dF[i]);
		    }
		    return p;
		  },

		  lagrange: function lagrange(X, F, value) {
		    var p = 0;
		    var i = 0;
		    var j, l;
		    var n = X.length;
		    for (; i < n; i++) {
		      l = F[i];
		      for (j = 0; j < n; j++) {
		        // calculating the lagrange polynomial L_i
		        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
		      }
		      // adding the lagrange polynomials found above
		      p += l;
		    }
		    return p;
		  },

		  cubic_spline: function cubic_spline(X, F, value) {
		    var n = X.length;
		    var i = 0, j;
		    var A = [];
		    var B = [];
		    var alpha = [];
		    var c = [];
		    var h = [];
		    var b = [];
		    var d = [];
		    for (; i < n - 1; i++)
		      h[i] = X[i + 1] - X[i];
		    alpha[0] = 0;
		    for (i = 1; i < n - 1; i++) {
		      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
		          (3 / h[i-1]) * (F[i] - F[i-1]);
		    }
		    for (i = 1; i < n - 1; i++) {
		      A[i] = [];
		      B[i] = [];
		      A[i][i-1] = h[i-1];
		      A[i][i] = 2 * (h[i - 1] + h[i]);
		      A[i][i+1] = h[i];
		      B[i][0] = alpha[i];
		    }
		    c = jStat.multiply(jStat.inv(A), B);
		    for (j = 0; j < n - 1; j++) {
		      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
		      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
		    }
		    for (j = 0; j < n; j++) {
		      if (X[j] > value) break;
		    }
		    j -= 1;
		    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
		        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
		  },

		  gauss_quadrature: function gauss_quadrature() {
		    throw new Error('gauss_quadrature not yet implemented');
		  },

		  PCA: function PCA(X) {
		    var m = X.length;
		    var n = X[0].length;
		    var i = 0;
		    var j, temp1;
		    var u = [];
		    var D = [];
		    var result = [];
		    var temp2 = [];
		    var Y = [];
		    var Bt = [];
		    var B = [];
		    var C = [];
		    var V = [];
		    var Vt = [];
		    for (i = 0; i < m; i++) {
		      u[i] = jStat.sum(X[i]) / n;
		    }
		    for (i = 0; i < n; i++) {
		      B[i] = [];
		      for(j = 0; j < m; j++) {
		        B[i][j] = X[j][i] - u[j];
		      }
		    }
		    B = jStat.transpose(B);
		    for (i = 0; i < m; i++) {
		      C[i] = [];
		      for (j = 0; j < m; j++) {
		        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
		      }
		    }
		    result = jStat.jacobi(C);
		    V = result[0];
		    D = result[1];
		    Vt = jStat.transpose(V);
		    for (i = 0; i < D.length; i++) {
		      for (j = i; j < D.length; j++) {
		        if(D[i] < D[j])  {
		          temp1 = D[i];
		          D[i] = D[j];
		          D[j] = temp1;
		          temp2 = Vt[i];
		          Vt[i] = Vt[j];
		          Vt[j] = temp2;
		        }
		      }
		    }
		    Bt = jStat.transpose(B);
		    for (i = 0; i < m; i++) {
		      Y[i] = [];
		      for (j = 0; j < Bt.length; j++) {
		        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
		      }
		    }
		    return [X, D, Vt, Y];
		  }
		});

		// extend jStat.fn with methods that require one argument
		(function(funcs) {
		  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
		    jStat.fn[passfunc] = function(arg, func) {
		      var tmpthis = this;
		      // check for callback
		      if (func) {
		        setTimeout(function() {
		          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
		        }, 15);
		        return this;
		      }
		      if (typeof jStat[passfunc](this, arg) === 'number')
		        return jStat[passfunc](this, arg);
		      else
		        return jStat(jStat[passfunc](this, arg));
		    };
		  }(funcs[i]));
		}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));

		}(jStat, Math));
		(function(jStat, Math) {

		var slice = [].slice;
		var isNumber = jStat.utils.isNumber;
		var isArray = jStat.utils.isArray;

		// flag==true denotes use of sample standard deviation
		// Z Statistics
		jStat.extend({
		  // 2 different parameter lists:
		  // (value, mean, sd)
		  // (value, array, flag)
		  zscore: function zscore() {
		    var args = slice.call(arguments);
		    if (isNumber(args[1])) {
		      return (args[0] - args[1]) / args[2];
		    }
		    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
		  },

		  // 3 different paramter lists:
		  // (value, mean, sd, sides)
		  // (zscore, sides)
		  // (value, array, sides, flag)
		  ztest: function ztest() {
		    var args = slice.call(arguments);
		    var z;
		    if (isArray(args[1])) {
		      // (value, array, sides, flag)
		      z = jStat.zscore(args[0],args[1],args[3]);
		      return (args[2] === 1) ?
		        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
		        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
		    } else {
		      if (args.length > 2) {
		        // (value, mean, sd, sides)
		        z = jStat.zscore(args[0],args[1],args[2]);
		        return (args[3] === 1) ?
		          (jStat.normal.cdf(-Math.abs(z),0,1)) :
		          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
		      } else {
		        // (zscore, sides)
		        z = args[0];
		        return (args[1] === 1) ?
		          (jStat.normal.cdf(-Math.abs(z),0,1)) :
		          (jStat.normal.cdf(-Math.abs(z),0,1)*2);
		      }
		    }
		  }
		});

		jStat.extend(jStat.fn, {
		  zscore: function zscore(value, flag) {
		    return (value - this.mean()) / this.stdev(flag);
		  },

		  ztest: function ztest(value, sides, flag) {
		    var zscore = Math.abs(this.zscore(value, flag));
		    return (sides === 1) ?
		      (jStat.normal.cdf(-zscore, 0, 1)) :
		      (jStat.normal.cdf(-zscore, 0, 1) * 2);
		  }
		});

		// T Statistics
		jStat.extend({
		  // 2 parameter lists
		  // (value, mean, sd, n)
		  // (value, array)
		  tscore: function tscore() {
		    var args = slice.call(arguments);
		    return (args.length === 4) ?
		      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
		      ((args[0] - jStat.mean(args[1])) /
		       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
		  },

		  // 3 different paramter lists:
		  // (value, mean, sd, n, sides)
		  // (tscore, n, sides)
		  // (value, array, sides)
		  ttest: function ttest() {
		    var args = slice.call(arguments);
		    var tscore;
		    if (args.length === 5) {
		      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
		      return (args[4] === 1) ?
		        (jStat.studentt.cdf(-tscore, args[3]-1)) :
		        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
		    }
		    if (isNumber(args[1])) {
		      tscore = Math.abs(args[0]);
		      return (args[2] == 1) ?
		        (jStat.studentt.cdf(-tscore, args[1]-1)) :
		        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
		    }
		    tscore = Math.abs(jStat.tscore(args[0], args[1]));
		    return (args[2] == 1) ?
		      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
		      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
		  }
		});

		jStat.extend(jStat.fn, {
		  tscore: function tscore(value) {
		    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
		  },

		  ttest: function ttest(value, sides) {
		    return (sides === 1) ?
		      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
		      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
		  }
		});

		// F Statistics
		jStat.extend({
		  // Paramter list is as follows:
		  // (array1, array2, array3, ...)
		  // or it is an array of arrays
		  // array of arrays conversion
		  anovafscore: function anovafscore() {
		    var args = slice.call(arguments),
		    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
		    if (args.length === 1) {
		      tmpargs = new Array(args[0].length);
		      for (i = 0; i < args[0].length; i++) {
		        tmpargs[i] = args[0][i];
		      }
		      args = tmpargs;
		    }
		    // Builds sample array
		    sample = new Array();
		    for (i = 0; i < args.length; i++) {
		      sample = sample.concat(args[i]);
		    }
		    sampMean = jStat.mean(sample);
		    // Computes the explained variance
		    expVar = 0;
		    for (i = 0; i < args.length; i++) {
		      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
		    }
		    expVar /= (args.length - 1);
		    // Computes unexplained variance
		    unexpVar = 0;
		    for (i = 0; i < args.length; i++) {
		      sampSampMean = jStat.mean(args[i]);
		      for (j = 0; j < args[i].length; j++) {
		        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
		      }
		    }
		    unexpVar /= (sample.length - args.length);
		    return expVar / unexpVar;
		  },

		  // 2 different paramter setups
		  // (array1, array2, array3, ...)
		  // (anovafscore, df1, df2)
		  anovaftest: function anovaftest() {
		    var args = slice.call(arguments),
		    df1, df2, n, i;
		    if (isNumber(args[0])) {
		      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
		    }
		    var anovafscore = jStat.anovafscore(args);
		    df1 = args.length - 1;
		    n = 0;
		    for (i = 0; i < args.length; i++) {
		      n = n + args[i].length;
		    }
		    df2 = n - df1 - 1;
		    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
		  },

		  ftest: function ftest(fscore, df1, df2) {
		    return 1 - jStat.centralF.cdf(fscore, df1, df2);
		  }
		});

		jStat.extend(jStat.fn, {
		  anovafscore: function anovafscore() {
		    return jStat.anovafscore(this.toArray());
		  },

		  anovaftes: function anovaftes() {
		    var n = 0;
		    var i;
		    for (i = 0; i < this.length; i++) {
		      n = n + this[i].length;
		    }
		    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
		  }
		});

		// Tukey's range test
		jStat.extend({
		  // 2 parameter lists
		  // (mean1, mean2, n1, n2, sd)
		  // (array1, array2, sd)
		  qscore: function qscore() {
		    var args = slice.call(arguments);
		    var mean1, mean2, n1, n2, sd;
		    if (isNumber(args[0])) {
		        mean1 = args[0];
		        mean2 = args[1];
		        n1 = args[2];
		        n2 = args[3];
		        sd = args[4];
		    } else {
		        mean1 = jStat.mean(args[0]);
		        mean2 = jStat.mean(args[1]);
		        n1 = args[0].length;
		        n2 = args[1].length;
		        sd = args[2];
		    }
		    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));
		  },

		  // 3 different parameter lists:
		  // (qscore, n, k)
		  // (mean1, mean2, n1, n2, sd, n, k)
		  // (array1, array2, sd, n, k)
		  qtest: function qtest() {
		    var args = slice.call(arguments);

		    var qscore;
		    if (args.length === 3) {
		      qscore = args[0];
		      args = args.slice(1);
		    } else if (args.length === 7) {
		      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);
		      args = args.slice(5);
		    } else {
		      qscore = jStat.qscore(args[0], args[1], args[2]);
		      args = args.slice(3);
		    }

		    var n = args[0];
		    var k = args[1];

		    return 1 - jStat.tukey.cdf(qscore, k, n - k);
		  },

		  tukeyhsd: function tukeyhsd(arrays) {
		    var sd = jStat.pooledstdev(arrays);
		    var means = arrays.map(function (arr) {return jStat.mean(arr);});
		    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);

		    var results = [];
		    for (var i = 0; i < arrays.length; ++i) {
		        for (var j = i + 1; j < arrays.length; ++j) {
		            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);
		            results.push([[i, j], p]);
		        }
		    }

		    return results;
		  }
		});

		// Error Bounds
		jStat.extend({
		  // 2 different parameter setups
		  // (value, alpha, sd, n)
		  // (value, alpha, array)
		  normalci: function normalci() {
		    var args = slice.call(arguments),
		    ans = new Array(2),
		    change;
		    if (args.length === 4) {
		      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
		                        args[2] / Math.sqrt(args[3]));
		    } else {
		      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
		                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
		    }
		    ans[0] = args[0] - change;
		    ans[1] = args[0] + change;
		    return ans;
		  },

		  // 2 different parameter setups
		  // (value, alpha, sd, n)
		  // (value, alpha, array)
		  tci: function tci() {
		    var args = slice.call(arguments),
		    ans = new Array(2),
		    change;
		    if (args.length === 4) {
		      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
		                        args[2] / Math.sqrt(args[3]));
		    } else {
		      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
		                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
		    }
		    ans[0] = args[0] - change;
		    ans[1] = args[0] + change;
		    return ans;
		  },

		  significant: function significant(pvalue, alpha) {
		    return pvalue < alpha;
		  }
		});

		jStat.extend(jStat.fn, {
		  normalci: function normalci(value, alpha) {
		    return jStat.normalci(value, alpha, this.toArray());
		  },

		  tci: function tci(value, alpha) {
		    return jStat.tci(value, alpha, this.toArray());
		  }
		});

		// internal method for calculating the z-score for a difference of proportions test
		function differenceOfProportions(p1, n1, p2, n2) {
		  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
		    throw new Error("Proportions should be greater than 0 and less than 1")
		  }
		  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
		  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));
		  return (p1 - p2) / se;
		}

		// Difference of Proportions
		jStat.extend(jStat.fn, {
		  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
		    var z = differenceOfProportions(p1, n1, p2, n2);
		    return jStat.ztest(z, 1);
		  },

		  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
		    var z = differenceOfProportions(p1, n1, p2, n2);
		    return jStat.ztest(z, 2);
		  }
		});

		}(jStat, Math));
		jStat.models = (function(){
		  function sub_regress(exog) {
		    var var_count = exog[0].length;
		    var modelList = jStat.arange(var_count).map(function(endog_index) {
		      var exog_index =
		          jStat.arange(var_count).filter(function(i){return i!==endog_index});
		      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),
		                 jStat.col(exog, exog_index))
		    });
		    return modelList;
		  }

		  // do OLS model regress
		  // exog have include const columns ,it will not generate it .In fact, exog is
		  // "design matrix" look at
		  //https://en.wikipedia.org/wiki/Design_matrix
		  function ols(endog, exog) {
		    var nobs = endog.length;
		    var df_model = exog[0].length - 1;
		    var df_resid = nobs-df_model - 1;
		    var coef = jStat.lstsq(exog, endog);
		    var predict =
		        jStat.multiply(exog, coef.map(function(x) { return [x] }))
		            .map(function(p) { return p[0] });
		    var resid = jStat.subtract(endog, predict);
		    var ybar = jStat.mean(endog);
		    // constant cause problem
		    // var SST = jStat.sum(endog.map(function(y) {
		    //   return Math.pow(y-ybar,2);
		    // }));
		    var SSE = jStat.sum(predict.map(function(f) {
		      return Math.pow(f - ybar, 2);
		    }));
		    var SSR = jStat.sum(endog.map(function(y, i) {
		      return Math.pow(y - predict[i], 2);
		    }));
		    var SST = SSE + SSR;
		    var R2 = (SSE / SST);
		    return {
		        exog:exog,
		        endog:endog,
		        nobs:nobs,
		        df_model:df_model,
		        df_resid:df_resid,
		        coef:coef,
		        predict:predict,
		        resid:resid,
		        ybar:ybar,
		        SST:SST,
		        SSE:SSE,
		        SSR:SSR,
		        R2:R2
		    };
		  }

		  // H0: b_I=0
		  // H1: b_I!=0
		  function t_test(model) {
		    var subModelList = sub_regress(model.exog);
		    //var sigmaHat=jStat.stdev(model.resid);
		    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));
		    var seBetaHat = subModelList.map(function(mod) {
		      var SST = mod.SST;
		      var R2 = mod.R2;
		      return sigmaHat / Math.sqrt(SST * (1 - R2));
		    });
		    var tStatistic = model.coef.map(function(coef, i) {
		      return (coef - 0) / seBetaHat[i];
		    });
		    var pValue = tStatistic.map(function(t) {
		      var leftppf = jStat.studentt.cdf(t, model.df_resid);
		      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
		    });
		    var c = jStat.studentt.inv(0.975, model.df_resid);
		    var interval95 = model.coef.map(function(coef, i) {
		      var d = c * seBetaHat[i];
		      return [coef - d, coef + d];
		    });
		    return {
		        se: seBetaHat,
		        t: tStatistic,
		        p: pValue,
		        sigmaHat: sigmaHat,
		        interval95: interval95
		    };
		  }

		  function F_test(model) {
		    var F_statistic =
		        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);
		    var fcdf = function(x, n1, n2) {
		      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)
		    };
		    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
		    return { F_statistic: F_statistic, pvalue: pvalue };
		  }

		  function ols_wrap(endog, exog) {
		    var model = ols(endog,exog);
		    var ttest = t_test(model);
		    var ftest = F_test(model);
		    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2
		    // Which matches the 'adjusted R^2' provided by R's lm package
		    var adjust_R2 =
		        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));
		    model.t = ttest;
		    model.f = ftest;
		    model.adjust_R2 = adjust_R2;
		    return model;
		  }

		  return { ols: ols_wrap };
		})();
		//To regress, simply build X matrix
		//(append column of 1's) using
		//buildxmatrix and build the Y
		//matrix using buildymatrix
		//(simply the transpose)
		//and run regress.



		//Regressions

		jStat.extend({
		  buildxmatrix: function buildxmatrix(){
		    //Parameters will be passed in as such
		    //(array1,array2,array3,...)
		    //as (x1,x2,x3,...)
		    //needs to be (1,x1,x2,x3,...)
		    var matrixRows = new Array(arguments.length);
		    for(var i=0;i<arguments.length;i++){
		      var array = [1];
		      matrixRows[i]= array.concat(arguments[i]);
		    }
		    return jStat(matrixRows);

		  },

		  builddxmatrix: function builddxmatrix() {
		    //Paramters will be passed in as such
		    //([array1,array2,...]
		    var matrixRows = new Array(arguments[0].length);
		    for(var i=0;i<arguments[0].length;i++){
		      var array = [1];
		      matrixRows[i]= array.concat(arguments[0][i]);
		    }
		    return jStat(matrixRows);

		  },

		  buildjxmatrix: function buildjxmatrix(jMat) {
		    //Builds from jStat Matrix
		    var pass = new Array(jMat.length);
		    for(var i=0;i<jMat.length;i++){
		      pass[i] = jMat[i];
		    }
		    return jStat.builddxmatrix(pass);

		  },

		  buildymatrix: function buildymatrix(array){
		    return jStat(array).transpose();
		  },

		  buildjymatrix: function buildjymatrix(jMat){
		    return jMat.transpose();
		  },

		  matrixmult: function matrixmult(A,B){
		    var i, j, k, result, sum;
		    if (A.cols() == B.rows()) {
		      if(B.rows()>1){
		        result = [];
		        for (i = 0; i < A.rows(); i++) {
		          result[i] = [];
		          for (j = 0; j < B.cols(); j++) {
		            sum = 0;
		            for (k = 0; k < A.cols(); k++) {
		              sum += A.toArray()[i][k] * B.toArray()[k][j];
		            }
		            result[i][j] = sum;
		          }
		        }
		        return jStat(result);
		      }
		      result = [];
		      for (i = 0; i < A.rows(); i++) {
		        result[i] = [];
		        for (j = 0; j < B.cols(); j++) {
		          sum = 0;
		          for (k = 0; k < A.cols(); k++) {
		            sum += A.toArray()[i][k] * B.toArray()[j];
		          }
		          result[i][j] = sum;
		        }
		      }
		      return jStat(result);
		    }
		  },

		  //regress and regresst to be fixed

		  regress: function regress(jMatX,jMatY){
		    //print("regressin!");
		    //print(jMatX.toArray());
		    var innerinv = jStat.xtranspxinv(jMatX);
		    //print(innerinv);
		    var xtransp = jMatX.transpose();
		    var next = jStat.matrixmult(jStat(innerinv),xtransp);
		    return jStat.matrixmult(next,jMatY);

		  },

		  regresst: function regresst(jMatX,jMatY,sides){
		    var beta = jStat.regress(jMatX,jMatY);

		    var compile = {};
		    compile.anova = {};
		    var jMatYBar = jStat.jMatYBar(jMatX, beta);
		    compile.yBar = jMatYBar;
		    var yAverage = jMatY.mean();
		    compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);

		    compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);
		    compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);

		    compile.anova.sse = jStat.sse(jMatY, jMatYBar);
		    compile.anova.mse =
		        compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);

		    compile.anova.sst = jStat.sst(jMatY, yAverage);
		    compile.anova.mst = compile.anova.sst / (jMatY.length - 1);

		    compile.anova.r2 = 1 - (compile.anova.sse / compile.anova.sst);
		    if (compile.anova.r2 < 0) compile.anova.r2 = 0;

		    compile.anova.fratio = compile.anova.msr / compile.anova.mse;
		    compile.anova.pvalue =
		        jStat.anovaftest(compile.anova.fratio,
		                         jMatX[0].length - 1,
		                         jMatY.length - (jMatX[0].length - 1) - 1);

		    compile.anova.rmse = Math.sqrt(compile.anova.mse);

		    compile.anova.r2adj = 1 - (compile.anova.mse / compile.anova.mst);
		    if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;

		    compile.stats = new Array(jMatX[0].length);
		    var covar = jStat.xtranspxinv(jMatX);
		    var sds, ts, ps;

		    for(var i=0; i<beta.length;i++){
		      sds=Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));
		      ts= Math.abs(beta[i] / sds);
		      ps= jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);

		      compile.stats[i]=[beta[i], sds, ts, ps];
		    }

		    compile.regress = beta;
		    return compile;
		  },

		  xtranspx: function xtranspx(jMatX){
		    return jStat.matrixmult(jMatX.transpose(),jMatX);
		  },


		  xtranspxinv: function xtranspxinv(jMatX){
		    var inner = jStat.matrixmult(jMatX.transpose(),jMatX);
		    var innerinv = jStat.inv(inner);
		    return innerinv;
		  },

		  jMatYBar: function jMatYBar(jMatX, beta) {
		    var yBar = jStat.matrixmult(jMatX, beta);
		    return new jStat(yBar);
		  },

		  residuals: function residuals(jMatY, jMatYBar) {
		    return jStat.matrixsubtract(jMatY, jMatYBar);
		  },

		  ssr: function ssr(jMatYBar, yAverage) {
		    var ssr = 0;
		    for(var i = 0; i < jMatYBar.length; i++) {
		      ssr += Math.pow(jMatYBar[i] - yAverage, 2);
		    }
		    return ssr;
		  },

		  sse: function sse(jMatY, jMatYBar) {
		    var sse = 0;
		    for(var i = 0; i < jMatY.length; i++) {
		      sse += Math.pow(jMatY[i] - jMatYBar[i], 2);
		    }
		    return sse;
		  },

		  sst: function sst(jMatY, yAverage) {
		    var sst = 0;
		    for(var i = 0; i < jMatY.length; i++) {
		      sst += Math.pow(jMatY[i] - yAverage, 2);
		    }
		    return sst;
		  },

		  matrixsubtract: function matrixsubtract(A,B){
		    var ans = new Array(A.length);
		    for(var i=0;i<A.length;i++){
		      ans[i] = new Array(A[i].length);
		      for(var j=0;j<A[i].length;j++){
		        ans[i][j]=A[i][j]-B[i][j];
		      }
		    }
		    return jStat(ans);
		  }
		});
		  // Make it compatible with previous version.
		  jStat.jStat = jStat;

		  return jStat;
		}); 
	} (jstat$2));
	return jstat$2.exports;
}

var jstatExports = requireJstat();
var jstat = /*@__PURE__*/getDefaultExportFromCjs(jstatExports);

function analyzeDistribution$1(values) {
  const numbers = values.filter(v => typeof v === 'number' && !isNaN(v));
  
  if (numbers.length < 20) {
    return {
      tests: {},
      recommendation: 'Insufficient data for distribution testing (n < 20)'
    };
  }
  
  const sorted = [...numbers].sort((a, b) => a - b);
  
  // Run distribution tests
  const tests = {
    normality: testNormality(sorted),
    uniformity: testUniformity(sorted),
    exponential: testExponential(sorted),
    bestFit: null
  };
  
  // Determine best fit
  tests.bestFit = determineBestFit(tests);
  
  // Transformation recommendations
  const transformations = recommendTransformations(numbers);
  
  return {
    sampleSize: numbers.length,
    tests,
    transformations,
    interpretation: interpretDistribution(tests, transformations)
  };
}

function testNormality(values) {
  const n = values.length;
  
  // Skip if too few values
  if (n < 3) {
    return { applicable: false, reason: 'Too few values' };
  }
  
  // Shapiro-Wilk test (for n < 5000)
  let shapiroWilk = null;
  if (n <= 5000) {
    shapiroWilk = shapiroWilkTest(values);
  }
  
  // Anderson-Darling test
  const andersonDarling = andersonDarlingTest(values);
  
  // Jarque-Bera test
  const jarqueBera = jarqueBeraTest(values);
  
  // Q-Q plot analysis
  const qqAnalysis = analyzeQQPlot(values);
  
  return {
    shapiroWilk,
    andersonDarling,
    jarqueBera,
    qqAnalysis,
    isNormal: determineNormality(shapiroWilk, andersonDarling, jarqueBera)
  };
}

function shapiroWilkTest(values) {
  const n = values.length;
  
  if (n < 3 || n > 5000) {
    return {
      applicable: false,
      reason: n < 3 ? 'Sample size too small (n < 3)' : 'Sample size too large (n > 5000)'
    };
  }
  
  const sorted = [...values].sort((a, b) => a - b);
  const mean = mean$2(values);
  
  // Calculate robust Shapiro-Wilk statistic using proper coefficients
  const coefficients = getShapiroWilkCoefficients(n);
  if (!coefficients) {
    // Fallback to asymptotic formula for sizes not in tables
    return shapiroWilkAsymptotic(sorted, mean);
  }
  
  let numerator = 0;
  const k = Math.floor(n / 2);
  
  for (let i = 0; i < k; i++) {
    numerator += coefficients[i] * (sorted[n - 1 - i] - sorted[i]);
  }
  numerator = numerator * numerator;
  
  const denominator = values.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0);
  const W = numerator / denominator;
  
  // Calculate p-value using Monte Carlo approximation
  const pValue = calculateShapiroWilkPValue(W, n);
  const alpha = 0.05;
  
  return {
    statistic: W,
    pValue: pValue,
    rejectNull: pValue < alpha,
    interpretation: pValue >= alpha ? 
      `Data appears normal (p = ${pValue.toFixed(4)})` : 
      `Data deviates from normality (p = ${pValue.toFixed(4)})`
  };
}

function getShapiroWilkCoefficients(n) {
  // Shapiro-Wilk coefficients for common sample sizes
  // These are the a_i coefficients from Shapiro & Wilk (1965) tables
  const coefficientTables = {
    3: [0.7071],
    4: [0.6872, 0.1677],
    5: [0.6646, 0.2413, 0.0000],
    6: [0.6431, 0.2806, 0.0875],
    7: [0.6233, 0.3031, 0.1401, 0.0000],
    8: [0.6052, 0.3164, 0.1743, 0.0561],
    9: [0.5888, 0.3244, 0.1976, 0.0947, 0.0000],
    10: [0.5739, 0.3291, 0.2141, 0.1224, 0.0399],
    11: [0.5601, 0.3315, 0.2260, 0.1429, 0.0695, 0.0000],
    12: [0.5475, 0.3325, 0.2347, 0.1586, 0.0922, 0.0303],
    15: [0.5150, 0.3325, 0.2412, 0.1707, 0.1099, 0.0542, 0.0000],
    20: [0.4734, 0.3211, 0.2565, 0.1877, 0.1271, 0.0739, 0.0240],
    25: [0.4450, 0.3104, 0.2691, 0.1966, 0.1383, 0.0878, 0.0433, 0.0000],
    30: [0.4254, 0.3015, 0.2786, 0.2025, 0.1470, 0.0973, 0.0539, 0.0140],
    35: [0.4101, 0.2939, 0.2858, 0.2072, 0.1539, 0.1047, 0.0618, 0.0220],
    40: [0.3964, 0.2875, 0.2916, 0.2110, 0.1594, 0.1109, 0.0685, 0.0284],
    50: [0.3751, 0.2759, 0.3008, 0.2171, 0.1686, 0.1207, 0.0804, 0.0433]
  };
  
  // Return exact coefficients if available
  if (coefficientTables[n]) {
    return coefficientTables[n];
  }
  
  // Interpolate for intermediate values
  const keys = Object.keys(coefficientTables).map(Number).sort((a, b) => a - b);
  const lowerKey = keys.find(k => k <= n && keys[keys.indexOf(k) + 1] > n);
  const upperKey = keys[keys.indexOf(lowerKey) + 1];
  
  if (lowerKey && upperKey) {
    const lowerCoeffs = coefficientTables[lowerKey];
    const upperCoeffs = coefficientTables[upperKey];
    const ratio = (n - lowerKey) / (upperKey - lowerKey);
    
    // Linear interpolation
    const interpolated = lowerCoeffs.map((lower, i) => {
      const upper = upperCoeffs[i] || 0;
      return lower + ratio * (upper - lower);
    });
    
    return interpolated.slice(0, Math.floor(n / 2));
  }
  
  return null;
}

function shapiroWilkAsymptotic(sorted, mean) {
  // Asymptotic approximation for large samples using D'Agostino's method
  const n = sorted.length;
  const variance = sorted.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / n;
  
  // Calculate sample skewness and kurtosis
  const skewness = sorted.reduce((sum, x) => sum + Math.pow((x - mean) / Math.sqrt(variance), 3), 0) / n;
  const kurtosis = sorted.reduce((sum, x) => sum + Math.pow((x - mean) / Math.sqrt(variance), 4), 0) / n;
  
  // Asymptotic W statistic approximation
  const W = 1 - (Math.pow(skewness, 2) / 6 + Math.pow(kurtosis - 3, 2) / 24) / n;
  const pValue = calculateShapiroWilkPValue(W, n);
  
  return {
    statistic: W,
    pValue: pValue,
    rejectNull: pValue < 0.05,
    interpretation: pValue >= 0.05 ? 
      `Data appears normal (asymptotic, p ≈ ${pValue.toFixed(4)})` : 
      `Data deviates from normality (asymptotic, p ≈ ${pValue.toFixed(4)})`
  };
}

function calculateShapiroWilkPValue(W, n) {
  // Monte Carlo approximation for p-value calculation
  // Based on Royston's algorithm (1995) for improved p-value estimation
  
  if (n < 3) return NaN;
  
  // Transform W statistic for normality
  let g, mu, sigma;
  
  if (n >= 3 && n <= 11) {
    // Small sample approximation
    g = -Math.log(1 - W);
    mu = -1.2725 + 1.0521 * Math.log(n);
    sigma = 1.0308 - 0.26758 * Math.log(n);
  } else {
    // Large sample approximation (n > 11)
    const ln_n = Math.log(n);
    g = Math.log(1 - W);
    
    mu = 0.0038915 * Math.pow(ln_n, 3) - 0.083751 * Math.pow(ln_n, 2) - 0.31082 * ln_n - 1.5861;
    sigma = Math.exp(0.0030302 * Math.pow(ln_n, 2) - 0.082676 * ln_n - 0.4803);
  }
  
  // Standard normal quantile
  const z = (g - mu) / sigma;
  
  // Convert to p-value using standard normal CDF
  // Using error function approximation
  const pValue = 0.5 * (1 + erf(z / Math.sqrt(2)));
  
  return Math.max(0.001, Math.min(0.999, pValue));
}

// Error function approximation (Abramowitz and Stegun)
function erf(x) {
  const a1 =  0.254829592;
  const a2 = -0.284496736;
  const a3 =  1.421413741;
  const a4 = -1.453152027;
  const a5 =  1.061405429;
  const p  =  0.3275911;
  
  const sign = x >= 0 ? 1 : -1;
  x = Math.abs(x);
  
  const t = 1.0 / (1.0 + p * x);
  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
  
  return sign * y;
}

function andersonDarlingTest(values) {
  const n = values.length;
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  
  // Standardize values
  const standardized = values.map(x => (x - mean) / stdDev).sort((a, b) => a - b);
  
  // Calculate A-squared statistic
  let sum = 0;
  for (let i = 0; i < n; i++) {
    const Fi = jstat.normal.cdf(standardized[i], 0, 1);
    const Fni = jstat.normal.cdf(standardized[n - 1 - i], 0, 1);
    sum += (2 * i + 1) * (Math.log(Fi) + Math.log(1 - Fni));
  }
  
  const A2 = -n - sum / n;
  const A2star = A2 * (1 + 0.75/n + 2.25/(n*n)); // Adjusted for sample size
  
  // Critical value at 0.05 significance
  const criticalValue = 0.752;
  
  return {
    statistic: A2star,
    criticalValue,
    rejectNull: A2star > criticalValue,
    interpretation: A2star <= criticalValue ? 'Consistent with normal distribution' : 'Significant deviation from normality'
  };
}

function jarqueBeraTest(values) {
  const n = values.length;
  const skewness = calculateSkewness$1(values);
  const kurtosis = calculateKurtosis$1(values);
  
  // Jarque-Bera statistic
  const JB = (n / 6) * (skewness * skewness + (kurtosis * kurtosis) / 4);
  
  // Chi-square critical value with 2 df at 0.05 significance
  const criticalValue = 5.991;
  const pValue = 1 - jstat.chisquare.cdf(JB, 2);
  
  return {
    statistic: JB,
    skewness,
    kurtosis,
    criticalValue,
    pValue,
    rejectNull: JB > criticalValue,
    interpretation: JB <= criticalValue ? 'Skewness and kurtosis consistent with normality' : 'Significant skewness or kurtosis'
  };
}

function analyzeQQPlot(values) {
  const n = values.length;
  const sorted = [...values].sort((a, b) => a - b);
  
  // Calculate theoretical quantiles
  const theoreticalQuantiles = [];
  const empiricalQuantiles = [];
  
  for (let i = 0; i < n; i++) {
    const p = (i + 0.5) / n;
    theoreticalQuantiles.push(jstat.normal.inv(p, mean$2(values), standardDeviation(values)));
    empiricalQuantiles.push(sorted[i]);
  }
  
  // Calculate correlation between theoretical and empirical quantiles
  const qqCorrelation = sampleCorrelation(theoreticalQuantiles, empiricalQuantiles);
  
  // Identify deviations
  let lowerTailDeviation = false;
  let upperTailDeviation = false;
  
  if (n > 10) {
    const lowerDiff = Math.abs(empiricalQuantiles[0] - theoreticalQuantiles[0]);
    const upperDiff = Math.abs(empiricalQuantiles[n-1] - theoreticalQuantiles[n-1]);
    const midDiff = Math.abs(empiricalQuantiles[Math.floor(n/2)] - theoreticalQuantiles[Math.floor(n/2)]);
    
    lowerTailDeviation = lowerDiff > 2 * midDiff;
    upperTailDeviation = upperDiff > 2 * midDiff;
  }
  
  return {
    correlation: qqCorrelation,
    interpretation: qqCorrelation > 0.98 ? 'Excellent fit to normal' : 
                   qqCorrelation > 0.95 ? 'Good fit to normal' : 
                   qqCorrelation > 0.90 ? 'Moderate fit to normal' : 'Poor fit to normal',
    lowerTailDeviation,
    upperTailDeviation
  };
}

function testUniformity(values) {
  const n = values.length;
  const min = Math.min(...values);
  const max = Math.max(...values);
  const range = max - min;
  
  if (range === 0) {
    return { applicable: false, reason: 'All values are identical' };
  }
  
  // Kolmogorov-Smirnov test for uniformity
  const sorted = [...values].sort((a, b) => a - b);
  let maxDiff = 0;
  
  for (let i = 0; i < n; i++) {
    const empiricalCDF = (i + 1) / n;
    const theoreticalCDF = (sorted[i] - min) / range;
    const diff = Math.abs(empiricalCDF - theoreticalCDF);
    maxDiff = Math.max(maxDiff, diff);
  }
  
  const KS = maxDiff;
  const criticalValue = 1.36 / Math.sqrt(n); // At 0.05 significance
  
  return {
    statistic: KS,
    criticalValue,
    rejectNull: KS > criticalValue,
    interpretation: KS <= criticalValue ? 'Consistent with uniform distribution' : 'Not uniformly distributed'
  };
}

function testExponential(values) {
  const n = values.length;
  const positiveValues = values.filter(v => v > 0);
  
  if (positiveValues.length < n * 0.9) {
    return { applicable: false, reason: 'Too many non-positive values' };
  }
  
  const mean = mean$2(positiveValues);
  const sorted = [...positiveValues].sort((a, b) => a - b);
  
  // Kolmogorov-Smirnov test for exponential
  let maxDiff = 0;
  
  for (let i = 0; i < sorted.length; i++) {
    const empiricalCDF = (i + 1) / sorted.length;
    const theoreticalCDF = 1 - Math.exp(-sorted[i] / mean);
    const diff = Math.abs(empiricalCDF - theoreticalCDF);
    maxDiff = Math.max(maxDiff, diff);
  }
  
  const KS = maxDiff;
  const criticalValue = 1.36 / Math.sqrt(sorted.length);
  
  return {
    statistic: KS,
    criticalValue,
    rejectNull: KS > criticalValue,
    interpretation: KS <= criticalValue ? 'Consistent with exponential distribution' : 'Not exponentially distributed',
    estimatedRate: 1 / mean
  };
}

function determineBestFit(tests) {
  const fits = [];
  
  if (tests.normality.isNormal) {
    fits.push({ distribution: 'normal', score: tests.normality.qqAnalysis.correlation });
  }
  
  if (tests.uniformity.applicable && !tests.uniformity.rejectNull) {
    fits.push({ distribution: 'uniform', score: 1 - tests.uniformity.statistic });
  }
  
  if (tests.exponential.applicable && !tests.exponential.rejectNull) {
    fits.push({ distribution: 'exponential', score: 1 - tests.exponential.statistic });
  }
  
  if (fits.length === 0) {
    return { distribution: 'none', interpretation: 'No standard distribution fits well' };
  }
  
  const best = fits.reduce((a, b) => a.score > b.score ? a : b);
  return {
    distribution: best.distribution,
    score: best.score,
    interpretation: `Best fit is ${best.distribution} distribution`
  };
}

function recommendTransformations(values, tests) {
  const recommendations = [];
  const stats = {
    skewness: calculateSkewness$1(values),
    min: Math.min(...values)
  };
  
  // Log transformation for right-skewed data
  if (stats.skewness > 1 && stats.min > 0) {
    const logTransformed = values.map(v => Math.log(v));
    const logSkewness = calculateSkewness$1(logTransformed);
    
    recommendations.push({
      type: 'log',
      applicable: true,
      originalSkewness: stats.skewness,
      transformedSkewness: logSkewness,
      improvement: Math.abs(logSkewness) < Math.abs(stats.skewness),
      description: 'Log transformation reduces right skew'
    });
  }
  
  // Square root for count data
  if (stats.min >= 0 && values.every(v => v === Math.floor(v))) {
    const sqrtTransformed = values.map(v => Math.sqrt(v));
    const sqrtSkewness = calculateSkewness$1(sqrtTransformed);
    
    recommendations.push({
      type: 'sqrt',
      applicable: true,
      originalSkewness: stats.skewness,
      transformedSkewness: sqrtSkewness,
      improvement: Math.abs(sqrtSkewness) < Math.abs(stats.skewness),
      description: 'Square root transformation for count data'
    });
  }
  
  // Box-Cox transformation
  if (stats.min > 0) {
    const lambda = findOptimalBoxCox(values);
    const boxcoxTransformed = values.map(v => 
      lambda === 0 ? Math.log(v) : (Math.pow(v, lambda) - 1) / lambda
    );
    const boxcoxSkewness = calculateSkewness$1(boxcoxTransformed);
    
    recommendations.push({
      type: 'box-cox',
      applicable: true,
      lambda,
      originalSkewness: stats.skewness,
      transformedSkewness: boxcoxSkewness,
      improvement: Math.abs(boxcoxSkewness) < Math.abs(stats.skewness),
      description: `Box-Cox transformation with λ=${lambda.toFixed(2)}`
    });
  }
  
  return recommendations.filter(r => r.improvement);
}

function findOptimalBoxCox(values) {
  // Simplified Box-Cox lambda estimation
  // In practice, this would use maximum likelihood estimation
  const lambdas = [-2, -1, -0.5, 0, 0.5, 1, 2];
  let bestLambda = 0;
  let minSkewness = Infinity;
  
  for (const lambda of lambdas) {
    const transformed = values.map(v => 
      lambda === 0 ? Math.log(v) : (Math.pow(v, lambda) - 1) / lambda
    );
    const skewness = Math.abs(calculateSkewness$1(transformed));
    
    if (skewness < minSkewness) {
      minSkewness = skewness;
      bestLambda = lambda;
    }
  }
  
  return bestLambda;
}

function calculateSkewness$1(values) {
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  const n = values.length;
  
  if (stdDev === 0) return 0;
  
  const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / stdDev, 3), 0);
  return (n / ((n - 1) * (n - 2))) * sum;
}

function calculateKurtosis$1(values) {
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  const n = values.length;
  
  if (stdDev === 0) return 0;
  
  const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / stdDev, 4), 0);
  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sum - 
         (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));
}

function determineNormality(shapiroWilk, andersonDarling, jarqueBera) {
  let votes = 0;
  let total = 0;
  
  if (shapiroWilk && shapiroWilk.rejectNull !== undefined) {
    if (!shapiroWilk.rejectNull) votes++;
    total++;
  }
  
  if (andersonDarling && andersonDarling.rejectNull !== undefined) {
    if (!andersonDarling.rejectNull) votes++;
    total++;
  }
  
  if (jarqueBera && jarqueBera.rejectNull !== undefined) {
    if (!jarqueBera.rejectNull) votes++;
    total++;
  }
  
  return total > 0 && votes / total > 0.5;
}

function interpretDistribution(tests, transformations) {
  const interpretations = [];
  
  if (tests.normality.isNormal) {
    interpretations.push('Data follows a normal distribution');
  } else if (tests.normality.jarqueBera) {
    if (tests.normality.jarqueBera.skewness > 1) {
      interpretations.push('Data is right-skewed');
    } else if (tests.normality.jarqueBera.skewness < -1) {
      interpretations.push('Data is left-skewed');
    }
    
    if (tests.normality.jarqueBera.kurtosis > 1) {
      interpretations.push('Distribution has heavy tails (leptokurtic)');
    } else if (tests.normality.jarqueBera.kurtosis < -1) {
      interpretations.push('Distribution has light tails (platykurtic)');
    }
  }
  
  if (tests.bestFit && tests.bestFit.distribution !== 'none') {
    interpretations.push(tests.bestFit.interpretation);
  }
  
  if (transformations.length > 0) {
    interpretations.push(`Consider ${transformations[0].type} transformation to normalize data`);
  }
  
  return interpretations.join('. ');
}

function detectOutliers(values, columnName) {
  const numbers = values.filter(v => typeof v === 'number' && !isNaN(v));
  
  if (numbers.length < 4) {
    return {
      column: columnName,
      totalRecords: values.length,
      numericRecords: numbers.length,
      methods: {},
      contextual: { patterns: [], recommendations: [] },
      aggregated: [],
      summary: 'Insufficient data for outlier detection (n < 4)'
    };
  }
  
  const sorted = [...numbers].sort((a, b) => a - b);
  
  // Run multiple outlier detection methods
  const methods = {
    iqr: detectIQROutliers(sorted),
    modifiedZScore: detectModifiedZScoreOutliers(sorted),
    gesd: numbers.length >= 25 ? detectGESDOutliers(sorted) : null,
    isolation: detectIsolationOutliers(numbers),
    grubbs: numbers.length >= 7 ? grubbsTest(sorted) : null
  };
  
  // Contextual analysis
  const contextual = analyzeOutlierContext(values, methods);
  
  // Aggregate outliers
  const allOutliers = aggregateOutliers(methods);
  
  return {
    column: columnName,
    totalRecords: values.length,
    numericRecords: numbers.length,
    methods,
    contextual,
    aggregated: allOutliers,
    summary: summarizeOutliers(methods, contextual, allOutliers)
  };
}

function detectIQROutliers(sortedValues) {
  const q1 = quantile(sortedValues, 0.25);
  const q3 = quantile(sortedValues, 0.75);
  const iqr = q3 - q1;
  
  const innerFenceLower = q1 - 1.5 * iqr;
  const innerFenceUpper = q3 + 1.5 * iqr;
  const outerFenceLower = q1 - 3 * iqr;
  const outerFenceUpper = q3 + 3 * iqr;
  
  const outliers = {
    mild: [],
    extreme: []
  };
  
  sortedValues.forEach(value => {
    if (value < outerFenceLower || value > outerFenceUpper) {
      outliers.extreme.push(value);
    } else if (value < innerFenceLower || value > innerFenceUpper) {
      outliers.mild.push(value);
    }
  });
  
  return {
    method: 'Tukey\'s Fences (IQR)',
    q1,
    q3,
    iqr,
    bounds: {
      innerLower: innerFenceLower,
      innerUpper: innerFenceUpper,
      outerLower: outerFenceLower,
      outerUpper: outerFenceUpper
    },
    outliers,
    totalOutliers: outliers.mild.length + outliers.extreme.length,
    outlierRate: (outliers.mild.length + outliers.extreme.length) / sortedValues.length * 100
  };
}

function detectModifiedZScoreOutliers(sortedValues) {
  const median$1 = median(sortedValues);
  const mad = medianAbsoluteDeviation(sortedValues);
  
  if (mad === 0) {
    return {
      method: 'Modified Z-Score (Iglewicz-Hoaglin)',
      applicable: false,
      reason: 'MAD is zero - all values may be identical'
    };
  }
  
  const threshold = 3.5;
  const outliers = [];
  const scores = [];
  
  sortedValues.forEach(value => {
    const modifiedZScore = 0.6745 * Math.abs(value - median$1) / mad;
    scores.push({ value, score: modifiedZScore });
    
    if (modifiedZScore > threshold) {
      outliers.push({
        value,
        score: modifiedZScore,
        severity: modifiedZScore > 5 ? 'extreme' : 'moderate'
      });
    }
  });
  
  return {
    method: 'Modified Z-Score (Iglewicz-Hoaglin)',
    median: median$1,
    mad,
    threshold,
    outliers,
    totalOutliers: outliers.length,
    outlierRate: outliers.length / sortedValues.length * 100,
    maxScore: Math.max(...scores.map(s => s.score))
  };
}

function detectGESDOutliers(sortedValues) {
  // Generalized Extreme Studentized Deviate test
  const alpha = 0.05;
  const maxOutliers = Math.floor(sortedValues.length * 0.1); // Test up to 10% as outliers
  
  const outliers = [];
  const testResults = [];
  let workingValues = [...sortedValues];
  
  for (let i = 0; i < maxOutliers; i++) {
    if (workingValues.length < 3) break;
    
    const mean = mean$2(workingValues);
    const stdDev = standardDeviation(workingValues);
    
    if (stdDev === 0) break;
    
    // Find the value with maximum deviation
    let maxDeviation = 0;
    let maxIndex = -1;
    let maxValue = null;
    
    workingValues.forEach((value, index) => {
      const deviation = Math.abs(value - mean) / stdDev;
      if (deviation > maxDeviation) {
        maxDeviation = deviation;
        maxIndex = index;
        maxValue = value;
      }
    });
    
    // Calculate critical value
    const n = workingValues.length;
    const tCrit = jstat.studentt.inv(1 - alpha / (2 * n), n - 2);
    const lambda = (n - 1) * tCrit / Math.sqrt(n * (n - 2 + tCrit * tCrit));
    
    testResults.push({
      iteration: i + 1,
      value: maxValue,
      statistic: maxDeviation,
      criticalValue: lambda,
      isOutlier: maxDeviation > lambda
    });
    
    if (maxDeviation > lambda) {
      outliers.push(maxValue);
      workingValues.splice(maxIndex, 1);
    } else {
      break; // No more outliers
    }
  }
  
  return {
    method: 'Generalized ESD Test',
    alpha,
    outliers,
    testResults,
    totalOutliers: outliers.length,
    outlierRate: outliers.length / sortedValues.length * 100
  };
}

function detectIsolationOutliers(values) {
  // Simplified Isolation Forest concept
  // In practice, this would use the full ml-isolation-forest library
  const n = values.length;
  const sampleSize = Math.min(256, n);
  const numTrees = 100;
  
  // Calculate isolation scores
  const scores = values.map(value => {
    let totalPathLength = 0;
    
    for (let tree = 0; tree < numTrees; tree++) {
      // Simulate isolation tree path length
      let pathLength = 0;
      let currentMin = Math.min(...values);
      let currentMax = Math.max(...values);
      let currentValue = value;
      
      while (pathLength < Math.log2(sampleSize)) {
        const splitPoint = Math.random() * (currentMax - currentMin) + currentMin;
        pathLength++;
        
        if (currentValue < splitPoint) {
          currentMax = splitPoint;
        } else {
          currentMin = splitPoint;
        }
        
        if (currentMax - currentMin < 0.001) break;
      }
      
      totalPathLength += pathLength;
    }
    
    const avgPathLength = totalPathLength / numTrees;
    const c = 2 * Math.log(sampleSize - 1) - 2 * (sampleSize - 1) / sampleSize;
    const anomalyScore = Math.pow(2, -avgPathLength / c);
    
    return { value, score: anomalyScore };
  });
  
  // Threshold for outliers (typically 0.5-0.6)
  const threshold = 0.6;
  const outliers = scores.filter(s => s.score > threshold);
  
  return {
    method: 'Isolation Forest (Simplified)',
    threshold,
    outliers: outliers.map(o => ({ value: o.value, anomalyScore: o.score })),
    totalOutliers: outliers.length,
    outlierRate: outliers.length / values.length * 100,
    averageScore: mean$2(scores.map(s => s.score))
  };
}

function grubbsTest(sortedValues) {
  const n = sortedValues.length;
  const mean = mean$2(sortedValues);
  const stdDev = standardDeviation(sortedValues);
  
  if (stdDev === 0) {
    return {
      method: 'Grubbs Test',
      applicable: false,
      reason: 'Standard deviation is zero'
    };
  }
  
  // Test for single outlier
  const deviations = sortedValues.map(v => Math.abs(v - mean));
  const maxDeviation = Math.max(...deviations);
  const maxIndex = deviations.indexOf(maxDeviation);
  const suspectValue = sortedValues[maxIndex];
  
  const G = maxDeviation / stdDev;
  
  // Critical value at 0.05 significance
  const alpha = 0.05;
  const tCrit = jstat.studentt.inv(1 - alpha / (2 * n), n - 2);
  const GCrit = ((n - 1) / Math.sqrt(n)) * Math.sqrt(tCrit * tCrit / (n - 2 + tCrit * tCrit));
  
  return {
    method: 'Grubbs Test',
    suspectValue,
    statistic: G,
    criticalValue: GCrit,
    isOutlier: G > GCrit,
    interpretation: G > GCrit ? 
      `Value ${suspectValue} is a significant outlier` : 
      'No significant outliers detected'
  };
}

function analyzeOutlierContext(allValues, methods) {
  const analysis = {
    patterns: [],
    recommendations: []
  };
  
  // Check if outliers are clustered
  const allOutlierValues = [];
  Object.values(methods).forEach(method => {
    if (method && method.outliers) {
      if (Array.isArray(method.outliers)) {
        allOutlierValues.push(...method.outliers.map(o => 
          typeof o === 'object' ? o.value : o
        ));
      } else if (method.outliers.mild) {
        allOutlierValues.push(...method.outliers.mild, ...method.outliers.extreme);
      }
    }
  });
  
  const uniqueOutliers = [...new Set(allOutlierValues)];
  
  // Check for systematic patterns
  if (uniqueOutliers.length > 0) {
    const outlierIndices = uniqueOutliers.map(v => allValues.indexOf(v));
    
    // Check if outliers appear in sequences
    const sequences = findSequences(outlierIndices.sort((a, b) => a - b));
    if (sequences.length > 0) {
      analysis.patterns.push('Outliers appear in sequences - may indicate temporal anomalies');
    }
    
    // Check if all outliers are in one direction
    const numbers = allValues.filter(v => typeof v === 'number' && !isNaN(v));
    const median$1 = median(numbers);
    const upperOutliers = uniqueOutliers.filter(v => v > median$1).length;
    const lowerOutliers = uniqueOutliers.filter(v => v < median$1).length;
    
    if (upperOutliers > 0 && lowerOutliers === 0) {
      analysis.patterns.push('All outliers are high values');
      analysis.recommendations.push('Consider if these represent legitimate peak events');
    } else if (lowerOutliers > 0 && upperOutliers === 0) {
      analysis.patterns.push('All outliers are low values');
      analysis.recommendations.push('Check for data quality issues or minimum thresholds');
    }
    
    // Check percentage of outliers
    const outlierPercentage = (uniqueOutliers.length / numbers.length) * 100;
    if (outlierPercentage > 10) {
      analysis.patterns.push(`High outlier rate (${outlierPercentage.toFixed(1)}%)`);
      analysis.recommendations.push('Review if these are true anomalies or natural variation');
    }
  }
  
  return analysis;
}

function findSequences(indices) {
  const sequences = [];
  let currentSequence = [indices[0]];
  
  for (let i = 1; i < indices.length; i++) {
    if (indices[i] - indices[i-1] === 1) {
      currentSequence.push(indices[i]);
    } else {
      if (currentSequence.length >= 3) {
        sequences.push(currentSequence);
      }
      currentSequence = [indices[i]];
    }
  }
  
  if (currentSequence.length >= 3) {
    sequences.push(currentSequence);
  }
  
  return sequences;
}

function aggregateOutliers(methods) {
  const outlierCounts = {};
  
  // Count how many methods flag each value
  Object.entries(methods).forEach(([methodName, result]) => {
    if (!result || !result.outliers) return;
    
    let outlierValues = [];
    if (Array.isArray(result.outliers)) {
      outlierValues = result.outliers.map(o => 
        typeof o === 'object' ? o.value : o
      );
    } else if (result.outliers.mild) {
      outlierValues = [...result.outliers.mild, ...result.outliers.extreme];
    }
    
    outlierValues.forEach(value => {
      if (!outlierCounts[value]) {
        outlierCounts[value] = { value, methods: [], confidence: 'low' };
      }
      outlierCounts[value].methods.push(methodName);
    });
  });
  
  // Classify confidence based on agreement
  const outliers = Object.values(outlierCounts);
  outliers.forEach(outlier => {
    const methodCount = outlier.methods.length;
    if (methodCount >= 4) {
      outlier.confidence = 'very high';
    } else if (methodCount >= 3) {
      outlier.confidence = 'high';
    } else if (methodCount >= 2) {
      outlier.confidence = 'medium';
    } else {
      outlier.confidence = 'low';
    }
  });
  
  return outliers.sort((a, b) => b.methods.length - a.methods.length);
}

function summarizeOutliers(methods, contextual, aggregated) {
  const summary = [];
  
  Object.values(methods).filter(m => m && m.totalOutliers !== undefined).length;
  const methodsWithOutliers = Object.values(methods).filter(m => m && m.totalOutliers > 0).length;
  
  if (methodsWithOutliers === 0) {
    summary.push('No outliers detected by any method');
  } else {
    const highConfidence = aggregated.filter(o => o.confidence === 'high' || o.confidence === 'very high');
    const topOutliers = aggregated.slice(0, 5).map(o => o.value);
    
    summary.push(`${aggregated.length} potential outliers detected`);
    summary.push(`${highConfidence.length} high-confidence outliers`);
    summary.push(`Top extreme values: [${topOutliers.join(', ')}]`);
    
    if (contextual.patterns.length > 0) {
      summary.push(`Patterns: ${contextual.patterns[0]}`);
    }
    
    if (contextual.recommendations.length > 0) {
      summary.push(`Recommendation: ${contextual.recommendations[0]}`);
    }
  }
  
  return summary.join('\n');
}

var matrix$1 = {};

// eslint-disable-next-line @typescript-eslint/unbound-method
const toString$2 = Object.prototype.toString;
/**
 * Checks if an object is an instance of an Array (array or typed array, except those that contain bigint values).
 *
 * @param value - Object to check.
 * @returns True if the object is an array or a typed array.
 */
function isAnyArray(value) {
    const tag = toString$2.call(value);
    return tag.endsWith('Array]') && !tag.includes('Big');
}

var libEsm = /*#__PURE__*/Object.freeze({
	__proto__: null,
	isAnyArray: isAnyArray
});

function max(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isAnyArray(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var _options$fromIndex = options.fromIndex,
      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
      _options$toIndex = options.toIndex,
      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
  }

  var maxValue = input[fromIndex];

  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] > maxValue) maxValue = input[i];
  }

  return maxValue;
}

function min(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isAnyArray(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var _options$fromIndex = options.fromIndex,
      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
      _options$toIndex = options.toIndex,
      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
  }

  var minValue = input[fromIndex];

  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] < minValue) minValue = input[i];
  }

  return minValue;
}

function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isAnyArray(input)) {
    throw new TypeError('input must be an array');
  } else if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var output;

  if (options.output !== undefined) {
    if (!isAnyArray(options.output)) {
      throw new TypeError('output option must be an array if specified');
    }

    output = options.output;
  } else {
    output = new Array(input.length);
  }

  var currentMin = min(input);
  var currentMax = max(input);

  if (currentMin === currentMax) {
    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
  }

  var _options$min = options.min,
      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
      _options$max = options.max,
      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

  if (minValue >= maxValue) {
    throw new RangeError('min option must be smaller than max option');
  }

  var factor = (maxValue - minValue) / (currentMax - currentMin);

  for (var i = 0; i < input.length; i++) {
    output[i] = (input[i] - currentMin) * factor + minValue;
  }

  return output;
}

var hasRequiredMatrix;

function requireMatrix () {
	if (hasRequiredMatrix) return matrix$1;
	hasRequiredMatrix = 1;

	Object.defineProperty(matrix$1, '__esModule', { value: true });

	var isAnyArray = libEsm;
	var rescale$1 = rescale;

	const indent = ' '.repeat(2);
	const indentData = ' '.repeat(4);

	/**
	 * @this {Matrix}
	 * @returns {string}
	 */
	function inspectMatrix() {
	  return inspectMatrixWithOptions(this);
	}

	function inspectMatrixWithOptions(matrix, options = {}) {
	  const {
	    maxRows = 15,
	    maxColumns = 10,
	    maxNumSize = 8,
	    padMinus = 'auto',
	  } = options;
	  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
	}

	function inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus) {
	  const { rows, columns } = matrix;
	  const maxI = Math.min(rows, maxRows);
	  const maxJ = Math.min(columns, maxColumns);
	  const result = [];

	  if (padMinus === 'auto') {
	    padMinus = false;
	    loop: for (let i = 0; i < maxI; i++) {
	      for (let j = 0; j < maxJ; j++) {
	        if (matrix.get(i, j) < 0) {
	          padMinus = true;
	          break loop;
	        }
	      }
	    }
	  }

	  for (let i = 0; i < maxI; i++) {
	    let line = [];
	    for (let j = 0; j < maxJ; j++) {
	      line.push(formatNumber(matrix.get(i, j), maxNumSize, padMinus));
	    }
	    result.push(`${line.join(' ')}`);
	  }
	  if (maxJ !== columns) {
	    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
	  }
	  if (maxI !== rows) {
	    result.push(`... ${rows - maxRows} more rows`);
	  }
	  return result.join(`\n${indentData}`);
	}

	function formatNumber(num, maxNumSize, padMinus) {
	  return (
	    num >= 0 && padMinus
	      ? ` ${formatNumber2(num, maxNumSize - 1)}`
	      : formatNumber2(num, maxNumSize)
	  ).padEnd(maxNumSize);
	}

	function formatNumber2(num, len) {
	  // small.length numbers should be as is
	  let str = num.toString();
	  if (str.length <= len) return str;

	  // (7)'0.00123' is better then (7)'1.23e-2'
	  // (8)'0.000123' is worse then (7)'1.23e-3',
	  let fix = num.toFixed(len);
	  if (fix.length > len) {
	    fix = num.toFixed(Math.max(0, len - (fix.length - len)));
	  }
	  if (
	    fix.length <= len &&
	    !fix.startsWith('0.000') &&
	    !fix.startsWith('-0.000')
	  ) {
	    return fix;
	  }

	  // well, if it's still too long the user should've used longer numbers
	  let exp = num.toExponential(len);
	  if (exp.length > len) {
	    exp = num.toExponential(Math.max(0, len - (exp.length - len)));
	  }
	  return exp.slice(0);
	}

	function installMathOperations(AbstractMatrix, Matrix) {
	  AbstractMatrix.prototype.add = function add(value) {
	    if (typeof value === 'number') return this.addS(value);
	    return this.addM(value);
	  };

	  AbstractMatrix.prototype.addS = function addS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) + value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.addM = function addM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) + matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.add = function add(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.add(value);
	  };

	  AbstractMatrix.prototype.sub = function sub(value) {
	    if (typeof value === 'number') return this.subS(value);
	    return this.subM(value);
	  };

	  AbstractMatrix.prototype.subS = function subS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) - value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.subM = function subM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) - matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.sub = function sub(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.sub(value);
	  };
	  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;
	  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;
	  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;
	  AbstractMatrix.subtract = AbstractMatrix.sub;

	  AbstractMatrix.prototype.mul = function mul(value) {
	    if (typeof value === 'number') return this.mulS(value);
	    return this.mulM(value);
	  };

	  AbstractMatrix.prototype.mulS = function mulS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) * value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.mulM = function mulM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) * matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.mul = function mul(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.mul(value);
	  };
	  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;
	  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;
	  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;
	  AbstractMatrix.multiply = AbstractMatrix.mul;

	  AbstractMatrix.prototype.div = function div(value) {
	    if (typeof value === 'number') return this.divS(value);
	    return this.divM(value);
	  };

	  AbstractMatrix.prototype.divS = function divS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) / value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.divM = function divM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) / matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.div = function div(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.div(value);
	  };
	  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;
	  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;
	  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;
	  AbstractMatrix.divide = AbstractMatrix.div;

	  AbstractMatrix.prototype.mod = function mod(value) {
	    if (typeof value === 'number') return this.modS(value);
	    return this.modM(value);
	  };

	  AbstractMatrix.prototype.modS = function modS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) % value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.modM = function modM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) % matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.mod = function mod(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.mod(value);
	  };
	  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;
	  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;
	  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;
	  AbstractMatrix.modulus = AbstractMatrix.mod;

	  AbstractMatrix.prototype.and = function and(value) {
	    if (typeof value === 'number') return this.andS(value);
	    return this.andM(value);
	  };

	  AbstractMatrix.prototype.andS = function andS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) & value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.andM = function andM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) & matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.and = function and(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.and(value);
	  };

	  AbstractMatrix.prototype.or = function or(value) {
	    if (typeof value === 'number') return this.orS(value);
	    return this.orM(value);
	  };

	  AbstractMatrix.prototype.orS = function orS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) | value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.orM = function orM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) | matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.or = function or(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.or(value);
	  };

	  AbstractMatrix.prototype.xor = function xor(value) {
	    if (typeof value === 'number') return this.xorS(value);
	    return this.xorM(value);
	  };

	  AbstractMatrix.prototype.xorS = function xorS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) ^ value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.xorM = function xorM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.xor = function xor(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.xor(value);
	  };

	  AbstractMatrix.prototype.leftShift = function leftShift(value) {
	    if (typeof value === 'number') return this.leftShiftS(value);
	    return this.leftShiftM(value);
	  };

	  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) << value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) << matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.leftShift = function leftShift(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.leftShift(value);
	  };

	  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
	    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);
	    return this.signPropagatingRightShiftM(value);
	  };

	  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) >> value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) >> matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.signPropagatingRightShift(value);
	  };

	  AbstractMatrix.prototype.rightShift = function rightShift(value) {
	    if (typeof value === 'number') return this.rightShiftS(value);
	    return this.rightShiftM(value);
	  };

	  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) >>> value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.rightShift = function rightShift(matrix, value) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.rightShift(value);
	  };
	  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;
	  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;
	  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;
	  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;

	  AbstractMatrix.prototype.not = function not() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, ~(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.not = function not(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.not();
	  };

	  AbstractMatrix.prototype.abs = function abs() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.abs(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.abs = function abs(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.abs();
	  };

	  AbstractMatrix.prototype.acos = function acos() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.acos(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.acos = function acos(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.acos();
	  };

	  AbstractMatrix.prototype.acosh = function acosh() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.acosh(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.acosh = function acosh(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.acosh();
	  };

	  AbstractMatrix.prototype.asin = function asin() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.asin(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.asin = function asin(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.asin();
	  };

	  AbstractMatrix.prototype.asinh = function asinh() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.asinh(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.asinh = function asinh(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.asinh();
	  };

	  AbstractMatrix.prototype.atan = function atan() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.atan(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.atan = function atan(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.atan();
	  };

	  AbstractMatrix.prototype.atanh = function atanh() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.atanh(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.atanh = function atanh(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.atanh();
	  };

	  AbstractMatrix.prototype.cbrt = function cbrt() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.cbrt(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.cbrt = function cbrt(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.cbrt();
	  };

	  AbstractMatrix.prototype.ceil = function ceil() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.ceil(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.ceil = function ceil(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.ceil();
	  };

	  AbstractMatrix.prototype.clz32 = function clz32() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.clz32(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.clz32 = function clz32(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.clz32();
	  };

	  AbstractMatrix.prototype.cos = function cos() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.cos(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.cos = function cos(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.cos();
	  };

	  AbstractMatrix.prototype.cosh = function cosh() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.cosh(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.cosh = function cosh(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.cosh();
	  };

	  AbstractMatrix.prototype.exp = function exp() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.exp(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.exp = function exp(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.exp();
	  };

	  AbstractMatrix.prototype.expm1 = function expm1() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.expm1(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.expm1 = function expm1(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.expm1();
	  };

	  AbstractMatrix.prototype.floor = function floor() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.floor(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.floor = function floor(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.floor();
	  };

	  AbstractMatrix.prototype.fround = function fround() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.fround(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.fround = function fround(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.fround();
	  };

	  AbstractMatrix.prototype.log = function log() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.log(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.log = function log(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.log();
	  };

	  AbstractMatrix.prototype.log1p = function log1p() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.log1p(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.log1p = function log1p(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.log1p();
	  };

	  AbstractMatrix.prototype.log10 = function log10() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.log10(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.log10 = function log10(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.log10();
	  };

	  AbstractMatrix.prototype.log2 = function log2() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.log2(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.log2 = function log2(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.log2();
	  };

	  AbstractMatrix.prototype.round = function round() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.round(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.round = function round(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.round();
	  };

	  AbstractMatrix.prototype.sign = function sign() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.sign(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.sign = function sign(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.sign();
	  };

	  AbstractMatrix.prototype.sin = function sin() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.sin(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.sin = function sin(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.sin();
	  };

	  AbstractMatrix.prototype.sinh = function sinh() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.sinh(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.sinh = function sinh(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.sinh();
	  };

	  AbstractMatrix.prototype.sqrt = function sqrt() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.sqrt(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.sqrt = function sqrt(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.sqrt();
	  };

	  AbstractMatrix.prototype.tan = function tan() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.tan(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.tan = function tan(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.tan();
	  };

	  AbstractMatrix.prototype.tanh = function tanh() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.tanh(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.tanh = function tanh(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.tanh();
	  };

	  AbstractMatrix.prototype.trunc = function trunc() {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, Math.trunc(this.get(i, j)));
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.trunc = function trunc(matrix) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.trunc();
	  };

	  AbstractMatrix.pow = function pow(matrix, arg0) {
	    const newMatrix = new Matrix(matrix);
	    return newMatrix.pow(arg0);
	  };

	  AbstractMatrix.prototype.pow = function pow(value) {
	    if (typeof value === 'number') return this.powS(value);
	    return this.powM(value);
	  };

	  AbstractMatrix.prototype.powS = function powS(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) ** value);
	      }
	    }
	    return this;
	  };

	  AbstractMatrix.prototype.powM = function powM(matrix) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	      this.columns !== matrix.columns) {
	      throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) ** matrix.get(i, j));
	      }
	    }
	    return this;
	  };
	}

	/**
	 * @private
	 * Check that a row index is not out of bounds
	 * @param {Matrix} matrix
	 * @param {number} index
	 * @param {boolean} [outer]
	 */
	function checkRowIndex(matrix, index, outer) {
	  let max = outer ? matrix.rows : matrix.rows - 1;
	  if (index < 0 || index > max) {
	    throw new RangeError('Row index out of range');
	  }
	}

	/**
	 * @private
	 * Check that a column index is not out of bounds
	 * @param {Matrix} matrix
	 * @param {number} index
	 * @param {boolean} [outer]
	 */
	function checkColumnIndex(matrix, index, outer) {
	  let max = outer ? matrix.columns : matrix.columns - 1;
	  if (index < 0 || index > max) {
	    throw new RangeError('Column index out of range');
	  }
	}

	/**
	 * @private
	 * Check that the provided vector is an array with the right length
	 * @param {Matrix} matrix
	 * @param {Array|Matrix} vector
	 * @return {Array}
	 * @throws {RangeError}
	 */
	function checkRowVector(matrix, vector) {
	  if (vector.to1DArray) {
	    vector = vector.to1DArray();
	  }
	  if (vector.length !== matrix.columns) {
	    throw new RangeError(
	      'vector size must be the same as the number of columns',
	    );
	  }
	  return vector;
	}

	/**
	 * @private
	 * Check that the provided vector is an array with the right length
	 * @param {Matrix} matrix
	 * @param {Array|Matrix} vector
	 * @return {Array}
	 * @throws {RangeError}
	 */
	function checkColumnVector(matrix, vector) {
	  if (vector.to1DArray) {
	    vector = vector.to1DArray();
	  }
	  if (vector.length !== matrix.rows) {
	    throw new RangeError('vector size must be the same as the number of rows');
	  }
	  return vector;
	}

	function checkRowIndices(matrix, rowIndices) {
	  if (!isAnyArray.isAnyArray(rowIndices)) {
	    throw new TypeError('row indices must be an array');
	  }

	  for (let i = 0; i < rowIndices.length; i++) {
	    if (rowIndices[i] < 0 || rowIndices[i] >= matrix.rows) {
	      throw new RangeError('row indices are out of range');
	    }
	  }
	}

	function checkColumnIndices(matrix, columnIndices) {
	  if (!isAnyArray.isAnyArray(columnIndices)) {
	    throw new TypeError('column indices must be an array');
	  }

	  for (let i = 0; i < columnIndices.length; i++) {
	    if (columnIndices[i] < 0 || columnIndices[i] >= matrix.columns) {
	      throw new RangeError('column indices are out of range');
	    }
	  }
	}

	function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
	  if (arguments.length !== 5) {
	    throw new RangeError('expected 4 arguments');
	  }
	  checkNumber('startRow', startRow);
	  checkNumber('endRow', endRow);
	  checkNumber('startColumn', startColumn);
	  checkNumber('endColumn', endColumn);
	  if (
	    startRow > endRow ||
	    startColumn > endColumn ||
	    startRow < 0 ||
	    startRow >= matrix.rows ||
	    endRow < 0 ||
	    endRow >= matrix.rows ||
	    startColumn < 0 ||
	    startColumn >= matrix.columns ||
	    endColumn < 0 ||
	    endColumn >= matrix.columns
	  ) {
	    throw new RangeError('Submatrix indices are out of range');
	  }
	}

	function newArray(length, value = 0) {
	  let array = [];
	  for (let i = 0; i < length; i++) {
	    array.push(value);
	  }
	  return array;
	}

	function checkNumber(name, value) {
	  if (typeof value !== 'number') {
	    throw new TypeError(`${name} must be a number`);
	  }
	}

	function checkNonEmpty(matrix) {
	  if (matrix.isEmpty()) {
	    throw new Error('Empty matrix has no elements to index');
	  }
	}

	function sumByRow(matrix) {
	  let sum = newArray(matrix.rows);
	  for (let i = 0; i < matrix.rows; ++i) {
	    for (let j = 0; j < matrix.columns; ++j) {
	      sum[i] += matrix.get(i, j);
	    }
	  }
	  return sum;
	}

	function sumByColumn(matrix) {
	  let sum = newArray(matrix.columns);
	  for (let i = 0; i < matrix.rows; ++i) {
	    for (let j = 0; j < matrix.columns; ++j) {
	      sum[j] += matrix.get(i, j);
	    }
	  }
	  return sum;
	}

	function sumAll(matrix) {
	  let v = 0;
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      v += matrix.get(i, j);
	    }
	  }
	  return v;
	}

	function productByRow(matrix) {
	  let sum = newArray(matrix.rows, 1);
	  for (let i = 0; i < matrix.rows; ++i) {
	    for (let j = 0; j < matrix.columns; ++j) {
	      sum[i] *= matrix.get(i, j);
	    }
	  }
	  return sum;
	}

	function productByColumn(matrix) {
	  let sum = newArray(matrix.columns, 1);
	  for (let i = 0; i < matrix.rows; ++i) {
	    for (let j = 0; j < matrix.columns; ++j) {
	      sum[j] *= matrix.get(i, j);
	    }
	  }
	  return sum;
	}

	function productAll(matrix) {
	  let v = 1;
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      v *= matrix.get(i, j);
	    }
	  }
	  return v;
	}

	function varianceByRow(matrix, unbiased, mean) {
	  const rows = matrix.rows;
	  const cols = matrix.columns;
	  const variance = [];

	  for (let i = 0; i < rows; i++) {
	    let sum1 = 0;
	    let sum2 = 0;
	    let x = 0;
	    for (let j = 0; j < cols; j++) {
	      x = matrix.get(i, j) - mean[i];
	      sum1 += x;
	      sum2 += x * x;
	    }
	    if (unbiased) {
	      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));
	    } else {
	      variance.push((sum2 - (sum1 * sum1) / cols) / cols);
	    }
	  }
	  return variance;
	}

	function varianceByColumn(matrix, unbiased, mean) {
	  const rows = matrix.rows;
	  const cols = matrix.columns;
	  const variance = [];

	  for (let j = 0; j < cols; j++) {
	    let sum1 = 0;
	    let sum2 = 0;
	    let x = 0;
	    for (let i = 0; i < rows; i++) {
	      x = matrix.get(i, j) - mean[j];
	      sum1 += x;
	      sum2 += x * x;
	    }
	    if (unbiased) {
	      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));
	    } else {
	      variance.push((sum2 - (sum1 * sum1) / rows) / rows);
	    }
	  }
	  return variance;
	}

	function varianceAll(matrix, unbiased, mean) {
	  const rows = matrix.rows;
	  const cols = matrix.columns;
	  const size = rows * cols;

	  let sum1 = 0;
	  let sum2 = 0;
	  let x = 0;
	  for (let i = 0; i < rows; i++) {
	    for (let j = 0; j < cols; j++) {
	      x = matrix.get(i, j) - mean;
	      sum1 += x;
	      sum2 += x * x;
	    }
	  }
	  if (unbiased) {
	    return (sum2 - (sum1 * sum1) / size) / (size - 1);
	  } else {
	    return (sum2 - (sum1 * sum1) / size) / size;
	  }
	}

	function centerByRow(matrix, mean) {
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      matrix.set(i, j, matrix.get(i, j) - mean[i]);
	    }
	  }
	}

	function centerByColumn(matrix, mean) {
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      matrix.set(i, j, matrix.get(i, j) - mean[j]);
	    }
	  }
	}

	function centerAll(matrix, mean) {
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      matrix.set(i, j, matrix.get(i, j) - mean);
	    }
	  }
	}

	function getScaleByRow(matrix) {
	  const scale = [];
	  for (let i = 0; i < matrix.rows; i++) {
	    let sum = 0;
	    for (let j = 0; j < matrix.columns; j++) {
	      sum += matrix.get(i, j) ** 2 / (matrix.columns - 1);
	    }
	    scale.push(Math.sqrt(sum));
	  }
	  return scale;
	}

	function scaleByRow(matrix, scale) {
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      matrix.set(i, j, matrix.get(i, j) / scale[i]);
	    }
	  }
	}

	function getScaleByColumn(matrix) {
	  const scale = [];
	  for (let j = 0; j < matrix.columns; j++) {
	    let sum = 0;
	    for (let i = 0; i < matrix.rows; i++) {
	      sum += matrix.get(i, j) ** 2 / (matrix.rows - 1);
	    }
	    scale.push(Math.sqrt(sum));
	  }
	  return scale;
	}

	function scaleByColumn(matrix, scale) {
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      matrix.set(i, j, matrix.get(i, j) / scale[j]);
	    }
	  }
	}

	function getScaleAll(matrix) {
	  const divider = matrix.size - 1;
	  let sum = 0;
	  for (let j = 0; j < matrix.columns; j++) {
	    for (let i = 0; i < matrix.rows; i++) {
	      sum += matrix.get(i, j) ** 2 / divider;
	    }
	  }
	  return Math.sqrt(sum);
	}

	function scaleAll(matrix, scale) {
	  for (let i = 0; i < matrix.rows; i++) {
	    for (let j = 0; j < matrix.columns; j++) {
	      matrix.set(i, j, matrix.get(i, j) / scale);
	    }
	  }
	}

	class AbstractMatrix {
	  static from1DArray(newRows, newColumns, newData) {
	    let length = newRows * newColumns;
	    if (length !== newData.length) {
	      throw new RangeError('data length does not match given dimensions');
	    }
	    let newMatrix = new Matrix(newRows, newColumns);
	    for (let row = 0; row < newRows; row++) {
	      for (let column = 0; column < newColumns; column++) {
	        newMatrix.set(row, column, newData[row * newColumns + column]);
	      }
	    }
	    return newMatrix;
	  }

	  static rowVector(newData) {
	    let vector = new Matrix(1, newData.length);
	    for (let i = 0; i < newData.length; i++) {
	      vector.set(0, i, newData[i]);
	    }
	    return vector;
	  }

	  static columnVector(newData) {
	    let vector = new Matrix(newData.length, 1);
	    for (let i = 0; i < newData.length; i++) {
	      vector.set(i, 0, newData[i]);
	    }
	    return vector;
	  }

	  static zeros(rows, columns) {
	    return new Matrix(rows, columns);
	  }

	  static ones(rows, columns) {
	    return new Matrix(rows, columns).fill(1);
	  }

	  static rand(rows, columns, options = {}) {
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { random = Math.random } = options;
	    let matrix = new Matrix(rows, columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        matrix.set(i, j, random());
	      }
	    }
	    return matrix;
	  }

	  static randInt(rows, columns, options = {}) {
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { min = 0, max = 1000, random = Math.random } = options;
	    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');
	    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');
	    if (min >= max) throw new RangeError('min must be smaller than max');
	    let interval = max - min;
	    let matrix = new Matrix(rows, columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        let value = min + Math.round(random() * interval);
	        matrix.set(i, j, value);
	      }
	    }
	    return matrix;
	  }

	  static eye(rows, columns, value) {
	    if (columns === undefined) columns = rows;
	    if (value === undefined) value = 1;
	    let min = Math.min(rows, columns);
	    let matrix = this.zeros(rows, columns);
	    for (let i = 0; i < min; i++) {
	      matrix.set(i, i, value);
	    }
	    return matrix;
	  }

	  static diag(data, rows, columns) {
	    let l = data.length;
	    if (rows === undefined) rows = l;
	    if (columns === undefined) columns = rows;
	    let min = Math.min(l, rows, columns);
	    let matrix = this.zeros(rows, columns);
	    for (let i = 0; i < min; i++) {
	      matrix.set(i, i, data[i]);
	    }
	    return matrix;
	  }

	  static min(matrix1, matrix2) {
	    matrix1 = this.checkMatrix(matrix1);
	    matrix2 = this.checkMatrix(matrix2);
	    let rows = matrix1.rows;
	    let columns = matrix1.columns;
	    let result = new Matrix(rows, columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
	      }
	    }
	    return result;
	  }

	  static max(matrix1, matrix2) {
	    matrix1 = this.checkMatrix(matrix1);
	    matrix2 = this.checkMatrix(matrix2);
	    let rows = matrix1.rows;
	    let columns = matrix1.columns;
	    let result = new this(rows, columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
	      }
	    }
	    return result;
	  }

	  static checkMatrix(value) {
	    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
	  }

	  static isMatrix(value) {
	    return value != null && value.klass === 'Matrix';
	  }

	  get size() {
	    return this.rows * this.columns;
	  }

	  apply(callback) {
	    if (typeof callback !== 'function') {
	      throw new TypeError('callback must be a function');
	    }
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        callback.call(this, i, j);
	      }
	    }
	    return this;
	  }

	  to1DArray() {
	    let array = [];
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        array.push(this.get(i, j));
	      }
	    }
	    return array;
	  }

	  to2DArray() {
	    let copy = [];
	    for (let i = 0; i < this.rows; i++) {
	      copy.push([]);
	      for (let j = 0; j < this.columns; j++) {
	        copy[i].push(this.get(i, j));
	      }
	    }
	    return copy;
	  }

	  toJSON() {
	    return this.to2DArray();
	  }

	  isRowVector() {
	    return this.rows === 1;
	  }

	  isColumnVector() {
	    return this.columns === 1;
	  }

	  isVector() {
	    return this.rows === 1 || this.columns === 1;
	  }

	  isSquare() {
	    return this.rows === this.columns;
	  }

	  isEmpty() {
	    return this.rows === 0 || this.columns === 0;
	  }

	  isSymmetric() {
	    if (this.isSquare()) {
	      for (let i = 0; i < this.rows; i++) {
	        for (let j = 0; j <= i; j++) {
	          if (this.get(i, j) !== this.get(j, i)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	    return false;
	  }

	  isDistance() {
	    if (!this.isSymmetric()) return false;

	    for (let i = 0; i < this.rows; i++) {
	      if (this.get(i, i) !== 0) return false;
	    }

	    return true;
	  }

	  isEchelonForm() {
	    let i = 0;
	    let j = 0;
	    let previousColumn = -1;
	    let isEchelonForm = true;
	    let checked = false;
	    while (i < this.rows && isEchelonForm) {
	      j = 0;
	      checked = false;
	      while (j < this.columns && checked === false) {
	        if (this.get(i, j) === 0) {
	          j++;
	        } else if (this.get(i, j) === 1 && j > previousColumn) {
	          checked = true;
	          previousColumn = j;
	        } else {
	          isEchelonForm = false;
	          checked = true;
	        }
	      }
	      i++;
	    }
	    return isEchelonForm;
	  }

	  isReducedEchelonForm() {
	    let i = 0;
	    let j = 0;
	    let previousColumn = -1;
	    let isReducedEchelonForm = true;
	    let checked = false;
	    while (i < this.rows && isReducedEchelonForm) {
	      j = 0;
	      checked = false;
	      while (j < this.columns && checked === false) {
	        if (this.get(i, j) === 0) {
	          j++;
	        } else if (this.get(i, j) === 1 && j > previousColumn) {
	          checked = true;
	          previousColumn = j;
	        } else {
	          isReducedEchelonForm = false;
	          checked = true;
	        }
	      }
	      for (let k = j + 1; k < this.rows; k++) {
	        if (this.get(i, k) !== 0) {
	          isReducedEchelonForm = false;
	        }
	      }
	      i++;
	    }
	    return isReducedEchelonForm;
	  }

	  echelonForm() {
	    let result = this.clone();
	    let h = 0;
	    let k = 0;
	    while (h < result.rows && k < result.columns) {
	      let iMax = h;
	      for (let i = h; i < result.rows; i++) {
	        if (result.get(i, k) > result.get(iMax, k)) {
	          iMax = i;
	        }
	      }
	      if (result.get(iMax, k) === 0) {
	        k++;
	      } else {
	        result.swapRows(h, iMax);
	        let tmp = result.get(h, k);
	        for (let j = k; j < result.columns; j++) {
	          result.set(h, j, result.get(h, j) / tmp);
	        }
	        for (let i = h + 1; i < result.rows; i++) {
	          let factor = result.get(i, k) / result.get(h, k);
	          result.set(i, k, 0);
	          for (let j = k + 1; j < result.columns; j++) {
	            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
	          }
	        }
	        h++;
	        k++;
	      }
	    }
	    return result;
	  }

	  reducedEchelonForm() {
	    let result = this.echelonForm();
	    let m = result.columns;
	    let n = result.rows;
	    let h = n - 1;
	    while (h >= 0) {
	      if (result.maxRow(h) === 0) {
	        h--;
	      } else {
	        let p = 0;
	        let pivot = false;
	        while (p < n && pivot === false) {
	          if (result.get(h, p) === 1) {
	            pivot = true;
	          } else {
	            p++;
	          }
	        }
	        for (let i = 0; i < h; i++) {
	          let factor = result.get(i, p);
	          for (let j = p; j < m; j++) {
	            let tmp = result.get(i, j) - factor * result.get(h, j);
	            result.set(i, j, tmp);
	          }
	        }
	        h--;
	      }
	    }
	    return result;
	  }

	  set() {
	    throw new Error('set method is unimplemented');
	  }

	  get() {
	    throw new Error('get method is unimplemented');
	  }

	  repeat(options = {}) {
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { rows = 1, columns = 1 } = options;
	    if (!Number.isInteger(rows) || rows <= 0) {
	      throw new TypeError('rows must be a positive integer');
	    }
	    if (!Number.isInteger(columns) || columns <= 0) {
	      throw new TypeError('columns must be a positive integer');
	    }
	    let matrix = new Matrix(this.rows * rows, this.columns * columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        matrix.setSubMatrix(this, this.rows * i, this.columns * j);
	      }
	    }
	    return matrix;
	  }

	  fill(value) {
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, value);
	      }
	    }
	    return this;
	  }

	  neg() {
	    return this.mulS(-1);
	  }

	  getRow(index) {
	    checkRowIndex(this, index);
	    let row = [];
	    for (let i = 0; i < this.columns; i++) {
	      row.push(this.get(index, i));
	    }
	    return row;
	  }

	  getRowVector(index) {
	    return Matrix.rowVector(this.getRow(index));
	  }

	  setRow(index, array) {
	    checkRowIndex(this, index);
	    array = checkRowVector(this, array);
	    for (let i = 0; i < this.columns; i++) {
	      this.set(index, i, array[i]);
	    }
	    return this;
	  }

	  swapRows(row1, row2) {
	    checkRowIndex(this, row1);
	    checkRowIndex(this, row2);
	    for (let i = 0; i < this.columns; i++) {
	      let temp = this.get(row1, i);
	      this.set(row1, i, this.get(row2, i));
	      this.set(row2, i, temp);
	    }
	    return this;
	  }

	  getColumn(index) {
	    checkColumnIndex(this, index);
	    let column = [];
	    for (let i = 0; i < this.rows; i++) {
	      column.push(this.get(i, index));
	    }
	    return column;
	  }

	  getColumnVector(index) {
	    return Matrix.columnVector(this.getColumn(index));
	  }

	  setColumn(index, array) {
	    checkColumnIndex(this, index);
	    array = checkColumnVector(this, array);
	    for (let i = 0; i < this.rows; i++) {
	      this.set(i, index, array[i]);
	    }
	    return this;
	  }

	  swapColumns(column1, column2) {
	    checkColumnIndex(this, column1);
	    checkColumnIndex(this, column2);
	    for (let i = 0; i < this.rows; i++) {
	      let temp = this.get(i, column1);
	      this.set(i, column1, this.get(i, column2));
	      this.set(i, column2, temp);
	    }
	    return this;
	  }

	  addRowVector(vector) {
	    vector = checkRowVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) + vector[j]);
	      }
	    }
	    return this;
	  }

	  subRowVector(vector) {
	    vector = checkRowVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) - vector[j]);
	      }
	    }
	    return this;
	  }

	  mulRowVector(vector) {
	    vector = checkRowVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) * vector[j]);
	      }
	    }
	    return this;
	  }

	  divRowVector(vector) {
	    vector = checkRowVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) / vector[j]);
	      }
	    }
	    return this;
	  }

	  addColumnVector(vector) {
	    vector = checkColumnVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) + vector[i]);
	      }
	    }
	    return this;
	  }

	  subColumnVector(vector) {
	    vector = checkColumnVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) - vector[i]);
	      }
	    }
	    return this;
	  }

	  mulColumnVector(vector) {
	    vector = checkColumnVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) * vector[i]);
	      }
	    }
	    return this;
	  }

	  divColumnVector(vector) {
	    vector = checkColumnVector(this, vector);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        this.set(i, j, this.get(i, j) / vector[i]);
	      }
	    }
	    return this;
	  }

	  mulRow(index, value) {
	    checkRowIndex(this, index);
	    for (let i = 0; i < this.columns; i++) {
	      this.set(index, i, this.get(index, i) * value);
	    }
	    return this;
	  }

	  mulColumn(index, value) {
	    checkColumnIndex(this, index);
	    for (let i = 0; i < this.rows; i++) {
	      this.set(i, index, this.get(i, index) * value);
	    }
	    return this;
	  }

	  max(by) {
	    if (this.isEmpty()) {
	      return NaN;
	    }
	    switch (by) {
	      case 'row': {
	        const max = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
	        for (let row = 0; row < this.rows; row++) {
	          for (let column = 0; column < this.columns; column++) {
	            if (this.get(row, column) > max[row]) {
	              max[row] = this.get(row, column);
	            }
	          }
	        }
	        return max;
	      }
	      case 'column': {
	        const max = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
	        for (let row = 0; row < this.rows; row++) {
	          for (let column = 0; column < this.columns; column++) {
	            if (this.get(row, column) > max[column]) {
	              max[column] = this.get(row, column);
	            }
	          }
	        }
	        return max;
	      }
	      case undefined: {
	        let max = this.get(0, 0);
	        for (let row = 0; row < this.rows; row++) {
	          for (let column = 0; column < this.columns; column++) {
	            if (this.get(row, column) > max) {
	              max = this.get(row, column);
	            }
	          }
	        }
	        return max;
	      }
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  maxIndex() {
	    checkNonEmpty(this);
	    let v = this.get(0, 0);
	    let idx = [0, 0];
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        if (this.get(i, j) > v) {
	          v = this.get(i, j);
	          idx[0] = i;
	          idx[1] = j;
	        }
	      }
	    }
	    return idx;
	  }

	  min(by) {
	    if (this.isEmpty()) {
	      return NaN;
	    }

	    switch (by) {
	      case 'row': {
	        const min = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
	        for (let row = 0; row < this.rows; row++) {
	          for (let column = 0; column < this.columns; column++) {
	            if (this.get(row, column) < min[row]) {
	              min[row] = this.get(row, column);
	            }
	          }
	        }
	        return min;
	      }
	      case 'column': {
	        const min = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
	        for (let row = 0; row < this.rows; row++) {
	          for (let column = 0; column < this.columns; column++) {
	            if (this.get(row, column) < min[column]) {
	              min[column] = this.get(row, column);
	            }
	          }
	        }
	        return min;
	      }
	      case undefined: {
	        let min = this.get(0, 0);
	        for (let row = 0; row < this.rows; row++) {
	          for (let column = 0; column < this.columns; column++) {
	            if (this.get(row, column) < min) {
	              min = this.get(row, column);
	            }
	          }
	        }
	        return min;
	      }
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  minIndex() {
	    checkNonEmpty(this);
	    let v = this.get(0, 0);
	    let idx = [0, 0];
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        if (this.get(i, j) < v) {
	          v = this.get(i, j);
	          idx[0] = i;
	          idx[1] = j;
	        }
	      }
	    }
	    return idx;
	  }

	  maxRow(row) {
	    checkRowIndex(this, row);
	    if (this.isEmpty()) {
	      return NaN;
	    }
	    let v = this.get(row, 0);
	    for (let i = 1; i < this.columns; i++) {
	      if (this.get(row, i) > v) {
	        v = this.get(row, i);
	      }
	    }
	    return v;
	  }

	  maxRowIndex(row) {
	    checkRowIndex(this, row);
	    checkNonEmpty(this);
	    let v = this.get(row, 0);
	    let idx = [row, 0];
	    for (let i = 1; i < this.columns; i++) {
	      if (this.get(row, i) > v) {
	        v = this.get(row, i);
	        idx[1] = i;
	      }
	    }
	    return idx;
	  }

	  minRow(row) {
	    checkRowIndex(this, row);
	    if (this.isEmpty()) {
	      return NaN;
	    }
	    let v = this.get(row, 0);
	    for (let i = 1; i < this.columns; i++) {
	      if (this.get(row, i) < v) {
	        v = this.get(row, i);
	      }
	    }
	    return v;
	  }

	  minRowIndex(row) {
	    checkRowIndex(this, row);
	    checkNonEmpty(this);
	    let v = this.get(row, 0);
	    let idx = [row, 0];
	    for (let i = 1; i < this.columns; i++) {
	      if (this.get(row, i) < v) {
	        v = this.get(row, i);
	        idx[1] = i;
	      }
	    }
	    return idx;
	  }

	  maxColumn(column) {
	    checkColumnIndex(this, column);
	    if (this.isEmpty()) {
	      return NaN;
	    }
	    let v = this.get(0, column);
	    for (let i = 1; i < this.rows; i++) {
	      if (this.get(i, column) > v) {
	        v = this.get(i, column);
	      }
	    }
	    return v;
	  }

	  maxColumnIndex(column) {
	    checkColumnIndex(this, column);
	    checkNonEmpty(this);
	    let v = this.get(0, column);
	    let idx = [0, column];
	    for (let i = 1; i < this.rows; i++) {
	      if (this.get(i, column) > v) {
	        v = this.get(i, column);
	        idx[0] = i;
	      }
	    }
	    return idx;
	  }

	  minColumn(column) {
	    checkColumnIndex(this, column);
	    if (this.isEmpty()) {
	      return NaN;
	    }
	    let v = this.get(0, column);
	    for (let i = 1; i < this.rows; i++) {
	      if (this.get(i, column) < v) {
	        v = this.get(i, column);
	      }
	    }
	    return v;
	  }

	  minColumnIndex(column) {
	    checkColumnIndex(this, column);
	    checkNonEmpty(this);
	    let v = this.get(0, column);
	    let idx = [0, column];
	    for (let i = 1; i < this.rows; i++) {
	      if (this.get(i, column) < v) {
	        v = this.get(i, column);
	        idx[0] = i;
	      }
	    }
	    return idx;
	  }

	  diag() {
	    let min = Math.min(this.rows, this.columns);
	    let diag = [];
	    for (let i = 0; i < min; i++) {
	      diag.push(this.get(i, i));
	    }
	    return diag;
	  }

	  norm(type = 'frobenius') {
	    switch (type) {
	      case 'max':
	        return this.max();
	      case 'frobenius':
	        return Math.sqrt(this.dot(this));
	      default:
	        throw new RangeError(`unknown norm type: ${type}`);
	    }
	  }

	  cumulativeSum() {
	    let sum = 0;
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        sum += this.get(i, j);
	        this.set(i, j, sum);
	      }
	    }
	    return this;
	  }

	  dot(vector2) {
	    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
	    let vector1 = this.to1DArray();
	    if (vector1.length !== vector2.length) {
	      throw new RangeError('vectors do not have the same size');
	    }
	    let dot = 0;
	    for (let i = 0; i < vector1.length; i++) {
	      dot += vector1[i] * vector2[i];
	    }
	    return dot;
	  }

	  mmul(other) {
	    other = Matrix.checkMatrix(other);

	    let m = this.rows;
	    let n = this.columns;
	    let p = other.columns;

	    let result = new Matrix(m, p);

	    let Bcolj = new Float64Array(n);
	    for (let j = 0; j < p; j++) {
	      for (let k = 0; k < n; k++) {
	        Bcolj[k] = other.get(k, j);
	      }

	      for (let i = 0; i < m; i++) {
	        let s = 0;
	        for (let k = 0; k < n; k++) {
	          s += this.get(i, k) * Bcolj[k];
	        }

	        result.set(i, j, s);
	      }
	    }
	    return result;
	  }

	  mpow(scalar) {
	    if (!this.isSquare()) {
	      throw new RangeError('Matrix must be square');
	    }
	    if (!Number.isInteger(scalar) || scalar < 0) {
	      throw new RangeError('Exponent must be a non-negative integer');
	    }
	    // Russian Peasant exponentiation, i.e. exponentiation by squaring
	    let result = Matrix.eye(this.rows);
	    let bb = this;
	    // Note: Don't bit shift. In JS, that would truncate at 32 bits
	    for (let e = scalar; e >= 1; e /= 2) {
	      if ((e & 1) !== 0) {
	        result = result.mmul(bb);
	      }
	      bb = bb.mmul(bb);
	    }
	    return result;
	  }

	  strassen2x2(other) {
	    other = Matrix.checkMatrix(other);
	    let result = new Matrix(2, 2);
	    const a11 = this.get(0, 0);
	    const b11 = other.get(0, 0);
	    const a12 = this.get(0, 1);
	    const b12 = other.get(0, 1);
	    const a21 = this.get(1, 0);
	    const b21 = other.get(1, 0);
	    const a22 = this.get(1, 1);
	    const b22 = other.get(1, 1);

	    // Compute intermediate values.
	    const m1 = (a11 + a22) * (b11 + b22);
	    const m2 = (a21 + a22) * b11;
	    const m3 = a11 * (b12 - b22);
	    const m4 = a22 * (b21 - b11);
	    const m5 = (a11 + a12) * b22;
	    const m6 = (a21 - a11) * (b11 + b12);
	    const m7 = (a12 - a22) * (b21 + b22);

	    // Combine intermediate values into the output.
	    const c00 = m1 + m4 - m5 + m7;
	    const c01 = m3 + m5;
	    const c10 = m2 + m4;
	    const c11 = m1 - m2 + m3 + m6;

	    result.set(0, 0, c00);
	    result.set(0, 1, c01);
	    result.set(1, 0, c10);
	    result.set(1, 1, c11);
	    return result;
	  }

	  strassen3x3(other) {
	    other = Matrix.checkMatrix(other);
	    let result = new Matrix(3, 3);

	    const a00 = this.get(0, 0);
	    const a01 = this.get(0, 1);
	    const a02 = this.get(0, 2);
	    const a10 = this.get(1, 0);
	    const a11 = this.get(1, 1);
	    const a12 = this.get(1, 2);
	    const a20 = this.get(2, 0);
	    const a21 = this.get(2, 1);
	    const a22 = this.get(2, 2);

	    const b00 = other.get(0, 0);
	    const b01 = other.get(0, 1);
	    const b02 = other.get(0, 2);
	    const b10 = other.get(1, 0);
	    const b11 = other.get(1, 1);
	    const b12 = other.get(1, 2);
	    const b20 = other.get(2, 0);
	    const b21 = other.get(2, 1);
	    const b22 = other.get(2, 2);

	    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
	    const m2 = (a00 - a10) * (-b01 + b11);
	    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
	    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
	    const m5 = (a10 + a11) * (-b00 + b01);
	    const m6 = a00 * b00;
	    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
	    const m8 = (-a00 + a20) * (b02 - b12);
	    const m9 = (a20 + a21) * (-b00 + b02);
	    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
	    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
	    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
	    const m13 = (a02 - a22) * (b11 - b21);
	    const m14 = a02 * b20;
	    const m15 = (a21 + a22) * (-b20 + b21);
	    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
	    const m17 = (a02 - a12) * (b12 - b22);
	    const m18 = (a11 + a12) * (-b20 + b22);
	    const m19 = a01 * b10;
	    const m20 = a12 * b21;
	    const m21 = a10 * b02;
	    const m22 = a20 * b01;
	    const m23 = a22 * b22;

	    const c00 = m6 + m14 + m19;
	    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
	    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
	    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
	    const c11 = m2 + m4 + m5 + m6 + m20;
	    const c12 = m14 + m16 + m17 + m18 + m21;
	    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
	    const c21 = m12 + m13 + m14 + m15 + m22;
	    const c22 = m6 + m7 + m8 + m9 + m23;

	    result.set(0, 0, c00);
	    result.set(0, 1, c01);
	    result.set(0, 2, c02);
	    result.set(1, 0, c10);
	    result.set(1, 1, c11);
	    result.set(1, 2, c12);
	    result.set(2, 0, c20);
	    result.set(2, 1, c21);
	    result.set(2, 2, c22);
	    return result;
	  }

	  mmulStrassen(y) {
	    y = Matrix.checkMatrix(y);
	    let x = this.clone();
	    let r1 = x.rows;
	    let c1 = x.columns;
	    let r2 = y.rows;
	    let c2 = y.columns;
	    if (c1 !== r2) {
	      // eslint-disable-next-line no-console
	      console.warn(
	        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,
	      );
	    }

	    // Put a matrix into the top left of a matrix of zeros.
	    // `rows` and `cols` are the dimensions of the output matrix.
	    function embed(mat, rows, cols) {
	      let r = mat.rows;
	      let c = mat.columns;
	      if (r === rows && c === cols) {
	        return mat;
	      } else {
	        let resultat = AbstractMatrix.zeros(rows, cols);
	        resultat = resultat.setSubMatrix(mat, 0, 0);
	        return resultat;
	      }
	    }

	    // Make sure both matrices are the same size.
	    // This is exclusively for simplicity:
	    // this algorithm can be implemented with matrices of different sizes.

	    let r = Math.max(r1, r2);
	    let c = Math.max(c1, c2);
	    x = embed(x, r, c);
	    y = embed(y, r, c);

	    // Our recursive multiplication function.
	    function blockMult(a, b, rows, cols) {
	      // For small matrices, resort to naive multiplication.
	      if (rows <= 512 || cols <= 512) {
	        return a.mmul(b); // a is equivalent to this
	      }

	      // Apply dynamic padding.
	      if (rows % 2 === 1 && cols % 2 === 1) {
	        a = embed(a, rows + 1, cols + 1);
	        b = embed(b, rows + 1, cols + 1);
	      } else if (rows % 2 === 1) {
	        a = embed(a, rows + 1, cols);
	        b = embed(b, rows + 1, cols);
	      } else if (cols % 2 === 1) {
	        a = embed(a, rows, cols + 1);
	        b = embed(b, rows, cols + 1);
	      }

	      let halfRows = parseInt(a.rows / 2, 10);
	      let halfCols = parseInt(a.columns / 2, 10);
	      // Subdivide input matrices.
	      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
	      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

	      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
	      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

	      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
	      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

	      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
	      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

	      // Compute intermediate values.
	      let m1 = blockMult(
	        AbstractMatrix.add(a11, a22),
	        AbstractMatrix.add(b11, b22),
	        halfRows,
	        halfCols,
	      );
	      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
	      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
	      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
	      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
	      let m6 = blockMult(
	        AbstractMatrix.sub(a21, a11),
	        AbstractMatrix.add(b11, b12),
	        halfRows,
	        halfCols,
	      );
	      let m7 = blockMult(
	        AbstractMatrix.sub(a12, a22),
	        AbstractMatrix.add(b21, b22),
	        halfRows,
	        halfCols,
	      );

	      // Combine intermediate values into the output.
	      let c11 = AbstractMatrix.add(m1, m4);
	      c11.sub(m5);
	      c11.add(m7);
	      let c12 = AbstractMatrix.add(m3, m5);
	      let c21 = AbstractMatrix.add(m2, m4);
	      let c22 = AbstractMatrix.sub(m1, m2);
	      c22.add(m3);
	      c22.add(m6);

	      // Crop output to the desired size (undo dynamic padding).
	      let result = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
	      result = result.setSubMatrix(c11, 0, 0);
	      result = result.setSubMatrix(c12, c11.rows, 0);
	      result = result.setSubMatrix(c21, 0, c11.columns);
	      result = result.setSubMatrix(c22, c11.rows, c11.columns);
	      return result.subMatrix(0, rows - 1, 0, cols - 1);
	    }

	    return blockMult(x, y, r, c);
	  }

	  scaleRows(options = {}) {
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { min = 0, max = 1 } = options;
	    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
	    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
	    if (min >= max) throw new RangeError('min must be smaller than max');
	    let newMatrix = new Matrix(this.rows, this.columns);
	    for (let i = 0; i < this.rows; i++) {
	      const row = this.getRow(i);
	      if (row.length > 0) {
	        rescale$1(row, { min, max, output: row });
	      }
	      newMatrix.setRow(i, row);
	    }
	    return newMatrix;
	  }

	  scaleColumns(options = {}) {
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { min = 0, max = 1 } = options;
	    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
	    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
	    if (min >= max) throw new RangeError('min must be smaller than max');
	    let newMatrix = new Matrix(this.rows, this.columns);
	    for (let i = 0; i < this.columns; i++) {
	      const column = this.getColumn(i);
	      if (column.length) {
	        rescale$1(column, {
	          min,
	          max,
	          output: column,
	        });
	      }
	      newMatrix.setColumn(i, column);
	    }
	    return newMatrix;
	  }

	  flipRows() {
	    const middle = Math.ceil(this.columns / 2);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < middle; j++) {
	        let first = this.get(i, j);
	        let last = this.get(i, this.columns - 1 - j);
	        this.set(i, j, last);
	        this.set(i, this.columns - 1 - j, first);
	      }
	    }
	    return this;
	  }

	  flipColumns() {
	    const middle = Math.ceil(this.rows / 2);
	    for (let j = 0; j < this.columns; j++) {
	      for (let i = 0; i < middle; i++) {
	        let first = this.get(i, j);
	        let last = this.get(this.rows - 1 - i, j);
	        this.set(i, j, last);
	        this.set(this.rows - 1 - i, j, first);
	      }
	    }
	    return this;
	  }

	  kroneckerProduct(other) {
	    other = Matrix.checkMatrix(other);

	    let m = this.rows;
	    let n = this.columns;
	    let p = other.rows;
	    let q = other.columns;

	    let result = new Matrix(m * p, n * q);
	    for (let i = 0; i < m; i++) {
	      for (let j = 0; j < n; j++) {
	        for (let k = 0; k < p; k++) {
	          for (let l = 0; l < q; l++) {
	            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
	          }
	        }
	      }
	    }
	    return result;
	  }

	  kroneckerSum(other) {
	    other = Matrix.checkMatrix(other);
	    if (!this.isSquare() || !other.isSquare()) {
	      throw new Error('Kronecker Sum needs two Square Matrices');
	    }
	    let m = this.rows;
	    let n = other.rows;
	    let AxI = this.kroneckerProduct(Matrix.eye(n, n));
	    let IxB = Matrix.eye(m, m).kroneckerProduct(other);
	    return AxI.add(IxB);
	  }

	  transpose() {
	    let result = new Matrix(this.columns, this.rows);
	    for (let i = 0; i < this.rows; i++) {
	      for (let j = 0; j < this.columns; j++) {
	        result.set(j, i, this.get(i, j));
	      }
	    }
	    return result;
	  }

	  sortRows(compareFunction = compareNumbers) {
	    for (let i = 0; i < this.rows; i++) {
	      this.setRow(i, this.getRow(i).sort(compareFunction));
	    }
	    return this;
	  }

	  sortColumns(compareFunction = compareNumbers) {
	    for (let i = 0; i < this.columns; i++) {
	      this.setColumn(i, this.getColumn(i).sort(compareFunction));
	    }
	    return this;
	  }

	  subMatrix(startRow, endRow, startColumn, endColumn) {
	    checkRange(this, startRow, endRow, startColumn, endColumn);
	    let newMatrix = new Matrix(
	      endRow - startRow + 1,
	      endColumn - startColumn + 1,
	    );
	    for (let i = startRow; i <= endRow; i++) {
	      for (let j = startColumn; j <= endColumn; j++) {
	        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
	      }
	    }
	    return newMatrix;
	  }

	  subMatrixRow(indices, startColumn, endColumn) {
	    if (startColumn === undefined) startColumn = 0;
	    if (endColumn === undefined) endColumn = this.columns - 1;
	    if (
	      startColumn > endColumn ||
	      startColumn < 0 ||
	      startColumn >= this.columns ||
	      endColumn < 0 ||
	      endColumn >= this.columns
	    ) {
	      throw new RangeError('Argument out of range');
	    }

	    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
	    for (let i = 0; i < indices.length; i++) {
	      for (let j = startColumn; j <= endColumn; j++) {
	        if (indices[i] < 0 || indices[i] >= this.rows) {
	          throw new RangeError(`Row index out of range: ${indices[i]}`);
	        }
	        newMatrix.set(i, j - startColumn, this.get(indices[i], j));
	      }
	    }
	    return newMatrix;
	  }

	  subMatrixColumn(indices, startRow, endRow) {
	    if (startRow === undefined) startRow = 0;
	    if (endRow === undefined) endRow = this.rows - 1;
	    if (
	      startRow > endRow ||
	      startRow < 0 ||
	      startRow >= this.rows ||
	      endRow < 0 ||
	      endRow >= this.rows
	    ) {
	      throw new RangeError('Argument out of range');
	    }

	    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
	    for (let i = 0; i < indices.length; i++) {
	      for (let j = startRow; j <= endRow; j++) {
	        if (indices[i] < 0 || indices[i] >= this.columns) {
	          throw new RangeError(`Column index out of range: ${indices[i]}`);
	        }
	        newMatrix.set(j - startRow, i, this.get(j, indices[i]));
	      }
	    }
	    return newMatrix;
	  }

	  setSubMatrix(matrix, startRow, startColumn) {
	    matrix = Matrix.checkMatrix(matrix);
	    if (matrix.isEmpty()) {
	      return this;
	    }
	    let endRow = startRow + matrix.rows - 1;
	    let endColumn = startColumn + matrix.columns - 1;
	    checkRange(this, startRow, endRow, startColumn, endColumn);
	    for (let i = 0; i < matrix.rows; i++) {
	      for (let j = 0; j < matrix.columns; j++) {
	        this.set(startRow + i, startColumn + j, matrix.get(i, j));
	      }
	    }
	    return this;
	  }

	  selection(rowIndices, columnIndices) {
	    checkRowIndices(this, rowIndices);
	    checkColumnIndices(this, columnIndices);
	    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
	    for (let i = 0; i < rowIndices.length; i++) {
	      let rowIndex = rowIndices[i];
	      for (let j = 0; j < columnIndices.length; j++) {
	        let columnIndex = columnIndices[j];
	        newMatrix.set(i, j, this.get(rowIndex, columnIndex));
	      }
	    }
	    return newMatrix;
	  }

	  trace() {
	    let min = Math.min(this.rows, this.columns);
	    let trace = 0;
	    for (let i = 0; i < min; i++) {
	      trace += this.get(i, i);
	    }
	    return trace;
	  }

	  clone() {
	    return this.constructor.copy(this, new Matrix(this.rows, this.columns));
	  }

	  /**
	   * @template {AbstractMatrix} M
	   * @param {AbstractMatrix} from
	   * @param {M} to
	   * @return {M}
	   */
	  static copy(from, to) {
	    for (const [row, column, value] of from.entries()) {
	      to.set(row, column, value);
	    }

	    return to;
	  }

	  sum(by) {
	    switch (by) {
	      case 'row':
	        return sumByRow(this);
	      case 'column':
	        return sumByColumn(this);
	      case undefined:
	        return sumAll(this);
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  product(by) {
	    switch (by) {
	      case 'row':
	        return productByRow(this);
	      case 'column':
	        return productByColumn(this);
	      case undefined:
	        return productAll(this);
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  mean(by) {
	    const sum = this.sum(by);
	    switch (by) {
	      case 'row': {
	        for (let i = 0; i < this.rows; i++) {
	          sum[i] /= this.columns;
	        }
	        return sum;
	      }
	      case 'column': {
	        for (let i = 0; i < this.columns; i++) {
	          sum[i] /= this.rows;
	        }
	        return sum;
	      }
	      case undefined:
	        return sum / this.size;
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  variance(by, options = {}) {
	    if (typeof by === 'object') {
	      options = by;
	      by = undefined;
	    }
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { unbiased = true, mean = this.mean(by) } = options;
	    if (typeof unbiased !== 'boolean') {
	      throw new TypeError('unbiased must be a boolean');
	    }
	    switch (by) {
	      case 'row': {
	        if (!isAnyArray.isAnyArray(mean)) {
	          throw new TypeError('mean must be an array');
	        }
	        return varianceByRow(this, unbiased, mean);
	      }
	      case 'column': {
	        if (!isAnyArray.isAnyArray(mean)) {
	          throw new TypeError('mean must be an array');
	        }
	        return varianceByColumn(this, unbiased, mean);
	      }
	      case undefined: {
	        if (typeof mean !== 'number') {
	          throw new TypeError('mean must be a number');
	        }
	        return varianceAll(this, unbiased, mean);
	      }
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  standardDeviation(by, options) {
	    if (typeof by === 'object') {
	      options = by;
	      by = undefined;
	    }
	    const variance = this.variance(by, options);
	    if (by === undefined) {
	      return Math.sqrt(variance);
	    } else {
	      for (let i = 0; i < variance.length; i++) {
	        variance[i] = Math.sqrt(variance[i]);
	      }
	      return variance;
	    }
	  }

	  center(by, options = {}) {
	    if (typeof by === 'object') {
	      options = by;
	      by = undefined;
	    }
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    const { center = this.mean(by) } = options;
	    switch (by) {
	      case 'row': {
	        if (!isAnyArray.isAnyArray(center)) {
	          throw new TypeError('center must be an array');
	        }
	        centerByRow(this, center);
	        return this;
	      }
	      case 'column': {
	        if (!isAnyArray.isAnyArray(center)) {
	          throw new TypeError('center must be an array');
	        }
	        centerByColumn(this, center);
	        return this;
	      }
	      case undefined: {
	        if (typeof center !== 'number') {
	          throw new TypeError('center must be a number');
	        }
	        centerAll(this, center);
	        return this;
	      }
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  scale(by, options = {}) {
	    if (typeof by === 'object') {
	      options = by;
	      by = undefined;
	    }
	    if (typeof options !== 'object') {
	      throw new TypeError('options must be an object');
	    }
	    let scale = options.scale;
	    switch (by) {
	      case 'row': {
	        if (scale === undefined) {
	          scale = getScaleByRow(this);
	        } else if (!isAnyArray.isAnyArray(scale)) {
	          throw new TypeError('scale must be an array');
	        }
	        scaleByRow(this, scale);
	        return this;
	      }
	      case 'column': {
	        if (scale === undefined) {
	          scale = getScaleByColumn(this);
	        } else if (!isAnyArray.isAnyArray(scale)) {
	          throw new TypeError('scale must be an array');
	        }
	        scaleByColumn(this, scale);
	        return this;
	      }
	      case undefined: {
	        if (scale === undefined) {
	          scale = getScaleAll(this);
	        } else if (typeof scale !== 'number') {
	          throw new TypeError('scale must be a number');
	        }
	        scaleAll(this, scale);
	        return this;
	      }
	      default:
	        throw new Error(`invalid option: ${by}`);
	    }
	  }

	  toString(options) {
	    return inspectMatrixWithOptions(this, options);
	  }

	  [Symbol.iterator]() {
	    return this.entries();
	  }

	  /**
	   * iterator from left to right, from top to bottom
	   * yield [row, column, value]
	   * @returns {Generator<[number, number, number], void, void>}
	   */
	  *entries() {
	    for (let row = 0; row < this.rows; row++) {
	      for (let col = 0; col < this.columns; col++) {
	        yield [row, col, this.get(row, col)];
	      }
	    }
	  }

	  /**
	   * iterator from left to right, from top to bottom
	   * yield value
	   * @returns {Generator<number, void, void>}
	   */
	  *values() {
	    for (let row = 0; row < this.rows; row++) {
	      for (let col = 0; col < this.columns; col++) {
	        yield this.get(row, col);
	      }
	    }
	  }
	}

	AbstractMatrix.prototype.klass = 'Matrix';
	if (typeof Symbol !== 'undefined') {
	  AbstractMatrix.prototype[Symbol.for('nodejs.util.inspect.custom')] =
	    inspectMatrix;
	}

	function compareNumbers(a, b) {
	  return a - b;
	}

	function isArrayOfNumbers(array) {
	  return array.every((element) => {
	    return typeof element === 'number';
	  });
	}

	// Synonyms
	AbstractMatrix.random = AbstractMatrix.rand;
	AbstractMatrix.randomInt = AbstractMatrix.randInt;
	AbstractMatrix.diagonal = AbstractMatrix.diag;
	AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
	AbstractMatrix.identity = AbstractMatrix.eye;
	AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
	AbstractMatrix.prototype.tensorProduct =
	  AbstractMatrix.prototype.kroneckerProduct;

	class Matrix extends AbstractMatrix {
	  /**
	   * @type {Float64Array[]}
	   */
	  data;

	  /**
	   * Init an empty matrix
	   * @param {number} nRows
	   * @param {number} nColumns
	   */
	  #initData(nRows, nColumns) {
	    this.data = [];

	    if (Number.isInteger(nColumns) && nColumns >= 0) {
	      for (let i = 0; i < nRows; i++) {
	        this.data.push(new Float64Array(nColumns));
	      }
	    } else {
	      throw new TypeError('nColumns must be a positive integer');
	    }

	    this.rows = nRows;
	    this.columns = nColumns;
	  }

	  constructor(nRows, nColumns) {
	    super();
	    if (Matrix.isMatrix(nRows)) {
	      this.#initData(nRows.rows, nRows.columns);
	      Matrix.copy(nRows, this);
	    } else if (Number.isInteger(nRows) && nRows >= 0) {
	      this.#initData(nRows, nColumns);
	    } else if (isAnyArray.isAnyArray(nRows)) {
	      // Copy the values from the 2D array
	      const arrayData = nRows;
	      nRows = arrayData.length;
	      nColumns = nRows ? arrayData[0].length : 0;
	      if (typeof nColumns !== 'number') {
	        throw new TypeError(
	          'Data must be a 2D array with at least one element',
	        );
	      }
	      this.data = [];

	      for (let i = 0; i < nRows; i++) {
	        if (arrayData[i].length !== nColumns) {
	          throw new RangeError('Inconsistent array dimensions');
	        }
	        if (!isArrayOfNumbers(arrayData[i])) {
	          throw new TypeError('Input data contains non-numeric values');
	        }
	        this.data.push(Float64Array.from(arrayData[i]));
	      }

	      this.rows = nRows;
	      this.columns = nColumns;
	    } else {
	      throw new TypeError(
	        'First argument must be a positive number or an array',
	      );
	    }
	  }

	  set(rowIndex, columnIndex, value) {
	    this.data[rowIndex][columnIndex] = value;
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.data[rowIndex][columnIndex];
	  }

	  removeRow(index) {
	    checkRowIndex(this, index);
	    this.data.splice(index, 1);
	    this.rows -= 1;
	    return this;
	  }

	  addRow(index, array) {
	    if (array === undefined) {
	      array = index;
	      index = this.rows;
	    }
	    checkRowIndex(this, index, true);
	    array = Float64Array.from(checkRowVector(this, array));
	    this.data.splice(index, 0, array);
	    this.rows += 1;
	    return this;
	  }

	  removeColumn(index) {
	    checkColumnIndex(this, index);
	    for (let i = 0; i < this.rows; i++) {
	      const newRow = new Float64Array(this.columns - 1);
	      for (let j = 0; j < index; j++) {
	        newRow[j] = this.data[i][j];
	      }
	      for (let j = index + 1; j < this.columns; j++) {
	        newRow[j - 1] = this.data[i][j];
	      }
	      this.data[i] = newRow;
	    }
	    this.columns -= 1;
	    return this;
	  }

	  addColumn(index, array) {
	    if (typeof array === 'undefined') {
	      array = index;
	      index = this.columns;
	    }
	    checkColumnIndex(this, index, true);
	    array = checkColumnVector(this, array);
	    for (let i = 0; i < this.rows; i++) {
	      const newRow = new Float64Array(this.columns + 1);
	      let j = 0;
	      for (; j < index; j++) {
	        newRow[j] = this.data[i][j];
	      }
	      newRow[j++] = array[i];
	      for (; j < this.columns + 1; j++) {
	        newRow[j] = this.data[i][j - 1];
	      }
	      this.data[i] = newRow;
	    }
	    this.columns += 1;
	    return this;
	  }
	}

	installMathOperations(AbstractMatrix, Matrix);

	/**
	 * @typedef {0 | 1 | number | boolean} Mask
	 */

	class SymmetricMatrix extends AbstractMatrix {
	  /** @type {Matrix} */
	  #matrix;

	  get size() {
	    return this.#matrix.size;
	  }

	  get rows() {
	    return this.#matrix.rows;
	  }

	  get columns() {
	    return this.#matrix.columns;
	  }

	  get diagonalSize() {
	    return this.rows;
	  }

	  /**
	   * not the same as matrix.isSymmetric()
	   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
	   *
	   * @param value
	   * @returns {boolean}
	   */
	  static isSymmetricMatrix(value) {
	    return Matrix.isMatrix(value) && value.klassType === 'SymmetricMatrix';
	  }

	  /**
	   * @param diagonalSize
	   * @return {SymmetricMatrix}
	   */
	  static zeros(diagonalSize) {
	    return new this(diagonalSize);
	  }

	  /**
	   * @param diagonalSize
	   * @return {SymmetricMatrix}
	   */
	  static ones(diagonalSize) {
	    return new this(diagonalSize).fill(1);
	  }

	  /**
	   * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
	   * @return {this}
	   */
	  constructor(diagonalSize) {
	    super();

	    if (Matrix.isMatrix(diagonalSize)) {
	      if (!diagonalSize.isSymmetric()) {
	        throw new TypeError('not symmetric data');
	      }

	      this.#matrix = Matrix.copy(
	        diagonalSize,
	        new Matrix(diagonalSize.rows, diagonalSize.rows),
	      );
	    } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
	      this.#matrix = new Matrix(diagonalSize, diagonalSize);
	    } else {
	      this.#matrix = new Matrix(diagonalSize);

	      if (!this.isSymmetric()) {
	        throw new TypeError('not symmetric data');
	      }
	    }
	  }

	  clone() {
	    const matrix = new SymmetricMatrix(this.diagonalSize);

	    for (const [row, col, value] of this.upperRightEntries()) {
	      matrix.set(row, col, value);
	    }

	    return matrix;
	  }

	  toMatrix() {
	    return new Matrix(this);
	  }

	  get(rowIndex, columnIndex) {
	    return this.#matrix.get(rowIndex, columnIndex);
	  }
	  set(rowIndex, columnIndex, value) {
	    // symmetric set
	    this.#matrix.set(rowIndex, columnIndex, value);
	    this.#matrix.set(columnIndex, rowIndex, value);

	    return this;
	  }

	  removeCross(index) {
	    // symmetric remove side
	    this.#matrix.removeRow(index);
	    this.#matrix.removeColumn(index);

	    return this;
	  }

	  addCross(index, array) {
	    if (array === undefined) {
	      array = index;
	      index = this.diagonalSize;
	    }

	    const row = array.slice();
	    row.splice(index, 1);

	    this.#matrix.addRow(index, row);
	    this.#matrix.addColumn(index, array);

	    return this;
	  }

	  /**
	   * @param {Mask[]} mask
	   */
	  applyMask(mask) {
	    if (mask.length !== this.diagonalSize) {
	      throw new RangeError('Mask size do not match with matrix size');
	    }

	    // prepare sides to remove from matrix from mask
	    /** @type {number[]} */
	    const sidesToRemove = [];
	    for (const [index, passthroughs] of mask.entries()) {
	      if (passthroughs) continue;
	      sidesToRemove.push(index);
	    }
	    // to remove from highest to lowest for no mutation shifting
	    sidesToRemove.reverse();

	    // remove sides
	    for (const sideIndex of sidesToRemove) {
	      this.removeCross(sideIndex);
	    }

	    return this;
	  }

	  /**
	   * Compact format upper-right corner of matrix
	   * iterate from left to right, from top to bottom.
	   *
	   * ```
	   *   A B C D
	   * A 1 2 3 4
	   * B 2 5 6 7
	   * C 3 6 8 9
	   * D 4 7 9 10
	   * ```
	   *
	   * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
	   *
	   * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
	   *
	   * @returns {number[]}
	   */
	  toCompact() {
	    const { diagonalSize } = this;

	    /** @type {number[]} */
	    const compact = new Array((diagonalSize * (diagonalSize + 1)) / 2);
	    for (let col = 0, row = 0, index = 0; index < compact.length; index++) {
	      compact[index] = this.get(row, col);

	      if (++col >= diagonalSize) col = ++row;
	    }

	    return compact;
	  }

	  /**
	   * @param {number[]} compact
	   * @return {SymmetricMatrix}
	   */
	  static fromCompact(compact) {
	    const compactSize = compact.length;
	    // compactSize = (sideSize * (sideSize + 1)) / 2
	    // https://mathsolver.microsoft.com/fr/solve-problem/y%20%3D%20%20x%20%60cdot%20%20%20%60frac%7B%20%20%60left(%20x%2B1%20%20%60right)%20%20%20%20%7D%7B%202%20%20%7D
	    // sideSize = (Sqrt(8 × compactSize + 1) - 1) / 2
	    const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;

	    if (!Number.isInteger(diagonalSize)) {
	      throw new TypeError(
	        `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
	          compact,
	        )}`,
	      );
	    }

	    const matrix = new SymmetricMatrix(diagonalSize);
	    for (let col = 0, row = 0, index = 0; index < compactSize; index++) {
	      matrix.set(col, row, compact[index]);
	      if (++col >= diagonalSize) col = ++row;
	    }

	    return matrix;
	  }

	  /**
	   * half iterator upper-right-corner from left to right, from top to bottom
	   * yield [row, column, value]
	   *
	   * @returns {Generator<[number, number, number], void, void>}
	   */
	  *upperRightEntries() {
	    for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
	      const value = this.get(row, col);

	      yield [row, col, value];

	      // at the end of row, move cursor to next row at diagonal position
	      if (++col >= this.diagonalSize) col = ++row;
	    }
	  }

	  /**
	   * half iterator upper-right-corner from left to right, from top to bottom
	   * yield value
	   *
	   * @returns {Generator<[number, number, number], void, void>}
	   */
	  *upperRightValues() {
	    for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
	      const value = this.get(row, col);

	      yield value;

	      // at the end of row, move cursor to next row at diagonal position
	      if (++col >= this.diagonalSize) col = ++row;
	    }
	  }
	}
	SymmetricMatrix.prototype.klassType = 'SymmetricMatrix';

	class DistanceMatrix extends SymmetricMatrix {
	  /**
	   * not the same as matrix.isSymmetric()
	   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
	   *
	   * @param value
	   * @returns {boolean}
	   */
	  static isDistanceMatrix(value) {
	    return (
	      SymmetricMatrix.isSymmetricMatrix(value) &&
	      value.klassSubType === 'DistanceMatrix'
	    );
	  }

	  constructor(sideSize) {
	    super(sideSize);

	    if (!this.isDistance()) {
	      throw new TypeError('Provided arguments do no produce a distance matrix');
	    }
	  }

	  set(rowIndex, columnIndex, value) {
	    // distance matrix diagonal is 0
	    if (rowIndex === columnIndex) value = 0;

	    return super.set(rowIndex, columnIndex, value);
	  }

	  addCross(index, array) {
	    if (array === undefined) {
	      array = index;
	      index = this.diagonalSize;
	    }

	    // ensure distance
	    array = array.slice();
	    array[index] = 0;

	    return super.addCross(index, array);
	  }

	  toSymmetricMatrix() {
	    return new SymmetricMatrix(this);
	  }

	  clone() {
	    const matrix = new DistanceMatrix(this.diagonalSize);

	    for (const [row, col, value] of this.upperRightEntries()) {
	      if (row === col) continue;
	      matrix.set(row, col, value);
	    }

	    return matrix;
	  }

	  /**
	   * Compact format upper-right corner of matrix
	   * no diagonal (only zeros)
	   * iterable from left to right, from top to bottom.
	   *
	   * ```
	   *   A B C D
	   * A 0 1 2 3
	   * B 1 0 4 5
	   * C 2 4 0 6
	   * D 3 5 6 0
	   * ```
	   *
	   * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
	   *
	   * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
	   *
	   * @returns {number[]}
	   */
	  toCompact() {
	    const { diagonalSize } = this;
	    const compactLength = ((diagonalSize - 1) * diagonalSize) / 2;

	    /** @type {number[]} */
	    const compact = new Array(compactLength);
	    for (let col = 1, row = 0, index = 0; index < compact.length; index++) {
	      compact[index] = this.get(row, col);

	      if (++col >= diagonalSize) col = ++row + 1;
	    }

	    return compact;
	  }

	  /**
	   * @param {number[]} compact
	   */
	  static fromCompact(compact) {
	    const compactSize = compact.length;

	    if (compactSize === 0) {
	      return new this(0);
	    }

	    // compactSize in Natural integer range ]0;∞]
	    // compactSize = (sideSize * (sideSize - 1)) / 2
	    // sideSize = (Sqrt(8 × compactSize + 1) + 1) / 2
	    const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;

	    if (!Number.isInteger(diagonalSize)) {
	      throw new TypeError(
	        `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
	          compact,
	        )}`,
	      );
	    }

	    const matrix = new this(diagonalSize);
	    for (let col = 1, row = 0, index = 0; index < compactSize; index++) {
	      matrix.set(col, row, compact[index]);
	      if (++col >= diagonalSize) col = ++row + 1;
	    }

	    return matrix;
	  }
	}
	DistanceMatrix.prototype.klassSubType = 'DistanceMatrix';

	class BaseView extends AbstractMatrix {
	  constructor(matrix, rows, columns) {
	    super();
	    this.matrix = matrix;
	    this.rows = rows;
	    this.columns = columns;
	  }
	}

	class MatrixColumnView extends BaseView {
	  constructor(matrix, column) {
	    checkColumnIndex(matrix, column);
	    super(matrix, matrix.rows, 1);
	    this.column = column;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(rowIndex, this.column, value);
	    return this;
	  }

	  get(rowIndex) {
	    return this.matrix.get(rowIndex, this.column);
	  }
	}

	class MatrixColumnSelectionView extends BaseView {
	  constructor(matrix, columnIndices) {
	    checkColumnIndices(matrix, columnIndices);
	    super(matrix, matrix.rows, columnIndices.length);
	    this.columnIndices = columnIndices;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
	  }
	}

	class MatrixFlipColumnView extends BaseView {
	  constructor(matrix) {
	    super(matrix, matrix.rows, matrix.columns);
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
	  }
	}

	class MatrixFlipRowView extends BaseView {
	  constructor(matrix) {
	    super(matrix, matrix.rows, matrix.columns);
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
	  }
	}

	class MatrixRowView extends BaseView {
	  constructor(matrix, row) {
	    checkRowIndex(matrix, row);
	    super(matrix, 1, matrix.columns);
	    this.row = row;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(this.row, columnIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(this.row, columnIndex);
	  }
	}

	class MatrixRowSelectionView extends BaseView {
	  constructor(matrix, rowIndices) {
	    checkRowIndices(matrix, rowIndices);
	    super(matrix, rowIndices.length, matrix.columns);
	    this.rowIndices = rowIndices;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
	  }
	}

	class MatrixSelectionView extends BaseView {
	  constructor(matrix, rowIndices, columnIndices) {
	    checkRowIndices(matrix, rowIndices);
	    checkColumnIndices(matrix, columnIndices);
	    super(matrix, rowIndices.length, columnIndices.length);
	    this.rowIndices = rowIndices;
	    this.columnIndices = columnIndices;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(
	      this.rowIndices[rowIndex],
	      this.columnIndices[columnIndex],
	      value,
	    );
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(
	      this.rowIndices[rowIndex],
	      this.columnIndices[columnIndex],
	    );
	  }
	}

	class MatrixSubView extends BaseView {
	  constructor(matrix, startRow, endRow, startColumn, endColumn) {
	    checkRange(matrix, startRow, endRow, startColumn, endColumn);
	    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
	    this.startRow = startRow;
	    this.startColumn = startColumn;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(
	      this.startRow + rowIndex,
	      this.startColumn + columnIndex,
	      value,
	    );
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(
	      this.startRow + rowIndex,
	      this.startColumn + columnIndex,
	    );
	  }
	}

	class MatrixTransposeView extends BaseView {
	  constructor(matrix) {
	    super(matrix, matrix.columns, matrix.rows);
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(columnIndex, rowIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(columnIndex, rowIndex);
	  }
	}

	class WrapperMatrix1D extends AbstractMatrix {
	  constructor(data, options = {}) {
	    const { rows = 1 } = options;

	    if (data.length % rows !== 0) {
	      throw new Error('the data length is not divisible by the number of rows');
	    }
	    super();
	    this.rows = rows;
	    this.columns = data.length / rows;
	    this.data = data;
	  }

	  set(rowIndex, columnIndex, value) {
	    let index = this._calculateIndex(rowIndex, columnIndex);
	    this.data[index] = value;
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    let index = this._calculateIndex(rowIndex, columnIndex);
	    return this.data[index];
	  }

	  _calculateIndex(row, column) {
	    return row * this.columns + column;
	  }
	}

	class WrapperMatrix2D extends AbstractMatrix {
	  constructor(data) {
	    super();
	    this.data = data;
	    this.rows = data.length;
	    this.columns = data[0].length;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.data[rowIndex][columnIndex] = value;
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.data[rowIndex][columnIndex];
	  }
	}

	function wrap(array, options) {
	  if (isAnyArray.isAnyArray(array)) {
	    if (array[0] && isAnyArray.isAnyArray(array[0])) {
	      return new WrapperMatrix2D(array);
	    } else {
	      return new WrapperMatrix1D(array, options);
	    }
	  } else {
	    throw new Error('the argument is not an array');
	  }
	}

	class LuDecomposition {
	  constructor(matrix) {
	    matrix = WrapperMatrix2D.checkMatrix(matrix);

	    let lu = matrix.clone();
	    let rows = lu.rows;
	    let columns = lu.columns;
	    let pivotVector = new Float64Array(rows);
	    let pivotSign = 1;
	    let i, j, k, p, s, t, v;
	    let LUcolj, kmax;

	    for (i = 0; i < rows; i++) {
	      pivotVector[i] = i;
	    }

	    LUcolj = new Float64Array(rows);

	    for (j = 0; j < columns; j++) {
	      for (i = 0; i < rows; i++) {
	        LUcolj[i] = lu.get(i, j);
	      }

	      for (i = 0; i < rows; i++) {
	        kmax = Math.min(i, j);
	        s = 0;
	        for (k = 0; k < kmax; k++) {
	          s += lu.get(i, k) * LUcolj[k];
	        }
	        LUcolj[i] -= s;
	        lu.set(i, j, LUcolj[i]);
	      }

	      p = j;
	      for (i = j + 1; i < rows; i++) {
	        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
	          p = i;
	        }
	      }

	      if (p !== j) {
	        for (k = 0; k < columns; k++) {
	          t = lu.get(p, k);
	          lu.set(p, k, lu.get(j, k));
	          lu.set(j, k, t);
	        }

	        v = pivotVector[p];
	        pivotVector[p] = pivotVector[j];
	        pivotVector[j] = v;

	        pivotSign = -pivotSign;
	      }

	      if (j < rows && lu.get(j, j) !== 0) {
	        for (i = j + 1; i < rows; i++) {
	          lu.set(i, j, lu.get(i, j) / lu.get(j, j));
	        }
	      }
	    }

	    this.LU = lu;
	    this.pivotVector = pivotVector;
	    this.pivotSign = pivotSign;
	  }

	  isSingular() {
	    let data = this.LU;
	    let col = data.columns;
	    for (let j = 0; j < col; j++) {
	      if (data.get(j, j) === 0) {
	        return true;
	      }
	    }
	    return false;
	  }

	  solve(value) {
	    value = Matrix.checkMatrix(value);

	    let lu = this.LU;
	    let rows = lu.rows;

	    if (rows !== value.rows) {
	      throw new Error('Invalid matrix dimensions');
	    }
	    if (this.isSingular()) {
	      throw new Error('LU matrix is singular');
	    }

	    let count = value.columns;
	    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
	    let columns = lu.columns;
	    let i, j, k;

	    for (k = 0; k < columns; k++) {
	      for (i = k + 1; i < columns; i++) {
	        for (j = 0; j < count; j++) {
	          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
	        }
	      }
	    }
	    for (k = columns - 1; k >= 0; k--) {
	      for (j = 0; j < count; j++) {
	        X.set(k, j, X.get(k, j) / lu.get(k, k));
	      }
	      for (i = 0; i < k; i++) {
	        for (j = 0; j < count; j++) {
	          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
	        }
	      }
	    }
	    return X;
	  }

	  get determinant() {
	    let data = this.LU;
	    if (!data.isSquare()) {
	      throw new Error('Matrix must be square');
	    }
	    let determinant = this.pivotSign;
	    let col = data.columns;
	    for (let j = 0; j < col; j++) {
	      determinant *= data.get(j, j);
	    }
	    return determinant;
	  }

	  get lowerTriangularMatrix() {
	    let data = this.LU;
	    let rows = data.rows;
	    let columns = data.columns;
	    let X = new Matrix(rows, columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        if (i > j) {
	          X.set(i, j, data.get(i, j));
	        } else if (i === j) {
	          X.set(i, j, 1);
	        } else {
	          X.set(i, j, 0);
	        }
	      }
	    }
	    return X;
	  }

	  get upperTriangularMatrix() {
	    let data = this.LU;
	    let rows = data.rows;
	    let columns = data.columns;
	    let X = new Matrix(rows, columns);
	    for (let i = 0; i < rows; i++) {
	      for (let j = 0; j < columns; j++) {
	        if (i <= j) {
	          X.set(i, j, data.get(i, j));
	        } else {
	          X.set(i, j, 0);
	        }
	      }
	    }
	    return X;
	  }

	  get pivotPermutationVector() {
	    return Array.from(this.pivotVector);
	  }
	}

	function hypotenuse(a, b) {
	  let r = 0;
	  if (Math.abs(a) > Math.abs(b)) {
	    r = b / a;
	    return Math.abs(a) * Math.sqrt(1 + r * r);
	  }
	  if (b !== 0) {
	    r = a / b;
	    return Math.abs(b) * Math.sqrt(1 + r * r);
	  }
	  return 0;
	}

	class QrDecomposition {
	  constructor(value) {
	    value = WrapperMatrix2D.checkMatrix(value);

	    let qr = value.clone();
	    let m = value.rows;
	    let n = value.columns;
	    let rdiag = new Float64Array(n);
	    let i, j, k, s;

	    for (k = 0; k < n; k++) {
	      let nrm = 0;
	      for (i = k; i < m; i++) {
	        nrm = hypotenuse(nrm, qr.get(i, k));
	      }
	      if (nrm !== 0) {
	        if (qr.get(k, k) < 0) {
	          nrm = -nrm;
	        }
	        for (i = k; i < m; i++) {
	          qr.set(i, k, qr.get(i, k) / nrm);
	        }
	        qr.set(k, k, qr.get(k, k) + 1);
	        for (j = k + 1; j < n; j++) {
	          s = 0;
	          for (i = k; i < m; i++) {
	            s += qr.get(i, k) * qr.get(i, j);
	          }
	          s = -s / qr.get(k, k);
	          for (i = k; i < m; i++) {
	            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
	          }
	        }
	      }
	      rdiag[k] = -nrm;
	    }

	    this.QR = qr;
	    this.Rdiag = rdiag;
	  }

	  solve(value) {
	    value = Matrix.checkMatrix(value);

	    let qr = this.QR;
	    let m = qr.rows;

	    if (value.rows !== m) {
	      throw new Error('Matrix row dimensions must agree');
	    }
	    if (!this.isFullRank()) {
	      throw new Error('Matrix is rank deficient');
	    }

	    let count = value.columns;
	    let X = value.clone();
	    let n = qr.columns;
	    let i, j, k, s;

	    for (k = 0; k < n; k++) {
	      for (j = 0; j < count; j++) {
	        s = 0;
	        for (i = k; i < m; i++) {
	          s += qr.get(i, k) * X.get(i, j);
	        }
	        s = -s / qr.get(k, k);
	        for (i = k; i < m; i++) {
	          X.set(i, j, X.get(i, j) + s * qr.get(i, k));
	        }
	      }
	    }
	    for (k = n - 1; k >= 0; k--) {
	      for (j = 0; j < count; j++) {
	        X.set(k, j, X.get(k, j) / this.Rdiag[k]);
	      }
	      for (i = 0; i < k; i++) {
	        for (j = 0; j < count; j++) {
	          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
	        }
	      }
	    }

	    return X.subMatrix(0, n - 1, 0, count - 1);
	  }

	  isFullRank() {
	    let columns = this.QR.columns;
	    for (let i = 0; i < columns; i++) {
	      if (this.Rdiag[i] === 0) {
	        return false;
	      }
	    }
	    return true;
	  }

	  get upperTriangularMatrix() {
	    let qr = this.QR;
	    let n = qr.columns;
	    let X = new Matrix(n, n);
	    let i, j;
	    for (i = 0; i < n; i++) {
	      for (j = 0; j < n; j++) {
	        if (i < j) {
	          X.set(i, j, qr.get(i, j));
	        } else if (i === j) {
	          X.set(i, j, this.Rdiag[i]);
	        } else {
	          X.set(i, j, 0);
	        }
	      }
	    }
	    return X;
	  }

	  get orthogonalMatrix() {
	    let qr = this.QR;
	    let rows = qr.rows;
	    let columns = qr.columns;
	    let X = new Matrix(rows, columns);
	    let i, j, k, s;

	    for (k = columns - 1; k >= 0; k--) {
	      for (i = 0; i < rows; i++) {
	        X.set(i, k, 0);
	      }
	      X.set(k, k, 1);
	      for (j = k; j < columns; j++) {
	        if (qr.get(k, k) !== 0) {
	          s = 0;
	          for (i = k; i < rows; i++) {
	            s += qr.get(i, k) * X.get(i, j);
	          }

	          s = -s / qr.get(k, k);

	          for (i = k; i < rows; i++) {
	            X.set(i, j, X.get(i, j) + s * qr.get(i, k));
	          }
	        }
	      }
	    }
	    return X;
	  }
	}

	class SingularValueDecomposition {
	  constructor(value, options = {}) {
	    value = WrapperMatrix2D.checkMatrix(value);

	    if (value.isEmpty()) {
	      throw new Error('Matrix must be non-empty');
	    }

	    let m = value.rows;
	    let n = value.columns;

	    const {
	      computeLeftSingularVectors = true,
	      computeRightSingularVectors = true,
	      autoTranspose = false,
	    } = options;

	    let wantu = Boolean(computeLeftSingularVectors);
	    let wantv = Boolean(computeRightSingularVectors);

	    let swapped = false;
	    let a;
	    if (m < n) {
	      if (!autoTranspose) {
	        a = value.clone();
	        // eslint-disable-next-line no-console
	        console.warn(
	          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',
	        );
	      } else {
	        a = value.transpose();
	        m = a.rows;
	        n = a.columns;
	        swapped = true;
	        let aux = wantu;
	        wantu = wantv;
	        wantv = aux;
	      }
	    } else {
	      a = value.clone();
	    }

	    let nu = Math.min(m, n);
	    let ni = Math.min(m + 1, n);
	    let s = new Float64Array(ni);
	    let U = new Matrix(m, nu);
	    let V = new Matrix(n, n);

	    let e = new Float64Array(n);
	    let work = new Float64Array(m);

	    let si = new Float64Array(ni);
	    for (let i = 0; i < ni; i++) si[i] = i;

	    let nct = Math.min(m - 1, n);
	    let nrt = Math.max(0, Math.min(n - 2, m));
	    let mrc = Math.max(nct, nrt);

	    for (let k = 0; k < mrc; k++) {
	      if (k < nct) {
	        s[k] = 0;
	        for (let i = k; i < m; i++) {
	          s[k] = hypotenuse(s[k], a.get(i, k));
	        }
	        if (s[k] !== 0) {
	          if (a.get(k, k) < 0) {
	            s[k] = -s[k];
	          }
	          for (let i = k; i < m; i++) {
	            a.set(i, k, a.get(i, k) / s[k]);
	          }
	          a.set(k, k, a.get(k, k) + 1);
	        }
	        s[k] = -s[k];
	      }

	      for (let j = k + 1; j < n; j++) {
	        if (k < nct && s[k] !== 0) {
	          let t = 0;
	          for (let i = k; i < m; i++) {
	            t += a.get(i, k) * a.get(i, j);
	          }
	          t = -t / a.get(k, k);
	          for (let i = k; i < m; i++) {
	            a.set(i, j, a.get(i, j) + t * a.get(i, k));
	          }
	        }
	        e[j] = a.get(k, j);
	      }

	      if (wantu && k < nct) {
	        for (let i = k; i < m; i++) {
	          U.set(i, k, a.get(i, k));
	        }
	      }

	      if (k < nrt) {
	        e[k] = 0;
	        for (let i = k + 1; i < n; i++) {
	          e[k] = hypotenuse(e[k], e[i]);
	        }
	        if (e[k] !== 0) {
	          if (e[k + 1] < 0) {
	            e[k] = 0 - e[k];
	          }
	          for (let i = k + 1; i < n; i++) {
	            e[i] /= e[k];
	          }
	          e[k + 1] += 1;
	        }
	        e[k] = -e[k];
	        if (k + 1 < m && e[k] !== 0) {
	          for (let i = k + 1; i < m; i++) {
	            work[i] = 0;
	          }
	          for (let i = k + 1; i < m; i++) {
	            for (let j = k + 1; j < n; j++) {
	              work[i] += e[j] * a.get(i, j);
	            }
	          }
	          for (let j = k + 1; j < n; j++) {
	            let t = -e[j] / e[k + 1];
	            for (let i = k + 1; i < m; i++) {
	              a.set(i, j, a.get(i, j) + t * work[i]);
	            }
	          }
	        }
	        if (wantv) {
	          for (let i = k + 1; i < n; i++) {
	            V.set(i, k, e[i]);
	          }
	        }
	      }
	    }

	    let p = Math.min(n, m + 1);
	    if (nct < n) {
	      s[nct] = a.get(nct, nct);
	    }
	    if (m < p) {
	      s[p - 1] = 0;
	    }
	    if (nrt + 1 < p) {
	      e[nrt] = a.get(nrt, p - 1);
	    }
	    e[p - 1] = 0;

	    if (wantu) {
	      for (let j = nct; j < nu; j++) {
	        for (let i = 0; i < m; i++) {
	          U.set(i, j, 0);
	        }
	        U.set(j, j, 1);
	      }
	      for (let k = nct - 1; k >= 0; k--) {
	        if (s[k] !== 0) {
	          for (let j = k + 1; j < nu; j++) {
	            let t = 0;
	            for (let i = k; i < m; i++) {
	              t += U.get(i, k) * U.get(i, j);
	            }
	            t = -t / U.get(k, k);
	            for (let i = k; i < m; i++) {
	              U.set(i, j, U.get(i, j) + t * U.get(i, k));
	            }
	          }
	          for (let i = k; i < m; i++) {
	            U.set(i, k, -U.get(i, k));
	          }
	          U.set(k, k, 1 + U.get(k, k));
	          for (let i = 0; i < k - 1; i++) {
	            U.set(i, k, 0);
	          }
	        } else {
	          for (let i = 0; i < m; i++) {
	            U.set(i, k, 0);
	          }
	          U.set(k, k, 1);
	        }
	      }
	    }

	    if (wantv) {
	      for (let k = n - 1; k >= 0; k--) {
	        if (k < nrt && e[k] !== 0) {
	          for (let j = k + 1; j < n; j++) {
	            let t = 0;
	            for (let i = k + 1; i < n; i++) {
	              t += V.get(i, k) * V.get(i, j);
	            }
	            t = -t / V.get(k + 1, k);
	            for (let i = k + 1; i < n; i++) {
	              V.set(i, j, V.get(i, j) + t * V.get(i, k));
	            }
	          }
	        }
	        for (let i = 0; i < n; i++) {
	          V.set(i, k, 0);
	        }
	        V.set(k, k, 1);
	      }
	    }

	    let pp = p - 1;
	    let eps = Number.EPSILON;
	    while (p > 0) {
	      let k, kase;
	      for (k = p - 2; k >= -1; k--) {
	        if (k === -1) {
	          break;
	        }
	        const alpha =
	          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
	        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
	          e[k] = 0;
	          break;
	        }
	      }
	      if (k === p - 2) {
	        kase = 4;
	      } else {
	        let ks;
	        for (ks = p - 1; ks >= k; ks--) {
	          if (ks === k) {
	            break;
	          }
	          let t =
	            (ks !== p ? Math.abs(e[ks]) : 0) +
	            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
	          if (Math.abs(s[ks]) <= eps * t) {
	            s[ks] = 0;
	            break;
	          }
	        }
	        if (ks === k) {
	          kase = 3;
	        } else if (ks === p - 1) {
	          kase = 1;
	        } else {
	          kase = 2;
	          k = ks;
	        }
	      }

	      k++;

	      switch (kase) {
	        case 1: {
	          let f = e[p - 2];
	          e[p - 2] = 0;
	          for (let j = p - 2; j >= k; j--) {
	            let t = hypotenuse(s[j], f);
	            let cs = s[j] / t;
	            let sn = f / t;
	            s[j] = t;
	            if (j !== k) {
	              f = -sn * e[j - 1];
	              e[j - 1] = cs * e[j - 1];
	            }
	            if (wantv) {
	              for (let i = 0; i < n; i++) {
	                t = cs * V.get(i, j) + sn * V.get(i, p - 1);
	                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
	                V.set(i, j, t);
	              }
	            }
	          }
	          break;
	        }
	        case 2: {
	          let f = e[k - 1];
	          e[k - 1] = 0;
	          for (let j = k; j < p; j++) {
	            let t = hypotenuse(s[j], f);
	            let cs = s[j] / t;
	            let sn = f / t;
	            s[j] = t;
	            f = -sn * e[j];
	            e[j] = cs * e[j];
	            if (wantu) {
	              for (let i = 0; i < m; i++) {
	                t = cs * U.get(i, j) + sn * U.get(i, k - 1);
	                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
	                U.set(i, j, t);
	              }
	            }
	          }
	          break;
	        }
	        case 3: {
	          const scale = Math.max(
	            Math.abs(s[p - 1]),
	            Math.abs(s[p - 2]),
	            Math.abs(e[p - 2]),
	            Math.abs(s[k]),
	            Math.abs(e[k]),
	          );
	          const sp = s[p - 1] / scale;
	          const spm1 = s[p - 2] / scale;
	          const epm1 = e[p - 2] / scale;
	          const sk = s[k] / scale;
	          const ek = e[k] / scale;
	          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
	          const c = sp * epm1 * (sp * epm1);
	          let shift = 0;
	          if (b !== 0 || c !== 0) {
	            if (b < 0) {
	              shift = 0 - Math.sqrt(b * b + c);
	            } else {
	              shift = Math.sqrt(b * b + c);
	            }
	            shift = c / (b + shift);
	          }
	          let f = (sk + sp) * (sk - sp) + shift;
	          let g = sk * ek;
	          for (let j = k; j < p - 1; j++) {
	            let t = hypotenuse(f, g);
	            if (t === 0) t = Number.MIN_VALUE;
	            let cs = f / t;
	            let sn = g / t;
	            if (j !== k) {
	              e[j - 1] = t;
	            }
	            f = cs * s[j] + sn * e[j];
	            e[j] = cs * e[j] - sn * s[j];
	            g = sn * s[j + 1];
	            s[j + 1] = cs * s[j + 1];
	            if (wantv) {
	              for (let i = 0; i < n; i++) {
	                t = cs * V.get(i, j) + sn * V.get(i, j + 1);
	                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
	                V.set(i, j, t);
	              }
	            }
	            t = hypotenuse(f, g);
	            if (t === 0) t = Number.MIN_VALUE;
	            cs = f / t;
	            sn = g / t;
	            s[j] = t;
	            f = cs * e[j] + sn * s[j + 1];
	            s[j + 1] = -sn * e[j] + cs * s[j + 1];
	            g = sn * e[j + 1];
	            e[j + 1] = cs * e[j + 1];
	            if (wantu && j < m - 1) {
	              for (let i = 0; i < m; i++) {
	                t = cs * U.get(i, j) + sn * U.get(i, j + 1);
	                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
	                U.set(i, j, t);
	              }
	            }
	          }
	          e[p - 2] = f;
	          break;
	        }
	        case 4: {
	          if (s[k] <= 0) {
	            s[k] = s[k] < 0 ? -s[k] : 0;
	            if (wantv) {
	              for (let i = 0; i <= pp; i++) {
	                V.set(i, k, -V.get(i, k));
	              }
	            }
	          }
	          while (k < pp) {
	            if (s[k] >= s[k + 1]) {
	              break;
	            }
	            let t = s[k];
	            s[k] = s[k + 1];
	            s[k + 1] = t;
	            if (wantv && k < n - 1) {
	              for (let i = 0; i < n; i++) {
	                t = V.get(i, k + 1);
	                V.set(i, k + 1, V.get(i, k));
	                V.set(i, k, t);
	              }
	            }
	            if (wantu && k < m - 1) {
	              for (let i = 0; i < m; i++) {
	                t = U.get(i, k + 1);
	                U.set(i, k + 1, U.get(i, k));
	                U.set(i, k, t);
	              }
	            }
	            k++;
	          }
	          p--;
	          break;
	        }
	        // no default
	      }
	    }

	    if (swapped) {
	      let tmp = V;
	      V = U;
	      U = tmp;
	    }

	    this.m = m;
	    this.n = n;
	    this.s = s;
	    this.U = U;
	    this.V = V;
	  }

	  solve(value) {
	    let Y = value;
	    let e = this.threshold;
	    let scols = this.s.length;
	    let Ls = Matrix.zeros(scols, scols);

	    for (let i = 0; i < scols; i++) {
	      if (Math.abs(this.s[i]) <= e) {
	        Ls.set(i, i, 0);
	      } else {
	        Ls.set(i, i, 1 / this.s[i]);
	      }
	    }

	    let U = this.U;
	    let V = this.rightSingularVectors;

	    let VL = V.mmul(Ls);
	    let vrows = V.rows;
	    let urows = U.rows;
	    let VLU = Matrix.zeros(vrows, urows);

	    for (let i = 0; i < vrows; i++) {
	      for (let j = 0; j < urows; j++) {
	        let sum = 0;
	        for (let k = 0; k < scols; k++) {
	          sum += VL.get(i, k) * U.get(j, k);
	        }
	        VLU.set(i, j, sum);
	      }
	    }

	    return VLU.mmul(Y);
	  }

	  solveForDiagonal(value) {
	    return this.solve(Matrix.diag(value));
	  }

	  inverse() {
	    let V = this.V;
	    let e = this.threshold;
	    let vrows = V.rows;
	    let vcols = V.columns;
	    let X = new Matrix(vrows, this.s.length);

	    for (let i = 0; i < vrows; i++) {
	      for (let j = 0; j < vcols; j++) {
	        if (Math.abs(this.s[j]) > e) {
	          X.set(i, j, V.get(i, j) / this.s[j]);
	        }
	      }
	    }

	    let U = this.U;

	    let urows = U.rows;
	    let ucols = U.columns;
	    let Y = new Matrix(vrows, urows);

	    for (let i = 0; i < vrows; i++) {
	      for (let j = 0; j < urows; j++) {
	        let sum = 0;
	        for (let k = 0; k < ucols; k++) {
	          sum += X.get(i, k) * U.get(j, k);
	        }
	        Y.set(i, j, sum);
	      }
	    }

	    return Y;
	  }

	  get condition() {
	    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
	  }

	  get norm2() {
	    return this.s[0];
	  }

	  get rank() {
	    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
	    let r = 0;
	    let s = this.s;
	    for (let i = 0, ii = s.length; i < ii; i++) {
	      if (s[i] > tol) {
	        r++;
	      }
	    }
	    return r;
	  }

	  get diagonal() {
	    return Array.from(this.s);
	  }

	  get threshold() {
	    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];
	  }

	  get leftSingularVectors() {
	    return this.U;
	  }

	  get rightSingularVectors() {
	    return this.V;
	  }

	  get diagonalMatrix() {
	    return Matrix.diag(this.s);
	  }
	}

	function inverse(matrix, useSVD = false) {
	  matrix = WrapperMatrix2D.checkMatrix(matrix);
	  if (useSVD) {
	    return new SingularValueDecomposition(matrix).inverse();
	  } else {
	    return solve(matrix, Matrix.eye(matrix.rows));
	  }
	}

	function solve(leftHandSide, rightHandSide, useSVD = false) {
	  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
	  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
	  if (useSVD) {
	    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
	  } else {
	    return leftHandSide.isSquare()
	      ? new LuDecomposition(leftHandSide).solve(rightHandSide)
	      : new QrDecomposition(leftHandSide).solve(rightHandSide);
	  }
	}

	function determinant(matrix) {
	  matrix = Matrix.checkMatrix(matrix);
	  if (matrix.isSquare()) {
	    if (matrix.columns === 0) {
	      return 1;
	    }

	    let a, b, c, d;
	    if (matrix.columns === 2) {
	      // 2 x 2 matrix
	      a = matrix.get(0, 0);
	      b = matrix.get(0, 1);
	      c = matrix.get(1, 0);
	      d = matrix.get(1, 1);

	      return a * d - b * c;
	    } else if (matrix.columns === 3) {
	      // 3 x 3 matrix
	      let subMatrix0, subMatrix1, subMatrix2;
	      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
	      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
	      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
	      a = matrix.get(0, 0);
	      b = matrix.get(0, 1);
	      c = matrix.get(0, 2);

	      return (
	        a * determinant(subMatrix0) -
	        b * determinant(subMatrix1) +
	        c * determinant(subMatrix2)
	      );
	    } else {
	      // general purpose determinant using the LU decomposition
	      return new LuDecomposition(matrix).determinant;
	    }
	  } else {
	    throw Error('determinant can only be calculated for a square matrix');
	  }
	}

	function xrange(n, exception) {
	  let range = [];
	  for (let i = 0; i < n; i++) {
	    if (i !== exception) {
	      range.push(i);
	    }
	  }
	  return range;
	}

	function dependenciesOneRow(
	  error,
	  matrix,
	  index,
	  thresholdValue = 10e-10,
	  thresholdError = 10e-10,
	) {
	  if (error > thresholdError) {
	    return new Array(matrix.rows + 1).fill(0);
	  } else {
	    let returnArray = matrix.addRow(index, [0]);
	    for (let i = 0; i < returnArray.rows; i++) {
	      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
	        returnArray.set(i, 0, 0);
	      }
	    }
	    return returnArray.to1DArray();
	  }
	}

	function linearDependencies(matrix, options = {}) {
	  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;
	  matrix = Matrix.checkMatrix(matrix);

	  let n = matrix.rows;
	  let results = new Matrix(n, n);

	  for (let i = 0; i < n; i++) {
	    let b = Matrix.columnVector(matrix.getRow(i));
	    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();
	    let svd = new SingularValueDecomposition(Abis);
	    let x = svd.solve(b);
	    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();
	    results.setRow(
	      i,
	      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),
	    );
	  }
	  return results;
	}

	function pseudoInverse(matrix, threshold = Number.EPSILON) {
	  matrix = Matrix.checkMatrix(matrix);
	  if (matrix.isEmpty()) {
	    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular
	    // (0xn)*(nx0)*(0xn) = 0xn
	    // (nx0)*(0xn)*(nx0) = nx0
	    return matrix.transpose();
	  }
	  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });

	  let U = svdSolution.leftSingularVectors;
	  let V = svdSolution.rightSingularVectors;
	  let s = svdSolution.diagonal;

	  for (let i = 0; i < s.length; i++) {
	    if (Math.abs(s[i]) > threshold) {
	      s[i] = 1.0 / s[i];
	    } else {
	      s[i] = 0.0;
	    }
	  }

	  return V.mmul(Matrix.diag(s).mmul(U.transpose()));
	}

	function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
	  xMatrix = new Matrix(xMatrix);
	  let yIsSame = false;
	  if (
	    typeof yMatrix === 'object' &&
	    !Matrix.isMatrix(yMatrix) &&
	    !isAnyArray.isAnyArray(yMatrix)
	  ) {
	    options = yMatrix;
	    yMatrix = xMatrix;
	    yIsSame = true;
	  } else {
	    yMatrix = new Matrix(yMatrix);
	  }
	  if (xMatrix.rows !== yMatrix.rows) {
	    throw new TypeError('Both matrices must have the same number of rows');
	  }
	  const { center = true } = options;
	  if (center) {
	    xMatrix = xMatrix.center('column');
	    if (!yIsSame) {
	      yMatrix = yMatrix.center('column');
	    }
	  }
	  const cov = xMatrix.transpose().mmul(yMatrix);
	  for (let i = 0; i < cov.rows; i++) {
	    for (let j = 0; j < cov.columns; j++) {
	      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
	    }
	  }
	  return cov;
	}

	function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
	  xMatrix = new Matrix(xMatrix);
	  let yIsSame = false;
	  if (
	    typeof yMatrix === 'object' &&
	    !Matrix.isMatrix(yMatrix) &&
	    !isAnyArray.isAnyArray(yMatrix)
	  ) {
	    options = yMatrix;
	    yMatrix = xMatrix;
	    yIsSame = true;
	  } else {
	    yMatrix = new Matrix(yMatrix);
	  }
	  if (xMatrix.rows !== yMatrix.rows) {
	    throw new TypeError('Both matrices must have the same number of rows');
	  }

	  const { center = true, scale = true } = options;
	  if (center) {
	    xMatrix.center('column');
	    if (!yIsSame) {
	      yMatrix.center('column');
	    }
	  }
	  if (scale) {
	    xMatrix.scale('column');
	    if (!yIsSame) {
	      yMatrix.scale('column');
	    }
	  }

	  const sdx = xMatrix.standardDeviation('column', { unbiased: true });
	  const sdy = yIsSame
	    ? sdx
	    : yMatrix.standardDeviation('column', { unbiased: true });

	  const corr = xMatrix.transpose().mmul(yMatrix);
	  for (let i = 0; i < corr.rows; i++) {
	    for (let j = 0; j < corr.columns; j++) {
	      corr.set(
	        i,
	        j,
	        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),
	      );
	    }
	  }
	  return corr;
	}

	class EigenvalueDecomposition {
	  constructor(matrix, options = {}) {
	    const { assumeSymmetric = false } = options;

	    matrix = WrapperMatrix2D.checkMatrix(matrix);
	    if (!matrix.isSquare()) {
	      throw new Error('Matrix is not a square matrix');
	    }

	    if (matrix.isEmpty()) {
	      throw new Error('Matrix must be non-empty');
	    }

	    let n = matrix.columns;
	    let V = new Matrix(n, n);
	    let d = new Float64Array(n);
	    let e = new Float64Array(n);
	    let value = matrix;
	    let i, j;

	    let isSymmetric = false;
	    if (assumeSymmetric) {
	      isSymmetric = true;
	    } else {
	      isSymmetric = matrix.isSymmetric();
	    }

	    if (isSymmetric) {
	      for (i = 0; i < n; i++) {
	        for (j = 0; j < n; j++) {
	          V.set(i, j, value.get(i, j));
	        }
	      }
	      tred2(n, e, d, V);
	      tql2(n, e, d, V);
	    } else {
	      let H = new Matrix(n, n);
	      let ort = new Float64Array(n);
	      for (j = 0; j < n; j++) {
	        for (i = 0; i < n; i++) {
	          H.set(i, j, value.get(i, j));
	        }
	      }
	      orthes(n, H, ort, V);
	      hqr2(n, e, d, V, H);
	    }

	    this.n = n;
	    this.e = e;
	    this.d = d;
	    this.V = V;
	  }

	  get realEigenvalues() {
	    return Array.from(this.d);
	  }

	  get imaginaryEigenvalues() {
	    return Array.from(this.e);
	  }

	  get eigenvectorMatrix() {
	    return this.V;
	  }

	  get diagonalMatrix() {
	    let n = this.n;
	    let e = this.e;
	    let d = this.d;
	    let X = new Matrix(n, n);
	    let i, j;
	    for (i = 0; i < n; i++) {
	      for (j = 0; j < n; j++) {
	        X.set(i, j, 0);
	      }
	      X.set(i, i, d[i]);
	      if (e[i] > 0) {
	        X.set(i, i + 1, e[i]);
	      } else if (e[i] < 0) {
	        X.set(i, i - 1, e[i]);
	      }
	    }
	    return X;
	  }
	}

	function tred2(n, e, d, V) {
	  let f, g, h, i, j, k, hh, scale;

	  for (j = 0; j < n; j++) {
	    d[j] = V.get(n - 1, j);
	  }

	  for (i = n - 1; i > 0; i--) {
	    scale = 0;
	    h = 0;
	    for (k = 0; k < i; k++) {
	      scale = scale + Math.abs(d[k]);
	    }

	    if (scale === 0) {
	      e[i] = d[i - 1];
	      for (j = 0; j < i; j++) {
	        d[j] = V.get(i - 1, j);
	        V.set(i, j, 0);
	        V.set(j, i, 0);
	      }
	    } else {
	      for (k = 0; k < i; k++) {
	        d[k] /= scale;
	        h += d[k] * d[k];
	      }

	      f = d[i - 1];
	      g = Math.sqrt(h);
	      if (f > 0) {
	        g = -g;
	      }

	      e[i] = scale * g;
	      h = h - f * g;
	      d[i - 1] = f - g;
	      for (j = 0; j < i; j++) {
	        e[j] = 0;
	      }

	      for (j = 0; j < i; j++) {
	        f = d[j];
	        V.set(j, i, f);
	        g = e[j] + V.get(j, j) * f;
	        for (k = j + 1; k <= i - 1; k++) {
	          g += V.get(k, j) * d[k];
	          e[k] += V.get(k, j) * f;
	        }
	        e[j] = g;
	      }

	      f = 0;
	      for (j = 0; j < i; j++) {
	        e[j] /= h;
	        f += e[j] * d[j];
	      }

	      hh = f / (h + h);
	      for (j = 0; j < i; j++) {
	        e[j] -= hh * d[j];
	      }

	      for (j = 0; j < i; j++) {
	        f = d[j];
	        g = e[j];
	        for (k = j; k <= i - 1; k++) {
	          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));
	        }
	        d[j] = V.get(i - 1, j);
	        V.set(i, j, 0);
	      }
	    }
	    d[i] = h;
	  }

	  for (i = 0; i < n - 1; i++) {
	    V.set(n - 1, i, V.get(i, i));
	    V.set(i, i, 1);
	    h = d[i + 1];
	    if (h !== 0) {
	      for (k = 0; k <= i; k++) {
	        d[k] = V.get(k, i + 1) / h;
	      }

	      for (j = 0; j <= i; j++) {
	        g = 0;
	        for (k = 0; k <= i; k++) {
	          g += V.get(k, i + 1) * V.get(k, j);
	        }
	        for (k = 0; k <= i; k++) {
	          V.set(k, j, V.get(k, j) - g * d[k]);
	        }
	      }
	    }

	    for (k = 0; k <= i; k++) {
	      V.set(k, i + 1, 0);
	    }
	  }

	  for (j = 0; j < n; j++) {
	    d[j] = V.get(n - 1, j);
	    V.set(n - 1, j, 0);
	  }

	  V.set(n - 1, n - 1, 1);
	  e[0] = 0;
	}

	function tql2(n, e, d, V) {
	  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;

	  for (i = 1; i < n; i++) {
	    e[i - 1] = e[i];
	  }

	  e[n - 1] = 0;

	  let f = 0;
	  let tst1 = 0;
	  let eps = Number.EPSILON;

	  for (l = 0; l < n; l++) {
	    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
	    m = l;
	    while (m < n) {
	      if (Math.abs(e[m]) <= eps * tst1) {
	        break;
	      }
	      m++;
	    }

	    if (m > l) {
	      do {

	        g = d[l];
	        p = (d[l + 1] - g) / (2 * e[l]);
	        r = hypotenuse(p, 1);
	        if (p < 0) {
	          r = -r;
	        }

	        d[l] = e[l] / (p + r);
	        d[l + 1] = e[l] * (p + r);
	        dl1 = d[l + 1];
	        h = g - d[l];
	        for (i = l + 2; i < n; i++) {
	          d[i] -= h;
	        }

	        f = f + h;

	        p = d[m];
	        c = 1;
	        c2 = c;
	        c3 = c;
	        el1 = e[l + 1];
	        s = 0;
	        s2 = 0;
	        for (i = m - 1; i >= l; i--) {
	          c3 = c2;
	          c2 = c;
	          s2 = s;
	          g = c * e[i];
	          h = c * p;
	          r = hypotenuse(p, e[i]);
	          e[i + 1] = s * r;
	          s = e[i] / r;
	          c = p / r;
	          p = c * d[i] - s * g;
	          d[i + 1] = h + s * (c * g + s * d[i]);

	          for (k = 0; k < n; k++) {
	            h = V.get(k, i + 1);
	            V.set(k, i + 1, s * V.get(k, i) + c * h);
	            V.set(k, i, c * V.get(k, i) - s * h);
	          }
	        }

	        p = (-s * s2 * c3 * el1 * e[l]) / dl1;
	        e[l] = s * p;
	        d[l] = c * p;
	      } while (Math.abs(e[l]) > eps * tst1);
	    }
	    d[l] = d[l] + f;
	    e[l] = 0;
	  }

	  for (i = 0; i < n - 1; i++) {
	    k = i;
	    p = d[i];
	    for (j = i + 1; j < n; j++) {
	      if (d[j] < p) {
	        k = j;
	        p = d[j];
	      }
	    }

	    if (k !== i) {
	      d[k] = d[i];
	      d[i] = p;
	      for (j = 0; j < n; j++) {
	        p = V.get(j, i);
	        V.set(j, i, V.get(j, k));
	        V.set(j, k, p);
	      }
	    }
	  }
	}

	function orthes(n, H, ort, V) {
	  let low = 0;
	  let high = n - 1;
	  let f, g, h, i, j, m;
	  let scale;

	  for (m = low + 1; m <= high - 1; m++) {
	    scale = 0;
	    for (i = m; i <= high; i++) {
	      scale = scale + Math.abs(H.get(i, m - 1));
	    }

	    if (scale !== 0) {
	      h = 0;
	      for (i = high; i >= m; i--) {
	        ort[i] = H.get(i, m - 1) / scale;
	        h += ort[i] * ort[i];
	      }

	      g = Math.sqrt(h);
	      if (ort[m] > 0) {
	        g = -g;
	      }

	      h = h - ort[m] * g;
	      ort[m] = ort[m] - g;

	      for (j = m; j < n; j++) {
	        f = 0;
	        for (i = high; i >= m; i--) {
	          f += ort[i] * H.get(i, j);
	        }

	        f = f / h;
	        for (i = m; i <= high; i++) {
	          H.set(i, j, H.get(i, j) - f * ort[i]);
	        }
	      }

	      for (i = 0; i <= high; i++) {
	        f = 0;
	        for (j = high; j >= m; j--) {
	          f += ort[j] * H.get(i, j);
	        }

	        f = f / h;
	        for (j = m; j <= high; j++) {
	          H.set(i, j, H.get(i, j) - f * ort[j]);
	        }
	      }

	      ort[m] = scale * ort[m];
	      H.set(m, m - 1, scale * g);
	    }
	  }

	  for (i = 0; i < n; i++) {
	    for (j = 0; j < n; j++) {
	      V.set(i, j, i === j ? 1 : 0);
	    }
	  }

	  for (m = high - 1; m >= low + 1; m--) {
	    if (H.get(m, m - 1) !== 0) {
	      for (i = m + 1; i <= high; i++) {
	        ort[i] = H.get(i, m - 1);
	      }

	      for (j = m; j <= high; j++) {
	        g = 0;
	        for (i = m; i <= high; i++) {
	          g += ort[i] * V.get(i, j);
	        }

	        g = g / ort[m] / H.get(m, m - 1);
	        for (i = m; i <= high; i++) {
	          V.set(i, j, V.get(i, j) + g * ort[i]);
	        }
	      }
	    }
	  }
	}

	function hqr2(nn, e, d, V, H) {
	  let n = nn - 1;
	  let low = 0;
	  let high = nn - 1;
	  let eps = Number.EPSILON;
	  let exshift = 0;
	  let norm = 0;
	  let p = 0;
	  let q = 0;
	  let r = 0;
	  let s = 0;
	  let z = 0;
	  let iter = 0;
	  let i, j, k, l, m, t, w, x, y;
	  let ra, sa, vr, vi;
	  let notlast, cdivres;

	  for (i = 0; i < nn; i++) {
	    if (i < low || i > high) {
	      d[i] = H.get(i, i);
	      e[i] = 0;
	    }

	    for (j = Math.max(i - 1, 0); j < nn; j++) {
	      norm = norm + Math.abs(H.get(i, j));
	    }
	  }

	  while (n >= low) {
	    l = n;
	    while (l > low) {
	      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
	      if (s === 0) {
	        s = norm;
	      }
	      if (Math.abs(H.get(l, l - 1)) < eps * s) {
	        break;
	      }
	      l--;
	    }

	    if (l === n) {
	      H.set(n, n, H.get(n, n) + exshift);
	      d[n] = H.get(n, n);
	      e[n] = 0;
	      n--;
	      iter = 0;
	    } else if (l === n - 1) {
	      w = H.get(n, n - 1) * H.get(n - 1, n);
	      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
	      q = p * p + w;
	      z = Math.sqrt(Math.abs(q));
	      H.set(n, n, H.get(n, n) + exshift);
	      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
	      x = H.get(n, n);

	      if (q >= 0) {
	        z = p >= 0 ? p + z : p - z;
	        d[n - 1] = x + z;
	        d[n] = d[n - 1];
	        if (z !== 0) {
	          d[n] = x - w / z;
	        }
	        e[n - 1] = 0;
	        e[n] = 0;
	        x = H.get(n, n - 1);
	        s = Math.abs(x) + Math.abs(z);
	        p = x / s;
	        q = z / s;
	        r = Math.sqrt(p * p + q * q);
	        p = p / r;
	        q = q / r;

	        for (j = n - 1; j < nn; j++) {
	          z = H.get(n - 1, j);
	          H.set(n - 1, j, q * z + p * H.get(n, j));
	          H.set(n, j, q * H.get(n, j) - p * z);
	        }

	        for (i = 0; i <= n; i++) {
	          z = H.get(i, n - 1);
	          H.set(i, n - 1, q * z + p * H.get(i, n));
	          H.set(i, n, q * H.get(i, n) - p * z);
	        }

	        for (i = low; i <= high; i++) {
	          z = V.get(i, n - 1);
	          V.set(i, n - 1, q * z + p * V.get(i, n));
	          V.set(i, n, q * V.get(i, n) - p * z);
	        }
	      } else {
	        d[n - 1] = x + p;
	        d[n] = x + p;
	        e[n - 1] = z;
	        e[n] = -z;
	      }

	      n = n - 2;
	      iter = 0;
	    } else {
	      x = H.get(n, n);
	      y = 0;
	      w = 0;
	      if (l < n) {
	        y = H.get(n - 1, n - 1);
	        w = H.get(n, n - 1) * H.get(n - 1, n);
	      }

	      if (iter === 10) {
	        exshift += x;
	        for (i = low; i <= n; i++) {
	          H.set(i, i, H.get(i, i) - x);
	        }
	        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
	        // eslint-disable-next-line no-multi-assign
	        x = y = 0.75 * s;
	        w = -0.4375 * s * s;
	      }

	      if (iter === 30) {
	        s = (y - x) / 2;
	        s = s * s + w;
	        if (s > 0) {
	          s = Math.sqrt(s);
	          if (y < x) {
	            s = -s;
	          }
	          s = x - w / ((y - x) / 2 + s);
	          for (i = low; i <= n; i++) {
	            H.set(i, i, H.get(i, i) - s);
	          }
	          exshift += s;
	          // eslint-disable-next-line no-multi-assign
	          x = y = w = 0.964;
	        }
	      }

	      iter = iter + 1;

	      m = n - 2;
	      while (m >= l) {
	        z = H.get(m, m);
	        r = x - z;
	        s = y - z;
	        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);
	        q = H.get(m + 1, m + 1) - z - r - s;
	        r = H.get(m + 2, m + 1);
	        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
	        p = p / s;
	        q = q / s;
	        r = r / s;
	        if (m === l) {
	          break;
	        }
	        if (
	          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <
	          eps *
	            (Math.abs(p) *
	              (Math.abs(H.get(m - 1, m - 1)) +
	                Math.abs(z) +
	                Math.abs(H.get(m + 1, m + 1))))
	        ) {
	          break;
	        }
	        m--;
	      }

	      for (i = m + 2; i <= n; i++) {
	        H.set(i, i - 2, 0);
	        if (i > m + 2) {
	          H.set(i, i - 3, 0);
	        }
	      }

	      for (k = m; k <= n - 1; k++) {
	        notlast = k !== n - 1;
	        if (k !== m) {
	          p = H.get(k, k - 1);
	          q = H.get(k + 1, k - 1);
	          r = notlast ? H.get(k + 2, k - 1) : 0;
	          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
	          if (x !== 0) {
	            p = p / x;
	            q = q / x;
	            r = r / x;
	          }
	        }

	        if (x === 0) {
	          break;
	        }

	        s = Math.sqrt(p * p + q * q + r * r);
	        if (p < 0) {
	          s = -s;
	        }

	        if (s !== 0) {
	          if (k !== m) {
	            H.set(k, k - 1, -s * x);
	          } else if (l !== m) {
	            H.set(k, k - 1, -H.get(k, k - 1));
	          }

	          p = p + s;
	          x = p / s;
	          y = q / s;
	          z = r / s;
	          q = q / p;
	          r = r / p;

	          for (j = k; j < nn; j++) {
	            p = H.get(k, j) + q * H.get(k + 1, j);
	            if (notlast) {
	              p = p + r * H.get(k + 2, j);
	              H.set(k + 2, j, H.get(k + 2, j) - p * z);
	            }

	            H.set(k, j, H.get(k, j) - p * x);
	            H.set(k + 1, j, H.get(k + 1, j) - p * y);
	          }

	          for (i = 0; i <= Math.min(n, k + 3); i++) {
	            p = x * H.get(i, k) + y * H.get(i, k + 1);
	            if (notlast) {
	              p = p + z * H.get(i, k + 2);
	              H.set(i, k + 2, H.get(i, k + 2) - p * r);
	            }

	            H.set(i, k, H.get(i, k) - p);
	            H.set(i, k + 1, H.get(i, k + 1) - p * q);
	          }

	          for (i = low; i <= high; i++) {
	            p = x * V.get(i, k) + y * V.get(i, k + 1);
	            if (notlast) {
	              p = p + z * V.get(i, k + 2);
	              V.set(i, k + 2, V.get(i, k + 2) - p * r);
	            }

	            V.set(i, k, V.get(i, k) - p);
	            V.set(i, k + 1, V.get(i, k + 1) - p * q);
	          }
	        }
	      }
	    }
	  }

	  if (norm === 0) {
	    return;
	  }

	  for (n = nn - 1; n >= 0; n--) {
	    p = d[n];
	    q = e[n];

	    if (q === 0) {
	      l = n;
	      H.set(n, n, 1);
	      for (i = n - 1; i >= 0; i--) {
	        w = H.get(i, i) - p;
	        r = 0;
	        for (j = l; j <= n; j++) {
	          r = r + H.get(i, j) * H.get(j, n);
	        }

	        if (e[i] < 0) {
	          z = w;
	          s = r;
	        } else {
	          l = i;
	          if (e[i] === 0) {
	            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
	          } else {
	            x = H.get(i, i + 1);
	            y = H.get(i + 1, i);
	            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
	            t = (x * s - z * r) / q;
	            H.set(i, n, t);
	            H.set(
	              i + 1,
	              n,
	              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,
	            );
	          }

	          t = Math.abs(H.get(i, n));
	          if (eps * t * t > 1) {
	            for (j = i; j <= n; j++) {
	              H.set(j, n, H.get(j, n) / t);
	            }
	          }
	        }
	      }
	    } else if (q < 0) {
	      l = n - 1;

	      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
	        H.set(n - 1, n - 1, q / H.get(n, n - 1));
	        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
	      } else {
	        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
	        H.set(n - 1, n - 1, cdivres[0]);
	        H.set(n - 1, n, cdivres[1]);
	      }

	      H.set(n, n - 1, 0);
	      H.set(n, n, 1);
	      for (i = n - 2; i >= 0; i--) {
	        ra = 0;
	        sa = 0;
	        for (j = l; j <= n; j++) {
	          ra = ra + H.get(i, j) * H.get(j, n - 1);
	          sa = sa + H.get(i, j) * H.get(j, n);
	        }

	        w = H.get(i, i) - p;

	        if (e[i] < 0) {
	          z = w;
	          r = ra;
	          s = sa;
	        } else {
	          l = i;
	          if (e[i] === 0) {
	            cdivres = cdiv(-ra, -sa, w, q);
	            H.set(i, n - 1, cdivres[0]);
	            H.set(i, n, cdivres[1]);
	          } else {
	            x = H.get(i, i + 1);
	            y = H.get(i + 1, i);
	            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
	            vi = (d[i] - p) * 2 * q;
	            if (vr === 0 && vi === 0) {
	              vr =
	                eps *
	                norm *
	                (Math.abs(w) +
	                  Math.abs(q) +
	                  Math.abs(x) +
	                  Math.abs(y) +
	                  Math.abs(z));
	            }
	            cdivres = cdiv(
	              x * r - z * ra + q * sa,
	              x * s - z * sa - q * ra,
	              vr,
	              vi,
	            );
	            H.set(i, n - 1, cdivres[0]);
	            H.set(i, n, cdivres[1]);
	            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
	              H.set(
	                i + 1,
	                n - 1,
	                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,
	              );
	              H.set(
	                i + 1,
	                n,
	                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,
	              );
	            } else {
	              cdivres = cdiv(
	                -r - y * H.get(i, n - 1),
	                -s - y * H.get(i, n),
	                z,
	                q,
	              );
	              H.set(i + 1, n - 1, cdivres[0]);
	              H.set(i + 1, n, cdivres[1]);
	            }
	          }

	          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
	          if (eps * t * t > 1) {
	            for (j = i; j <= n; j++) {
	              H.set(j, n - 1, H.get(j, n - 1) / t);
	              H.set(j, n, H.get(j, n) / t);
	            }
	          }
	        }
	      }
	    }
	  }

	  for (i = 0; i < nn; i++) {
	    if (i < low || i > high) {
	      for (j = i; j < nn; j++) {
	        V.set(i, j, H.get(i, j));
	      }
	    }
	  }

	  for (j = nn - 1; j >= low; j--) {
	    for (i = low; i <= high; i++) {
	      z = 0;
	      for (k = low; k <= Math.min(j, high); k++) {
	        z = z + V.get(i, k) * H.get(k, j);
	      }
	      V.set(i, j, z);
	    }
	  }
	}

	function cdiv(xr, xi, yr, yi) {
	  let r, d;
	  if (Math.abs(yr) > Math.abs(yi)) {
	    r = yi / yr;
	    d = yr + r * yi;
	    return [(xr + r * xi) / d, (xi - r * xr) / d];
	  } else {
	    r = yr / yi;
	    d = yi + r * yr;
	    return [(r * xr + xi) / d, (r * xi - xr) / d];
	  }
	}

	class CholeskyDecomposition {
	  constructor(value) {
	    value = WrapperMatrix2D.checkMatrix(value);
	    if (!value.isSymmetric()) {
	      throw new Error('Matrix is not symmetric');
	    }

	    let a = value;
	    let dimension = a.rows;
	    let l = new Matrix(dimension, dimension);
	    let positiveDefinite = true;
	    let i, j, k;

	    for (j = 0; j < dimension; j++) {
	      let d = 0;
	      for (k = 0; k < j; k++) {
	        let s = 0;
	        for (i = 0; i < k; i++) {
	          s += l.get(k, i) * l.get(j, i);
	        }
	        s = (a.get(j, k) - s) / l.get(k, k);
	        l.set(j, k, s);
	        d = d + s * s;
	      }

	      d = a.get(j, j) - d;

	      positiveDefinite &&= d > 0;
	      l.set(j, j, Math.sqrt(Math.max(d, 0)));
	      for (k = j + 1; k < dimension; k++) {
	        l.set(j, k, 0);
	      }
	    }

	    this.L = l;
	    this.positiveDefinite = positiveDefinite;
	  }

	  isPositiveDefinite() {
	    return this.positiveDefinite;
	  }

	  solve(value) {
	    value = WrapperMatrix2D.checkMatrix(value);

	    let l = this.L;
	    let dimension = l.rows;

	    if (value.rows !== dimension) {
	      throw new Error('Matrix dimensions do not match');
	    }
	    if (this.isPositiveDefinite() === false) {
	      throw new Error('Matrix is not positive definite');
	    }

	    let count = value.columns;
	    let B = value.clone();
	    let i, j, k;

	    for (k = 0; k < dimension; k++) {
	      for (j = 0; j < count; j++) {
	        for (i = 0; i < k; i++) {
	          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));
	        }
	        B.set(k, j, B.get(k, j) / l.get(k, k));
	      }
	    }

	    for (k = dimension - 1; k >= 0; k--) {
	      for (j = 0; j < count; j++) {
	        for (i = k + 1; i < dimension; i++) {
	          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));
	        }
	        B.set(k, j, B.get(k, j) / l.get(k, k));
	      }
	    }

	    return B;
	  }

	  get lowerTriangularMatrix() {
	    return this.L;
	  }
	}

	class nipals {
	  constructor(X, options = {}) {
	    X = WrapperMatrix2D.checkMatrix(X);
	    let { Y } = options;
	    const {
	      scaleScores = false,
	      maxIterations = 1000,
	      terminationCriteria = 1e-10,
	    } = options;

	    let u;
	    if (Y) {
	      if (isAnyArray.isAnyArray(Y) && typeof Y[0] === 'number') {
	        Y = Matrix.columnVector(Y);
	      } else {
	        Y = WrapperMatrix2D.checkMatrix(Y);
	      }
	      if (Y.rows !== X.rows) {
	        throw new Error('Y should have the same number of rows as X');
	      }
	      u = Y.getColumnVector(0);
	    } else {
	      u = X.getColumnVector(0);
	    }

	    let diff = 1;
	    let t, q, w, tOld;

	    for (
	      let counter = 0;
	      counter < maxIterations && diff > terminationCriteria;
	      counter++
	    ) {
	      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));
	      w = w.div(w.norm());

	      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));

	      if (counter > 0) {
	        diff = t.clone().sub(tOld).pow(2).sum();
	      }
	      tOld = t.clone();

	      if (Y) {
	        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
	        q = q.div(q.norm());

	        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
	      } else {
	        u = t;
	      }
	    }

	    if (Y) {
	      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
	      p = p.div(p.norm());
	      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
	      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
	      let yResidual = Y.clone().sub(
	        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),
	      );

	      this.t = t;
	      this.p = p.transpose();
	      this.w = w.transpose();
	      this.q = q;
	      this.u = u;
	      this.s = t.transpose().mmul(t);
	      this.xResidual = xResidual;
	      this.yResidual = yResidual;
	      this.betas = residual;
	    } else {
	      this.w = w.transpose();
	      this.s = t.transpose().mmul(t).sqrt();
	      if (scaleScores) {
	        this.t = t.clone().div(this.s.get(0, 0));
	      } else {
	        this.t = t;
	      }
	      this.xResidual = X.sub(t.mmul(w.transpose()));
	    }
	  }
	}

	matrix$1.AbstractMatrix = AbstractMatrix;
	matrix$1.CHO = CholeskyDecomposition;
	matrix$1.CholeskyDecomposition = CholeskyDecomposition;
	matrix$1.DistanceMatrix = DistanceMatrix;
	matrix$1.EVD = EigenvalueDecomposition;
	matrix$1.EigenvalueDecomposition = EigenvalueDecomposition;
	matrix$1.LU = LuDecomposition;
	matrix$1.LuDecomposition = LuDecomposition;
	matrix$1.Matrix = Matrix;
	matrix$1.MatrixColumnSelectionView = MatrixColumnSelectionView;
	matrix$1.MatrixColumnView = MatrixColumnView;
	matrix$1.MatrixFlipColumnView = MatrixFlipColumnView;
	matrix$1.MatrixFlipRowView = MatrixFlipRowView;
	matrix$1.MatrixRowSelectionView = MatrixRowSelectionView;
	matrix$1.MatrixRowView = MatrixRowView;
	matrix$1.MatrixSelectionView = MatrixSelectionView;
	matrix$1.MatrixSubView = MatrixSubView;
	matrix$1.MatrixTransposeView = MatrixTransposeView;
	matrix$1.NIPALS = nipals;
	matrix$1.Nipals = nipals;
	matrix$1.QR = QrDecomposition;
	matrix$1.QrDecomposition = QrDecomposition;
	matrix$1.SVD = SingularValueDecomposition;
	matrix$1.SingularValueDecomposition = SingularValueDecomposition;
	matrix$1.SymmetricMatrix = SymmetricMatrix;
	matrix$1.WrapperMatrix1D = WrapperMatrix1D;
	matrix$1.WrapperMatrix2D = WrapperMatrix2D;
	matrix$1.correlation = correlation;
	matrix$1.covariance = covariance;
	matrix$1.default = Matrix;
	matrix$1.determinant = determinant;
	matrix$1.inverse = inverse;
	matrix$1.linearDependencies = linearDependencies;
	matrix$1.pseudoInverse = pseudoInverse;
	matrix$1.solve = solve;
	matrix$1.wrap = wrap;
	return matrix$1;
}

var matrixExports = /*@__PURE__*/ requireMatrix();
var matrix = /*@__PURE__*/getDefaultExportFromCjs(matrixExports);

const Matrix = matrixExports.Matrix;
matrix.Matrix ? matrix.Matrix : matrixExports.Matrix;

function sum(input) {
  if (!isAnyArray(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var sumValue = 0;

  for (var i = 0; i < input.length; i++) {
    sumValue += input[i];
  }

  return sumValue;
}

function mean$1(input) {
  return sum(input) / input.length;
}

/**
 * @private
 * return an array of probabilities of each class
 * @param {Array} array - contains the classes
 * @param {number} numberOfClasses
 * @return {Matrix} - rowVector of probabilities.
 */
function toDiscreteDistribution(array, numberOfClasses) {
  let counts = new Array(numberOfClasses).fill(0);
  for (let i = 0; i < array.length; ++i) {
    counts[array[i]] += 1 / array.length;
  }

  return Matrix.rowVector(counts);
}

/**
 * @private
 * Retrieves the impurity of array of predictions
 * @param {Array} array - predictions.
 * @return {number} Gini impurity
 */
function giniImpurity(array) {
  if (array.length === 0) {
    return 0;
  }

  let probabilities = toDiscreteDistribution(
    array,
    getNumberOfClasses(array),
  ).getRow(0);

  let sum = 0.0;
  for (let i = 0; i < probabilities.length; ++i) {
    sum += probabilities[i] * probabilities[i];
  }

  return 1 - sum;
}

/**
 * @private
 * Return the number of classes given the array of predictions.
 * @param {Array} array - predictions.
 * @return {number} Number of classes.
 */
function getNumberOfClasses(array) {
  return array
    .filter((val, i, arr) => {
      return arr.indexOf(val) === i;
    })
    .map((val) => val + 1)
    .reduce((a, b) => Math.max(a, b));
}

/**
 * @private
 * Calculates the Gini Gain of an array of predictions and those predictions splitted by a feature.
 * @param {Array} array - Predictions
 * @param {object} splitted - Object with elements "greater" and "lesser" that contains an array of predictions splitted.
 * @return {number} - Gini Gain.
 */

function giniGain(array, splitted) {
  let splitsImpurity = 0.0;
  let splits = ['greater', 'lesser'];

  for (let i = 0; i < splits.length; ++i) {
    let currentSplit = splitted[splits[i]];
    splitsImpurity +=
      (giniImpurity(currentSplit) * currentSplit.length) / array.length;
  }

  return giniImpurity(array) - splitsImpurity;
}

/**
 * @private
 * Calculates the squared error of a predictions values.
 * @param {Array} array - predictions values
 * @return {number} squared error.
 */
function squaredError(array) {
  let l = array.length;
  if (l === 0) {
    return 0.0;
  }

  let m = mean$1(array);
  let error = 0.0;

  for (let i = 0; i < l; ++i) {
    let currentElement = array[i];
    error += (currentElement - m) * (currentElement - m);
  }

  return error;
}

/**
 * @private
 * Calculates the sum of squared error of the two arrays that contains the splitted values.
 * @param {Array} array - this argument is no necessary but is used to fit with the main interface.
 * @param {object} splitted - Object with elements "greater" and "lesser" that contains an array of predictions splitted.
 * @return {number} - sum of squared errors.
 */
function regressionError(array, splitted) {
  let error = 0.0;
  let splits = ['greater', 'lesser'];

  for (let i = 0; i < splits.length; ++i) {
    let currentSplit = splitted[splits[i]];
    error += squaredError(currentSplit);
  }
  return error;
}

/**
 * @private
 * Split the training set and values from a given column of the training set if is less than a value
 * @param {Matrix} X - Training set.
 * @param {Array} y - Training values.
 * @param {number} column - Column to split.
 * @param {number} value - value to split the Training set and values.
 * @return {object} - Object that contains the splitted values.
 */
function matrixSplitter(X, y, column, value) {
  let lesserX = [];
  let greaterX = [];
  let lesserY = [];
  let greaterY = [];

  for (let i = 0; i < X.rows; ++i) {
    if (X.get(i, column) < value) {
      lesserX.push(X.getRow(i));
      lesserY.push(y[i]);
    } else {
      greaterX.push(X.getRow(i));
      greaterY.push(y[i]);
    }
  }

  return {
    greaterX: greaterX,
    greaterY: greaterY,
    lesserX: lesserX,
    lesserY: lesserY,
  };
}

/**
 * @private
 * Calculates the mean between two values
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
function mean(a, b) {
  return (a + b) / 2;
}

/**
 * @private
 * Returns a list of tuples that contains the i-th element of each array.
 * @param {Array} a
 * @param {Array} b
 * @return {Array} list of tuples.
 */
function zip(a, b) {
  if (a.length !== b.length) {
    throw new TypeError(
      `Error on zip: the size of a: ${a.length} is different from b: ${b.length}`,
    );
  }

  let ret = new Array(a.length);
  for (let i = 0; i < a.length; ++i) {
    ret[i] = [a[i], b[i]];
  }

  return ret;
}

const gainFunctions = {
  gini: giniGain,
  regression: regressionError,
};

const splitFunctions = {
  mean: mean,
};

class TreeNode {
  /**
   * @private
   * Constructor for a tree node given the options received on the main classes (DecisionTreeClassifier, DecisionTreeRegression)
   * @param {object|TreeNode} options for loading
   * @constructor
   */
  constructor(options) {
    // options parameters
    this.kind = options.kind;
    this.gainFunction = options.gainFunction;
    this.splitFunction = options.splitFunction;
    this.minNumSamples = options.minNumSamples;
    this.maxDepth = options.maxDepth;
  this.gainThreshold = options.gainThreshold || 0;
  }

  /**
   * @private
   * Function that retrieve the best feature to make the split.
   * @param {Matrix} XTranspose - Training set transposed
   * @param {Array} y - labels or values (depending of the decision tree)
   * @return {object} - return tree values, the best gain, column and the split value.
   */
  bestSplit(XTranspose, y) {
    // Depending in the node tree class, we set the variables to check information gain (to classify)
    // or error (for regression)

    let bestGain = this.kind === 'classifier' ? -Infinity : Infinity;
    let check = this.kind === 'classifier' ? (a, b) => a > b : (a, b) => a < b;

    let maxColumn;
    let maxValue;
    let numberSamples;

    for (let i = 0; i < XTranspose.rows; ++i) {
      let currentFeature = XTranspose.getRow(i);
      let splitValues = this.featureSplit(currentFeature, y);
      for (let j = 0; j < splitValues.length; ++j) {
        let currentSplitVal = splitValues[j];
        let splitted = this.split(currentFeature, y, currentSplitVal);

        let gain = gainFunctions[this.gainFunction](y, splitted);
        if (check(gain, bestGain)) {
          maxColumn = i;
          maxValue = currentSplitVal;
          bestGain = gain;
          numberSamples = currentFeature.length;
        }
      }
    }

    return {
      maxGain: bestGain,
      maxColumn: maxColumn,
      maxValue: maxValue,
      numberSamples: numberSamples,
    };
  }

  /**
   * @private
   * Makes the split of the training labels or values from the training set feature given a split value.
   * @param {Array} x - Training set feature
   * @param {Array} y - Training set value or label
   * @param {number} splitValue
   * @return {object}
   */
  split(x, y, splitValue) {
    let lesser = [];
    let greater = [];

    for (let i = 0; i < x.length; ++i) {
      if (x[i] < splitValue) {
        lesser.push(y[i]);
      } else {
        greater.push(y[i]);
      }
    }

    return {
      greater: greater,
      lesser: lesser,
    };
  }

  /**
   * @private
   * Calculates the possible points to split over the tree given a training set feature and corresponding labels or values.
   * @param {Array} x - Training set feature
   * @param {Array} y - Training set value or label
   * @return {Array} possible split values.
   */
  featureSplit(x, y) {
    let splitValues = [];
    let arr = zip(x, y);
    arr.sort((a, b) => {
      return a[0] - b[0];
    });

    for (let i = 1; i < arr.length; ++i) {
      if (arr[i - 1][1] !== arr[i][1]) {
        splitValues.push(
          splitFunctions[this.splitFunction](arr[i - 1][0], arr[i][0]),
        );
      }
    }

    return splitValues;
  }

  /**
   * @private
   * Calculate the predictions of a leaf tree node given the training labels or values
   * @param {Array} y
   */
  calculatePrediction(y) {
    if (this.kind === 'classifier') {
      this.distribution = toDiscreteDistribution(
        y,
        getNumberOfClasses(y),
      );
      if (this.distribution.columns === 0) {
        throw new TypeError('Error on calculate the prediction');
      }
    } else {
      this.distribution = mean$1(y);
    }
  }

  /**
   * @private
   * Train a node given the training set and labels, because it trains recursively, it also receive
   * the current depth of the node, parent gain to avoid infinite recursion and boolean value to check if
   * the training set is transposed.
   * @param {Matrix} X - Training set (could be transposed or not given transposed).
   * @param {Array} y - Training labels or values.
   * @param {number} currentDepth - Current depth of the node.
   * @param {number} parentGain - parent node gain or error.
   */
  train(X, y, currentDepth, parentGain) {
    if (X.rows <= this.minNumSamples) {
      this.calculatePrediction(y);
      return;
    }
    if (parentGain === undefined) parentGain = 0.0;

    let XTranspose = X.transpose();
    let split = this.bestSplit(XTranspose, y);

    this.splitValue = split.maxValue;
    this.splitColumn = split.maxColumn;
    this.gain = split.maxGain;
    this.numberSamples = split.numberSamples;

    let splittedMatrix = matrixSplitter(
      X,
      y,
      this.splitColumn,
      this.splitValue,
    );

    if (
      currentDepth < this.maxDepth &&
      this.gain > this.gainThreshold &&
      this.gain !== parentGain &&
      splittedMatrix.lesserX.length > 0 &&
      splittedMatrix.greaterX.length > 0
    ) {
      this.left = new TreeNode(this);
      this.right = new TreeNode(this);

      let lesserX = new Matrix(splittedMatrix.lesserX);
      let greaterX = new Matrix(splittedMatrix.greaterX);

      this.left.train(
        lesserX,
        splittedMatrix.lesserY,
        currentDepth + 1,
        this.gain,
      );
      this.right.train(
        greaterX,
        splittedMatrix.greaterY,
        currentDepth + 1,
        this.gain,
      );
    } else {
      this.calculatePrediction(y);
    }
  }

  /**
   * @private
   * Calculates the prediction of a given element.
   * @param {Array} row
   * @return {number|Array} prediction
   *          * if a node is a classifier returns an array of probabilities of each class.
   *          * if a node is for regression returns a number with the prediction.
   */
  classify(row) {
    if (this.right && this.left) {
      if (row[this.splitColumn] < this.splitValue) {
        return this.left.classify(row);
      } else {
        return this.right.classify(row);
      }
    }

    return this.distribution;
  }

  /**
   * @private
   * Set the parameter of the current node and their children.
   * @param {object} node - parameters of the current node and the children.
   */
  setNodeParameters(node) {
    if (node.distribution !== undefined) {
      this.distribution =
        node.distribution.constructor === Array
          ? new Matrix(node.distribution)
          : node.distribution;
    } else {
      this.distribution = undefined;
      this.splitValue = node.splitValue;
      this.splitColumn = node.splitColumn;
      this.gain = node.gain;

      this.left = new TreeNode(this);
      this.right = new TreeNode(this);

      if (node.left !== {}) {
        this.left.setNodeParameters(node.left);
      }
      if (node.right !== {}) {
        this.right.setNodeParameters(node.right);
      }
    }
  }
}

const defaultOptions = {
  gainFunction: 'regression',
  splitFunction: 'mean',
  minNumSamples: 3,
  maxDepth: Infinity,
};

class DecisionTreeRegression {
  /**
   * Create new Decision Tree Regression with CART implementation with the given options.
   * @param {object} options
   * @param {string} [options.gainFunction="regression"] - gain function to get the best split, "regression" the only one supported.
   * @param {string} [options.splitFunction="mean"] - given two integers from a split feature, get the value to split, "mean" the only one supported.
   * @param {number} [options.minNumSamples=3] - minimum number of samples to create a leaf node to decide a class.
   * @param {number} [options.maxDepth=Infinity] - Max depth of the tree.
   * @param {object} model - for load purposes.
   */
  constructor(options, model) {
    if (options === true) {
      this.options = model.options;
      this.root = new TreeNode(model.options);
      this.root.setNodeParameters(model.root);
    } else {
      this.options = Object.assign({}, defaultOptions, options);
      this.options.kind = 'regression';
    }
  }

  /**
   * Train the decision tree with the given training set and values.
   * @param {Matrix|MatrixTransposeView|Array} trainingSet
   * @param {Array} trainingValues
   */
  train(trainingSet, trainingValues) {
    this.root = new TreeNode(this.options);

    if (
      typeof trainingSet[0] !== 'undefined' &&
      trainingSet[0].length === undefined
    ) {
      trainingSet = Matrix.columnVector(trainingSet);
    } else {
      trainingSet = Matrix.checkMatrix(trainingSet);
    }
    this.root.train(trainingSet, trainingValues, 0);
  }

  /**
   * Predicts the values given the matrix to predict.
   * @param {Matrix|MatrixTransposeView|Array} toPredict
   * @return {Array} predictions
   */
  predict(toPredict) {
    if (
      typeof toPredict[0] !== 'undefined' &&
      toPredict[0].length === undefined
    ) {
      toPredict = Matrix.columnVector(toPredict);
    }
    toPredict = Matrix.checkMatrix(toPredict);

    let predictions = new Array(toPredict.rows);
    for (let i = 0; i < toPredict.rows; ++i) {
      predictions[i] = this.root.classify(toPredict.getRow(i));
    }

    return predictions;
  }

  /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */
  toJSON() {
    return {
      options: this.options,
      root: this.root,
      name: 'DTRegression',
    };
  }

  /**
   * Load a Decision tree regression with the given model.
   * @param {object} model
   * @return {DecisionTreeRegression}
   */
  static load(model) {
    if (model.name !== 'DTRegression') {
      throw new RangeError(`Invalid model:${model.name}`);
    }

    return new DecisionTreeRegression(true, model);
  }
}

function performCARTAnalysis(records, columns, columnTypes, targetColumn = null) {
  // Prepare data for CART analysis
  const numericColumns = columns.filter(col => 
    ['integer', 'float'].includes(columnTypes[col].type)
  );
  const categoricalColumns = columns.filter(col => 
    columnTypes[col].type === 'categorical' && 
    columnTypes[col].categories.length <= 20 // Limit categories
  );
  
  if (numericColumns.length === 0 || (numericColumns.length + categoricalColumns.length) < 3) {
    return {
      applicable: false,
      reason: 'Insufficient columns for meaningful CART analysis'
    };
  }
  
  // Auto-select target if not provided
  if (!targetColumn) {
    targetColumn = selectBestTarget(records, numericColumns);
  }
  
  if (!targetColumn) {
    return {
      applicable: false,
      reason: 'No suitable target variable found'
    };
  }
  
  // Prepare features and target
  const { features, target, featureNames } = prepareData(
    records, 
    numericColumns, 
    categoricalColumns, 
    targetColumn,
    columnTypes
  );
  
  if (features.length < 50) {
    return {
      applicable: false,
      reason: 'Too few samples for reliable CART analysis'
    };
  }
  
  // Build decision tree
  const treeConfig = {
    maxDepth: 5,
    minNumSamples: Math.max(5, Math.floor(features.length * 0.05))
  };
  
  const regression = new DecisionTreeRegression(treeConfig);
  regression.train(features, target);
  
  // Extract rules
  const rules = extractRules(regression.root, featureNames, 0, columnTypes);
  const importances = calculateFeatureImportances(regression, features, target, featureNames);
  
  // Find interesting segments
  const segments = findBusinessSegments(rules, records.length);
  
  return {
    applicable: true,
    targetVariable: targetColumn,
    featureNames,
    treeDepth: getTreeDepth(regression.root),
    rules,
    segments,
    featureImportances: importances,
    modelQuality: evaluateModelQuality(regression, features, target)
  };
}

function selectBestTarget(records, numericColumns, columnTypes) {
  let bestTarget = null;
  let bestScore = 0;
  
  numericColumns.forEach(col => {
    const values = records.map(r => r[col]).filter(v => v !== null && v !== undefined);
    const uniqueRatio = new Set(values).size / values.length;
    const variance = calculateVariance(values);
    
    // Score based on variance and uniqueness
    const score = uniqueRatio * Math.log(1 + variance);
    
    if (score > bestScore) {
      bestScore = score;
      bestTarget = col;
    }
  });
  
  return bestTarget;
}

function prepareData(records, numericColumns, categoricalColumns, targetColumn, columnTypes) {
  const features = [];
  const target = [];
  const featureNames = [];
  
  // Prepare feature names
  numericColumns.forEach(col => {
    if (col !== targetColumn) {
      featureNames.push(col);
    }
  });
  
  // One-hot encode categorical variables
  const encodings = {};
  categoricalColumns.forEach(col => {
    if (col !== targetColumn) {
      const categories = columnTypes[col].categories;
      encodings[col] = {};
      categories.forEach((cat, idx) => {
        const featureName = `${col}_${cat}`;
        encodings[col][cat] = featureNames.length;
        featureNames.push(featureName);
      });
    }
  });
  
  // Build feature matrix
  records.forEach(record => {
    const targetValue = record[targetColumn];
    if (targetValue === null || targetValue === undefined) return;
    
    const row = [];
    
    // Numeric features
    numericColumns.forEach(col => {
      if (col !== targetColumn) {
        const value = record[col];
        row.push(value !== null && value !== undefined ? value : 0);
      }
    });
    
    // Categorical features (one-hot)
    categoricalColumns.forEach(col => {
      if (col !== targetColumn) {
        const value = record[col];
        const categories = columnTypes[col].categories;
        categories.forEach(cat => {
          row.push(value === cat ? 1 : 0);
        });
      }
    });
    
    features.push(row);
    target.push(targetValue);
  });
  
  return { features, target, featureNames };
}

function extractRules(node, featureNames, depth = 0, columnTypes, path = []) {
  const rules = [];
  
  if (!node || depth > 5) return rules;
  
  if (node.left === null && node.right === null) {
    // Leaf node - create rule
    if (path.length > 0 && node.values && node.values.length > 10) {
      const avgValue = node.values.reduce((a, b) => a + b, 0) / node.values.length;
      const support = node.values.length;
      
      rules.push({
        conditions: [...path],
        prediction: avgValue,
        support,
        confidence: calculateConfidence(node.values),
        depth
      });
    }
  } else {
    // Internal node
    const feature = featureNames[node.splitColumn];
    const threshold = node.splitValue;
    
    if (node.left) {
      const leftPath = [...path, `${feature} <= ${threshold.toFixed(2)}`];
      rules.push(...extractRules(node.left, featureNames, depth + 1, columnTypes, leftPath));
    }
    
    if (node.right) {
      const rightPath = [...path, `${feature} > ${threshold.toFixed(2)}`];
      rules.push(...extractRules(node.right, featureNames, depth + 1, columnTypes, rightPath));
    }
  }
  
  return rules;
}

function calculateConfidence(values) {
  if (values.length === 0) return 0;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
  const cv = Math.sqrt(variance) / (Math.abs(mean) + 1);
  return Math.max(0, 1 - cv);
}

function calculateFeatureImportances(model, features, target, featureNames) {
  // Simple importance based on split frequency and depth
  const importances = {};
  featureNames.forEach(name => { importances[name] = 0; });
  
  function traverseTree(node, depth = 1) {
    if (!node || !node.splitColumn !== undefined) return;
    
    const feature = featureNames[node.splitColumn];
    if (feature) {
      // Weight by inverse depth (earlier splits are more important)
      importances[feature] += 1 / depth;
    }
    
    if (node.left) traverseTree(node.left, depth + 1);
    if (node.right) traverseTree(node.right, depth + 1);
  }
  
  traverseTree(model.root);
  
  // Normalize
  const total = Object.values(importances).reduce((a, b) => a + b, 0);
  if (total > 0) {
    Object.keys(importances).forEach(key => {
      importances[key] = (importances[key] / total) * 100;
    });
  }
  
  return Object.entries(importances)
    .filter(([_, importance]) => importance > 0)
    .sort((a, b) => b[1] - a[1])
    .map(([feature, importance]) => ({
      feature,
      importance: importance.toFixed(1)
    }));
}

function findBusinessSegments(rules, totalRecords) {
  // Convert rules to business-friendly segments
  const segments = [];
  
  // Sort rules by support and prediction value
  const sortedRules = rules.sort((a, b) => b.support - a.support);
  
  sortedRules.slice(0, 10).forEach((rule, idx) => {
    const segment = {
      id: idx + 1,
      description: formatSegmentDescription(rule),
      conditions: rule.conditions,
      size: rule.support,
      sizePercentage: (rule.support / totalRecords * 100).toFixed(1),
      avgValue: rule.prediction.toFixed(2),
      confidence: (rule.confidence * 100).toFixed(0)
    };
    
    // Classify segment
    if (rule.prediction > getPercentile(rules.map(r => r.prediction), 0.75)) {
      segment.type = 'high-value';
      segment.actionability = 'Focus on retention and upselling';
    } else if (rule.prediction < getPercentile(rules.map(r => r.prediction), 0.25)) {
      segment.type = 'low-value';
      segment.actionability = 'Investigate improvement opportunities';
    } else {
      segment.type = 'medium-value';
      segment.actionability = 'Monitor and optimize';
    }
    
    segments.push(segment);
  });
  
  return segments;
}

function formatSegmentDescription(rule) {
  const conditions = rule.conditions.map(cond => {
    // Make conditions more readable
    return cond
      .replace(/_/g, ' ')
      .replace(/([<>]=?)/g, ' $1 ')
      .replace(/\s+/g, ' ')
      .trim();
  });
  
  if (conditions.length === 1) {
    return `When ${conditions[0]}`;
  } else if (conditions.length === 2) {
    return `When ${conditions[0]} AND ${conditions[1]}`;
  } else {
    return `When ${conditions.slice(0, -1).join(', ')} AND ${conditions[conditions.length - 1]}`;
  }
}

function getTreeDepth(node, currentDepth = 0) {
  if (!node || (node.left === null && node.right === null)) {
    return currentDepth;
  }
  
  const leftDepth = node.left ? getTreeDepth(node.left, currentDepth + 1) : currentDepth;
  const rightDepth = node.right ? getTreeDepth(node.right, currentDepth + 1) : currentDepth;
  
  return Math.max(leftDepth, rightDepth);
}

function evaluateModelQuality(model, features, target) {
  // Simple R-squared calculation
  const predictions = features.map(f => model.predict([f])[0]);
  const targetMean = target.reduce((a, b) => a + b, 0) / target.length;
  
  const ssTotal = target.reduce((sum, val) => sum + Math.pow(val - targetMean, 2), 0);
  const ssResidual = target.reduce((sum, val, idx) => 
    sum + Math.pow(val - predictions[idx], 2), 0
  );
  
  const rSquared = 1 - (ssResidual / ssTotal);
  
  return {
    rSquared: rSquared.toFixed(3),
    interpretation: 
      rSquared > 0.7 ? 'Strong predictive power' :
      rSquared > 0.5 ? 'Moderate predictive power' :
      rSquared > 0.3 ? 'Weak predictive power' :
      'Poor predictive power'
  };
}

function calculateVariance(values) {
  const numbers = values.filter(v => typeof v === 'number');
  if (numbers.length < 2) return 0;
  
  const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
  return numbers.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / numbers.length;
}

function getPercentile(values, percentile) {
  const sorted = [...values].sort((a, b) => a - b);
  const index = Math.ceil(percentile * sorted.length) - 1;
  return sorted[index];
}

var regression$2 = {exports: {}};

var regression$1 = regression$2.exports;

var hasRequiredRegression;

function requireRegression () {
	if (hasRequiredRegression) return regression$2.exports;
	hasRequiredRegression = 1;
	(function (module, exports) {
		(function (global, factory) {
		  {
		    factory(module);
		  }
		})(regression$1, function (module) {

		  function _defineProperty(obj, key, value) {
		    if (key in obj) {
		      Object.defineProperty(obj, key, {
		        value: value,
		        enumerable: true,
		        configurable: true,
		        writable: true
		      });
		    } else {
		      obj[key] = value;
		    }

		    return obj;
		  }

		  var _extends = Object.assign || function (target) {
		    for (var i = 1; i < arguments.length; i++) {
		      var source = arguments[i];

		      for (var key in source) {
		        if (Object.prototype.hasOwnProperty.call(source, key)) {
		          target[key] = source[key];
		        }
		      }
		    }

		    return target;
		  };

		  function _toConsumableArray(arr) {
		    if (Array.isArray(arr)) {
		      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
		        arr2[i] = arr[i];
		      }

		      return arr2;
		    } else {
		      return Array.from(arr);
		    }
		  }

		  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

		  /**
		  * Determine the coefficient of determination (r^2) of a fit from the observations
		  * and predictions.
		  *
		  * @param {Array<Array<number>>} data - Pairs of observed x-y values
		  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
		  *
		  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
		  */
		  function determinationCoefficient(data, results) {
		    var predictions = [];
		    var observations = [];

		    data.forEach(function (d, i) {
		      if (d[1] !== null) {
		        observations.push(d);
		        predictions.push(results[i]);
		      }
		    });

		    var sum = observations.reduce(function (a, observation) {
		      return a + observation[1];
		    }, 0);
		    var mean = sum / observations.length;

		    var ssyy = observations.reduce(function (a, observation) {
		      var difference = observation[1] - mean;
		      return a + difference * difference;
		    }, 0);

		    var sse = observations.reduce(function (accum, observation, index) {
		      var prediction = predictions[index];
		      var residual = observation[1] - prediction[1];
		      return accum + residual * residual;
		    }, 0);

		    return 1 - sse / ssyy;
		  }

		  /**
		  * Determine the solution of a system of linear equations A * x = b using
		  * Gaussian elimination.
		  *
		  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
		  * @param {number} order - How many degrees to solve for
		  *
		  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
		  */
		  function gaussianElimination(input, order) {
		    var matrix = input;
		    var n = input.length - 1;
		    var coefficients = [order];

		    for (var i = 0; i < n; i++) {
		      var maxrow = i;
		      for (var j = i + 1; j < n; j++) {
		        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
		          maxrow = j;
		        }
		      }

		      for (var k = i; k < n + 1; k++) {
		        var tmp = matrix[k][i];
		        matrix[k][i] = matrix[k][maxrow];
		        matrix[k][maxrow] = tmp;
		      }

		      for (var _j = i + 1; _j < n; _j++) {
		        for (var _k = n; _k >= i; _k--) {
		          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
		        }
		      }
		    }

		    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
		      var total = 0;
		      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
		        total += matrix[_k2][_j2] * coefficients[_k2];
		      }

		      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
		    }

		    return coefficients;
		  }

		  /**
		  * Round a number to a precision, specificed in number of decimal places
		  *
		  * @param {number} number - The number to round
		  * @param {number} precision - The number of decimal places to round to:
		  *                             > 0 means decimals, < 0 means powers of 10
		  *
		  *
		  * @return {numbr} - The number, rounded
		  */
		  function round(number, precision) {
		    var factor = Math.pow(10, precision);
		    return Math.round(number * factor) / factor;
		  }

		  /**
		  * The set of all fitting methods
		  *
		  * @namespace
		  */
		  var methods = {
		    linear: function linear(data, options) {
		      var sum = [0, 0, 0, 0, 0];
		      var len = 0;

		      for (var n = 0; n < data.length; n++) {
		        if (data[n][1] !== null) {
		          len++;
		          sum[0] += data[n][0];
		          sum[1] += data[n][1];
		          sum[2] += data[n][0] * data[n][0];
		          sum[3] += data[n][0] * data[n][1];
		          sum[4] += data[n][1] * data[n][1];
		        }
		      }

		      var run = len * sum[2] - sum[0] * sum[0];
		      var rise = len * sum[3] - sum[0] * sum[1];
		      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
		      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

		      var predict = function predict(x) {
		        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
		      };

		      var points = data.map(function (point) {
		        return predict(point[0]);
		      });

		      return {
		        points: points,
		        predict: predict,
		        equation: [gradient, intercept],
		        r2: round(determinationCoefficient(data, points), options.precision),
		        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
		      };
		    },
		    exponential: function exponential(data, options) {
		      var sum = [0, 0, 0, 0, 0, 0];

		      for (var n = 0; n < data.length; n++) {
		        if (data[n][1] !== null) {
		          sum[0] += data[n][0];
		          sum[1] += data[n][1];
		          sum[2] += data[n][0] * data[n][0] * data[n][1];
		          sum[3] += data[n][1] * Math.log(data[n][1]);
		          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
		          sum[5] += data[n][0] * data[n][1];
		        }
		      }

		      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
		      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
		      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
		      var coeffA = round(a, options.precision);
		      var coeffB = round(b, options.precision);
		      var predict = function predict(x) {
		        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
		      };

		      var points = data.map(function (point) {
		        return predict(point[0]);
		      });

		      return {
		        points: points,
		        predict: predict,
		        equation: [coeffA, coeffB],
		        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
		        r2: round(determinationCoefficient(data, points), options.precision)
		      };
		    },
		    logarithmic: function logarithmic(data, options) {
		      var sum = [0, 0, 0, 0];
		      var len = data.length;

		      for (var n = 0; n < len; n++) {
		        if (data[n][1] !== null) {
		          sum[0] += Math.log(data[n][0]);
		          sum[1] += data[n][1] * Math.log(data[n][0]);
		          sum[2] += data[n][1];
		          sum[3] += Math.pow(Math.log(data[n][0]), 2);
		        }
		      }

		      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
		      var coeffB = round(a, options.precision);
		      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

		      var predict = function predict(x) {
		        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
		      };

		      var points = data.map(function (point) {
		        return predict(point[0]);
		      });

		      return {
		        points: points,
		        predict: predict,
		        equation: [coeffA, coeffB],
		        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
		        r2: round(determinationCoefficient(data, points), options.precision)
		      };
		    },
		    power: function power(data, options) {
		      var sum = [0, 0, 0, 0, 0];
		      var len = data.length;

		      for (var n = 0; n < len; n++) {
		        if (data[n][1] !== null) {
		          sum[0] += Math.log(data[n][0]);
		          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
		          sum[2] += Math.log(data[n][1]);
		          sum[3] += Math.pow(Math.log(data[n][0]), 2);
		        }
		      }

		      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
		      var a = (sum[2] - b * sum[0]) / len;
		      var coeffA = round(Math.exp(a), options.precision);
		      var coeffB = round(b, options.precision);

		      var predict = function predict(x) {
		        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
		      };

		      var points = data.map(function (point) {
		        return predict(point[0]);
		      });

		      return {
		        points: points,
		        predict: predict,
		        equation: [coeffA, coeffB],
		        string: 'y = ' + coeffA + 'x^' + coeffB,
		        r2: round(determinationCoefficient(data, points), options.precision)
		      };
		    },
		    polynomial: function polynomial(data, options) {
		      var lhs = [];
		      var rhs = [];
		      var a = 0;
		      var b = 0;
		      var len = data.length;
		      var k = options.order + 1;

		      for (var i = 0; i < k; i++) {
		        for (var l = 0; l < len; l++) {
		          if (data[l][1] !== null) {
		            a += Math.pow(data[l][0], i) * data[l][1];
		          }
		        }

		        lhs.push(a);
		        a = 0;

		        var c = [];
		        for (var j = 0; j < k; j++) {
		          for (var _l = 0; _l < len; _l++) {
		            if (data[_l][1] !== null) {
		              b += Math.pow(data[_l][0], i + j);
		            }
		          }
		          c.push(b);
		          b = 0;
		        }
		        rhs.push(c);
		      }
		      rhs.push(lhs);

		      var coefficients = gaussianElimination(rhs, k).map(function (v) {
		        return round(v, options.precision);
		      });

		      var predict = function predict(x) {
		        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
		          return sum + coeff * Math.pow(x, power);
		        }, 0), options.precision)];
		      };

		      var points = data.map(function (point) {
		        return predict(point[0]);
		      });

		      var string = 'y = ';
		      for (var _i = coefficients.length - 1; _i >= 0; _i--) {
		        if (_i > 1) {
		          string += coefficients[_i] + 'x^' + _i + ' + ';
		        } else if (_i === 1) {
		          string += coefficients[_i] + 'x + ';
		        } else {
		          string += coefficients[_i];
		        }
		      }

		      return {
		        string: string,
		        points: points,
		        predict: predict,
		        equation: [].concat(_toConsumableArray(coefficients)).reverse(),
		        r2: round(determinationCoefficient(data, points), options.precision)
		      };
		    }
		  };

		  function createWrapper() {
		    var reduce = function reduce(accumulator, name) {
		      return _extends({
		        _round: round
		      }, accumulator, _defineProperty({}, name, function (data, supplied) {
		        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
		      }));
		    };

		    return Object.keys(methods).reduce(reduce, {});
		  }

		  module.exports = createWrapper();
		}); 
	} (regression$2));
	return regression$2.exports;
}

var regressionExports = requireRegression();
var regression = /*@__PURE__*/getDefaultExportFromCjs(regressionExports);

function performRegressionAnalysis(records, columns, columnTypes, targetColumn = null) {
  const numericColumns = columns.filter(col => 
    ['integer', 'float'].includes(columnTypes[col].type)
  );
  
  if (numericColumns.length < 2) {
    return {
      applicable: false,
      reason: 'Need at least 2 numeric columns for regression analysis'
    };
  }
  
  // Auto-select target if not provided
  if (!targetColumn) {
    targetColumn = selectRegressionTarget(records, numericColumns);
  }
  
  const predictors = numericColumns.filter(col => col !== targetColumn);
  if (predictors.length === 0) {
    return {
      applicable: false,
      reason: 'No predictor variables available'
    };
  }
  
  // Prepare data
  const data = prepareRegressionData(records, predictors, targetColumn);
  
  if (data.length < 20) {
    return {
      applicable: false,
      reason: 'Insufficient data points for reliable regression'
    };
  }
  
  // Perform multiple regression types
  const analyses = {
    simple: predictors.map(predictor => 
      performSimpleRegression(records, predictor, targetColumn)
    ),
    multiple: performMultipleRegression(data, predictors),
    polynomial: performPolynomialRegression(records, predictors[0], targetColumn),
    robust: performRobustRegression(data, predictors)
  };
  
  // Select best model
  const bestModel = selectBestModel(analyses);
  
  // Residual analysis for best model
  const residualAnalysis = analyzeResiduals(bestModel, data);
  
  return {
    applicable: true,
    targetVariable: targetColumn,
    predictors,
    analyses,
    bestModel,
    residualAnalysis,
    diagnostics: performRegressionDiagnostics(bestModel),
    interpretation: interpretRegression(bestModel, residualAnalysis)
  };
}

function selectRegressionTarget(records, columns) {
  let bestTarget = null;
  let maxVariance = 0;
  
  columns.forEach(col => {
    const values = records.map(r => r[col]).filter(v => v !== null && !isNaN(v));
    const variance$1 = variance(values);
    
    if (variance$1 > maxVariance) {
      maxVariance = variance$1;
      bestTarget = col;
    }
  });
  
  return bestTarget;
}

function prepareRegressionData(records, predictors, target) {
  const data = [];
  
  records.forEach(record => {
    const targetValue = record[target];
    if (targetValue === null || isNaN(targetValue)) return;
    
    const predictorValues = predictors.map(p => record[p]);
    if (predictorValues.some(v => v === null || isNaN(v))) return;
    
    data.push({
      predictors: predictorValues,
      target: targetValue,
      record
    });
  });
  
  return data;
}

function performSimpleRegression(records, predictor, target) {
  const points = [];
  
  records.forEach(record => {
    const x = record[predictor];
    const y = record[target];
    if (x !== null && y !== null && !isNaN(x) && !isNaN(y)) {
      points.push([x, y]);
    }
  });
  
  if (points.length < 10) {
    return { applicable: false };
  }
  
  // Linear regression
  const result = regression.linear(points);
  
  // Calculate additional statistics
  const predicted = points.map(p => result.predict(p[0])[1]);
  const actual = points.map(p => p[1]);
  const residuals = actual.map((y, i) => y - predicted[i]);
  
  const meanY = mean$2(actual);
  const ssTotal = actual.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
  const ssResidual = residuals.reduce((sum, r) => sum + r * r, 0);
  const ssRegression = ssTotal - ssResidual;
  
  const n = points.length;
  const mse = ssResidual / (n - 2);
  const rmse = Math.sqrt(mse);
  
  // Standard errors
  const xValues = points.map(p => p[0]);
  const xMean = mean$2(xValues);
  const xSS = xValues.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0);
  const slopeStdError = Math.sqrt(mse / xSS);
  const interceptStdError = Math.sqrt(mse * (1/n + xMean*xMean/xSS));
  
  // t-statistics and p-values
  const slopeTStat = result.equation[0] / slopeStdError;
  const interceptTStat = result.equation[1] / interceptStdError;
  const df = n - 2;
  const slopePValue = 2 * (1 - jstat.studentt.cdf(Math.abs(slopeTStat), df));
  const interceptPValue = 2 * (1 - jstat.studentt.cdf(Math.abs(interceptTStat), df));
  
  // F-statistic
  const fStat = ssRegression / mse;
  const fPValue = 1 - jstat.centralF.cdf(fStat, 1, df);
  
  return {
    type: 'simple',
    predictor,
    equation: result.equation,
    r2: result.r2,
    adjustedR2: 1 - (1 - result.r2) * (n - 1) / (n - 2),
    rmse,
    coefficients: [
      {
        name: predictor,
        value: result.equation[0],
        stdError: slopeStdError,
        tStat: slopeTStat,
        pValue: slopePValue,
        significant: slopePValue < 0.05
      },
      {
        name: 'intercept',
        value: result.equation[1],
        stdError: interceptStdError,
        tStat: interceptTStat,
        pValue: interceptPValue,
        significant: interceptPValue < 0.05
      }
    ],
    fStatistic: {
      value: fStat,
      df1: 1,
      df2: df,
      pValue: fPValue,
      significant: fPValue < 0.05
    },
    residuals,
    predicted
  };
}

function performMultipleRegression(data, predictors, target) {
  // Prepare matrix for multiple regression
  const X = [];
  const y = [];
  
  data.forEach(d => {
    X.push([1, ...d.predictors]); // Add intercept
    y.push(d.target);
  });
  
  // Use robust QR decomposition instead of normal equation
  const qrResult = qrDecomposition(X);
  const coefficients = solveQR(qrResult, y);
  
  // Calculate predictions and residuals
  const predicted = X.map(row => 
    row.reduce((sum, x, i) => sum + x * coefficients[i], 0)
  );
  const residuals = y.map((actual, i) => actual - predicted[i]);
  
  // Calculate R-squared
  const meanY = mean$2(y);
  const ssTotal = y.reduce((sum, val) => sum + Math.pow(val - meanY, 2), 0);
  const ssResidual = residuals.reduce((sum, r) => sum + r * r, 0);
  const r2 = 1 - ssResidual / ssTotal;
  
  const n = data.length;
  const p = predictors.length;
  const adjustedR2 = 1 - (1 - r2) * (n - 1) / (n - p - 1);
  
  // Calculate standard errors using QR approach
  const mse = ssResidual / (n - p - 1);
  const rmse = Math.sqrt(mse);
  
  // Calculate covariance matrix from QR decomposition: (R^T R)^-1 * mse
  const { R } = qrResult;
  const RtR = Array(p + 1).fill(null).map(() => Array(p + 1).fill(0));
  
  // Compute R^T * R
  for (let i = 0; i < p + 1; i++) {
    for (let j = 0; j < p + 1; j++) {
      for (let k = Math.max(i, j); k < p + 1; k++) {
        RtR[i][j] += R[k][i] * R[k][j];
      }
    }
  }
  
  // Invert R^T * R (small matrix, safe to invert)
  const RtR_inv = matrixInverse(RtR);
  const covMatrix = RtR_inv.map(row => row.map(val => val * mse));
  const stdErrors = covMatrix.map((row, i) => Math.sqrt(Math.abs(row[i])));
  
  // Calculate t-statistics and p-values
  const coefficientStats = coefficients.map((coef, i) => {
    const tStat = coef / stdErrors[i];
    const pValue = 2 * (1 - jstat.studentt.cdf(Math.abs(tStat), n - p - 1));
    
    return {
      name: i === 0 ? 'intercept' : predictors[i - 1],
      value: coef,
      stdError: stdErrors[i],
      tStat,
      pValue,
      significant: pValue < 0.05
    };
  });
  
  // F-statistic
  const ssRegression = ssTotal - ssResidual;
  const fStat = (ssRegression / p) / (ssResidual / (n - p - 1));
  const fPValue = 1 - jstat.centralF.cdf(fStat, p, n - p - 1);
  
  // Calculate VIF for multicollinearity
  const vifs = calculateVIF(X, predictors);
  
  return {
    type: 'multiple',
    predictors,
    coefficients: coefficientStats,
    r2,
    adjustedR2,
    rmse,
    fStatistic: {
      value: fStat,
      df1: p,
      df2: n - p - 1,
      pValue: fPValue,
      significant: fPValue < 0.05
    },
    multicollinearity: vifs,
    residuals,
    predicted
  };
}

function performPolynomialRegression(records, predictor, target, degree = 2) {
  const points = [];
  
  records.forEach(record => {
    const x = record[predictor];
    const y = record[target];
    if (x !== null && y !== null && !isNaN(x) && !isNaN(y)) {
      points.push([x, y]);
    }
  });
  
  if (points.length < 10) {
    return { applicable: false };
  }
  
  const result = regression.polynomial(points, { order: degree });
  
  // Calculate R-squared manually
  const predicted = points.map(p => result.predict(p[0])[1]);
  const actual = points.map(p => p[1]);
  const meanY = mean$2(actual);
  const ssTotal = actual.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
  const ssResidual = actual.reduce((sum, y, i) => sum + Math.pow(y - predicted[i], 2), 0);
  const r2 = 1 - ssResidual / ssTotal;
  
  return {
    type: 'polynomial',
    predictor,
    degree,
    equation: result.equation,
    r2,
    interpretation: r2 > 0.1 ? 'Non-linear relationship detected' : 'Weak non-linear relationship'
  };
}

function performRobustRegression(data, predictors, target) {
  // Simplified robust regression using Huber weights
  const maxIterations = 20;
  const tolerance = 0.0001;
  let weights = data.map(() => 1);
  let prevCoefficients = null;
  
  for (let iter = 0; iter < maxIterations; iter++) {
    // Weighted least squares
    const weightedData = data.map((d, i) => ({
      ...d,
      weight: weights[i]
    }));
    
    const coefficients = calculateWeightedRegression(weightedData, predictors);
    
    // Check convergence
    if (prevCoefficients && 
        coefficients.every((c, i) => Math.abs(c - prevCoefficients[i]) < tolerance)) {
      break;
    }
    
    // Update weights based on residuals
    const residuals = data.map((d, i) => {
      const predicted = coefficients[0] + 
        d.predictors.reduce((sum, x, j) => sum + x * coefficients[j + 1], 0);
      return d.target - predicted;
    });
    
    const mad = medianAbsoluteDeviation(residuals);
    const c = 1.345; // Huber constant
    
    weights = residuals.map(r => {
      const scaled = Math.abs(r) / (mad * c);
      return scaled <= 1 ? 1 : 1 / scaled;
    });
    
    prevCoefficients = coefficients;
  }
  
  return {
    type: 'robust',
    interpretation: 'Outlier-resistant regression',
    outlierCount: weights.filter(w => w < 0.5).length
  };
}

function analyzeResiduals(model, data) {
  if (!model.residuals) return null;
  
  const residuals = model.residuals;
  const predicted = model.predicted;
  
  // Normality test
  const normalityTest = testResidualNormality(residuals);
  
  // Homoscedasticity test (Breusch-Pagan)
  const homoscedasticityTest = testHomoscedasticity(residuals, predicted);
  
  // Independence test (Durbin-Watson)
  const independenceTest = testIndependence(residuals);
  
  // Influential points
  const influential = findInfluentialPoints(data, residuals);
  
  return {
    normalityTest,
    homoscedasticityTest,
    independenceTest,
    influential,
    patterns: detectResidualPatterns(residuals, predicted)
  };
}

function testResidualNormality(residuals) {
  const n = residuals.length;
  const mean = mean$2(residuals);
  const stdDev = standardDeviation(residuals);
  
  // Standardize residuals
  const standardized = residuals.map(r => (r - mean) / stdDev);
  
  // Shapiro-Wilk test (simplified)
  const sorted = [...standardized].sort((a, b) => a - b);
  let W = 0;
  
  for (let i = 0; i < Math.floor(n/2); i++) {
    const ai = 0.5; // Simplified coefficient
    W += ai * (sorted[n - 1 - i] - sorted[i]);
  }
  W = Math.pow(W, 2) / residuals.reduce((sum, r) => sum + r * r, 0);
  
  return {
    test: 'Shapiro-Wilk',
    statistic: W,
    normal: W > 0.9,
    interpretation: W > 0.9 ? 'Residuals appear normally distributed' : 
                               'Residuals deviate from normality'
  };
}

function testHomoscedasticity(residuals, predicted) {
  // Breusch-Pagan test
  const n = residuals.length;
  const squaredResiduals = residuals.map(r => r * r);
  
  // Regress squared residuals on predicted values
  const points = predicted.map((p, i) => [p, squaredResiduals[i]]);
  const auxRegression = regression.linear(points);
  
  const lmStatistic = n * auxRegression.r2;
  const pValue = 1 - jstat.chisquare.cdf(lmStatistic, 1);
  
  return {
    test: 'Breusch-Pagan',
    statistic: lmStatistic,
    pValue,
    homoscedastic: pValue > 0.05,
    interpretation: pValue > 0.05 ? 'Constant variance (homoscedastic)' : 
                                   'Non-constant variance (heteroscedastic)'
  };
}

function testIndependence(residuals) {
  // Durbin-Watson test
  let sumSquaredDiff = 0;
  let sumSquared = 0;
  
  for (let i = 1; i < residuals.length; i++) {
    sumSquaredDiff += Math.pow(residuals[i] - residuals[i-1], 2);
  }
  
  residuals.forEach(r => {
    sumSquared += r * r;
  });
  
  const dw = sumSquaredDiff / sumSquared;
  
  return {
    test: 'Durbin-Watson',
    statistic: dw,
    interpretation: 
      dw < 1.5 ? 'Positive autocorrelation' :
      dw > 2.5 ? 'Negative autocorrelation' :
      'No significant autocorrelation'
  };
}

function findInfluentialPoints(data, residuals, predicted) {
  const n = data.length;
  const p = data[0].predictors.length + 1; // Including intercept
  
  const influential = [];
  const leverage = calculateLeverage(data);
  
  residuals.forEach((r, i) => {
    // Cook's distance (simplified)
    const h = leverage[i];
    const standardizedResidual = r / (Math.sqrt(variance(residuals)) * Math.sqrt(1 - h));
    const cooksD = (standardizedResidual * standardizedResidual * h) / (p * (1 - h));
    
    if (cooksD > 4 / n || h > 2 * p / n) {
      influential.push({
        index: i,
        cooksDistance: cooksD,
        leverage: h,
        influence: cooksD > 1 ? 'high' : cooksD > 0.5 ? 'moderate' : 'low'
      });
    }
  });
  
  return influential;
}

function detectResidualPatterns(residuals, predicted) {
  const patterns = [];
  
  // Check for systematic bias
  const meanResidual = mean$2(residuals);
  if (Math.abs(meanResidual) > 0.01) {
    patterns.push('Systematic bias in predictions');
  }
  
  // Check for funnel pattern (heteroscedasticity)
  const bins = 5;
  const sortedByPredicted = predicted
    .map((p, i) => ({ predicted: p, residual: residuals[i] }))
    .sort((a, b) => a.predicted - b.predicted);
  
  const binSize = Math.floor(sortedByPredicted.length / bins);
  const binVariances = [];
  
  for (let i = 0; i < bins; i++) {
    const binData = sortedByPredicted.slice(i * binSize, (i + 1) * binSize);
    const binResiduals = binData.map(d => d.residual);
    binVariances.push(variance(binResiduals));
  }
  
  const varianceRatio = Math.max(...binVariances) / Math.min(...binVariances);
  if (varianceRatio > 3) {
    patterns.push('Funnel pattern detected (variance changes with predicted values)');
  }
  
  return patterns;
}

// Robust QR decomposition for numerical stability
function qrDecomposition(A) {
  const m = A.length;     // rows
  const n = A[0].length;  // columns
  
  // Copy matrix A
  const Q = Array(m).fill(null).map(() => Array(n).fill(0));
  const R = Array(n).fill(null).map(() => Array(n).fill(0));
  const A_copy = A.map(row => [...row]);
  
  // Modified Gram-Schmidt process for better numerical stability
  for (let j = 0; j < n; j++) {
    // Get column j
    let v = Array(m);
    for (let i = 0; i < m; i++) {
      v[i] = A_copy[i][j];
    }
    
    // Orthogonalize against previous columns
    for (let k = 0; k < j; k++) {
      // R[k][j] = Q_k^T * v
      let dot = 0;
      for (let i = 0; i < m; i++) {
        dot += Q[i][k] * v[i];
      }
      R[k][j] = dot;
      
      // v = v - R[k][j] * Q_k
      for (let i = 0; i < m; i++) {
        v[i] -= R[k][j] * Q[i][k];
      }
    }
    
    // Normalize v to get Q_j
    let norm = 0;
    for (let i = 0; i < m; i++) {
      norm += v[i] * v[i];
    }
    norm = Math.sqrt(norm);
    
    if (norm < 1e-12) {
      // Handle near-zero columns (rank deficiency)
      R[j][j] = 0;
      for (let i = 0; i < m; i++) {
        Q[i][j] = 0;
      }
    } else {
      R[j][j] = norm;
      for (let i = 0; i < m; i++) {
        Q[i][j] = v[i] / norm;
      }
    }
  }
  
  return { Q, R, rank: n }; // Simplified rank calculation
}

function solveQR(qrResult, b) {
  const { Q, R } = qrResult;
  const m = Q.length;
  const n = R.length;
  
  // Solve Q^T * b = c
  const c = Array(n);
  for (let i = 0; i < n; i++) {
    c[i] = 0;
    for (let j = 0; j < m; j++) {
      c[i] += Q[j][i] * b[j];
    }
  }
  
  // Solve R * x = c using back substitution
  const x = Array(n).fill(0);
  for (let i = n - 1; i >= 0; i--) {
    if (Math.abs(R[i][i]) < 1e-12) {
      // Handle singular matrix
      x[i] = 0;
      continue;
    }
    
    x[i] = c[i];
    for (let j = i + 1; j < n; j++) {
      x[i] -= R[i][j] * x[j];
    }
    x[i] /= R[i][i];
  }
  
  return x;
}

function matrixInverse(matrix) {
  // Simplified 2x2 or 3x3 matrix inversion
  // In practice, use a proper linear algebra library
  const n = matrix.length;
  const identity = Array(n).fill(null).map((_, i) => 
    Array(n).fill(0).map((_, j) => i === j ? 1 : 0)
  );
  
  // Gauss-Jordan elimination (simplified)
  const augmented = matrix.map((row, i) => [...row, ...identity[i]]);
  
  for (let i = 0; i < n; i++) {
    // Pivot
    let maxRow = i;
    for (let k = i + 1; k < n; k++) {
      if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
        maxRow = k;
      }
    }
    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
    
    // Scale
    const pivot = augmented[i][i];
    for (let j = 0; j < 2 * n; j++) {
      augmented[i][j] /= pivot;
    }
    
    // Eliminate
    for (let k = 0; k < n; k++) {
      if (k !== i) {
        const factor = augmented[k][i];
        for (let j = 0; j < 2 * n; j++) {
          augmented[k][j] -= factor * augmented[i][j];
        }
      }
    }
  }
  
  return augmented.map(row => row.slice(n));
}

function calculateVIF(X, predictors) {
  const vifs = [];
  
  for (let i = 1; i < X[0].length; i++) { // Skip intercept
    // Regress predictor i on all other predictors
    const y = X.map(row => row[i]);
    const XOther = X.map(row => row.filter((_, j) => j !== i));
    
    // Calculate R-squared for this regression
    const r2 = calculateR2ForVIF(XOther, y);
    const vif = 1 / (1 - r2);
    
    vifs.push({
      predictor: predictors[i - 1],
      vif: vif,
      interpretation: vif > 10 ? 'Severe multicollinearity' :
                     vif > 5 ? 'Moderate multicollinearity' :
                     'No multicollinearity concern'
    });
  }
  
  return vifs;
}

function calculateR2ForVIF(X, y) {
  // Robust R-squared calculation using QR decomposition
  try {
    const qrResult = qrDecomposition(X);
    const coefficients = solveQR(qrResult, y);
    
    // Calculate predictions
    const predicted = X.map(row => 
      row.reduce((sum, x, i) => sum + x * coefficients[i], 0)
    );
    
    // Calculate R-squared
    const meanY = mean$2(y);
    const ssTotal = y.reduce((sum, val) => sum + Math.pow(val - meanY, 2), 0);
    const ssResidual = y.reduce((sum, val, i) => sum + Math.pow(val - predicted[i], 2), 0);
    
    return Math.max(0, Math.min(1, 1 - ssResidual / ssTotal));
  } catch (error) {
    // Fallback to correlation-based estimate if QR fails
    const correlations = X[0].map((_, col) => {
      const xCol = X.map(row => row[col]);
      return sampleCorrelation(xCol, y);
    });
    
    return Math.max(...correlations.map(r => r * r));
  }
}

function calculateWeightedRegression(weightedData, predictors) {
  // Simplified weighted least squares
  const weights = weightedData.map(d => d.weight);
  const sumWeights = weights.reduce((a, b) => a + b, 0);
  
  // Calculate weighted means
  const weightedMeanY = weightedData.reduce((sum, d, i) => 
    sum + d.target * weights[i], 0) / sumWeights;
  
  const weightedMeanX = predictors.map((_, j) => 
    weightedData.reduce((sum, d, i) => 
      sum + d.predictors[j] * weights[i], 0) / sumWeights
  );
  
  // Simplified coefficient calculation
  const coefficients = [weightedMeanY, ...weightedMeanX.map(() => 0.5)];
  
  return coefficients;
}

function calculateLeverage(data) {
  // Simplified leverage calculation
  const n = data.length;
  const p = data[0].predictors.length + 1;
  
  return data.map(() => p / n); // Simplified - equal leverage
}

function selectBestModel(analyses) {
  // Select model with highest adjusted R-squared
  let best = null;
  let maxAdjR2 = -Infinity;
  
  if (analyses.simple) {
    analyses.simple.forEach(model => {
      if (model.adjustedR2 > maxAdjR2) {
        maxAdjR2 = model.adjustedR2;
        best = model;
      }
    });
  }
  
  if (analyses.multiple && analyses.multiple.adjustedR2 > maxAdjR2) {
    best = analyses.multiple;
  }
  
  return best;
}

function performRegressionDiagnostics(model, data) {
  if (!model) return null;
  
  const diagnostics = {
    modelQuality: interpretModelQuality(model),
    assumptions: [],
    warnings: []
  };
  
  // Check R-squared
  if (model.r2 < 0.1) {
    diagnostics.warnings.push('Very low R² - model explains little variance');
  }
  
  // Check multicollinearity
  if (model.multicollinearity) {
    const highVIF = model.multicollinearity.filter(v => v.vif > 5);
    if (highVIF.length > 0) {
      diagnostics.warnings.push('Multicollinearity detected - consider removing correlated predictors');
    }
  }
  
  // Check coefficient significance
  if (model.coefficients) {
    const nonSig = model.coefficients.filter(c => !c.significant && c.name !== 'intercept');
    if (nonSig.length > 0) {
      diagnostics.warnings.push(`Non-significant predictors: ${nonSig.map(c => c.name).join(', ')}`);
    }
  }
  
  return diagnostics;
}

function interpretModelQuality(model) {
  const r2 = model.r2 || 0;
  const adjR2 = model.adjustedR2 || r2;
  
  return {
    r2: r2.toFixed(3),
    adjustedR2: adjR2.toFixed(3),
    interpretation: 
      adjR2 > 0.8 ? 'Excellent model fit' :
      adjR2 > 0.6 ? 'Good model fit' :
      adjR2 > 0.4 ? 'Moderate model fit' :
      adjR2 > 0.2 ? 'Weak model fit' :
      'Poor model fit'
  };
}

function interpretRegression(model, residualAnalysis) {
  const interpretations = [];
  
  // Model fit
  if (model) {
    interpretations.push(interpretModelQuality(model).interpretation);
    
    // Significant predictors
    if (model.coefficients) {
      const significant = model.coefficients
        .filter(c => c.significant && c.name !== 'intercept')
        .map(c => `${c.name} (p=${c.pValue.toFixed(3)})`);
      
      if (significant.length > 0) {
        interpretations.push(`Significant predictors: ${significant.join(', ')}`);
      }
    }
  }
  
  // Residual diagnostics
  if (residualAnalysis) {
    if (!residualAnalysis.normalityTest.normal) {
      interpretations.push('Residuals show non-normality - consider transformations');
    }
    
    if (!residualAnalysis.homoscedasticityTest.homoscedastic) {
      interpretations.push('Heteroscedasticity detected - consider weighted regression');
    }
    
    if (residualAnalysis.influential.length > 0) {
      interpretations.push(`${residualAnalysis.influential.length} influential points detected`);
    }
  }
  
  return interpretations.join('. ');
}

function performCorrelationAnalysis(records, columns, columnTypes) {
  const numericColumns = columns.filter(col => 
    ['integer', 'float'].includes(columnTypes[col].type)
  );
  
  if (numericColumns.length < 2) {
    return null;
  }
  
  const analysis = {
    pearson: [],
    spearman: [],
    distanceCorrelation: [],
    partialCorrelations: [],
    multicollinearity: []
  };
  
  // Calculate pairwise correlations
  for (let i = 0; i < numericColumns.length; i++) {
    for (let j = i + 1; j < numericColumns.length; j++) {
      const col1 = numericColumns[i];
      const col2 = numericColumns[j];
      
      records.map(r => r[col1]).filter(v => v !== null && !isNaN(v));
      records.map(r => r[col2]).filter(v => v !== null && !isNaN(v));
      
      // Get paired values
      const pairs = [];
      records.forEach(r => {
        const v1 = r[col1];
        const v2 = r[col2];
        if (v1 !== null && v2 !== null && !isNaN(v1) && !isNaN(v2)) {
          pairs.push([v1, v2]);
        }
      });
      
      if (pairs.length < 10) continue;
      
      // Pearson correlation
      const pearson = sampleCorrelation(pairs.map(p => p[0]), pairs.map(p => p[1]));
      if (!isNaN(pearson) && Math.abs(pearson) > 0.1) {
        analysis.pearson.push({
          var1: col1,
          var2: col2,
          value: pearson,
          pValue: calculateCorrelationPValue(pearson, pairs.length),
          significant: Math.abs(pearson) > 0.3
        });
      }
      
      // Spearman correlation
      const spearman = calculateSpearmanCorrelation(pairs);
      if (!isNaN(spearman) && Math.abs(spearman) > 0.1) {
        analysis.spearman.push({
          var1: col1,
          var2: col2,
          value: spearman,
          interpretation: interpretCorrelation(spearman)
        });
      }
    }
  }
  
  // Sort by absolute value
  analysis.pearson.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
  analysis.spearman.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
  
  // Calculate VIF for multicollinearity
  if (numericColumns.length >= 3) {
    analysis.multicollinearity = calculateMulticollinearity(records, numericColumns);
  }
  
  return analysis;
}

function calculateSpearmanCorrelation(pairs) {
  // Rank the values
  const ranks1 = getRanks(pairs.map(p => p[0]));
  const ranks2 = getRanks(pairs.map(p => p[1]));
  
  // Calculate Pearson correlation on ranks
  return sampleCorrelation(ranks1, ranks2);
}

function getRanks(values) {
  const sorted = values
    .map((v, i) => ({ value: v, index: i }))
    .sort((a, b) => a.value - b.value);
  
  const ranks = new Array(values.length);
  
  for (let i = 0; i < sorted.length; i++) {
    let j = i;
    while (j < sorted.length - 1 && sorted[j + 1].value === sorted[i].value) {
      j++;
    }
    
    const avgRank = (i + j + 2) / 2;
    for (let k = i; k <= j; k++) {
      ranks[sorted[k].index] = avgRank;
    }
    
    i = j;
  }
  
  return ranks;
}

function calculateCorrelationPValue(r, n) {
  if (n < 3) return 1;
  
  const t = r * Math.sqrt((n - 2) / (1 - r * r));
  const df = n - 2;
  
  return 2 * (1 - jstat.studentt.cdf(Math.abs(t), df));
}

function interpretCorrelation(r) {
  const absR = Math.abs(r);
  const direction = r > 0 ? 'positive' : 'negative';
  
  if (absR >= 0.9) return `Very strong ${direction}`;
  if (absR >= 0.7) return `Strong ${direction}`;
  if (absR >= 0.5) return `Moderate ${direction}`;
  if (absR >= 0.3) return `Weak ${direction}`;
  return 'Negligible';
}

function calculateMulticollinearity(records, columns) {
  const vifs = [];
  
  columns.forEach((targetCol, idx) => {
    const otherCols = columns.filter((_, i) => i !== idx);
    
    if (otherCols.length === 0) return;
    
    // Prepare data
    const y = records.map(r => r[targetCol]).filter(v => v !== null && !isNaN(v));
    const X = [];
    
    records.forEach(record => {
      const targetValue = record[targetCol];
      if (targetValue === null || isNaN(targetValue)) return;
      
      const row = otherCols.map(col => {
        const val = record[col];
        return val !== null && !isNaN(val) ? val : 0;
      });
      
      if (row.every(v => !isNaN(v))) {
        X.push(row);
      }
    });
    
    if (X.length < 10) return;
    
    // Simple R-squared approximation
    const r2 = calculateR2Approximation(X, y);
    const vif = 1 / (1 - r2);
    
    vifs.push({
      variable: targetCol,
      value: vif,
      interpretation: 
        vif > 10 ? 'Severe multicollinearity' :
        vif > 5 ? 'Moderate multicollinearity' :
        'No concern'
    });
  });
  
  return vifs.sort((a, b) => b.value - a.value);
}

function calculateR2Approximation(X, y) {
  // Very simple approximation using average correlation
  if (X.length === 0 || X[0].length === 0) return 0;
  
  let totalCorr = 0;
  let count = 0;
  
  for (let j = 0; j < X[0].length; j++) {
    const xCol = X.map(row => row[j]);
    const corr = sampleCorrelation(xCol, y);
    
    if (!isNaN(corr)) {
      totalCorr += Math.abs(corr);
      count++;
    }
  }
  
  const avgCorr = count > 0 ? totalCorr / count : 0;
  return Math.min(0.99, avgCorr * avgCorr * 1.5); // Rough approximation
}

function performTimeSeriesAnalysis(records, dateColumn, numericColumns) {
  const dates = records
    .map(r => ({ date: r[dateColumn], record: r }))
    .filter(d => d.date instanceof Date)
    .sort((a, b) => a.date - b.date);
  
  if (dates.length < 20) {
    return {
      applicable: false,
      reason: 'Insufficient temporal data points (need at least 20)'
    };
  }
  
  // Check for regular intervals
  const intervals = [];
  for (let i = 1; i < dates.length; i++) {
    intervals.push(dates[i].date - dates[i-1].date);
  }
  
  const frequency = detectFrequency(intervals);
  if (!frequency) {
    return {
      applicable: false,
      reason: 'Irregular time intervals detected'
    };
  }
  
  const analysis = {
    applicable: true,
    timeColumn: dateColumn,
    frequency,
    dateRange: `${formatDate$2(dates[0].date)} to ${formatDate$2(dates[dates.length - 1].date)}`,
    dataPoints: dates.length,
    series: {}
  };
  
  // Analyze each numeric column
  numericColumns.forEach(col => {
    const values = dates.map(d => d.record[col]).filter(v => v !== null && !isNaN(v));
    
    if (values.length < dates.length * 0.8) {
      return; // Skip columns with too many missing values
    }
    
    analysis.series[col] = {
      trend: analyzeTrend(values, dates.map(d => d.date)),
      seasonality: analyzeSeasonality$2(values, dates.map(d => d.date), frequency),
      stationarity: testStationarity(values),
      decomposition: decomposeTimeSeries(values),
      forecast: generateForecast(values)
    };
  });
  
  // Overall time series characteristics
  analysis.overall = summarizeTimeSeriesCharacteristics(analysis.series);
  
  return analysis;
}

function detectFrequency(intervals) {
  if (intervals.length === 0) return null;
  
  // Calculate median interval
  const sortedIntervals = [...intervals].sort((a, b) => a - b);
  const medianInterval = sortedIntervals[Math.floor(sortedIntervals.length / 2)];
  
  // Check consistency (coefficient of variation)
  const mean = mean$2(intervals);
  const stdDev = standardDeviation(intervals);
  const cv = stdDev / mean;
  
  if (cv > 0.3) return null; // Too irregular
  
  // Determine frequency based on median interval (in milliseconds)
  const hour = 60 * 60 * 1000;
  const day = 24 * hour;
  const week = 7 * day;
  const month = 30 * day; // Approximate
  
  if (Math.abs(medianInterval - hour) < hour * 0.1) return 'hourly';
  if (Math.abs(medianInterval - day) < day * 0.1) return 'daily';
  if (Math.abs(medianInterval - week) < week * 0.1) return 'weekly';
  if (Math.abs(medianInterval - month) < month * 0.2) return 'monthly';
  
  return 'custom';
}

function analyzeTrend(values, dates) {
  // Simple linear trend
  const x = dates.map((d, i) => i);
  const regression = linearRegression([x, values]);
  const regressionLine = linearRegressionLine(regression);
  
  // Calculate trend strength
  const predicted = x.map(regressionLine);
  const r2 = calculateR2(values, predicted);
  
  // Polynomial trend
  let polynomialTrend = null;
  if (values.length > 30) {
    polynomialTrend = detectPolynomialTrend(x);
  }
  
  return {
    type: polynomialTrend && polynomialTrend.r2 > r2 + 0.1 ? 'polynomial' : 'linear',
    slope: regression.m,
    intercept: regression.b,
    strength: r2,
    direction: regression.m > 0 ? 'increasing' : regression.m < 0 ? 'decreasing' : 'flat',
    changePerPeriod: regression.m,
    polynomialDegree: polynomialTrend?.degree,
    interpretation: interpretTrend(regression.m, r2, values)
  };
}

function analyzeSeasonality$2(values, dates, frequency) {
  if (values.length < 24) {
    return { detected: false, reason: 'Insufficient data for seasonality detection' };
  }
  
  // Detrend the series first
  const detrended = detrendSeries(values);
  
  // Seasonal decomposition based on frequency
  let seasonalPattern = null;
  let period = null;
  
  switch (frequency) {
    case 'hourly':
      period = 24; // Daily seasonality
      break;
    case 'daily':
      period = 7; // Weekly seasonality
      if (values.length > 365) {
        // Also check for monthly/yearly patterns
        const yearlyPattern = detectYearlySeasonality(values, dates);
        if (yearlyPattern.strength > 0.3) {
          return yearlyPattern;
        }
      }
      break;
    case 'weekly':
      period = 4; // Monthly seasonality (approximate)
      break;
    case 'monthly':
      period = 12; // Yearly seasonality
      break;
  }
  
  if (period && values.length >= period * 2) {
    seasonalPattern = calculateSeasonalIndices(detrended, period);
    
    return {
      detected: seasonalPattern.strength > 0.2,
      period,
      strength: seasonalPattern.strength,
      indices: seasonalPattern.indices,
      peaks: identifyPeakPeriods(seasonalPattern.indices),
      interpretation: interpretSeasonality(seasonalPattern, frequency)
    };
  }
  
  return { detected: false, reason: 'No clear seasonal pattern detected' };
}

function testStationarity(values) {
  // Augmented Dickey-Fuller test (simplified)
  const adf = augmentedDickeyFuller(values);
  
  // KPSS test (simplified)
  const kpss = kpssTest(values);
  
  // Check for structural breaks
  const breaks = detectStructuralBreaks(values);
  
  return {
    adf: {
      statistic: adf.statistic,
      pValue: adf.pValue,
      isStationary: adf.pValue < 0.05,
      interpretation: adf.pValue < 0.05 ? 'Series is stationary' : 'Series is non-stationary'
    },
    kpss: {
      statistic: kpss.statistic,
      criticalValue: kpss.criticalValue,
      isStationary: kpss.statistic < kpss.criticalValue,
      interpretation: kpss.statistic < kpss.criticalValue ? 'Series is trend stationary' : 'Series has unit root'
    },
    structuralBreaks: breaks,
    recommendation: generateStationarityRecommendation(adf, kpss, breaks)
  };
}

function augmentedDickeyFuller(values) {
  // Simplified ADF test
  const n = values.length;
  const diffs = [];
  
  for (let i = 1; i < n; i++) {
    diffs.push(values[i] - values[i-1]);
  }
  
  // Regression: Δy_t = α + βy_{t-1} + ε_t
  const y = diffs;
  const x = values.slice(0, -1);
  
  const regression = linearRegression([x, y]);
  const stdError = calculateStandardError(x, y, regression);
  
  const tStat = regression.m / stdError;
  
  // Critical values (approximate)
  const criticalValue = -2.86 - 0.48 / n - 2.78 / (n * n);
  
  return {
    statistic: tStat,
    criticalValue,
    pValue: tStat < criticalValue ? 0.01 : 0.1, // Simplified
    rejectNull: tStat < criticalValue
  };
}

function kpssTest(values) {
  // Simplified KPSS test
  const n = values.length;
  const mean = mean$2(values);
  
  // Partial sums
  const S = [];
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += values[i] - mean;
    S.push(sum);
  }
  
  // Calculate test statistic
  const variance$1 = variance(values);
  const stat = S.reduce((acc, s) => acc + s * s, 0) / (n * n * variance$1);
  
  // Critical value at 5% significance
  const criticalValue = 0.463;
  
  return {
    statistic: stat,
    criticalValue,
    rejectNull: stat > criticalValue
  };
}

function decomposeTimeSeries(values, frequency) {
  if (values.length < 24) {
    return null;
  }
  
  // Moving average for trend
  const trend = calculateMovingAverage(values, Math.min(12, Math.floor(values.length / 4)));
  
  // Detrended series
  const detrended = values.map((v, i) => v - (trend[i] || trend[trend.length - 1]));
  
  // Seasonal component (simplified)
  const seasonal = calculateSeasonalComponent(detrended);
  
  // Residual
  const residual = values.map((v, i) => 
    v - (trend[i] || trend[trend.length - 1]) - (seasonal[i] || 0)
  );
  
  return {
    trend: {
      values: trend,
      direction: trend[trend.length - 1] > trend[0] ? 'increasing' : 'decreasing'
    },
    seasonal: {
      values: seasonal,
      strength: calculateSeasonalStrength(seasonal, residual)
    },
    residual: {
      values: residual,
      variance: variance(residual)
    }
  };
}

function generateForecast(values, frequency) {
  // Simple forecast using trend and seasonality
  const n = values.length;
  const forecastHorizon = Math.min(12, Math.floor(n * 0.2));
  
  // Fit trend
  const x = Array.from({ length: n }, (_, i) => i);
  const regression = linearRegression([x, values]);
  const trend = linearRegressionLine(regression);
  
  // Generate forecast
  const forecasts = [];
  for (let i = 0; i < forecastHorizon; i++) {
    const trendValue = trend(n + i);
    
    // Add seasonal component if detected
    const seasonalValue = 0; // Simplified
    
    forecasts.push({
      period: n + i + 1,
      forecast: trendValue + seasonalValue,
      confidence: {
        lower: trendValue - 2 * Math.sqrt(variance(values)),
        upper: trendValue + 2 * Math.sqrt(variance(values))
      }
    });
  }
  
  return {
    horizon: forecastHorizon,
    method: 'Linear trend with seasonality',
    forecasts: forecasts.slice(0, 3), // Just show first 3
    accuracy: 'Use with caution - simple forecast method'
  };
}

// Helper functions
function formatDate$2(date) {
  return date.toISOString().split('T')[0];
}

function calculateR2(actual, predicted) {
  const meanActual = mean$2(actual);
  const ssTotal = actual.reduce((sum, y) => sum + Math.pow(y - meanActual, 2), 0);
  const ssResidual = actual.reduce((sum, y, i) => sum + Math.pow(y - predicted[i], 2), 0);
  return 1 - ssResidual / ssTotal;
}

function detrendSeries(values) {
  const x = Array.from({ length: values.length }, (_, i) => i);
  const regression = linearRegression([x, values]);
  const trend = linearRegressionLine(regression);
  
  return values.map((v, i) => v - trend(i));
}

function detectPolynomialTrend(x, y) {
  // Try quadratic trend
  const x2 = x.map(xi => xi * xi);
  x.map((xi, i) => [1, xi, x2[i]]);
  
  // Simplified polynomial regression
  // In practice, use proper matrix operations
  const coeffs = [0, 0, 0]; // Placeholder
  
  return {
    degree: 2,
    r2: 0.5, // Placeholder
    coefficients: coeffs
  };
}

function detectYearlySeasonality(values, dates) {
  const monthlyAverages = {};
  
  dates.forEach((date, i) => {
    const month = date.getMonth();
    if (!monthlyAverages[month]) {
      monthlyAverages[month] = [];
    }
    if (values[i] !== null) {
      monthlyAverages[month].push(values[i]);
    }
  });
  
  const monthlyMeans = Object.entries(monthlyAverages)
    .map(([month, vals]) => ({
      month: parseInt(month),
      mean: mean$2(vals)
    }))
    .sort((a, b) => a.month - b.month);
  
  if (monthlyMeans.length < 6) {
    return { detected: false };
  }
  
  const overallMean = mean$2(monthlyMeans.map(m => m.mean));
  const seasonalStrength = standardDeviation(monthlyMeans.map(m => m.mean)) / overallMean;
  
  return {
    detected: seasonalStrength > 0.1,
    period: 12,
    strength: seasonalStrength,
    peaks: monthlyMeans
      .filter(m => m.mean > overallMean * 1.1)
      .map(m => getMonthName(m.month)),
    interpretation: 'Yearly seasonal pattern detected'
  };
}

function calculateSeasonalIndices(values, period) {
  const indices = Array(period).fill(0);
  const counts = Array(period).fill(0);
  
  values.forEach((val, i) => {
    const seasonIndex = i % period;
    indices[seasonIndex] += val;
    counts[seasonIndex]++;
  });
  
  // Calculate average for each season
  for (let i = 0; i < period; i++) {
    indices[i] = counts[i] > 0 ? indices[i] / counts[i] : 0;
  }
  
  // Normalize
  const mean = mean$2(indices);
  const normalizedIndices = indices.map(idx => idx / mean);
  
  // Calculate strength
  const strength = standardDeviation(normalizedIndices);
  
  return {
    indices: normalizedIndices,
    strength
  };
}

function identifyPeakPeriods(indices) {
  const peaks = [];
  const mean = mean$2(indices);
  
  indices.forEach((idx, i) => {
    if (idx > mean * 1.1) {
      peaks.push({
        period: i,
        strength: idx
      });
    }
  });
  
  return peaks;
}

function detectStructuralBreaks(values) {
  // Simplified structural break detection
  const n = values.length;
  const windowSize = Math.max(10, Math.floor(n * 0.1));
  const breaks = [];
  
  for (let i = windowSize; i < n - windowSize; i++) {
    const before = values.slice(i - windowSize, i);
    const after = values.slice(i, i + windowSize);
    
    const meanBefore = mean$2(before);
    const meanAfter = mean$2(after);
    const pooledStd = Math.sqrt((variance(before) + variance(after)) / 2);
    
    const tStat = Math.abs(meanAfter - meanBefore) / (pooledStd * Math.sqrt(2 / windowSize));
    
    if (tStat > 2.5) {
      breaks.push({
        index: i,
        magnitude: meanAfter - meanBefore,
        significance: tStat
      });
    }
  }
  
  return breaks;
}

function calculateStandardError(x, y, regression) {
  const predicted = x.map(xi => regression.m * xi + regression.b);
  const residuals = y.map((yi, i) => yi - predicted[i]);
  const sse = residuals.reduce((sum, r) => sum + r * r, 0);
  const mse = sse / (x.length - 2);
  
  const xMean = mean$2(x);
  const xSS = x.reduce((sum, xi) => sum + Math.pow(xi - xMean, 2), 0);
  
  return Math.sqrt(mse / xSS);
}

function calculateMovingAverage(values, window) {
  const ma = [];
  
  for (let i = 0; i < values.length; i++) {
    const start = Math.max(0, i - Math.floor(window / 2));
    const end = Math.min(values.length, i + Math.floor(window / 2) + 1);
    const subset = values.slice(start, end);
    ma.push(mean$2(subset));
  }
  
  return ma;
}

function calculateSeasonalComponent(detrended, frequency) {
  // Simplified seasonal extraction
  return detrended.map((v, i) => Math.sin(2 * Math.PI * i / 12) * 0.1);
}

function calculateSeasonalStrength(seasonal, residual) {
  const varSeasonal = variance(seasonal);
  const varResidual = variance(residual);
  return varSeasonal / (varSeasonal + varResidual);
}

function interpretTrend(slope, r2, values) {
  const percentChange = (slope / mean$2(values)) * 100;
  
  if (r2 < 0.1) return 'No clear trend';
  if (Math.abs(percentChange) < 1) return 'Stable with minimal trend';
  if (percentChange > 5) return `Strong upward trend (+${percentChange.toFixed(1)}% per period)`;
  if (percentChange < -5) return `Strong downward trend (${percentChange.toFixed(1)}% per period)`;
  if (percentChange > 0) return `Moderate upward trend (+${percentChange.toFixed(1)}% per period)`;
  return `Moderate downward trend (${percentChange.toFixed(1)}% per period)`;
}

function interpretSeasonality(pattern, frequency) {
  if (!pattern || pattern.strength < 0.2) {
    return 'No significant seasonal pattern';
  }
  
  const peaks = pattern.indices
    .map((idx, i) => ({ period: i, value: idx }))
    .filter(p => p.value > 1.1)
    .sort((a, b) => b.value - a.value);
  
  if (peaks.length === 0) {
    return 'Mild seasonal variation detected';
  }
  
  const periodNames = {
    hourly: ['12AM', '1AM', '2AM', '3AM', '4AM', '5AM', '6AM', '7AM', '8AM', '9AM', '10AM', '11AM',
             '12PM', '1PM', '2PM', '3PM', '4PM', '5PM', '6PM', '7PM', '8PM', '9PM', '10PM', '11PM'],
    daily: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    weekly: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
    monthly: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  };
  
  const names = periodNames[frequency] || [];
  const peakName = names[peaks[0].period] || `Period ${peaks[0].period}`;
  
  return `Strong seasonality with peak at ${peakName} (${((peaks[0].value - 1) * 100).toFixed(0)}% above average)`;
}

function generateStationarityRecommendation(adf, kpss, breaks) {
  if (adf.isStationary && kpss.isStationary) {
    return 'Series is stationary - suitable for time series modeling';
  }
  
  if (!adf.isStationary && !kpss.isStationary) {
    return 'Series is non-stationary - consider differencing or detrending';
  }
  
  if (breaks.length > 0) {
    return 'Structural breaks detected - consider segmented analysis';
  }
  
  if (!adf.isStationary && kpss.isStationary) {
    return 'Series is trend stationary - detrending recommended';
  }
  
  return 'Mixed stationarity results - further investigation needed';
}

function getMonthName(month) {
  const names = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  return names[month];
}

function summarizeTimeSeriesCharacteristics(series) {
  const characteristics = [];
  
  // Check if any series has strong trend
  const trendingSeries = Object.entries(series)
    .filter(([_, analysis]) => analysis.trend && analysis.trend.strength > 0.5)
    .map(([name, analysis]) => ({
      name,
      direction: analysis.trend.direction,
      strength: analysis.trend.strength
    }));
  
  if (trendingSeries.length > 0) {
    characteristics.push(`${trendingSeries.length} series show significant trends`);
  }
  
  // Check for seasonality
  const seasonalSeries = Object.entries(series)
    .filter(([_, analysis]) => analysis.seasonality && analysis.seasonality.detected)
    .map(([name, _]) => name);
  
  if (seasonalSeries.length > 0) {
    characteristics.push(`Seasonal patterns detected in ${seasonalSeries.join(', ')}`);
  }
  
  // Check stationarity
  const nonStationarySeries = Object.entries(series)
    .filter(([_, analysis]) => 
      analysis.stationarity && 
      !analysis.stationarity.adf.isStationary
    ).length;
  
  if (nonStationarySeries > 0) {
    characteristics.push(`${nonStationarySeries} series require differencing for stationarity`);
  }
  
  return characteristics;
}

// This file is a workaround for a bug in web browsers' "native"
// ES6 importing system which is uncapable of importing "*.json" files.
// https://github.com/catamphetamine/libphonenumber-js/issues/239
var metadata = {"version":4,"country_calling_codes":{"1":["US","AG","AI","AS","BB","BM","BS","CA","DM","DO","GD","GU","JM","KN","KY","LC","MP","MS","PR","SX","TC","TT","VC","VG","VI"],"7":["RU","KZ"],"20":["EG"],"27":["ZA"],"30":["GR"],"31":["NL"],"32":["BE"],"33":["FR"],"34":["ES"],"36":["HU"],"39":["IT","VA"],"40":["RO"],"41":["CH"],"43":["AT"],"44":["GB","GG","IM","JE"],"45":["DK"],"46":["SE"],"47":["NO","SJ"],"48":["PL"],"49":["DE"],"51":["PE"],"52":["MX"],"53":["CU"],"54":["AR"],"55":["BR"],"56":["CL"],"57":["CO"],"58":["VE"],"60":["MY"],"61":["AU","CC","CX"],"62":["ID"],"63":["PH"],"64":["NZ"],"65":["SG"],"66":["TH"],"81":["JP"],"82":["KR"],"84":["VN"],"86":["CN"],"90":["TR"],"91":["IN"],"92":["PK"],"93":["AF"],"94":["LK"],"95":["MM"],"98":["IR"],"211":["SS"],"212":["MA","EH"],"213":["DZ"],"216":["TN"],"218":["LY"],"220":["GM"],"221":["SN"],"222":["MR"],"223":["ML"],"224":["GN"],"225":["CI"],"226":["BF"],"227":["NE"],"228":["TG"],"229":["BJ"],"230":["MU"],"231":["LR"],"232":["SL"],"233":["GH"],"234":["NG"],"235":["TD"],"236":["CF"],"237":["CM"],"238":["CV"],"239":["ST"],"240":["GQ"],"241":["GA"],"242":["CG"],"243":["CD"],"244":["AO"],"245":["GW"],"246":["IO"],"247":["AC"],"248":["SC"],"249":["SD"],"250":["RW"],"251":["ET"],"252":["SO"],"253":["DJ"],"254":["KE"],"255":["TZ"],"256":["UG"],"257":["BI"],"258":["MZ"],"260":["ZM"],"261":["MG"],"262":["RE","YT"],"263":["ZW"],"264":["NA"],"265":["MW"],"266":["LS"],"267":["BW"],"268":["SZ"],"269":["KM"],"290":["SH","TA"],"291":["ER"],"297":["AW"],"298":["FO"],"299":["GL"],"350":["GI"],"351":["PT"],"352":["LU"],"353":["IE"],"354":["IS"],"355":["AL"],"356":["MT"],"357":["CY"],"358":["FI","AX"],"359":["BG"],"370":["LT"],"371":["LV"],"372":["EE"],"373":["MD"],"374":["AM"],"375":["BY"],"376":["AD"],"377":["MC"],"378":["SM"],"380":["UA"],"381":["RS"],"382":["ME"],"383":["XK"],"385":["HR"],"386":["SI"],"387":["BA"],"389":["MK"],"420":["CZ"],"421":["SK"],"423":["LI"],"500":["FK"],"501":["BZ"],"502":["GT"],"503":["SV"],"504":["HN"],"505":["NI"],"506":["CR"],"507":["PA"],"508":["PM"],"509":["HT"],"590":["GP","BL","MF"],"591":["BO"],"592":["GY"],"593":["EC"],"594":["GF"],"595":["PY"],"596":["MQ"],"597":["SR"],"598":["UY"],"599":["CW","BQ"],"670":["TL"],"672":["NF"],"673":["BN"],"674":["NR"],"675":["PG"],"676":["TO"],"677":["SB"],"678":["VU"],"679":["FJ"],"680":["PW"],"681":["WF"],"682":["CK"],"683":["NU"],"685":["WS"],"686":["KI"],"687":["NC"],"688":["TV"],"689":["PF"],"690":["TK"],"691":["FM"],"692":["MH"],"850":["KP"],"852":["HK"],"853":["MO"],"855":["KH"],"856":["LA"],"880":["BD"],"886":["TW"],"960":["MV"],"961":["LB"],"962":["JO"],"963":["SY"],"964":["IQ"],"965":["KW"],"966":["SA"],"967":["YE"],"968":["OM"],"970":["PS"],"971":["AE"],"972":["IL"],"973":["BH"],"974":["QA"],"975":["BT"],"976":["MN"],"977":["NP"],"992":["TJ"],"993":["TM"],"994":["AZ"],"995":["GE"],"996":["KG"],"998":["UZ"]},"countries":{"AC":["247","00","(?:[01589]\\d|[46])\\d{4}",[5,6]],"AD":["376","00","(?:1|6\\d)\\d{7}|[135-9]\\d{5}",[6,8,9],[["(\\d{3})(\\d{3})","$1 $2",["[135-9]"]],["(\\d{4})(\\d{4})","$1 $2",["1"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]]],"AE":["971","00","(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}",[5,6,7,8,9,10,11,12],[["(\\d{3})(\\d{2,9})","$1 $2",["60|8"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[236]|[479][2-8]"],"0$1"],["(\\d{3})(\\d)(\\d{5})","$1 $2 $3",["[479]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"]],"0"],"AF":["93","00","[2-7]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"]],"0"],"AG":["1","011","(?:268|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([457]\\d{6})$|1","268$1",0,"268"],"AI":["1","011","(?:264|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2457]\\d{6})$|1","264$1",0,"264"],"AL":["355","00","(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}",[6,7,8,9],[["(\\d{3})(\\d{3,4})","$1 $2",["80|9"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["4[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2358][2-5]|4"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["[23578]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["6"],"0$1"]],"0"],"AM":["374","00","(?:[1-489]\\d|55|60|77)\\d{6}",[8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0 $1"],["(\\d{3})(\\d{5})","$1 $2",["2|3[12]"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["1|47"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[3-9]"],"0$1"]],"0"],"AO":["244","00","[29]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[29]"]]]],"AR":["54","00","(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}",[10,11],[["(\\d{4})(\\d{2})(\\d{4})","$1 $2-$3",["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])","2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["1"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[68]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2-$3",["[23]"],"0$1",1],["(\\d)(\\d{4})(\\d{2})(\\d{4})","$2 15-$3-$4",["9(?:2[2-469]|3[3-578])","9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))","9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",0,"$1 $2 $3-$4"],["(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 15-$3-$4",["91"],"0$1",0,"$1 $2 $3-$4"],["(\\d{3})(\\d{3})(\\d{5})","$1-$2-$3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 15-$3-$4",["9"],"0$1",0,"$1 $2 $3-$4"]],"0",0,"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?","9$1"],"AS":["1","011","(?:[58]\\d\\d|684|900)\\d{7}",[10],0,"1",0,"([267]\\d{6})$|1","684$1",0,"684"],"AT":["43","00","1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}",[4,5,6,7,8,9,10,11,12,13],[["(\\d)(\\d{3,12})","$1 $2",["1(?:11|[2-9])"],"0$1"],["(\\d{3})(\\d{2})","$1 $2",["517"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["5[079]"],"0$1"],["(\\d{3})(\\d{3,10})","$1 $2",["(?:31|4)6|51|6(?:48|5[0-3579]|[6-9])|7(?:20|32|8)|[89]","(?:31|4)6|51|6(?:485|5[0-3579]|[6-9])|7(?:20|32|8)|[89]"],"0$1"],["(\\d{4})(\\d{3,9})","$1 $2",["[2-467]|5[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["5"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,7})","$1 $2 $3",["5"],"0$1"]],"0"],"AU":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}",[5,6,7,8,9,10,12],[["(\\d{2})(\\d{3,4})","$1 $2",["16"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,4})","$1 $2 $3",["16"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["14|4"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[2378]"],"(0$1)"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:30|[89])"]]],"0",0,"(183[12])|0",0,0,0,[["(?:(?:(?:2(?:[0-26-9]\\d|3[0-8]|4[02-9]|5[0135-9])|7(?:[013-57-9]\\d|2[0-8]))\\d|3(?:(?:[0-3589]\\d|6[1-9]|7[0-35-9])\\d|4(?:[0-578]\\d|90)))\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|3\\d\\d)|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}",[9]],["4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,["163\\d{2,6}",[5,6,7,8,9]],["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",[9]],["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",[6,8,10,12]]],"0011"],"AW":["297","00","(?:[25-79]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[25-9]"]]]],"AX":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}",[5,6,7,8,9,10,11,12],0,"0",0,0,0,0,"18",0,"00"],"AZ":["994","00","365\\d{6}|(?:[124579]\\d|60|88)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[28]|2|365|46","1[28]|2|365[45]|46","1[28]|2|365(?:4|5[02])|46"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[13-9]"],"0$1"]],"0"],"BA":["387","00","6\\d{8}|(?:[35689]\\d|49|70)\\d{6}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["6[1-3]|[7-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2-$3",["[3-5]|6[56]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["6"],"0$1"]],"0"],"BB":["1","011","(?:246|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","246$1",0,"246"],"BD":["880","00","[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}",[6,7,8,9,10],[["(\\d{2})(\\d{4,6})","$1-$2",["31[5-8]|[459]1"],"0$1"],["(\\d{3})(\\d{3,7})","$1-$2",["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"],"0$1"],["(\\d{4})(\\d{3,6})","$1-$2",["[13-9]|2[23]"],"0$1"],["(\\d)(\\d{7,8})","$1-$2",["2"],"0$1"]],"0"],"BE":["32","00","4\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:80|9)0"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[239]|4[23]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[15-8]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4"],"0$1"]],"0"],"BF":["226","00","[025-7]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[025-7]"]]]],"BG":["359","00","00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}",[6,7,8,9,12],[["(\\d)(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["43[1-6]|70[1-9]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:70|8)0"],"0$1"],["(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["43[1-7]|7"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[48]|9[08]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"]],"0"],"BH":["973","00","[136-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[13679]|8[02-4679]"]]]],"BI":["257","00","(?:[267]\\d|31)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2367]"]]]],"BJ":["229","00","(?:01\\d|[24-689])\\d{7}",[8,10],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-689]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["0"]]]],"BL":["590","00","(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",[9],0,"0",0,0,0,0,0,[["590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"],["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],["80[0-5]\\d{6}"],0,0,0,0,0,["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]],"BM":["1","011","(?:441|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","441$1",0,"441"],"BN":["673","00","[2-578]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-578]"]]]],"BO":["591","00(?:1\\d)?","8001\\d{5}|(?:[2-467]\\d|50)\\d{6}",[8,9],[["(\\d)(\\d{7})","$1 $2",["[235]|4[46]"]],["(\\d{8})","$1",["[67]"]],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["8"]]],"0",0,"0(1\\d)?"],"BQ":["599","00","(?:[34]1|7\\d)\\d{5}",[7],0,0,0,0,0,0,"[347]"],"BR":["55","00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)","[1-467]\\d{9,10}|55[0-46-9]\\d{8}|[34]\\d{7}|55\\d{7,8}|(?:5[0-46-9]|[89]\\d)\\d{7,9}",[8,9,10,11],[["(\\d{4})(\\d{4})","$1-$2",["300|4(?:0[02]|37|86)","300|4(?:0(?:0|20)|370|864)"]],["(\\d{3})(\\d{2,3})(\\d{4})","$1 $2 $3",["(?:[358]|90)0"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"],"($1)"],["(\\d{2})(\\d{5})(\\d{4})","$1 $2-$3",["[16][1-9]|[2-57-9]"],"($1)"]],"0",0,"(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?","$2"],"BS":["1","011","(?:242|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([3-8]\\d{6})$|1","242$1",0,"242"],"BT":["975","00","[17]\\d{7}|[2-8]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[2-68]|7[246]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[67]|7"]]]],"BW":["267","00","(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}",[7,8,10],[["(\\d{2})(\\d{5})","$1 $2",["90"]],["(\\d{3})(\\d{4})","$1 $2",["[24-6]|3[15-9]"]],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37]"]],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["0"]],["(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["8"]]]],"BY":["375","810","(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}",[6,7,8,9,10,11],[["(\\d{3})(\\d{3})","$1 $2",["800"],"8 $1"],["(\\d{3})(\\d{2})(\\d{2,4})","$1 $2 $3",["800"],"8 $1"],["(\\d{4})(\\d{2})(\\d{3})","$1 $2-$3",["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])","1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"],"8 0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["1(?:[56]|7[467])|2[1-3]"],"8 0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-4]"],"8 0$1"],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["[89]"],"8 $1"]],"8",0,"0|80?",0,0,0,0,"8~10"],"BZ":["501","00","(?:0800\\d|[2-8])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1-$2",["[2-8]"]],["(\\d)(\\d{3})(\\d{4})(\\d{3})","$1-$2-$3-$4",["0"]]]],"CA":["1","011","[2-9]\\d{9}|3\\d{6}",[7,10],0,"1",0,0,0,0,0,[["(?:2(?:04|[23]6|[48]9|50|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|9(?:0[25]|42))[2-9]\\d{6}",[10]],["",[10]],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",[10]],["900[2-9]\\d{6}",[10]],["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:2[125-9]|33|44|66|77|88)|6(?:22|33))[2-9]\\d{6}",[10]],0,["310\\d{4}",[7]],0,["600[2-9]\\d{6}",[10]]]],"CC":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}",[6,7,8,9,10,12],0,"0",0,"([59]\\d{7})$|0","8$1",0,0,[["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}",[9]],["4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",[9]],["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",[6,8,10,12]]],"0011"],"CD":["243","00","(?:(?:[189]|5\\d)\\d|2)\\d{7}|[1-68]\\d{6}",[7,8,9,10],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[1-6]"],"0$1"],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["5"],"0$1"]],"0"],"CF":["236","00","(?:[27]\\d{3}|8776)\\d{4}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[278]"]]]],"CG":["242","00","222\\d{6}|(?:0\\d|80)\\d{7}",[9],[["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["8"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[02]"]]]],"CH":["41","00","8\\d{11}|[2-9]\\d{8}",[9,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8[047]|90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]|81"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["8"],"0$1"]],"0"],"CI":["225","00","[02]\\d{9}",[10],[["(\\d{2})(\\d{2})(\\d)(\\d{5})","$1 $2 $3 $4",["2"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3 $4",["0"]]]],"CK":["682","00","[2-578]\\d{4}",[5],[["(\\d{2})(\\d{3})","$1 $2",["[2-578]"]]]],"CL":["56","(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0","12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}",[9,10,11],[["(\\d{5})(\\d{4})","$1 $2",["219","2196"],"($1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["44"]],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2[1-36]"],"($1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["9[2-9]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"],"($1)"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["60|8"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{3})(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3 $4",["60"]]]],"CM":["237","00","[26]\\d{8}|88\\d{6,7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["88"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[26]|88"]]]],"CN":["86","00|1(?:[12]\\d|79)\\d\\d00","(?:(?:1[03-689]|2\\d)\\d\\d|6)\\d{8}|1\\d{10}|[126]\\d{6}(?:\\d(?:\\d{2})?)?|86\\d{5,6}|(?:[3-579]\\d|8[0-57-9])\\d{5,9}",[7,8,9,10,11,12],[["(\\d{2})(\\d{5,6})","$1 $2",["(?:10|2[0-57-9])[19]|3(?:[157]|35|49|9[1-68])|4(?:1[124-9]|2[179]|6[47-9]|7|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:07|1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3|4[13]|5[1-5]|7[0-79]|9[0-35-9])|(?:4[35]|59|85)[1-9]","(?:10|2[0-57-9])(?:1[02]|9[56])|8078|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))1","10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|80781|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))12","10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|807812|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123","10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:078|1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123"],"0$1"],["(\\d{3})(\\d{5,6})","$1 $2",["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]","(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]","85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])","85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["(?:4|80)0"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|2(?:[02-57-9]|1[1-9])","10|2(?:[02-57-9]|1[1-9])","10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"],"0$1",1],["(\\d{3})(\\d{7,8})","$1 $2",["9"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["80"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[3-578]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["1[3-9]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3 $4",["[12]"],"0$1",1]],"0",0,"(1(?:[12]\\d|79)\\d\\d)|0",0,0,0,0,"00"],"CO":["57","00(?:4(?:[14]4|56)|[579])","(?:46|60\\d\\d)\\d{6}|(?:1\\d|[39])\\d{9}",[8,10,11],[["(\\d{4})(\\d{4})","$1 $2",["46"]],["(\\d{3})(\\d{7})","$1 $2",["6|90"],"($1)"],["(\\d{3})(\\d{7})","$1 $2",["3[0-357]|91"]],["(\\d)(\\d{3})(\\d{7})","$1-$2-$3",["1"],"0$1",0,"$1 $2 $3"]],"0",0,"0([3579]|4(?:[14]4|56))?"],"CR":["506","00","(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}",[8,10],[["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[3-9]"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[89]"]]],0,0,"(19(?:0[0-2468]|1[09]|20|66|77|99))"],"CU":["53","119","(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}",[6,7,8,10],[["(\\d{2})(\\d{4,6})","$1 $2",["2[1-4]|[34]"],"(0$1)"],["(\\d)(\\d{6,7})","$1 $2",["7"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["[56]"],"0$1"],["(\\d{3})(\\d{7})","$1 $2",["8"],"0$1"]],"0"],"CV":["238","0","(?:[2-59]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2-589]"]]]],"CW":["599","00","(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[3467]"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["9[4-8]"]]],0,0,0,0,0,"[69]"],"CX":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}",[6,7,8,9,10,12],0,"0",0,"([59]\\d{7})$|0","8$1",0,0,[["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}",[9]],["4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",[9]],["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",[6,8,10,12]]],"0011"],"CY":["357","00","(?:[279]\\d|[58]0)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[257-9]"]]]],"CZ":["420","00","(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}",[9,10,11,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]|9[015-7]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3 $4",["96"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]]],"DE":["49","00","[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}",[4,5,6,7,8,9,10,11,12,13,14,15],[["(\\d{2})(\\d{3,13})","$1 $2",["3[02]|40|[68]9"],"0$1"],["(\\d{3})(\\d{3,12})","$1 $2",["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1","2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"],"0$1"],["(\\d{4})(\\d{2,11})","$1 $2",["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]","[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["138"],"0$1"],["(\\d{5})(\\d{2,10})","$1 $2",["3"],"0$1"],["(\\d{3})(\\d{5,11})","$1 $2",["181"],"0$1"],["(\\d{3})(\\d)(\\d{4,10})","$1 $2 $3",["1(?:3|80)|9"],"0$1"],["(\\d{3})(\\d{7,8})","$1 $2",["1[67]"],"0$1"],["(\\d{3})(\\d{7,12})","$1 $2",["8"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["185","1850","18500"],"0$1"],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["18[68]"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["15[1279]"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["15[03568]","15(?:[0568]|31)"],"0$1"],["(\\d{3})(\\d{8})","$1 $2",["18"],"0$1"],["(\\d{3})(\\d{2})(\\d{7,8})","$1 $2 $3",["1(?:6[023]|7)"],"0$1"],["(\\d{4})(\\d{2})(\\d{7})","$1 $2 $3",["15[279]"],"0$1"],["(\\d{3})(\\d{2})(\\d{8})","$1 $2 $3",["15"],"0$1"]],"0"],"DJ":["253","00","(?:2\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[27]"]]]],"DK":["45","00","[2-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-9]"]]]],"DM":["1","011","(?:[58]\\d\\d|767|900)\\d{7}",[10],0,"1",0,"([2-7]\\d{6})$|1","767$1",0,"767"],"DO":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,0,0,0,"8001|8[024]9"],"DZ":["213","00","(?:[1-4]|[5-79]\\d|80)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["9"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-8]"],"0$1"]],"0"],"EC":["593","00","1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}",[8,9,10,11],[["(\\d)(\\d{3})(\\d{4})","$1 $2-$3",["[2-7]"],"(0$1)",0,"$1-$2-$3"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{3})(\\d{3,4})","$1 $2 $3",["1"]]],"0"],"EE":["372","00","8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}",[7,8,10],[["(\\d{3})(\\d{4})","$1 $2",["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88","[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]],["(\\d{4})(\\d{3,4})","$1 $2",["[45]|8(?:00|[1-49])","[45]|8(?:00[1-9]|[1-49])"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"EG":["20","00","[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}",[8,9,10],[["(\\d)(\\d{7,8})","$1 $2",["[23]"],"0$1"],["(\\d{2})(\\d{6,7})","$1 $2",["1[35]|[4-6]|8[2468]|9[235-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{8})","$1 $2",["1"],"0$1"]],"0"],"EH":["212","00","[5-8]\\d{8}",[9],0,"0",0,0,0,0,"528[89]"],"ER":["291","00","[178]\\d{6}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[178]"],"0$1"]],"0"],"ES":["34","00","[5-9]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]00"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-9]"]]]],"ET":["251","00","(?:11|[2-579]\\d)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-579]"],"0$1"]],"0"],"FI":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}",[5,6,7,8,9,10,11,12],[["(\\d{5})","$1",["20[2-59]"],"0$1"],["(\\d{3})(\\d{3,7})","$1 $2",["(?:[1-3]0|[68])0|70[07-9]"],"0$1"],["(\\d{2})(\\d{4,8})","$1 $2",["[14]|2[09]|50|7[135]"],"0$1"],["(\\d{2})(\\d{6,10})","$1 $2",["7"],"0$1"],["(\\d)(\\d{4,9})","$1 $2",["(?:19|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"],"0$1"]],"0",0,0,0,0,"1[03-79]|[2-9]",0,"00"],"FJ":["679","0(?:0|52)","45\\d{5}|(?:0800\\d|[235-9])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1 $2",["[235-9]|45"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]]],0,0,0,0,0,0,0,"00"],"FK":["500","00","[2-7]\\d{4}",[5]],"FM":["691","00","(?:[39]\\d\\d|820)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[389]"]]]],"FO":["298","00","[2-9]\\d{5}",[6],[["(\\d{6})","$1",["[2-9]"]]],0,0,"(10(?:01|[12]0|88))"],"FR":["33","00","[1-9]\\d{8}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0 $1"],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[1-79]"],"0$1"]],"0"],"GA":["241","00","(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}",[7,8],[["(\\d)(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-7]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["11|[67]"],"0$1"]],0,0,"0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})","$1"],"GB":["44","00","[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}",[7,9,10],[["(\\d{3})(\\d{4})","$1 $2",["800","8001","80011","800111","8001111"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["845","8454","84546","845464"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["800"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["1(?:38|5[23]|69|76|94)","1(?:(?:38|69)7|5(?:24|39)|768|946)","1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["1(?:[2-69][02-9]|[78])"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[25]|7(?:0|6[02-9])","[25]|7(?:0|6(?:[03-9]|2[356]))"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[1389]"],"0$1"]],"0",0,0,0,0,0,[["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0-35])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-3]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}",[9,10]],["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}",[10]],["56\\d{8}",[10]]],0," x"],"GD":["1","011","(?:473|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","473$1",0,"473"],"GE":["995","00","(?:[3-57]\\d\\d|800)\\d{6}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["32"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[57]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[348]"],"0$1"]],"0"],"GF":["594","00","(?:[56]94\\d|7093)\\d{5}|(?:80|9\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]|9[47]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[89]"],"0$1"]],"0"],"GG":["44","00","(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?",[7,9,10],0,"0",0,"([25-9]\\d{5})$|0","1481$1",0,0,[["1481[25-9]\\d{5}",[10]],["7(?:(?:781|839)\\d|911[17])\\d{5}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}",[10]],["56\\d{8}",[10]]]],"GH":["233","00","(?:[235]\\d{3}|800)\\d{5}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[235]"],"0$1"]],"0"],"GI":["350","00","(?:[25]\\d|60)\\d{6}",[8],[["(\\d{3})(\\d{5})","$1 $2",["2"]]]],"GL":["299","00","(?:19|[2-689]\\d|70)\\d{4}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["19|[2-9]"]]]],"GM":["220","00","[2-9]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"GN":["224","00","722\\d{6}|(?:3|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["3"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[67]"]]]],"GP":["590","00","(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-79]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0$1"]],"0",0,0,0,0,0,[["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"],["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],["80[0-5]\\d{6}"],0,0,0,0,0,["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]],"GQ":["240","00","222\\d{6}|(?:3\\d|55|[89]0)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235]"]],["(\\d{3})(\\d{6})","$1 $2",["[89]"]]]],"GR":["30","00","5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}",[10,11,12],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["21|7"]],["(\\d{4})(\\d{6})","$1 $2",["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2689]"]],["(\\d{3})(\\d{3,4})(\\d{5})","$1 $2 $3",["8"]]]],"GT":["502","00","80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1 $2",["[2-8]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"GU":["1","011","(?:[58]\\d\\d|671|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","671$1",0,"671"],"GW":["245","00","[49]\\d{8}|4\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["40"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"]]]],"GY":["592","001","(?:[2-8]\\d{3}|9008)\\d{3}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"HK":["852","00(?:30|5[09]|[126-9]?)","8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}",[5,6,7,8,9,11],[["(\\d{3})(\\d{2,5})","$1 $2",["900","9003"]],["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],["(\\d{3})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]],0,0,0,0,0,0,0,"00"],"HN":["504","00","8\\d{10}|[237-9]\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1-$2",["[237-9]"]]]],"HR":["385","00","[2-69]\\d{8}|80\\d{5,7}|[1-79]\\d{7}|6\\d{6}",[7,8,9],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["6[01]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{4})(\\d{3})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6|7[245]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-57]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"]],"0"],"HT":["509","00","(?:[2-489]\\d|55)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[2-589]"]]]],"HU":["36","00","[235-7]\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"(06 $1)"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"],"(06 $1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"06 $1"]],"06"],"ID":["62","00[89]","00[1-9]\\d{9,14}|(?:[1-36]|8\\d{5})\\d{6}|00\\d{9}|[1-9]\\d{8,10}|[2-9]\\d{7}",[7,8,9,10,11,12,13,14,15,16,17],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["15"]],["(\\d{2})(\\d{5,9})","$1 $2",["2[124]|[36]1"],"(0$1)"],["(\\d{3})(\\d{5,7})","$1 $2",["800"],"0$1"],["(\\d{3})(\\d{5,8})","$1 $2",["[2-79]"],"(0$1)"],["(\\d{3})(\\d{3,4})(\\d{3})","$1-$2-$3",["8[1-35-9]"],"0$1"],["(\\d{3})(\\d{6,8})","$1 $2",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["804"],"0$1"],["(\\d{3})(\\d)(\\d{3})(\\d{3})","$1 $2 $3 $4",["80"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1-$2-$3",["8"],"0$1"]],"0"],"IE":["353","00","(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["2[24-9]|47|58|6[237-9]|9[35-9]"],"(0$1)"],["(\\d{3})(\\d{5})","$1 $2",["[45]0"],"(0$1)"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["1"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2569]|4[1-69]|7[14]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["81"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[78]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["4"],"(0$1)"],["(\\d{2})(\\d)(\\d{3})(\\d{4})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"IL":["972","0(?:0|1[2-9])","1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}",[7,8,9,10,11,12],[["(\\d{4})(\\d{3})","$1-$2",["125"]],["(\\d{4})(\\d{2})(\\d{2})","$1-$2-$3",["121"]],["(\\d)(\\d{3})(\\d{4})","$1-$2-$3",["[2-489]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1-$2-$3",["12"]],["(\\d{4})(\\d{6})","$1-$2",["159"]],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3-$4",["1[7-9]"]],["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})","$1-$2 $3-$4",["15"]]],"0"],"IM":["44","00","1624\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"([25-8]\\d{5})$|0","1624$1",0,"74576|(?:16|7[56])24"],"IN":["91","00","(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}",[8,9,10,11,12,13],[["(\\d{8})","$1",["5(?:0|2[23]|3[03]|[67]1|88)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"],0,1],["(\\d{4})(\\d{4,5})","$1 $2",["180","1800"],0,1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["140"],0,1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["11|2[02]|33|4[04]|79[1-7]|80[2-46]","11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])","11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"],"0$1",1],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807","1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]","1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"],"0$1",1],["(\\d{5})(\\d{5})","$1 $2",["[6-9]"],"0$1",1],["(\\d{4})(\\d{2,4})(\\d{4})","$1 $2 $3",["1(?:6|8[06])","1(?:6|8[06]0)"],0,1],["(\\d{4})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["18"],0,1]],"0"],"IO":["246","00","3\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["3"]]]],"IQ":["964","00","(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-6]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"IR":["98","00","[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}",[4,5,6,7,10],[["(\\d{4,5})","$1",["96"],"0$1"],["(\\d{2})(\\d{4,5})","$1 $2",["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[1-8]"],"0$1"]],"0"],"IS":["354","00|1(?:0(?:01|[12]0)|100)","(?:38\\d|[4-9])\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["[4-9]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["3"]]],0,0,0,0,0,0,0,"00"],"IT":["39","00","0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?",[6,7,8,9,10,11,12],[["(\\d{2})(\\d{4,6})","$1 $2",["0[26]"]],["(\\d{3})(\\d{3,6})","$1 $2",["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])","0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]],["(\\d{4})(\\d{2,6})","$1 $2",["0(?:[13-579][2-46-8]|8[236-8])"]],["(\\d{4})(\\d{4})","$1 $2",["894"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[26]|5"]],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["1(?:44|[679])|[378]|43"]],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[13-57-9][0159]|14"]],["(\\d{2})(\\d{4})(\\d{5})","$1 $2 $3",["0[26]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["3"]]],0,0,0,0,0,0,[["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}",[6,7,8,9,10,11]],["3[2-9]\\d{7,8}|(?:31|43)\\d{8}",[9,10]],["80(?:0\\d{3}|3)\\d{3}",[6,9]],["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}",[6,8,9,10]],["1(?:78\\d|99)\\d{6}",[9,10]],["3[2-8]\\d{9,10}",[11,12]],0,0,["55\\d{8}",[10]],["84(?:[08]\\d{3}|[17])\\d{3}",[6,9]]]],"JE":["44","00","1534\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"([0-24-8]\\d{5})$|0","1534$1",0,0,[["1534[0-24-8]\\d{5}"],["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"],["80(?:07(?:35|81)|8901)\\d{4}"],["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"],["701511\\d{4}"],0,["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"],["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"],["56\\d{8}"]]],"JM":["1","011","(?:[58]\\d\\d|658|900)\\d{7}",[10],0,"1",0,0,0,0,"658|876"],"JO":["962","00","(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2356]|87"],"(0$1)"],["(\\d{3})(\\d{5,6})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["70"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"JP":["81","010","00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}",[8,9,10,11,12,13,14,15,16,17],[["(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3",["(?:12|57|99)0"],"0$1"],["(\\d{4})(\\d)(\\d{4})","$1-$2-$3",["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2-$3",["[36]|4(?:2[09]|7[01])","[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"],"0$1"],["(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3",["[14]|[289][2-9]|5[3-9]|7[2-4679]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["800"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[257-9]"],"0$1"]],"0",0,"(000[259]\\d{6})$|(?:(?:003768)0?)|0","$1"],"KE":["254","000","(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}",[7,8,9,10],[["(\\d{2})(\\d{5,7})","$1 $2",["[24-6]"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[17]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0"],"KG":["996","00","8\\d{9}|[235-9]\\d{8}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["3(?:1[346]|[24-79])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-79]|88"],"0$1"],["(\\d{3})(\\d{3})(\\d)(\\d{2,3})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"KH":["855","00[14-9]","1\\d{9}|[1-9]\\d{7,8}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"KI":["686","00","(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}",[5,8],0,"0"],"KM":["269","00","[3478]\\d{6}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[3478]"]]]],"KN":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-7]\\d{6})$|1","869$1",0,"869"],"KP":["850","00|99","85\\d{6}|(?:19\\d|[2-7])\\d{7}",[8,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"]],"0"],"KR":["82","00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))","00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}",[5,6,8,9,10,11,12,13,14],[["(\\d{2})(\\d{3,4})","$1-$2",["(?:3[1-3]|[46][1-4]|5[1-5])1"],"0$1"],["(\\d{4})(\\d{4})","$1-$2",["1"]],["(\\d)(\\d{3,4})(\\d{4})","$1-$2-$3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["[36]0|8"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1-$2-$3",["[1346]|5[1-5]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{2})(\\d{5})(\\d{4})","$1-$2-$3",["5"],"0$1"]],"0",0,"0(8(?:[1-46-8]|5\\d\\d))?"],"KW":["965","00","18\\d{5}|(?:[2569]\\d|41)\\d{6}",[7,8],[["(\\d{4})(\\d{3,4})","$1 $2",["[169]|2(?:[235]|4[1-35-9])|52"]],["(\\d{3})(\\d{5})","$1 $2",["[245]"]]]],"KY":["1","011","(?:345|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","345$1",0,"345"],"KZ":["7","810","(?:33622|8\\d{8})\\d{5}|[78]\\d{9}",[10,14],0,"8",0,0,0,0,"33|7",0,"8~10"],"LA":["856","00","[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2[13]|3[14]|[4-8]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["3"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[23]"],"0$1"]],"0"],"LB":["961","00","[27-9]\\d{7}|[13-9]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[27-9]"]]],"0"],"LC":["1","011","(?:[58]\\d\\d|758|900)\\d{7}",[10],0,"1",0,"([2-8]\\d{6})$|1","758$1",0,"758"],"LI":["423","00","[68]\\d{8}|(?:[2378]\\d|90)\\d{5}",[7,9],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2379]|8(?:0[09]|7)","[2379]|8(?:0(?:02|9)|7)"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["69"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]],"0",0,"(1001)|0"],"LK":["94","00","[1-9]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[1-689]"],"0$1"]],"0"],"LR":["231","00","(?:[245]\\d|33|77|88)\\d{7}|(?:2\\d|[4-6])\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["4[67]|[56]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-578]"],"0$1"]],"0"],"LS":["266","00","(?:[256]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2568]"]]]],"LT":["370","00","(?:[3469]\\d|52|[78]0)\\d{6}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["52[0-7]"],"(0-$1)",1],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[7-9]"],"0 $1",1],["(\\d{2})(\\d{6})","$1 $2",["37|4(?:[15]|6[1-8])"],"(0-$1)",1],["(\\d{3})(\\d{5})","$1 $2",["[3-6]"],"(0-$1)",1]],"0",0,"[08]"],"LU":["352","00","35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}",[4,5,6,7,8,9,10,11],[["(\\d{2})(\\d{3})","$1 $2",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["20[2-689]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4",["2(?:[0367]|4[3-8])"]],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["80[01]|90[015]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["20"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4 $5",["2(?:[0367]|4[3-8])"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})","$1 $2 $3 $4",["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]],0,0,"(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"],"LV":["371","00","(?:[268]\\d|90)\\d{6}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[269]|8[01]"]]]],"LY":["218","00","[2-9]\\d{8}",[9],[["(\\d{2})(\\d{7})","$1-$2",["[2-9]"],"0$1"]],"0"],"MA":["212","00","[5-8]\\d{8}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5[45]"],"0$1"],["(\\d{4})(\\d{5})","$1-$2",["5(?:2[2-46-9]|3[3-9]|9)|8(?:0[89]|92)"],"0$1"],["(\\d{2})(\\d{7})","$1-$2",["8"],"0$1"],["(\\d{3})(\\d{6})","$1-$2",["[5-7]"],"0$1"]],"0",0,0,0,0,0,[["5(?:2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"],["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-467]|5[0-3]|8[0-7]))\\d{6}"],["80[0-7]\\d{6}"],["89\\d{7}"],0,0,0,0,["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]]],"MC":["377","00","(?:[3489]|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["4"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[389]"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["6"],"0$1"]],"0"],"MD":["373","00","(?:[235-7]\\d|[89]0)\\d{6}",[8],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["22|3"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[25-7]"],"0$1"]],"0"],"ME":["382","00","(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"0$1"]],"0"],"MF":["590","00","(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",[9],0,"0",0,0,0,0,0,[["590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"],["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],["80[0-5]\\d{6}"],0,0,0,0,0,["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]],"MG":["261","00","[23]\\d{8}",[9],[["(\\d{2})(\\d{2})(\\d{3})(\\d{2})","$1 $2 $3 $4",["[23]"],"0$1"]],"0",0,"([24-9]\\d{6})$|0","20$1"],"MH":["692","011","329\\d{4}|(?:[256]\\d|45)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1-$2",["[2-6]"]]],"1"],"MK":["389","00","[2-578]\\d{7}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2|34[47]|4(?:[37]7|5[47]|64)"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[347]"],"0$1"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["[58]"],"0$1"]],"0"],"ML":["223","00","[24-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-9]"]]]],"MM":["95","00","1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}",[6,7,8,9,10],[["(\\d)(\\d{2})(\\d{3})","$1 $2 $3",["16|2"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["4(?:[2-46]|5[3-5])|5|6(?:[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-5]|(?:60|86)[23]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]|452|678|86","[12]|452|6788|86"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[4-7]|8[1-35]"],"0$1"],["(\\d)(\\d{3})(\\d{4,6})","$1 $2 $3",["9(?:2[0-4]|[35-9]|4[137-9])"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["92"],"0$1"],["(\\d)(\\d{5})(\\d{4})","$1 $2 $3",["9"],"0$1"]],"0"],"MN":["976","001","[12]\\d{7,9}|[5-9]\\d{7}",[8,9,10],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[12]1"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[5-9]"]],["(\\d{3})(\\d{5,6})","$1 $2",["[12]2[1-3]"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["[12](?:27|3[2-8]|4[2-68]|5[1-4689])","[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["[12]"],"0$1"]],"0"],"MO":["853","00","0800\\d{3}|(?:28|[68]\\d)\\d{6}",[7,8],[["(\\d{4})(\\d{3})","$1 $2",["0"]],["(\\d{4})(\\d{4})","$1 $2",["[268]"]]]],"MP":["1","011","[58]\\d{9}|(?:67|90)0\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","670$1",0,"670"],"MQ":["596","00","(?:596\\d|7091)\\d{5}|(?:69|[89]\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-79]|8(?:0[6-9]|[36])"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"MR":["222","00","(?:[2-4]\\d\\d|800)\\d{5}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-48]"]]]],"MS":["1","011","(?:[58]\\d\\d|664|900)\\d{7}",[10],0,"1",0,"([34]\\d{6})$|1","664$1",0,"664"],"MT":["356","00","3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2357-9]"]]]],"MU":["230","0(?:0|[24-7]0|3[03])","(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}",[7,8,10],[["(\\d{3})(\\d{4})","$1 $2",["[2-46]|8[013]"]],["(\\d{4})(\\d{4})","$1 $2",["[57]"]],["(\\d{5})(\\d{5})","$1 $2",["8"]]],0,0,0,0,0,0,0,"020"],"MV":["960","0(?:0|19)","(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}",[7,10],[["(\\d{3})(\\d{4})","$1-$2",["[34679]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"]]],0,0,0,0,0,0,0,"00"],"MW":["265","00","(?:[1289]\\d|31|77)\\d{7}|1\\d{6}",[7,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["1[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[137-9]"],"0$1"]],"0"],"MX":["52","0[09]","[2-9]\\d{9}",[10],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["33|5[56]|81"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2-9]"]]],0,0,0,0,0,0,0,"00"],"MY":["60","00","1\\d{8,9}|(?:3\\d|[4-9])\\d{7}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["[4-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1-$2 $3",["1(?:[02469]|[378][1-9]|53)|8","1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2 $3",["3"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3-$4",["1(?:[367]|80)"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2 $3",["15"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2 $3",["1"],"0$1"]],"0"],"MZ":["258","00","(?:2|8\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2|8[2-79]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"NA":["264","00","[68]\\d{7,8}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["87"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],"0"],"NC":["687","00","(?:050|[2-57-9]\\d\\d)\\d{3}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1.$2.$3",["[02-57-9]"]]]],"NE":["227","00","[027-9]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["08"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[089]|2[013]|7[0467]"]]]],"NF":["672","00","[13]\\d{5}",[6],[["(\\d{2})(\\d{4})","$1 $2",["1[0-3]"]],["(\\d)(\\d{5})","$1 $2",["[13]"]]],0,0,"([0-258]\\d{4})$","3$1"],"NG":["234","009","(?:20|9\\d)\\d{8}|[78]\\d{9,13}",[10,11,12,13,14],[["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[7-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["20[129]"],"0$1"],["(\\d{4})(\\d{2})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["[78]"],"0$1"],["(\\d{3})(\\d{5})(\\d{5,6})","$1 $2 $3",["[78]"],"0$1"]],"0"],"NI":["505","00","(?:1800|[25-8]\\d{3})\\d{4}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[125-8]"]]]],"NL":["31","00","(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}",[5,6,7,8,9,10,11],[["(\\d{3})(\\d{4,7})","$1 $2",["[89]0"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["66"],"0$1"],["(\\d)(\\d{8})","$1 $2",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-578]|91"],"0$1"],["(\\d{3})(\\d{3})(\\d{5})","$1 $2 $3",["9"],"0$1"]],"0"],"NO":["47","00","(?:0|[2-9]\\d{3})\\d{4}",[5,8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["8"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]"]]],0,0,0,0,0,"[02-689]|7[0-8]"],"NP":["977","00","(?:1\\d|9)\\d{9}|[1-9]\\d{7}",[8,10,11],[["(\\d)(\\d{7})","$1-$2",["1[2-6]"],"0$1"],["(\\d{2})(\\d{6})","$1-$2",["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"],"0$1"],["(\\d{3})(\\d{7})","$1-$2",["9"]]],"0"],"NR":["674","00","(?:222|444|(?:55|8\\d)\\d|666|777|999)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[24-9]"]]]],"NU":["683","00","(?:[4-7]|888\\d)\\d{3}",[4,7],[["(\\d{3})(\\d{4})","$1 $2",["8"]]]],"NZ":["64","0(?:0|161)","[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,8})","$1 $2",["8[1-79]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["50[036-8]|8|90","50(?:[0367]|88)|8|90"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["24|[346]|7[2-57-9]|9[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:10|74)|[589]"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["1|2[028]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,5})","$1 $2 $3",["2(?:[169]|7[0-35-9])|7"],"0$1"]],"0",0,0,0,0,0,0,"00"],"OM":["968","00","(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}",[7,8,9],[["(\\d{3})(\\d{4,6})","$1 $2",["[58]"]],["(\\d{2})(\\d{6})","$1 $2",["2"]],["(\\d{4})(\\d{4})","$1 $2",["[179]"]]]],"PA":["507","00","(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}",[7,8,10,11],[["(\\d{3})(\\d{4})","$1-$2",["[1-57-9]"]],["(\\d{4})(\\d{4})","$1-$2",["[68]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]]],"PE":["51","00|19(?:1[124]|77|90)00","(?:[14-8]|9\\d)\\d{7}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["80"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["1"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[4-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"]]],"0",0,0,0,0,0,0,"00"," Anexo "],"PF":["689","00","4\\d{5}(?:\\d{2})?|8\\d{7,8}",[6,8,9],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["44"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4|8[7-9]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]]]],"PG":["675","00|140[1-3]","(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["18|[2-69]|85"]],["(\\d{4})(\\d{4})","$1 $2",["[78]"]]],0,0,0,0,0,0,0,"00"],"PH":["63","00","(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}",[6,8,9,10,11,12,13],[["(\\d)(\\d{5})","$1 $2",["2"],"(0$1)"],["(\\d{4})(\\d{4,6})","$1 $2",["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2","3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"],"(0$1)"],["(\\d{5})(\\d{4})","$1 $2",["346|4(?:27|9[35])|883","3469|4(?:279|9(?:30|56))|8834"],"(0$1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|8[2-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})","$1 $2 $3 $4",["1"]]],"0"],"PK":["92","00","122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}",[8,9,10,11,12],[["(\\d{3})(\\d{3})(\\d{2,7})","$1 $2 $3",["[89]0"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["1"]],["(\\d{3})(\\d{6,7})","$1 $2",["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])","9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"],"(0$1)"],["(\\d{2})(\\d{7,8})","$1 $2",["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"],"(0$1)"],["(\\d{5})(\\d{5})","$1 $2",["58"],"(0$1)"],["(\\d{3})(\\d{7})","$1 $2",["3"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[24-9]"],"(0$1)"]],"0"],"PL":["48","00","(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}",[6,7,8,9,10],[["(\\d{5})","$1",["19"]],["(\\d{3})(\\d{3})","$1 $2",["11|20|64"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1","(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["64"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[2-8]|[2-7]|8[1-79]|9[145]"]],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["8"]]]],"PM":["508","00","[45]\\d{5}|(?:708|8\\d\\d)\\d{6}",[6,9],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[45]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"PR":["1","011","(?:[589]\\d\\d|787)\\d{7}",[10],0,"1",0,0,0,0,"787|939"],"PS":["970","00","[2489]2\\d{6}|(?:1\\d|5)\\d{8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2489]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["5"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"PT":["351","00","1693\\d{5}|(?:[26-9]\\d|30)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["2[12]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["16|[236-9]"]]]],"PW":["680","01[12]","(?:[24-8]\\d\\d|345|900)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"PY":["595","00","59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}",[6,7,8,9,10,11],[["(\\d{3})(\\d{3,6})","$1 $2",["[2-9]0"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"],"(0$1)"],["(\\d{3})(\\d{4,5})","$1 $2",["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["87"]],["(\\d{3})(\\d{6})","$1 $2",["9(?:[5-79]|8[1-7])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]"],"0$1"],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["9"]]],"0"],"QA":["974","00","800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}",[7,8,9,11],[["(\\d{3})(\\d{4})","$1 $2",["2[136]|8"]],["(\\d{4})(\\d{4})","$1 $2",["[3-7]"]]]],"RE":["262","00","709\\d{6}|(?:26|[689]\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[26-9]"],"0$1"]],"0",0,0,0,0,0,[["26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"],["(?:69(?:2\\d\\d|3(?:[06][0-6]|1[0-3]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))|7092[0-3])\\d{4}"],["80\\d{7}"],["89[1-37-9]\\d{6}"],0,0,0,0,["9(?:399[0-3]|479[0-6]|76(?:2[278]|3[0-37]))\\d{4}"],["8(?:1[019]|2[0156]|84|90)\\d{6}"]]],"RO":["40","00","(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}",[6,9],[["(\\d{3})(\\d{3})","$1 $2",["2[3-6]","2[3-6]\\d9"],"0$1"],["(\\d{2})(\\d{4})","$1 $2",["219|31"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[23]1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[236-9]"],"0$1"]],"0",0,0,0,0,0,0,0," int "],"RS":["381","00","38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}",[6,7,8,9,10,11,12],[["(\\d{3})(\\d{3,9})","$1 $2",["(?:2[389]|39)0|[7-9]"],"0$1"],["(\\d{2})(\\d{5,10})","$1 $2",["[1-36]"],"0$1"]],"0"],"RU":["7","810","8\\d{13}|[347-9]\\d{9}",[10,14],[["(\\d{4})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-8]|2[1-9])","7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))","7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"],"8 ($1)",1],["(\\d{5})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-68]|2[1-9])","7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))","7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[349]|8(?:[02-7]|1[1-8])"],"8 ($1)",1],["(\\d{4})(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3 $4",["8"],"8 ($1)"]],"8",0,0,0,0,"3[04-689]|[489]",0,"8~10"],"RW":["250","00","(?:06|[27]\\d\\d|[89]00)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"],"0$1"]],"0"],"SA":["966","00","92\\d{7}|(?:[15]|8\\d)\\d{8}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["9"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["81"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]],"0"],"SB":["677","0[01]","[6-9]\\d{6}|[1-6]\\d{4}",[5,7],[["(\\d{2})(\\d{5})","$1 $2",["6[89]|7|8[4-9]|9(?:[1-8]|9[0-8])"]]]],"SC":["248","010|0[0-2]","(?:[2489]\\d|64)\\d{5}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[246]|9[57]"]]],0,0,0,0,0,0,0,"00"],"SD":["249","00","[19]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[19]"],"0$1"]],"0"],"SE":["46","00","(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}",[6,7,8,9,10,12],[["(\\d{2})(\\d{2,3})(\\d{2})","$1-$2 $3",["20"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{4})","$1-$2",["9(?:00|39|44|9)"],"0$1",0,"$1 $2"],["(\\d{2})(\\d{3})(\\d{2})","$1-$2 $3",["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3"],["(\\d)(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2,3})(\\d{2})","$1-$2 $3",["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{2,3})(\\d{3})","$1-$2 $3",["9(?:00|39|44)"],"0$1",0,"$1 $2 $3"],["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3 $4"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["10|7"],"0$1",0,"$1 $2 $3 $4"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1-$2 $3 $4",["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{3})","$1-$2 $3 $4",["9"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4 $5",["[26]"],"0$1",0,"$1 $2 $3 $4 $5"]],"0"],"SG":["65","0[0-3]\\d","(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}",[8,10,11],[["(\\d{4})(\\d{4})","$1 $2",["[369]|8(?:0[1-9]|[1-9])"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]],["(\\d{4})(\\d{4})(\\d{3})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"SH":["290","00","(?:[256]\\d|8)\\d{3}",[4,5],0,0,0,0,0,0,"[256]"],"SI":["386","00|10(?:22|66|88|99)","[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}",[5,6,7,8],[["(\\d{2})(\\d{3,6})","$1 $2",["8[09]|9"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["59|8"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37][01]|4[0139]|51|6"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-57]"],"(0$1)"]],"0",0,0,0,0,0,0,"00"],"SJ":["47","00","0\\d{4}|(?:[489]\\d|79)\\d{6}",[5,8],0,0,0,0,0,0,"79"],"SK":["421","00","[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}",[6,7,9],[["(\\d)(\\d{2})(\\d{3,4})","$1 $2 $3",["21"],"0$1"],["(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["[3-5][1-8]1","[3-5][1-8]1[67]"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1/$2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[689]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1/$2 $3 $4",["[3-5]"],"0$1"]],"0"],"SL":["232","00","(?:[237-9]\\d|66)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[236-9]"],"(0$1)"]],"0"],"SM":["378","00","(?:0549|[5-7]\\d)\\d{6}",[8,10],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]"]],["(\\d{4})(\\d{6})","$1 $2",["0"]]],0,0,"([89]\\d{5})$","0549$1"],"SN":["221","00","(?:[378]\\d|93)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[379]"]]]],"SO":["252","00","[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}",[6,7,8,9],[["(\\d{2})(\\d{4})","$1 $2",["8[125]"]],["(\\d{6})","$1",["[134]"]],["(\\d)(\\d{6})","$1 $2",["[15]|2[0-79]|3[0-46-8]|4[0-7]"]],["(\\d)(\\d{7})","$1 $2",["(?:2|90)4|[67]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[348]|64|79|90"]],["(\\d{2})(\\d{5,7})","$1 $2",["1|28|6[0-35-9]|7[67]|9[2-9]"]]],"0"],"SR":["597","00","(?:[2-5]|68|[78]\\d|90)\\d{5}",[6,7],[["(\\d{2})(\\d{2})(\\d{2})","$1-$2-$3",["56"]],["(\\d{3})(\\d{3})","$1-$2",["[2-5]"]],["(\\d{3})(\\d{4})","$1-$2",["[6-9]"]]]],"SS":["211","00","[19]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[19]"],"0$1"]],"0"],"ST":["239","00","(?:22|9\\d)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[29]"]]]],"SV":["503","00","[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?",[7,8,11],[["(\\d{3})(\\d{4})","$1 $2",["[89]"]],["(\\d{4})(\\d{4})","$1 $2",["[267]"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[89]"]]]],"SX":["1","011","7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"(5\\d{6})$|1","721$1",0,"721"],"SY":["963","00","[1-39]\\d{8}|[1-5]\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-5]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1",1]],"0"],"SZ":["268","00","0800\\d{4}|(?:[237]\\d|900)\\d{6}",[8,9],[["(\\d{4})(\\d{4})","$1 $2",["[0237]"]],["(\\d{5})(\\d{4})","$1 $2",["9"]]]],"TA":["290","00","8\\d{3}",[4],0,0,0,0,0,0,"8"],"TC":["1","011","(?:[58]\\d\\d|649|900)\\d{7}",[10],0,"1",0,"([2-479]\\d{6})$|1","649$1",0,"649"],"TD":["235","00|16","(?:22|[689]\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[26-9]"]]],0,0,0,0,0,0,0,"00"],"TG":["228","00","[279]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[279]"]]]],"TH":["66","00[1-9]","(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}",[8,9,10,13],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[13-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"TJ":["992","810","[0-57-9]\\d{8}",[9],[["(\\d{6})(\\d)(\\d{2})","$1 $2 $3",["331","3317"]],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["44[02-479]|[34]7"]],["(\\d{4})(\\d)(\\d{4})","$1 $2 $3",["3(?:[1245]|3[12])"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[0-57-9]"]]],0,0,0,0,0,0,0,"8~10"],"TK":["690","00","[2-47]\\d{3,6}",[4,5,6,7]],"TL":["670","00","7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[2-489]|70"]],["(\\d{4})(\\d{4})","$1 $2",["7"]]]],"TM":["993","810","(?:[1-6]\\d|71)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["12"],"(8 $1)"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-5]"],"(8 $1)"],["(\\d{2})(\\d{6})","$1 $2",["[67]"],"8 $1"]],"8",0,0,0,0,0,0,"8~10"],"TN":["216","00","[2-57-9]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-57-9]"]]]],"TO":["676","00","(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}",[5,7],[["(\\d{2})(\\d{3})","$1-$2",["[2-4]|50|6[09]|7[0-24-69]|8[05]"]],["(\\d{4})(\\d{3})","$1 $2",["0"]],["(\\d{3})(\\d{4})","$1 $2",["[5-9]"]]]],"TR":["90","00","4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}",[7,10,12,13],[["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["512|8[01589]|90"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5(?:[0-59]|61)","5(?:[0-59]|61[06])","5(?:[0-59]|61[06]1)"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24][1-8]|3[1-9]"],"(0$1)",1],["(\\d{3})(\\d{3})(\\d{6,7})","$1 $2 $3",["80"],"0$1",1]],"0"],"TT":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-46-8]\\d{6})$|1","868$1",0,"868"],"TV":["688","00","(?:2|7\\d\\d|90)\\d{4}",[5,6,7],[["(\\d{2})(\\d{3})","$1 $2",["2"]],["(\\d{2})(\\d{4})","$1 $2",["90"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"TW":["886","0(?:0[25-79]|19)","[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}",[7,8,9,10,11],[["(\\d{2})(\\d)(\\d{4})","$1 $2 $3",["202"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[258]0"],"0$1"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]","[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,5})","$1 $2 $3",["7"],"0$1"]],"0",0,0,0,0,0,0,0,"#"],"TZ":["255","00[056]","(?:[25-8]\\d|41|90)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[24]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["5"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[67]"],"0$1"]],"0"],"UA":["380","00","[89]\\d{9}|[3-9]\\d{8}",[9,10],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]","6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])","3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|89|9[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0",0,0,0,0,0,0,"0~0"],"UG":["256","00[057]","800\\d{6}|(?:[29]0|[347]\\d)\\d{7}",[9],[["(\\d{4})(\\d{5})","$1 $2",["202","2024"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[27-9]|4(?:6[45]|[7-9])"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[34]"],"0$1"]],"0"],"US":["1","011","[2-9]\\d{9}|3\\d{6}",[10],[["(\\d{3})(\\d{4})","$1-$2",["310"],0,1],["(\\d{3})(\\d{3})(\\d{4})","($1) $2-$3",["[2-9]"],0,1,"$1-$2-$3"]],"1",0,0,0,0,0,[["(?:3052(?:0[0-8]|[1-9]\\d)|5056(?:[0-35-9]\\d|4[0-468]))\\d{4}|(?:2742|305[3-9]|472[247-9]|505[2-57-9]|983[2-47-9])\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-47-9]|1[02-9]|2[0135-79]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-47-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[0-247]|4[037]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[0168]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"],[""],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],["900[2-9]\\d{6}"],["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"],0,0,0,["305209\\d{4}"]]],"UY":["598","0(?:0|1[3-9]\\d)","0004\\d{2,9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}",[6,7,8,9,10,11,12,13],[["(\\d{3})(\\d{3,4})","$1 $2",["0"]],["(\\d{3})(\\d{4})","$1 $2",["[49]0|8"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[124]"]],["(\\d{3})(\\d{3})(\\d{2,4})","$1 $2 $3",["0"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})","$1 $2 $3 $4",["0"]]],"0",0,0,0,0,0,0,"00"," int. "],"UZ":["998","00","(?:20|33|[5-9]\\d)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[235-9]"]]]],"VA":["39","00","0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",[6,7,8,9,10,11,12],0,0,0,0,0,0,"06698"],"VC":["1","011","(?:[58]\\d\\d|784|900)\\d{7}",[10],0,"1",0,"([2-7]\\d{6})$|1","784$1",0,"784"],"VE":["58","00","[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}",[10],[["(\\d{3})(\\d{7})","$1-$2",["[24-689]"],"0$1"]],"0"],"VG":["1","011","(?:284|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-578]\\d{6})$|1","284$1",0,"284"],"VI":["1","011","[58]\\d{9}|(?:34|90)0\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","340$1",0,"340"],"VN":["84","00","[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["80"],"0$1",1],["(\\d{4})(\\d{4,6})","$1 $2",["1"],0,1],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["6"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[357-9]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["2[48]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["2"],"0$1",1]],"0"],"VU":["678","00","[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}",[5,7],[["(\\d{3})(\\d{4})","$1 $2",["[57-9]"]]]],"WF":["681","00","(?:40|72|8\\d{4})\\d{4}|[89]\\d{5}",[6,9],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[47-9]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]]]],"WS":["685","0","(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}",[5,6,7,10],[["(\\d{5})","$1",["[2-5]|6[1-9]"]],["(\\d{3})(\\d{3,7})","$1 $2",["[68]"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"XK":["383","00","2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}",[8,9,10,11,12],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2|39"],"0$1"],["(\\d{2})(\\d{7,10})","$1 $2",["3"],"0$1"]],"0"],"YE":["967","00","(?:1|7\\d)\\d{7}|[1-7]\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-6]|7(?:[24-6]|8[0-7])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"],"0$1"]],"0"],"YT":["262","00","7093\\d{5}|(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}",[9],0,"0",0,0,0,0,0,[["269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"],["(?:639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])|7093[5-7])\\d{4}"],["80\\d{7}"],0,0,0,0,0,["9(?:(?:39|47)8[01]|769\\d)\\d{4}"]]],"ZA":["27","00","[1-79]\\d{8}|8\\d{4,9}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,4})","$1 $2",["8[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["8[1-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["860"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],"0"],"ZM":["260","00","800\\d{6}|(?:21|[579]\\d|63)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[28]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[579]"],"0$1"]],"0"],"ZW":["263","00","2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}",[5,6,7,8,9,10],[["(\\d{3})(\\d{3,5})","$1 $2",["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"],"0$1"],["(\\d)(\\d{3})(\\d{2,4})","$1 $2 $3",["[49]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["80"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2","2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)","2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["29[013-9]|39|54"],"0$1"],["(\\d{4})(\\d{3,5})","$1 $2",["(?:25|54)8","258|5483"],"0$1"]],"0"]},"nonGeographic":{"800":["800",0,"(?:00|[1-9]\\d)\\d{6}",[8],[["(\\d{4})(\\d{4})","$1 $2",["\\d"]]],0,0,0,0,0,0,[0,0,["(?:00|[1-9]\\d)\\d{6}"]]],"808":["808",0,"[1-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[1-9]"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,0,["[1-9]\\d{7}"]]],"870":["870",0,"7\\d{11}|[235-7]\\d{8}",[9,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-7]"]]],0,0,0,0,0,0,[0,["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"],0,0,0,0,0,0,["2\\d{8}",[9]]]],"878":["878",0,"10\\d{10}",[12],[["(\\d{2})(\\d{5})(\\d{5})","$1 $2 $3",["1"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,["10\\d{10}"]]],"881":["881",0,"6\\d{9}|[0-36-9]\\d{8}",[9,10],[["(\\d)(\\d{3})(\\d{5})","$1 $2 $3",["[0-37-9]"]],["(\\d)(\\d{3})(\\d{5,6})","$1 $2 $3",["6"]]],0,0,0,0,0,0,[0,["6\\d{9}|[0-36-9]\\d{8}"]]],"882":["882",0,"[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?",[7,8,9,10,11,12],[["(\\d{2})(\\d{5})","$1 $2",["16|342"]],["(\\d{2})(\\d{6})","$1 $2",["49"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["1[36]|9"]],["(\\d{2})(\\d{4})(\\d{3})","$1 $2 $3",["3[23]"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["16"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|23|3(?:[15]|4[57])|4|51"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["34"]],["(\\d{2})(\\d{4,5})(\\d{5})","$1 $2 $3",["[1-35]"]]],0,0,0,0,0,0,[0,["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}",[7,8,9,10,12]],0,0,0,["348[57]\\d{7}",[11]],0,0,["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]],"883":["883",0,"(?:[1-4]\\d|51)\\d{6,10}",[8,9,10,11,12],[["(\\d{3})(\\d{3})(\\d{2,8})","$1 $2 $3",["[14]|2[24-689]|3[02-689]|51[24-9]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["510"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["21"]],["(\\d{4})(\\d{4})(\\d{4})","$1 $2 $3",["51[13]"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[235]"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]],"888":["888",0,"\\d{11}",[11],[["(\\d{3})(\\d{3})(\\d{5})","$1 $2 $3"]],0,0,0,0,0,0,[0,0,0,0,0,0,["\\d{11}"]]],"979":["979",0,"[1359]\\d{8}",[9],[["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[1359]"]]],0,0,0,0,0,0,[0,0,0,["[1359]\\d{8}"]]]}};

// Importing from a ".js" file is a workaround for Node.js "ES Modules"
// importing system which is even uncapable of importing "*.json" files.

function withMetadataArgument(func, _arguments) {
	var args = Array.prototype.slice.call(_arguments);
	args.push(metadata);
	return func.apply(this, args)
}

// Copy-pasted from:
// https://github.com/substack/semver-compare/blob/master/index.js
//
// Inlining this function because some users reported issues with
// importing from `semver-compare` in a browser with ES6 "native" modules.
//
// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc "tags".
// https://github.com/catamphetamine/libphonenumber-js/issues/381
function compare (a, b) {
  a = a.split('-');
  b = b.split('-');
  var pa = a[0].split('.');
  var pb = b[0].split('.');

  for (var i = 0; i < 3; i++) {
    var na = Number(pa[i]);
    var nb = Number(pb[i]);
    if (na > nb) return 1;
    if (nb > na) return -1;
    if (!isNaN(na) && isNaN(nb)) return 1;
    if (isNaN(na) && !isNaN(nb)) return -1;
  }

  if (a[1] && b[1]) {
    return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
  }

  return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
}

var objectConstructor = {}.constructor;
function isObject$1(object) {
  return object !== undefined && object !== null && object.constructor === objectConstructor;
}

function _typeof$1(obj) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$1(obj); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var V3 = '1.2.0'; // Moved `001` country code to "nonGeographic" section of metadata.

var V4 = '1.7.35';
var DEFAULT_EXT_PREFIX = ' ext. ';
var CALLING_CODE_REG_EXP = /^\d+$/;
/**
 * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md
 */

var Metadata = /*#__PURE__*/function () {
  function Metadata(metadata) {
    _classCallCheck$2(this, Metadata);

    validateMetadata(metadata);
    this.metadata = metadata;
    setVersion.call(this, metadata);
  }

  _createClass$2(Metadata, [{
    key: "getCountries",
    value: function getCountries() {
      return Object.keys(this.metadata.countries).filter(function (_) {
        return _ !== '001';
      });
    }
  }, {
    key: "getCountryMetadata",
    value: function getCountryMetadata(countryCode) {
      return this.metadata.countries[countryCode];
    }
  }, {
    key: "nonGeographic",
    value: function nonGeographic() {
      if (this.v1 || this.v2 || this.v3) return; // `nonGeographical` was a typo.
      // It's present in metadata generated from `1.7.35` to `1.7.37`.
      // The test case could be found by searching for "nonGeographical".

      return this.metadata.nonGeographic || this.metadata.nonGeographical;
    }
  }, {
    key: "hasCountry",
    value: function hasCountry(country) {
      return this.getCountryMetadata(country) !== undefined;
    }
  }, {
    key: "hasCallingCode",
    value: function hasCallingCode(callingCode) {
      if (this.getCountryCodesForCallingCode(callingCode)) {
        return true;
      }

      if (this.nonGeographic()) {
        if (this.nonGeographic()[callingCode]) {
          return true;
        }
      } else {
        // A hacky workaround for old custom metadata (generated before V4).
        var countryCodes = this.countryCallingCodes()[callingCode];

        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
          return true;
        }
      }
    }
  }, {
    key: "isNonGeographicCallingCode",
    value: function isNonGeographicCallingCode(callingCode) {
      if (this.nonGeographic()) {
        return this.nonGeographic()[callingCode] ? true : false;
      } else {
        return this.getCountryCodesForCallingCode(callingCode) ? false : true;
      }
    } // Deprecated.

  }, {
    key: "country",
    value: function country(countryCode) {
      return this.selectNumberingPlan(countryCode);
    }
  }, {
    key: "selectNumberingPlan",
    value: function selectNumberingPlan(countryCode, callingCode) {
      // Supports just passing `callingCode` as the first argument.
      if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
        callingCode = countryCode;
        countryCode = null;
      }

      if (countryCode && countryCode !== '001') {
        if (!this.hasCountry(countryCode)) {
          throw new Error("Unknown country: ".concat(countryCode));
        }

        this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
      } else if (callingCode) {
        if (!this.hasCallingCode(callingCode)) {
          throw new Error("Unknown calling code: ".concat(callingCode));
        }

        this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
      } else {
        this.numberingPlan = undefined;
      }

      return this;
    }
  }, {
    key: "getCountryCodesForCallingCode",
    value: function getCountryCodesForCallingCode(callingCode) {
      var countryCodes = this.countryCallingCodes()[callingCode];

      if (countryCodes) {
        // Metadata before V4 included "non-geographic entity" calling codes
        // inside `country_calling_codes` (for example, `"881":["001"]`).
        // Now the semantics of `country_calling_codes` has changed:
        // it's specifically for "countries" now.
        // Older versions of custom metadata will simply skip parsing
        // "non-geographic entity" phone numbers with new versions
        // of this library: it's not considered a bug,
        // because such numbers are extremely rare,
        // and developers extremely rarely use custom metadata.
        if (countryCodes.length === 1 && countryCodes[0].length === 3) {
          return;
        }

        return countryCodes;
      }
    }
  }, {
    key: "getCountryCodeForCallingCode",
    value: function getCountryCodeForCallingCode(callingCode) {
      var countryCodes = this.getCountryCodesForCallingCode(callingCode);

      if (countryCodes) {
        return countryCodes[0];
      }
    }
  }, {
    key: "getNumberingPlanMetadata",
    value: function getNumberingPlanMetadata(callingCode) {
      var countryCode = this.getCountryCodeForCallingCode(callingCode);

      if (countryCode) {
        return this.getCountryMetadata(countryCode);
      }

      if (this.nonGeographic()) {
        var metadata = this.nonGeographic()[callingCode];

        if (metadata) {
          return metadata;
        }
      } else {
        // A hacky workaround for old custom metadata (generated before V4).
        // In that metadata, there was no concept of "non-geographic" metadata
        // so metadata for `001` country code was stored along with other countries.
        // The test case can be found by searching for:
        // "should work around `nonGeographic` metadata not existing".
        var countryCodes = this.countryCallingCodes()[callingCode];

        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
          return this.metadata.countries['001'];
        }
      }
    } // Deprecated.

  }, {
    key: "countryCallingCode",
    value: function countryCallingCode() {
      return this.numberingPlan.callingCode();
    } // Deprecated.

  }, {
    key: "IDDPrefix",
    value: function IDDPrefix() {
      return this.numberingPlan.IDDPrefix();
    } // Deprecated.

  }, {
    key: "defaultIDDPrefix",
    value: function defaultIDDPrefix() {
      return this.numberingPlan.defaultIDDPrefix();
    } // Deprecated.

  }, {
    key: "nationalNumberPattern",
    value: function nationalNumberPattern() {
      return this.numberingPlan.nationalNumberPattern();
    } // Deprecated.

  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      return this.numberingPlan.possibleLengths();
    } // Deprecated.

  }, {
    key: "formats",
    value: function formats() {
      return this.numberingPlan.formats();
    } // Deprecated.

  }, {
    key: "nationalPrefixForParsing",
    value: function nationalPrefixForParsing() {
      return this.numberingPlan.nationalPrefixForParsing();
    } // Deprecated.

  }, {
    key: "nationalPrefixTransformRule",
    value: function nationalPrefixTransformRule() {
      return this.numberingPlan.nationalPrefixTransformRule();
    } // Deprecated.

  }, {
    key: "leadingDigits",
    value: function leadingDigits() {
      return this.numberingPlan.leadingDigits();
    } // Deprecated.

  }, {
    key: "hasTypes",
    value: function hasTypes() {
      return this.numberingPlan.hasTypes();
    } // Deprecated.

  }, {
    key: "type",
    value: function type(_type) {
      return this.numberingPlan.type(_type);
    } // Deprecated.

  }, {
    key: "ext",
    value: function ext() {
      return this.numberingPlan.ext();
    }
  }, {
    key: "countryCallingCodes",
    value: function countryCallingCodes() {
      if (this.v1) return this.metadata.country_phone_code_to_countries;
      return this.metadata.country_calling_codes;
    } // Deprecated.

  }, {
    key: "chooseCountryByCountryCallingCode",
    value: function chooseCountryByCountryCallingCode(callingCode) {
      return this.selectNumberingPlan(callingCode);
    }
  }, {
    key: "hasSelectedNumberingPlan",
    value: function hasSelectedNumberingPlan() {
      return this.numberingPlan !== undefined;
    }
  }]);

  return Metadata;
}();

var NumberingPlan = /*#__PURE__*/function () {
  function NumberingPlan(metadata, globalMetadataObject) {
    _classCallCheck$2(this, NumberingPlan);

    this.globalMetadataObject = globalMetadataObject;
    this.metadata = metadata;
    setVersion.call(this, globalMetadataObject.metadata);
  }

  _createClass$2(NumberingPlan, [{
    key: "callingCode",
    value: function callingCode() {
      return this.metadata[0];
    } // Formatting information for regions which share
    // a country calling code is contained by only one region
    // for performance reasons. For example, for NANPA region
    // ("North American Numbering Plan Administration",
    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
    // it will be contained in the metadata for `US`.

  }, {
    key: "getDefaultCountryMetadataForRegion",
    value: function getDefaultCountryMetadataForRegion() {
      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
    } // Is always present.

  }, {
    key: "IDDPrefix",
    value: function IDDPrefix() {
      if (this.v1 || this.v2) return;
      return this.metadata[1];
    } // Is only present when a country supports multiple IDD prefixes.

  }, {
    key: "defaultIDDPrefix",
    value: function defaultIDDPrefix() {
      if (this.v1 || this.v2) return;
      return this.metadata[12];
    }
  }, {
    key: "nationalNumberPattern",
    value: function nationalNumberPattern() {
      if (this.v1 || this.v2) return this.metadata[1];
      return this.metadata[2];
    } // "possible length" data is always present in Google's metadata.

  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      if (this.v1) return;
      return this.metadata[this.v2 ? 2 : 3];
    }
  }, {
    key: "_getFormats",
    value: function _getFormats(metadata) {
      return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
    } // For countries of the same region (e.g. NANPA)
    // formats are all stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".

  }, {
    key: "formats",
    value: function formats() {
      var _this = this;

      var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
      return formats.map(function (_) {
        return new Format(_, _this);
      });
    }
  }, {
    key: "nationalPrefix",
    value: function nationalPrefix() {
      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
    }
  }, {
    key: "_getNationalPrefixFormattingRule",
    value: function _getNationalPrefixFormattingRule(metadata) {
      return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
    } // For countries of the same region (e.g. NANPA)
    // national prefix formatting rule is stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".

  }, {
    key: "nationalPrefixFormattingRule",
    value: function nationalPrefixFormattingRule() {
      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "_nationalPrefixForParsing",
    value: function _nationalPrefixForParsing() {
      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
    }
  }, {
    key: "nationalPrefixForParsing",
    value: function nationalPrefixForParsing() {
      // If `national_prefix_for_parsing` is not set explicitly,
      // then infer it from `national_prefix` (if any)
      return this._nationalPrefixForParsing() || this.nationalPrefix();
    }
  }, {
    key: "nationalPrefixTransformRule",
    value: function nationalPrefixTransformRule() {
      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
    }
  }, {
    key: "_getNationalPrefixIsOptionalWhenFormatting",
    value: function _getNationalPrefixIsOptionalWhenFormatting() {
      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
    } // For countries of the same region (e.g. NANPA)
    // "national prefix is optional when formatting" flag is
    // stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".

  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "leadingDigits",
    value: function leadingDigits() {
      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
    }
  }, {
    key: "types",
    value: function types() {
      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
    }
  }, {
    key: "hasTypes",
    value: function hasTypes() {
      // Versions 1.2.0 - 1.2.4: can be `[]`.

      /* istanbul ignore next */
      if (this.types() && this.types().length === 0) {
        return false;
      } // Versions <= 1.2.4: can be `undefined`.
      // Version >= 1.2.5: can be `0`.


      return !!this.types();
    }
  }, {
    key: "type",
    value: function type(_type2) {
      if (this.hasTypes() && getType(this.types(), _type2)) {
        return new Type$2(getType(this.types(), _type2), this);
      }
    }
  }, {
    key: "ext",
    value: function ext() {
      if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;
      return this.metadata[13] || DEFAULT_EXT_PREFIX;
    }
  }]);

  return NumberingPlan;
}();

var Format = /*#__PURE__*/function () {
  function Format(format, metadata) {
    _classCallCheck$2(this, Format);

    this._format = format;
    this.metadata = metadata;
  }

  _createClass$2(Format, [{
    key: "pattern",
    value: function pattern() {
      return this._format[0];
    }
  }, {
    key: "format",
    value: function format() {
      return this._format[1];
    }
  }, {
    key: "leadingDigitsPatterns",
    value: function leadingDigitsPatterns() {
      return this._format[2] || [];
    }
  }, {
    key: "nationalPrefixFormattingRule",
    value: function nationalPrefixFormattingRule() {
      return this._format[3] || this.metadata.nationalPrefixFormattingRule();
    }
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
  }, {
    key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
    value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
      // National prefix is omitted if there's no national prefix formatting rule
      // set for this country, or when the national prefix formatting rule
      // contains no national prefix itself, or when this rule is set but
      // national prefix is optional for this phone number format
      // (and it is not enforced explicitly)
      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    } // Checks whether national prefix formatting rule contains national prefix.

  }, {
    key: "usesNationalPrefix",
    value: function usesNationalPrefix() {
      return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
      !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) // In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`
      // when `national_prefix_formatting_rule` is not present.
      // So, `true` or `false` are returned explicitly here, so that
      // `0` number isn't returned.
      ? true : false;
    }
  }, {
    key: "internationalFormat",
    value: function internationalFormat() {
      return this._format[5] || this.format();
    }
  }]);

  return Format;
}();
/**
 * A pattern that is used to determine if the national prefix formatting rule
 * has the first group only, i.e., does not start with the national prefix.
 * Note that the pattern explicitly allows for unbalanced parentheses.
 */


var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;

var Type$2 = /*#__PURE__*/function () {
  function Type(type, metadata) {
    _classCallCheck$2(this, Type);

    this.type = type;
    this.metadata = metadata;
  }

  _createClass$2(Type, [{
    key: "pattern",
    value: function pattern() {
      if (this.metadata.v1) return this.type;
      return this.type[0];
    }
  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      if (this.metadata.v1) return;
      return this.type[1] || this.metadata.possibleLengths();
    }
  }]);

  return Type;
}();

function getType(types, type) {
  switch (type) {
    case 'FIXED_LINE':
      return types[0];

    case 'MOBILE':
      return types[1];

    case 'TOLL_FREE':
      return types[2];

    case 'PREMIUM_RATE':
      return types[3];

    case 'PERSONAL_NUMBER':
      return types[4];

    case 'VOICEMAIL':
      return types[5];

    case 'UAN':
      return types[6];

    case 'PAGER':
      return types[7];

    case 'VOIP':
      return types[8];

    case 'SHARED_COST':
      return types[9];
  }
}

function validateMetadata(metadata) {
  if (!metadata) {
    throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');
  } // `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.
  // For that reason, it's not used in this detection algorithm.
  // Instead, it detects by `countries: {}` property existence.


  if (!isObject$1(metadata) || !isObject$1(metadata.countries)) {
    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(isObject$1(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata, "."));
  }
} // Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".

/* istanbul ignore next */

var typeOf = function typeOf(_) {
  return _typeof$1(_);
};
/**
 * Returns "country calling code" for a country.
 * Throws an error if the country doesn't exist or isn't supported by this library.
 * @param  {string} country
 * @param  {object} metadata
 * @return {string}
 * @example
 * // Returns "44"
 * getCountryCallingCode("GB")
 */

function getCountryCallingCode(country, metadata) {
  metadata = new Metadata(metadata);

  if (metadata.hasCountry(country)) {
    return metadata.country(country).countryCallingCode();
  }

  throw new Error("Unknown country: ".concat(country));
}
function isSupportedCountry(country, metadata) {
  // metadata = new Metadata(metadata)
  // return metadata.hasCountry(country)
  return metadata.countries.hasOwnProperty(country);
}

function setVersion(metadata) {
  var version = metadata.version;

  if (typeof version === 'number') {
    this.v1 = version === 1;
    this.v2 = version === 2;
    this.v3 = version === 3;
    this.v4 = version === 4;
  } else {
    if (!version) {
      this.v1 = true;
    } else if (compare(version, V3) === -1) {
      this.v2 = true;
    } else if (compare(version, V4) === -1) {
      this.v3 = true;
    } else {
      this.v4 = true;
    }
  }
} // const ISO_COUNTRY_CODE = /^[A-Z]{2}$/
// function isCountryCode(countryCode) {
// 	return ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)
// }

function checkNumberLength(nationalNumber, metadata) {
  return checkNumberLengthForType(nationalNumber, undefined, metadata);
} // Checks whether a number is possible for the country based on its length.
// Should only be called for the "new" metadata which has "possible lengths".

function checkNumberLengthForType(nationalNumber, type, metadata) {
  var type_info = metadata.type(type); // There should always be "<possiblePengths/>" set for every type element.
  // This is declared in the XML schema.
  // For size efficiency, where a sub-description (e.g. fixed-line)
  // has the same "<possiblePengths/>" as the "general description", this is missing,
  // so we fall back to the "general description". Where no numbers of the type
  // exist at all, there is one possible length (-1) which is guaranteed
  // not to match the length of any real phone number.

  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths(); // let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()
  // Metadata before version `1.0.18` didn't contain `possible_lengths`.

  if (!possible_lengths) {
    return 'IS_POSSIBLE';
  }

  var actual_length = nationalNumber.length; // In `libphonenumber-js` all "local-only" formats are dropped for simplicity.
  // // This is safe because there is never an overlap beween the possible lengths
  // // and the local-only lengths; this is checked at build time.
  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)
  // {
  // 	return 'IS_POSSIBLE_LOCAL_ONLY'
  // }

  var minimum_length = possible_lengths[0];

  if (minimum_length === actual_length) {
    return 'IS_POSSIBLE';
  }

  if (minimum_length > actual_length) {
    return 'TOO_SHORT';
  }

  if (possible_lengths[possible_lengths.length - 1] < actual_length) {
    return 'TOO_LONG';
  } // We skip the first element since we've already checked it.


  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';
}

/**
 * Checks if a phone number is "possible" (basically just checks its length).
 *
 * isPossible(phoneNumberInstance, { ..., v2: true }, metadata)
 *
 * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)
 * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)
 *
 * @param  {object|PhoneNumber} input — If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.
 * @param  {object} [options]
 * @param  {object} metadata
 * @return {string}
 */

function isPossiblePhoneNumber(input, options, metadata) {
  /* istanbul ignore if */
  if (options === undefined) {
    options = {};
  }

  metadata = new Metadata(metadata);

  if (options.v2) {
    if (!input.countryCallingCode) {
      throw new Error('Invalid phone number object passed');
    }

    metadata.selectNumberingPlan(input.countryCallingCode);
  } else {
    if (!input.phone) {
      return false;
    }

    if (input.country) {
      if (!metadata.hasCountry(input.country)) {
        throw new Error("Unknown country: ".concat(input.country));
      }

      metadata.country(input.country);
    } else {
      if (!input.countryCallingCode) {
        throw new Error('Invalid phone number object passed');
      }

      metadata.selectNumberingPlan(input.countryCallingCode);
    }
  } // Old metadata (< 1.0.18) had no "possible length" data.


  if (metadata.possibleLengths()) {
    return isPossibleNumber(input.phone || input.nationalNumber, metadata);
  } else {
    // There was a bug between `1.7.35` and `1.7.37` where "possible_lengths"
    // were missing for "non-geographical" numbering plans.
    // Just assume the number is possible in such cases:
    // it's unlikely that anyone generated their custom metadata
    // in that short period of time (one day).
    // This code can be removed in some future major version update.
    if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {
      // "Non-geographic entities" did't have `possibleLengths`
      // due to a bug in metadata generation process.
      return true;
    } else {
      throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
    }
  }
}
function isPossibleNumber(nationalNumber, metadata) {
  //, isInternational) {
  switch (checkNumberLength(nationalNumber, metadata)) {
    case 'IS_POSSIBLE':
      return true;
    // This library ignores "local-only" phone numbers (for simplicity).
    // See the readme for more info on what are "local-only" phone numbers.
    // case 'IS_POSSIBLE_LOCAL_ONLY':
    // 	return !isInternational

    default:
      return false;
  }
}

/**
 * Checks whether the entire input sequence can be matched
 * against the regular expression.
 * @return {boolean}
 */
function matchesEntirely(text, regular_expression) {
  // If assigning the `''` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  text = text || '';
  return new RegExp('^(?:' + regular_expression + ')$').test(text);
}

function _createForOfIteratorHelperLoose$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL']; // Finds out national phone number type (fixed line, mobile, etc)

function getNumberType(input, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {}; // When `parse()` returns an empty object — `{}` —
  // that means that the phone number is malformed,
  // so it can't possibly be valid.

  if (!input.country && !input.countryCallingCode) {
    return;
  }

  metadata = new Metadata(metadata);
  metadata.selectNumberingPlan(input.country, input.countryCallingCode);
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // The following is copy-pasted from the original function:
  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835
  // Is this national number even valid for this country

  if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {
    return;
  } // Is it fixed line number


  if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {
    // Because duplicate regular expressions are removed
    // to reduce metadata size, if "mobile" pattern is ""
    // then it means it was removed due to being a duplicate of the fixed-line pattern.
    //
    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {
      return 'FIXED_LINE_OR_MOBILE';
    } // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.
    // For example, for "US" country.
    // Old metadata (< `1.0.18`) had a specific "types" data structure
    // that happened to be `undefined` for `MOBILE` in that case.
    // Newer metadata (>= `1.0.18`) has another data structure that is
    // not `undefined` for `MOBILE` in that case (it's just an empty array).
    // So this `if` is just for backwards compatibility with old metadata.


    if (!metadata.type('MOBILE')) {
      return 'FIXED_LINE_OR_MOBILE';
    } // Check if the number happens to qualify as both fixed line and mobile.
    // (no such country in the minimal metadata set)

    /* istanbul ignore if */


    if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {
      return 'FIXED_LINE_OR_MOBILE';
    }

    return 'FIXED_LINE';
  }

  for (var _iterator = _createForOfIteratorHelperLoose$3(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;) {
    var type = _step.value;

    if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {
      return type;
    }
  }
}
function isNumberTypeEqualTo(nationalNumber, type, metadata) {
  type = metadata.type(type);

  if (!type || !type.pattern()) {
    return false;
  } // Check if any possible number lengths are present;
  // if so, we use them to avoid checking
  // the validation pattern if they don't match.
  // If they are absent, this means they match
  // the general description, which we have
  // already checked before a specific number type.


  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
    return false;
  }

  return matchesEntirely(nationalNumber, type.pattern());
}

/**
 * Checks if a given phone number is valid.
 *
 * isValid(phoneNumberInstance, { ..., v2: true }, metadata)
 *
 * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)
 * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)
 *
 * If the `number` is a string, it will be parsed to an object,
 * but only if it contains only valid phone number characters (including punctuation).
 * If the `number` is an object, it is used as is.
 *
 * The optional `defaultCountry` argument is the default country.
 * I.e. it does not restrict to just that country,
 * e.g. in those cases where several countries share
 * the same phone numbering rules (NANPA, Britain, etc).
 * For example, even though the number `07624 369230`
 * belongs to the Isle of Man ("IM" country code)
 * calling `isValidNumber('07624369230', 'GB', metadata)`
 * still returns `true` because the country is not restricted to `GB`,
 * it's just that `GB` is the default one for the phone numbering rules.
 * For restricting the country see `isValidNumberForRegion()`
 * though restricting a country might not be a good idea.
 * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
 *
 * Examples:
 *
 * ```js
 * isValidNumber('+78005553535', metadata)
 * isValidNumber('8005553535', 'RU', metadata)
 * isValidNumber('88005553535', 'RU', metadata)
 * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)
 * ```
 */

function isValidNumber(input, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {};
  metadata = new Metadata(metadata);
  metadata.selectNumberingPlan(input.country, input.countryCallingCode); // By default, countries only have type regexps when it's required for
  // distinguishing different countries having the same `countryCallingCode`.

  if (metadata.hasTypes()) {
    return getNumberType(input, options, metadata.metadata) !== undefined;
  } // If there are no type regexps for this country in metadata then use
  // `nationalNumberPattern` as a "better than nothing" replacement.


  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  return matchesEntirely(nationalNumber, metadata.nationalNumberPattern());
}

/**
 * Returns a list of countries that the phone number could potentially belong to.
 * @param  {string} callingCode — Calling code.
 * @param  {string} nationalNumber — National (significant) number.
 * @param  {object} metadata — Metadata.
 * @return {string[]} A list of possible countries.
 */

function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {
  var _metadata = new Metadata(metadata);

  var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);

  if (!possibleCountries) {
    return [];
  }

  return possibleCountries.filter(function (country) {
    return couldNationalNumberBelongToCountry(nationalNumber, country, metadata);
  });
}

function couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {
  var _metadata = new Metadata(metadata);

  _metadata.selectNumberingPlan(country);

  if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {
    return true;
  }

  return false;
}

// The minimum length of the national significant number.
var MIN_LENGTH_FOR_NSN = 2; // The ITU says the maximum length should be 15,
// but one can find longer numbers in Germany.

var MAX_LENGTH_FOR_NSN = 17; // The maximum length of the country calling code.

var MAX_LENGTH_COUNTRY_CODE = 3; // Digits accepted in phone numbers
// (ascii, fullwidth, arabic-indic, and eastern arabic digits).

var VALID_DIGITS = "0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9"; // `DASHES` will be right after the opening square bracket of the "character class"

var DASHES = "-\u2010-\u2015\u2212\u30FC\uFF0D";
var SLASHES = "\uFF0F/";
var DOTS = "\uFF0E.";
var WHITESPACE = " \xA0\xAD\u200B\u2060\u3000";
var BRACKETS = "()\uFF08\uFF09\uFF3B\uFF3D\\[\\]"; // export const OPENING_BRACKETS = '(\uFF08\uFF3B\\\['

var TILDES = "~\u2053\u223C\uFF5E"; // Regular expression of acceptable punctuation found in phone numbers. This
// excludes punctuation found as a leading character only. This consists of dash
// characters, white space characters, full stops, slashes, square brackets,
// parentheses and tildes. Full-width variants are also present.

var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
var PLUS_CHARS = "+\uFF0B"; // const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')

var CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])');
function stripIddPrefix(number, country, callingCode, metadata) {
  if (!country) {
    return;
  } // Check if the number is IDD-prefixed.


  var countryMetadata = new Metadata(metadata);
  countryMetadata.selectNumberingPlan(country, callingCode);
  var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());

  if (number.search(IDDPrefixPattern) !== 0) {
    return;
  } // Strip IDD prefix.


  number = number.slice(number.match(IDDPrefixPattern)[0].length); // If there're any digits after an IDD prefix,
  // then those digits are a country calling code.
  // Since no country code starts with a `0`,
  // the code below validates that the next digit (if present) is not `0`.

  var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);

  if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
    if (matchedGroups[1] === '0') {
      return;
    }
  }

  return number;
}

/**
 * Strips any national prefix (such as 0, 1) present in a
 * (possibly incomplete) number provided.
 * "Carrier codes" are only used  in Colombia and Brazil,
 * and only when dialing within those countries from a mobile phone to a fixed line number.
 * Sometimes it won't actually strip national prefix
 * and will instead prepend some digits to the `number`:
 * for example, when number `2345678` is passed with `VI` country selected,
 * it will return `{ number: "3402345678" }`, because `340` area code is prepended.
 * @param {string} number — National number digits.
 * @param {object} metadata — Metadata with country selected.
 * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.
 */
function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {
  if (number && metadata.numberingPlan.nationalPrefixForParsing()) {
    // See METADATA.md for the description of
    // `national_prefix_for_parsing` and `national_prefix_transform_rule`.
    // Attempt to parse the first digits as a national prefix.
    var prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')');
    var prefixMatch = prefixPattern.exec(number);

    if (prefixMatch) {
      var nationalNumber;
      var carrierCode; // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
      // If a `national_prefix_for_parsing` has any "capturing groups"
      // then it means that the national (significant) number is equal to
      // those "capturing groups" transformed via `national_prefix_transform_rule`,
      // and nothing could be said about the actual national prefix:
      // what is it and was it even there.
      // If a `national_prefix_for_parsing` doesn't have any "capturing groups",
      // then everything it matches is a national prefix.
      // To determine whether `national_prefix_for_parsing` matched any
      // "capturing groups", the value of the result of calling `.exec()`
      // is looked at, and if it has non-undefined values where there're
      // "capturing groups" in the regular expression, then it means
      // that "capturing groups" have been matched.
      // It's not possible to tell whether there'll be any "capturing gropus"
      // before the matching process, because a `national_prefix_for_parsing`
      // could exhibit both behaviors.

      var capturedGroupsCount = prefixMatch.length - 1;
      var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];

      if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {
        nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule()); // If there's more than one captured group,
        // then carrier code is the second one.

        if (capturedGroupsCount > 1) {
          carrierCode = prefixMatch[1];
        }
      } // If there're no "capturing groups",
      // or if there're "capturing groups" but no
      // `national_prefix_transform_rule`,
      // then just strip the national prefix from the number,
      // and possibly a carrier code.
      // Seems like there could be more.
      else {
        // `prefixBeforeNationalNumber` is the whole substring matched by
        // the `national_prefix_for_parsing` regular expression.
        // There seem to be no guarantees that it's just a national prefix.
        // For example, if there's a carrier code, it's gonna be a
        // part of `prefixBeforeNationalNumber` too.
        var prefixBeforeNationalNumber = prefixMatch[0];
        nationalNumber = number.slice(prefixBeforeNationalNumber.length); // If there's at least one captured group,
        // then carrier code is the first one.

        if (hasCapturedGroups) {
          carrierCode = prefixMatch[1];
        }
      } // Tries to guess whether a national prefix was present in the input.
      // This is not something copy-pasted from Google's library:
      // they don't seem to have an equivalent for that.
      // So this isn't an "officially approved" way of doing something like that.
      // But since there seems no other existing method, this library uses it.


      var nationalPrefix;

      if (hasCapturedGroups) {
        var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
        var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup); // Example: an Argentinian (AR) phone number `0111523456789`.
        // `prefixMatch[0]` is `01115`, and `$1` is `11`,
        // and the rest of the phone number is `23456789`.
        // The national number is transformed via `9$1` to `91123456789`.
        // National prefix `0` is detected being present at the start.
        // if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {

        if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {
          nationalPrefix = metadata.numberingPlan.nationalPrefix();
        }
      } else {
        nationalPrefix = prefixMatch[0];
      }

      return {
        nationalNumber: nationalNumber,
        nationalPrefix: nationalPrefix,
        carrierCode: carrierCode
      };
    }
  }

  return {
    nationalNumber: number
  };
}

/**
 * Strips national prefix and carrier code from a complete phone number.
 * The difference from the non-"FromCompleteNumber" function is that
 * it won't extract national prefix if the resultant number is too short
 * to be a complete number for the selected phone numbering plan.
 * @param  {string} number — Complete phone number digits.
 * @param  {Metadata} metadata — Metadata with a phone numbering plan selected.
 * @return {object} `{ nationalNumber: string, carrierCode: string? }`.
 */

function extractNationalNumber(number, metadata) {
  // Parsing national prefixes and carrier codes
  // is only required for local phone numbers
  // but some people don't understand that
  // and sometimes write international phone numbers
  // with national prefixes (or maybe even carrier codes).
  // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html
  // Google's original library forgives such mistakes
  // and so does this library, because it has been requested:
  // https://github.com/catamphetamine/libphonenumber-js/issues/127
  var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(number, metadata),
      carrierCode = _extractNationalNumbe.carrierCode,
      nationalNumber = _extractNationalNumbe.nationalNumber;

  if (nationalNumber !== number) {
    if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {
      // Don't strip the national prefix.
      return {
        nationalNumber: number
      };
    } // Check the national (significant) number length after extracting national prefix and carrier code.
    // Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature.


    if (metadata.possibleLengths()) {
      // The number remaining after stripping the national prefix and carrier code
      // should be long enough to have a possible length for the country.
      // Otherwise, don't strip the national prefix and carrier code,
      // since the original number could be a valid number.
      // This check has been copy-pasted "as is" from Google's original library:
      // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250
      // It doesn't check for the "possibility" of the original `number`.
      // I guess it's fine not checking that one. It works as is anyway.
      if (!isPossibleIncompleteNationalNumber(nationalNumber, metadata)) {
        // Don't strip the national prefix.
        return {
          nationalNumber: number
        };
      }
    }
  }

  return {
    nationalNumber: nationalNumber,
    carrierCode: carrierCode
  };
} // In some countries, the same digit could be a national prefix
// or a leading digit of a valid phone number.
// For example, in Russia, national prefix is `8`,
// and also `800 555 35 35` is a valid number
// in which `8` is not a national prefix, but the first digit
// of a national (significant) number.
// Same's with Belarus:
// `82004910060` is a valid national (significant) number,
// but `2004910060` is not.
// To support such cases (to prevent the code from always stripping
// national prefix), a condition is imposed: a national prefix
// is not extracted when the original number is "viable" and the
// resultant number is not, a "viable" national number being the one
// that matches `national_number_pattern`.

function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {
  // The equivalent in Google's code is:
  // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004
  if (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) && !matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {
    return false;
  } // This "is possible" national number (length) check has been commented out
  // because it's superceded by the (effectively) same check done in the
  // `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.
  // In other words, why run the same check twice if it could only be run once.
  // // Check the national (significant) number length after extracting national prefix and carrier code.
  // // Fixes a minor "weird behavior" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57
  // // (Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature).
  // if (metadata.possibleLengths()) {
  // 	if (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&
  // 		!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {
  // 		return false
  // 	}
  // }


  return true;
}

function isPossibleIncompleteNationalNumber(nationalNumber, metadata) {
  switch (checkNumberLength(nationalNumber, metadata)) {
    case 'TOO_SHORT':
    case 'INVALID_LENGTH':
      // This library ignores "local-only" phone numbers (for simplicity).
      // See the readme for more info on what are "local-only" phone numbers.
      // case 'IS_POSSIBLE_LOCAL_ONLY':
      return false;

    default:
      return true;
  }
}

/**
 * Sometimes some people incorrectly input international phone numbers
 * without the leading `+`. This function corrects such input.
 * @param  {string} number — Phone number digits.
 * @param  {string?} country
 * @param  {string?} callingCode
 * @param  {object} metadata
 * @return {object} `{ countryCallingCode: string?, number: string }`.
 */

function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata) {
  var countryCallingCode = country ? getCountryCallingCode(country, metadata) : callingCode;

  if (number.indexOf(countryCallingCode) === 0) {
    metadata = new Metadata(metadata);
    metadata.selectNumberingPlan(country, callingCode);
    var possibleShorterNumber = number.slice(countryCallingCode.length);

    var _extractNationalNumbe = extractNationalNumber(possibleShorterNumber, metadata),
        possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;

    var _extractNationalNumbe2 = extractNationalNumber(number, metadata),
        nationalNumber = _extractNationalNumbe2.nationalNumber; // If the number was not valid before but is valid now,
    // or if it was too long before, we consider the number
    // with the country calling code stripped to be a better result
    // and keep that instead.
    // For example, in Germany (+49), `49` is a valid area code,
    // so if a number starts with `49`, it could be both a valid
    // national German number or an international number without
    // a leading `+`.


    if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) && matchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || checkNumberLength(nationalNumber, metadata) === 'TOO_LONG') {
      return {
        countryCallingCode: countryCallingCode,
        number: possibleShorterNumber
      };
    }
  }

  return {
    number: number
  };
}

/**
 * Converts a phone number digits (possibly with a `+`)
 * into a calling code and the rest phone number digits.
 * The "rest phone number digits" could include
 * a national prefix, carrier code, and national
 * (significant) number.
 * @param  {string} number — Phone number digits (possibly with a `+`).
 * @param  {string} [country] — Default country.
 * @param  {string} [callingCode] — Default calling code (some phone numbering plans are non-geographic).
 * @param  {object} metadata
 * @return {object} `{ countryCallingCodeSource: string?, countryCallingCode: string?, number: string }`
 * @example
 * // Returns `{ countryCallingCode: "1", number: "2133734253" }`.
 * extractCountryCallingCode('2133734253', 'US', null, metadata)
 * extractCountryCallingCode('2133734253', null, '1', metadata)
 * extractCountryCallingCode('+12133734253', null, null, metadata)
 * extractCountryCallingCode('+12133734253', 'RU', null, metadata)
 */

function extractCountryCallingCode(number, country, callingCode, metadata) {
  if (!number) {
    return {};
  }

  var isNumberWithIddPrefix; // If this is not an international phone number,
  // then either extract an "IDD" prefix, or extract a
  // country calling code from a number by autocorrecting it
  // by prepending a leading `+` in cases when it starts
  // with the country calling code.
  // https://wikitravel.org/en/International_dialling_prefix
  // https://github.com/catamphetamine/libphonenumber-js/issues/376

  if (number[0] !== '+') {
    // Convert an "out-of-country" dialing phone number
    // to a proper international phone number.
    var numberWithoutIDD = stripIddPrefix(number, country, callingCode, metadata); // If an IDD prefix was stripped then
    // convert the number to international one
    // for subsequent parsing.

    if (numberWithoutIDD && numberWithoutIDD !== number) {
      isNumberWithIddPrefix = true;
      number = '+' + numberWithoutIDD;
    } else {
      // Check to see if the number starts with the country calling code
      // for the default country. If so, we remove the country calling code,
      // and do some checks on the validity of the number before and after.
      // https://github.com/catamphetamine/libphonenumber-js/issues/376
      if (country || callingCode) {
        var _extractCountryCallin = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata),
            countryCallingCode = _extractCountryCallin.countryCallingCode,
            shorterNumber = _extractCountryCallin.number;

        if (countryCallingCode) {
          return {
            countryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',
            countryCallingCode: countryCallingCode,
            number: shorterNumber
          };
        }
      }

      return {
        // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
        // countryCallingCodeSource: 'UNSPECIFIED',
        number: number
      };
    }
  } // Fast abortion: country codes do not begin with a '0'


  if (number[1] === '0') {
    return {};
  }

  metadata = new Metadata(metadata); // The thing with country phone codes
  // is that they are orthogonal to each other
  // i.e. there's no such country phone code A
  // for which country phone code B exists
  // where B starts with A.
  // Therefore, while scanning digits,
  // if a valid country code is found,
  // that means that it is the country code.
  //

  var i = 2;

  while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {
    var _countryCallingCode = number.slice(1, i);

    if (metadata.hasCallingCode(_countryCallingCode)) {
      metadata.selectNumberingPlan(_countryCallingCode);
      return {
        countryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',
        countryCallingCode: _countryCallingCode,
        number: number.slice(i)
      };
    }

    i++;
  }

  return {};
} // The possible values for the returned `countryCallingCodeSource` are:
//
// Copy-pasted from:
// https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto
//
// // The source from which the country_code is derived. This is not set in the
// // general parsing method, but in the method that parses and keeps raw_input.
// // New fields could be added upon request.
// enum CountryCodeSource {
//  // Default value returned if this is not set, because the phone number was
//  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will
//  // return false if this is the case.
//  UNSPECIFIED = 0;
//
//  // The country_code is derived based on a phone number with a leading "+",
//  // e.g. the French number "+33 1 42 68 53 00".
//  FROM_NUMBER_WITH_PLUS_SIGN = 1;
//
//  // The country_code is derived based on a phone number with a leading IDD,
//  // e.g. the French number "011 33 1 42 68 53 00", as it is dialled from US.
//  FROM_NUMBER_WITH_IDD = 5;
//
//  // The country_code is derived based on a phone number without a leading
//  // "+", e.g. the French number "33 1 42 68 53 00" when defaultCountry is
//  // supplied as France.
//  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;
//
//  // The country_code is derived NOT based on the phone number itself, but
//  // from the defaultCountry parameter provided in the parsing function by the
//  // clients. This happens mostly for numbers written in the national format
//  // (without country code). For example, this would be set when parsing the
//  // French number "01 42 68 53 00", when defaultCountry is supplied as
//  // France.
//  FROM_DEFAULT_COUNTRY = 20;
// }

//
// E.g. "(999) 111-22-33" -> "999 111 22 33"
//
// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.
// Meanwhile, there's no single opinion about using punctuation in international phone numbers.
//
// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.
// And here's a quote from WikiPedia's "North American Numbering Plan" page:
// https://en.wikipedia.org/wiki/North_American_Numbering_Plan
//
// "The country calling code for all countries participating in the NANP is 1.
// In international format, an NANP number should be listed as +1 301 555 01 00,
// where 301 is an area code (Maryland)."
//
// I personally prefer the international format without any punctuation.
// For example, brackets are remnants of the old age, meaning that the
// phone number part in brackets (so called "area code") can be omitted
// if dialing within the same "area".
// And hyphens were clearly introduced for splitting local numbers into memorizable groups.
// For example, remembering "5553535" is difficult but "555-35-35" is much simpler.
// Imagine a man taking a bus from home to work and seeing an ad with a phone number.
// He has a couple of seconds to memorize that number until it passes by.
// If it were spaces instead of hyphens the man wouldn't necessarily get it,
// but with hyphens instead of spaces the grouping is more explicit.
// I personally think that hyphens introduce visual clutter,
// so I prefer replacing them with spaces in international numbers.
// In the modern age all output is done on displays where spaces are clearly distinguishable
// so hyphens can be safely replaced with spaces without losing any legibility.
//

function applyInternationalSeparatorStyle(formattedNumber) {
  return formattedNumber.replace(new RegExp("[".concat(VALID_PUNCTUATION, "]+"), 'g'), ' ').trim();
}

// first group is not used in the national pattern (e.g. Argentina) so the $1
// group does not match correctly. Therefore, we use `\d`, so that the first
// group actually used in the pattern will be matched.

var FIRST_GROUP_PATTERN = /(\$\d)/;
function formatNationalNumberUsingFormat(number, format, _ref) {
  var useInternationalFormat = _ref.useInternationalFormat,
      withNationalPrefix = _ref.withNationalPrefix;
  var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() : // This library doesn't use `domestic_carrier_code_formatting_rule`,
  // because that one is only used when formatting phone numbers
  // for dialing from a mobile phone, and this is not a dialing library.
  // carrierCode && format.domesticCarrierCodeFormattingRule()
  // 	// First, replace the $CC in the formatting rule with the desired carrier code.
  // 	// Then, replace the $FG in the formatting rule with the first group
  // 	// and the carrier code combined in the appropriate way.
  // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
  // 	: (
  // 		withNationalPrefix && format.nationalPrefixFormattingRule()
  // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
  // 			: format.format()
  // 	)
  withNationalPrefix && format.nationalPrefixFormattingRule() ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());

  if (useInternationalFormat) {
    return applyInternationalSeparatorStyle(formattedNumber);
  }

  return formattedNumber;
}

/**
 * Pattern that makes it easy to distinguish whether a region has a single
 * international dialing prefix or not. If a region has a single international
 * prefix (e.g. 011 in USA), it will be represented as a string that contains
 * a sequence of ASCII digits, and possibly a tilde, which signals waiting for
 * the tone. If there are multiple available international prefixes in a
 * region, they will be represented as a regex string that always contains one
 * or more characters that are not ASCII digits or a tilde.
 */

var SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/; // For regions that have multiple IDD prefixes
// a preferred IDD prefix is returned.

function getIddPrefix(country, callingCode, metadata) {
  var countryMetadata = new Metadata(metadata);
  countryMetadata.selectNumberingPlan(country, callingCode);

  if (countryMetadata.defaultIDDPrefix()) {
    return countryMetadata.defaultIDDPrefix();
  }

  if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {
    return countryMetadata.IDDPrefix();
  }
}

var RFC3966_EXTN_PREFIX = ';ext=';
/**
 * Helper method for constructing regular expressions for parsing. Creates
 * an expression that captures up to max_length digits.
 * @return {string} RegEx pattern to capture extension digits.
 */

var getExtensionDigitsPattern = function getExtensionDigitsPattern(maxLength) {
  return "([".concat(VALID_DIGITS, "]{1,").concat(maxLength, "})");
};
/**
 * Helper initialiser method to create the regular-expression pattern to match
 * extensions.
 * Copy-pasted from Google's `libphonenumber`:
 * https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766
 * @return {string} RegEx pattern to capture extensions.
 */


function createExtensionPattern(purpose) {
  // We cap the maximum length of an extension based on the ambiguity of the way
  // the extension is prefixed. As per ITU, the officially allowed length for
  // extensions is actually 40, but we don't support this since we haven't seen real
  // examples and this introduces many false interpretations as the extension labels
  // are not standardized.

  /** @type {string} */
  var extLimitAfterExplicitLabel = '20';
  /** @type {string} */

  var extLimitAfterLikelyLabel = '15';
  /** @type {string} */

  var extLimitAfterAmbiguousChar = '9';
  /** @type {string} */

  var extLimitWhenNotSure = '6';
  /** @type {string} */

  var possibleSeparatorsBetweenNumberAndExtLabel = "[ \xA0\\t,]*"; // Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.

  /** @type {string} */

  var possibleCharsAfterExtLabel = "[:\\.\uFF0E]?[ \xA0\\t,-]*";
  /** @type {string} */

  var optionalExtnSuffix = "#?"; // Here the extension is called out in more explicit way, i.e mentioning it obvious
  // patterns like "ext.".

  /** @type {string} */

  var explicitExtLabels = "(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|\u0434\u043E\u0431|anexo)"; // One-character symbols that can be used to indicate an extension, and less
  // commonly used or more ambiguous extension labels.

  /** @type {string} */

  var ambiguousExtLabels = "(?:[x\uFF58#\uFF03~\uFF5E]|int|\uFF49\uFF4E\uFF54)"; // When extension is not separated clearly.

  /** @type {string} */

  var ambiguousSeparator = "[- ]+"; // This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching
  // comma as extension label may have it.

  /** @type {string} */

  var possibleSeparatorsNumberExtLabelNoComma = "[ \xA0\\t]*"; // ",," is commonly used for auto dialling the extension when connected. First
  // comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do
  // not repeat it here. Semi-colon works in Iphone and Android also to pop up a
  // button with the extension number following.

  /** @type {string} */

  var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";
  /** @type {string} */

  var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
  /** @type {string} */

  var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
  /** @type {string} */

  var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
  /** @type {string} */

  var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";
  /** @type {string} */

  var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
  /** @type {string} */

  var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix; // The first regular expression covers RFC 3966 format, where the extension is added
  // using ";ext=". The second more generic where extension is mentioned with explicit
  // labels like "ext:". In both the above cases we allow more numbers in extension than
  // any other extension labels. The third one captures when single character extension
  // labels or less commonly used labels are used. In such cases we capture fewer
  // extension digits in order to reduce the chance of falsely interpreting two
  // numbers beside each other as a number + extension. The fourth one covers the
  // special case of American numbers where the extension is written with a hash
  // at the end, such as "- 503#". The fifth one is exclusively for extension
  // autodialling formats which are used when dialling and in this case we accept longer
  // extensions. The last one is more liberal on the number of commas that acts as
  // extension labels, so we have a strict cap on the number of digits in such extensions.

  return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
}

//  Checks we have at least three leading digits, and only valid punctuation,
//  alpha characters and digits in the phone number. Does not include extension
//  data. The symbol 'x' is allowed here as valid punctuation since it is often
//  used as a placeholder for carrier codes, for example in Brazilian phone
//  numbers. We also allow multiple '+' characters at the start.
//
//  Corresponds to the following:
//  [digits]{minLengthNsn}|
//  plus_sign*
//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*
//
//  The first reg-ex is to allow short numbers (two digits long) to be parsed if
//  they are entered as "15" etc, but only if there is no punctuation in them.
//  The second expression restricts the number of digits to three or more, but
//  then allows them to be in international form, and to have alpha-characters
//  and punctuation. We split up the two reg-exes here and combine them when
//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it
//  with ^ and append $ to each branch.
//
//  "Note VALID_PUNCTUATION starts with a -,
//   so must be the first in the range" (c) Google devs.
//  (wtf did they mean by saying that; probably nothing)
//

var MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'; //
// And this is the second reg-exp:
// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)
//

var VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*'; // This regular expression isn't present in Google's `libphonenumber`
// and is only used to determine whether the phone number being input
// is too short for it to even consider it a "valid" number.
// This is just a way to differentiate between a really invalid phone
// number like "abcde" and a valid phone number that a user has just
// started inputting, like "+1" or "1": both these cases would be
// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
// library can provide a more detailed error message — whether it's
// really "not a number", or is it just a start of a valid phone number.

var VALID_PHONE_NUMBER_START_REG_EXP = new RegExp('^' + '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){1,2}' + '$', 'i');
var VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER + // Phone number extensions
'(?:' + createExtensionPattern() + ')?'; // The combined regular expression for valid phone numbers:
//

var VALID_PHONE_NUMBER_PATTERN = new RegExp( // Either a short two-digit-only phone number
'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' + // Or a longer fully parsed phone number (min 3 characters)
'^' + VALID_PHONE_NUMBER_WITH_EXTENSION + '$', 'i'); // Checks to see if the string of characters could possibly be a phone number at
// all. At the moment, checks to see that the string begins with at least 2
// digits, ignoring any punctuation commonly found in phone numbers. This method
// does not require the number to be normalized in advance - but does assume
// that leading non-number symbols have been removed, such as by the method
// `extract_possible_number`.
//

function isViablePhoneNumber(number) {
  return number.length >= MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
} // This is just a way to differentiate between a really invalid phone
// number like "abcde" and a valid phone number that a user has just
// started inputting, like "+1" or "1": both these cases would be
// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
// library can provide a more detailed error message — whether it's
// really "not a number", or is it just a start of a valid phone number.

function isViablePhoneNumberStart(number) {
  return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
}

/**
 * @param  {object} - `{ ?number, ?extension }`.
 * @return {string} Phone URI (RFC 3966).
 */

function formatRFC3966(_ref) {
  var number = _ref.number,
      ext = _ref.ext;

  if (!number) {
    return '';
  }

  if (number[0] !== '+') {
    throw new Error("\"formatRFC3966()\" expects \"number\" to be in E.164 format.");
  }

  return "tel:".concat(number).concat(ext ? ';ext=' + ext : '');
}

function _createForOfIteratorHelperLoose$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$4(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DEFAULT_OPTIONS = {
  formatExtension: function formatExtension(formattedNumber, extension, metadata) {
    return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
  }
};
/**
 * Formats a phone number.
 *
 * format(phoneNumberInstance, 'INTERNATIONAL', { ..., v2: true }, metadata)
 * format(phoneNumberInstance, 'NATIONAL', { ..., v2: true }, metadata)
 *
 * format({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', { ... }, metadata)
 * format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', undefined, metadata)
 *
 * @param  {object|PhoneNumber} input — If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.
 * @param  {string} format
 * @param  {object} [options]
 * @param  {object} metadata
 * @return {string}
 */

function formatNumber$1(input, format, options, metadata) {
  // Apply default options.
  if (options) {
    options = _objectSpread$4(_objectSpread$4({}, DEFAULT_OPTIONS), options);
  } else {
    options = DEFAULT_OPTIONS;
  }

  metadata = new Metadata(metadata);

  if (input.country && input.country !== '001') {
    // Validate `input.country`.
    if (!metadata.hasCountry(input.country)) {
      throw new Error("Unknown country: ".concat(input.country));
    }

    metadata.country(input.country);
  } else if (input.countryCallingCode) {
    metadata.selectNumberingPlan(input.countryCallingCode);
  } else return input.phone || '';

  var countryCallingCode = metadata.countryCallingCode();
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // This variable should have been declared inside `case`s
  // but Babel has a bug and it says "duplicate variable declaration".

  var number;

  switch (format) {
    case 'NATIONAL':
      // Legacy argument support.
      // (`{ country: ..., phone: '' }`)
      if (!nationalNumber) {
        return '';
      }

      number = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options);
      return addExtension(number, input.ext, metadata, options.formatExtension);

    case 'INTERNATIONAL':
      // Legacy argument support.
      // (`{ country: ..., phone: '' }`)
      if (!nationalNumber) {
        return "+".concat(countryCallingCode);
      }

      number = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options);
      number = "+".concat(countryCallingCode, " ").concat(number);
      return addExtension(number, input.ext, metadata, options.formatExtension);

    case 'E.164':
      // `E.164` doesn't define "phone number extensions".
      return "+".concat(countryCallingCode).concat(nationalNumber);

    case 'RFC3966':
      return formatRFC3966({
        number: "+".concat(countryCallingCode).concat(nationalNumber),
        ext: input.ext
      });
    // For reference, here's Google's IDD formatter:
    // https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546
    // Not saying that this IDD formatter replicates it 1:1, but it seems to work.
    // Who would even need to format phone numbers in IDD format anyway?

    case 'IDD':
      if (!options.fromCountry) {
        return; // throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')
      }

      var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata);
      return addExtension(formattedNumber, input.ext, metadata, options.formatExtension);

    default:
      throw new Error("Unknown \"format\" argument passed to \"formatNumber()\": \"".concat(format, "\""));
  }
}

function formatNationalNumber(number, carrierCode, formatAs, metadata, options) {
  var format = chooseFormatForNumber(metadata.formats(), number);

  if (!format) {
    return number;
  }

  return formatNationalNumberUsingFormat(number, format, {
    useInternationalFormat: formatAs === 'INTERNATIONAL',
    withNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true});
}

function chooseFormatForNumber(availableFormats, nationalNnumber) {
  for (var _iterator = _createForOfIteratorHelperLoose$2(availableFormats), _step; !(_step = _iterator()).done;) {
    var format = _step.value;

    // Validate leading digits.
    // The test case for "else path" could be found by searching for
    // "format.leadingDigitsPatterns().length === 0".
    if (format.leadingDigitsPatterns().length > 0) {
      // The last leading_digits_pattern is used here, as it is the most detailed
      var lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]; // If leading digits don't match then move on to the next phone number format

      if (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) {
        continue;
      }
    } // Check that the national number matches the phone number format regular expression


    if (matchesEntirely(nationalNnumber, format.pattern())) {
      return format;
    }
  }
}

function addExtension(formattedNumber, ext, metadata, formatExtension) {
  return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
}

function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata) {
  var fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata.metadata); // When calling within the same country calling code.

  if (fromCountryCallingCode === countryCallingCode) {
    var formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata); // For NANPA regions, return the national format for these regions
    // but prefix it with the country calling code.

    if (countryCallingCode === '1') {
      return countryCallingCode + ' ' + formattedNumber;
    } // If regions share a country calling code, the country calling code need
    // not be dialled. This also applies when dialling within a region, so this
    // if clause covers both these cases. Technically this is the case for
    // dialling from La Reunion to other overseas departments of France (French
    // Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover
    // this edge case for now and for those cases return the version including
    // country calling code. Details here:
    // http://www.petitfute.com/voyage/225-info-pratiques-reunion
    //


    return formattedNumber;
  }

  var iddPrefix = getIddPrefix(fromCountry, undefined, metadata.metadata);

  if (iddPrefix) {
    return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata));
  }
}

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$3(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var PhoneNumber = /*#__PURE__*/function () {
  /**
   * @param  {string} countryOrCountryCallingCode
   * @param  {string} nationalNumber
   * @param  {object} metadata — Metadata JSON
   * @return {PhoneNumber}
   */
  function PhoneNumber(countryOrCountryCallingCode, nationalNumber, metadata) {
    _classCallCheck$1(this, PhoneNumber);

    // Validate `countryOrCountryCallingCode` argument.
    if (!countryOrCountryCallingCode) {
      throw new TypeError('First argument is required');
    }

    if (typeof countryOrCountryCallingCode !== 'string') {
      throw new TypeError('First argument must be a string');
    } // In case of public API use: `constructor(number, metadata)`.
    // Transform the arguments from `constructor(number, metadata)` to
    // `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.


    if (typeof countryOrCountryCallingCode === 'string') {
      if (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {
        throw new TypeError('`metadata` argument not passed');
      }

      if (isObject$1(nationalNumber) && isObject$1(nationalNumber.countries)) {
        metadata = nationalNumber;
        var e164Number = countryOrCountryCallingCode;

        if (!E164_NUMBER_REGEXP.test(e164Number)) {
          throw new Error('Invalid `number` argument passed: must consist of a "+" followed by digits');
        }

        var _extractCountryCallin = extractCountryCallingCode(e164Number, undefined, undefined, metadata),
            _countryCallingCode = _extractCountryCallin.countryCallingCode,
            number = _extractCountryCallin.number;

        nationalNumber = number;
        countryOrCountryCallingCode = _countryCallingCode;

        if (!nationalNumber) {
          throw new Error('Invalid `number` argument passed: too short');
        }
      }
    } // Validate `nationalNumber` argument.


    if (!nationalNumber) {
      throw new TypeError('`nationalNumber` argument is required');
    }

    if (typeof nationalNumber !== 'string') {
      throw new TypeError('`nationalNumber` argument must be a string');
    } // Validate `metadata` argument.


    validateMetadata(metadata); // Initialize properties.

    var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata),
        country = _getCountryAndCountry.country,
        countryCallingCode = _getCountryAndCountry.countryCallingCode;

    this.country = country;
    this.countryCallingCode = countryCallingCode;
    this.nationalNumber = nationalNumber;
    this.number = '+' + this.countryCallingCode + this.nationalNumber; // Exclude `metadata` property output from `PhoneNumber.toString()`
    // so that it doesn't clutter the console output of Node.js.
    // Previously, when Node.js did `console.log(new PhoneNumber(...))`,
    // it would output the whole internal structure of the `metadata` object.

    this.getMetadata = function () {
      return metadata;
    };
  }

  _createClass$1(PhoneNumber, [{
    key: "setExt",
    value: function setExt(ext) {
      this.ext = ext;
    }
  }, {
    key: "getPossibleCountries",
    value: function getPossibleCountries() {
      if (this.country) {
        return [this.country];
      }

      return getPossibleCountriesForNumber(this.countryCallingCode, this.nationalNumber, this.getMetadata());
    }
  }, {
    key: "isPossible",
    value: function isPossible() {
      return isPossiblePhoneNumber(this, {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "isValid",
    value: function isValid() {
      return isValidNumber(this, {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "isNonGeographic",
    value: function isNonGeographic() {
      var metadata = new Metadata(this.getMetadata());
      return metadata.isNonGeographicCallingCode(this.countryCallingCode);
    }
  }, {
    key: "isEqual",
    value: function isEqual(phoneNumber) {
      return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
    } // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
    // but later it was found out that it doesn't include the possible `TOO_SHORT` result
    // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
    // so eventually I simply commented out this method from the `PhoneNumber` class
    // and just left the `validatePhoneNumberLength()` function, even though that one would require
    // and additional step to also validate the actual country / calling code of the phone number.
    // validateLength() {
    // 	const metadata = new Metadata(this.getMetadata())
    // 	metadata.selectNumberingPlan(this.countryCallingCode)
    // 	const result = checkNumberLength(this.nationalNumber, metadata)
    // 	if (result !== 'IS_POSSIBLE') {
    // 		return result
    // 	}
    // }

  }, {
    key: "getType",
    value: function getType() {
      return getNumberType(this, {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "format",
    value: function format(_format, options) {
      return formatNumber$1(this, _format, options ? _objectSpread$3(_objectSpread$3({}, options), {}, {
        v2: true
      }) : {
        v2: true
      }, this.getMetadata());
    }
  }, {
    key: "formatNational",
    value: function formatNational(options) {
      return this.format('NATIONAL', options);
    }
  }, {
    key: "formatInternational",
    value: function formatInternational(options) {
      return this.format('INTERNATIONAL', options);
    }
  }, {
    key: "getURI",
    value: function getURI(options) {
      return this.format('RFC3966', options);
    }
  }]);

  return PhoneNumber;
}();

var isCountryCode = function isCountryCode(value) {
  return /^[A-Z]{2}$/.test(value);
};

function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
  var country;
  var countryCallingCode;
  var metadata = new Metadata(metadataJson); // If country code is passed then derive `countryCallingCode` from it.
  // Also store the country code as `.country`.

  if (isCountryCode(countryOrCountryCallingCode)) {
    country = countryOrCountryCallingCode;
    metadata.selectNumberingPlan(country);
    countryCallingCode = metadata.countryCallingCode();
  } else {
    countryCallingCode = countryOrCountryCallingCode;
  }

  return {
    country: country,
    countryCallingCode: countryCallingCode
  };
}

var E164_NUMBER_REGEXP = /^\+\d+$/;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createClass(Constructor, protoProps, staticProps) { Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// https://stackoverflow.com/a/46971044/970769
// "Breaking changes in Typescript 2.1"
// "Extending built-ins like Error, Array, and Map may no longer work."
// "As a recommendation, you can manually adjust the prototype immediately after any super(...) calls."
// https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
var ParseError = /*#__PURE__*/function (_Error) {
  _inherits(ParseError, _Error);

  var _super = _createSuper(ParseError);

  function ParseError(code) {
    var _this;

    _classCallCheck(this, ParseError);

    _this = _super.call(this, code); // Set the prototype explicitly.
    // Any subclass of FooError will have to manually set the prototype as well.

    Object.setPrototypeOf(_assertThisInitialized(_this), ParseError.prototype);
    _this.name = _this.constructor.name;
    return _this;
  }

  return _createClass(ParseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

// 1 or more valid digits, for use when parsing.

var EXTN_PATTERN = new RegExp('(?:' + createExtensionPattern() + ')$', 'i'); // Strips any extension (as in, the part of the number dialled after the call is
// connected, usually indicated with extn, ext, x or similar) from the end of
// the number, and returns it.

function extractExtension(number) {
  var start = number.search(EXTN_PATTERN);

  if (start < 0) {
    return {};
  } // If we find a potential extension, and the number preceding this is a viable
  // number, we assume it is an extension.


  var numberWithoutExtension = number.slice(0, start);
  var matches = number.match(EXTN_PATTERN);
  var i = 1;

  while (i < matches.length) {
    if (matches[i]) {
      return {
        number: numberWithoutExtension,
        ext: matches[i]
      };
    }

    i++;
  }
}

// These mappings map a character (key) to a specific digit that should
// replace it for normalization purposes. Non-European digits that
// may be used in phone numbers are mapped to a European equivalent.
//
// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.
//
var DIGITS = {
  '0': '0',
  '1': '1',
  '2': '2',
  '3': '3',
  '4': '4',
  '5': '5',
  '6': '6',
  '7': '7',
  '8': '8',
  '9': '9',
  "\uFF10": '0',
  // Fullwidth digit 0
  "\uFF11": '1',
  // Fullwidth digit 1
  "\uFF12": '2',
  // Fullwidth digit 2
  "\uFF13": '3',
  // Fullwidth digit 3
  "\uFF14": '4',
  // Fullwidth digit 4
  "\uFF15": '5',
  // Fullwidth digit 5
  "\uFF16": '6',
  // Fullwidth digit 6
  "\uFF17": '7',
  // Fullwidth digit 7
  "\uFF18": '8',
  // Fullwidth digit 8
  "\uFF19": '9',
  // Fullwidth digit 9
  "\u0660": '0',
  // Arabic-indic digit 0
  "\u0661": '1',
  // Arabic-indic digit 1
  "\u0662": '2',
  // Arabic-indic digit 2
  "\u0663": '3',
  // Arabic-indic digit 3
  "\u0664": '4',
  // Arabic-indic digit 4
  "\u0665": '5',
  // Arabic-indic digit 5
  "\u0666": '6',
  // Arabic-indic digit 6
  "\u0667": '7',
  // Arabic-indic digit 7
  "\u0668": '8',
  // Arabic-indic digit 8
  "\u0669": '9',
  // Arabic-indic digit 9
  "\u06F0": '0',
  // Eastern-Arabic digit 0
  "\u06F1": '1',
  // Eastern-Arabic digit 1
  "\u06F2": '2',
  // Eastern-Arabic digit 2
  "\u06F3": '3',
  // Eastern-Arabic digit 3
  "\u06F4": '4',
  // Eastern-Arabic digit 4
  "\u06F5": '5',
  // Eastern-Arabic digit 5
  "\u06F6": '6',
  // Eastern-Arabic digit 6
  "\u06F7": '7',
  // Eastern-Arabic digit 7
  "\u06F8": '8',
  // Eastern-Arabic digit 8
  "\u06F9": '9' // Eastern-Arabic digit 9

};
function parseDigit(character) {
  return DIGITS[character];
}

function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Parses phone number characters from a string.
 * Drops all punctuation leaving only digits and the leading `+` sign (if any).
 * Also converts wide-ascii and arabic-indic numerals to conventional numerals.
 * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.
 * @param  {string} string
 * @return {string}
 * @example
 * ```js
 * // Outputs '8800555'.
 * parseIncompletePhoneNumber('8 (800) 555')
 * // Outputs '+7800555'.
 * parseIncompletePhoneNumber('+7 800 555')
 * ```
 */

function parseIncompletePhoneNumber(string) {
  var result = ''; // Using `.split('')` here instead of normal `for ... of`
  // because the importing application doesn't neccessarily include an ES6 polyfill.
  // The `.split('')` approach discards "exotic" UTF-8 characters
  // (the ones consisting of four bytes) but digits
  // (including non-European ones) don't fall into that range
  // so such "exotic" characters would be discarded anyway.

  for (var _iterator = _createForOfIteratorHelperLoose$1(string.split('')), _step; !(_step = _iterator()).done;) {
    var character = _step.value;
    result += parsePhoneNumberCharacter(character, result) || '';
  }

  return result;
}
/**
 * Parses next character while parsing phone number digits (including a `+`)
 * from text: discards everything except `+` and digits, and `+` is only allowed
 * at the start of a phone number.
 * For example, is used in `react-phone-number-input` where it uses
 * [`input-format`](https://gitlab.com/catamphetamine/input-format).
 * @param  {string} character - Yet another character from raw input string.
 * @param  {string?} prevParsedCharacters - Previous parsed characters.
 * @param  {function?} emitEvent - An optional "emit event" function.
 * @return {string?} The parsed character.
 */

function parsePhoneNumberCharacter(character, prevParsedCharacters, emitEvent) {
  // Only allow a leading `+`.
  if (character === '+') {
    // If this `+` is not the first parsed character
    // then discard it.
    if (prevParsedCharacters) {

      return;
    }

    return '+';
  } // Allow digits.


  return parseDigit(character);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function getCountryByNationalNumber(nationalPhoneNumber, _ref) {
  var countries = _ref.countries,
      metadata = _ref.metadata;
  // Re-create `metadata` because it will be selecting a `country`.
  metadata = new Metadata(metadata); // const matchingCountries = []

  for (var _iterator = _createForOfIteratorHelperLoose(countries), _step; !(_step = _iterator()).done;) {
    var country = _step.value;
    metadata.country(country); // "Leading digits" patterns are only defined for about 20% of all countries.
    // By definition, matching "leading digits" is a sufficient but not a necessary
    // condition for a phone number to belong to a country.
    // The point of "leading digits" check is that it's the fastest one to get a match.
    // https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits
    // I'd suppose that "leading digits" patterns are mutually exclusive for different countries
    // because of the intended use of that feature.

    if (metadata.leadingDigits()) {
      if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {
        return country;
      }
    } // Else perform full validation with all of those
    // fixed-line/mobile/etc regular expressions.
    else if (getNumberType({
      phone: nationalPhoneNumber,
      country: country
    }, undefined, metadata.metadata)) {
      // If both the `defaultCountry` and the "main" one match the phone number,
      // don't prefer the `defaultCountry` over the "main" one.
      // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/154
      return country; // // If the `defaultCountry` is among the `matchingCountries` then return it.
      // if (defaultCountry) {
      // 	if (country === defaultCountry) {
      // 		return country
      // 	}
      // 	matchingCountries.push(country)
      // } else {
      // 	return country
      // }
    }
  } // // Return the first ("main") one of the `matchingCountries`.
  // if (matchingCountries.length > 0) {
  // 	return matchingCountries[0]
  // }

}

function getCountryByCallingCode(callingCode, _ref) {
  var nationalPhoneNumber = _ref.nationalNumber,
      metadata = _ref.metadata;

  var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);

  if (!possibleCountries) {
    return;
  } // If there's just one country corresponding to the country code,
  // then just return it, without further phone number digits validation.


  if (possibleCountries.length === 1) {
    return possibleCountries[0];
  }

  return getCountryByNationalNumber(nationalPhoneNumber, {
    countries: possibleCountries,
    metadata: metadata.metadata
  });
}

// When phone numbers are written in `RFC3966` format — `"tel:+12133734253"` —
// they can have their "calling code" part written separately in a `phone-context` parameter.
// Example: `"tel:12133734253;phone-context=+1"`.
// This function parses the full phone number from the local number and the `phone-context`
// when the `phone-context` contains a `+` sign.
var PLUS_SIGN = '+';
var RFC3966_VISUAL_SEPARATOR_ = '[\\-\\.\\(\\)]?';
var RFC3966_PHONE_DIGIT_ = '(' + '[' + VALID_DIGITS + ']' + '|' + RFC3966_VISUAL_SEPARATOR_ + ')';
var RFC3966_GLOBAL_NUMBER_DIGITS_ = '^' + '\\' + PLUS_SIGN + RFC3966_PHONE_DIGIT_ + '*' + '[' + VALID_DIGITS + ']' + RFC3966_PHONE_DIGIT_ + '*' + '$';
/**
 * Regular expression of valid global-number-digits for the phone-context
 * parameter, following the syntax defined in RFC3966.
 */

var RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, 'g'); // In this port of Google's library, we don't accept alpha characters in phone numbers.
// const ALPHANUM_ = VALID_ALPHA_ + VALID_DIGITS

var ALPHANUM_ = VALID_DIGITS;
var RFC3966_DOMAINLABEL_ = '[' + ALPHANUM_ + ']+((\\-)*[' + ALPHANUM_ + '])*';
var VALID_ALPHA_ = 'a-zA-Z';
var RFC3966_TOPLABEL_ = '[' + VALID_ALPHA_ + ']+((\\-)*[' + ALPHANUM_ + '])*';
var RFC3966_DOMAINNAME_ = '^(' + RFC3966_DOMAINLABEL_ + '\\.)*' + RFC3966_TOPLABEL_ + '\\.?$';
/**
 * Regular expression of valid domainname for the phone-context parameter,
 * following the syntax defined in RFC3966.
 */

var RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, 'g');
var RFC3966_PREFIX_ = 'tel:';
var RFC3966_PHONE_CONTEXT_ = ';phone-context=';
var RFC3966_ISDN_SUBADDRESS_ = ';isub=';
/**
 * Extracts the value of the phone-context parameter of `numberToExtractFrom`,
 * following the syntax defined in RFC3966.
 *
 * @param {string} numberToExtractFrom
 * @return {string|null} the extracted string (possibly empty), or `null` if no phone-context parameter is found.
 */

function extractPhoneContext(numberToExtractFrom) {
  var indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_); // If no phone-context parameter is present

  if (indexOfPhoneContext < 0) {
    return null;
  }

  var phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length; // If phone-context parameter is empty

  if (phoneContextStart >= numberToExtractFrom.length) {
    return '';
  }

  var phoneContextEnd = numberToExtractFrom.indexOf(';', phoneContextStart); // If phone-context is not the last parameter

  if (phoneContextEnd >= 0) {
    return numberToExtractFrom.substring(phoneContextStart, phoneContextEnd);
  } else {
    return numberToExtractFrom.substring(phoneContextStart);
  }
}
/**
 * Returns whether the value of phoneContext follows the syntax defined in RFC3966.
 *
 * @param {string|null} phoneContext
 * @return {boolean}
 */

function isPhoneContextValid(phoneContext) {
  if (phoneContext === null) {
    return true;
  }

  if (phoneContext.length === 0) {
    return false;
  } // Does phone-context value match pattern of global-number-digits or domainname.


  return RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) || RFC3966_DOMAINNAME_PATTERN_.test(phoneContext);
}

/**
 * @param  {string} numberToParse
 * @param  {string} nationalNumber
 * @return {}
 */

function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, _ref) {
  var extractFormattedPhoneNumber = _ref.extractFormattedPhoneNumber;
  var phoneContext = extractPhoneContext(numberToParse);

  if (!isPhoneContextValid(phoneContext)) {
    throw new ParseError('NOT_A_NUMBER');
  }

  var phoneNumberString;

  if (phoneContext === null) {
    // Extract a possible number from the string passed in.
    // (this strips leading characters that could not be the start of a phone number)
    phoneNumberString = extractFormattedPhoneNumber(numberToParse) || '';
  } else {
    phoneNumberString = ''; // If the phone context contains a phone number prefix, we need to capture
    // it, whereas domains will be ignored.

    if (phoneContext.charAt(0) === PLUS_SIGN) {
      phoneNumberString += phoneContext;
    } // Now append everything between the "tel:" prefix and the phone-context.
    // This should include the national number, an optional extension or
    // isdn-subaddress component. Note we also handle the case when "tel:" is
    // missing, as we have seen in some of the phone number inputs.
    // In that case, we append everything from the beginning.


    var indexOfRfc3966Prefix = numberToParse.indexOf(RFC3966_PREFIX_);
    var indexOfNationalNumber; // RFC 3966 "tel:" prefix is preset at this stage because
    // `isPhoneContextValid()` requires it to be present.

    /* istanbul ignore else */

    if (indexOfRfc3966Prefix >= 0) {
      indexOfNationalNumber = indexOfRfc3966Prefix + RFC3966_PREFIX_.length;
    } else {
      indexOfNationalNumber = 0;
    }

    var indexOfPhoneContext = numberToParse.indexOf(RFC3966_PHONE_CONTEXT_);
    phoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext);
  } // Delete the isdn-subaddress and everything after it if it is present.
  // Note extension won't appear at the same time with isdn-subaddress
  // according to paragraph 5.3 of the RFC3966 spec.


  var indexOfIsdn = phoneNumberString.indexOf(RFC3966_ISDN_SUBADDRESS_);

  if (indexOfIsdn > 0) {
    phoneNumberString = phoneNumberString.substring(0, indexOfIsdn);
  } // If both phone context and isdn-subaddress are absent but other
  // parameters are present, the parameters are left in nationalNumber.
  // This is because we are concerned about deleting content from a potential
  // number string when there is no strong evidence that the number is
  // actually written in RFC3966.


  if (phoneNumberString !== '') {
    return phoneNumberString;
  }
}

// This is a port of Google Android `libphonenumber`'s
// `phonenumberutil.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js
// This prevents malicious input from consuming CPU.

var MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.

var PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.
// A trailing `#` is sometimes used when writing phone numbers with extensions in US.
// Example: "+1 (645) 123 1234-910#" number has extension "910".

var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$');
//
// ```js
// parse('8 (800) 555-35-35', 'RU')
// parse('8 (800) 555-35-35', 'RU', metadata)
// parse('8 (800) 555-35-35', { country: { default: 'RU' } })
// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)
// parse('+7 800 555 35 35')
// parse('+7 800 555 35 35', metadata)
// ```
//

/**
 * Parses a phone number.
 *
 * parse('123456789', { defaultCountry: 'RU', v2: true }, metadata)
 * parse('123456789', { defaultCountry: 'RU' }, metadata)
 * parse('123456789', undefined, metadata)
 *
 * @param  {string} input
 * @param  {object} [options]
 * @param  {object} metadata
 * @return {object|PhoneNumber?} If `options.v2: true` flag is passed, it returns a `PhoneNumber?` instance. Otherwise, returns an object of shape `{ phone: '...', country: '...' }` (or just `{}` if no phone number was parsed).
 */

function parse$1(text, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {};
  metadata = new Metadata(metadata); // Validate `defaultCountry`.

  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
    if (options.v2) {
      throw new ParseError('INVALID_COUNTRY');
    }

    throw new Error("Unknown country: ".concat(options.defaultCountry));
  } // Parse the phone number.


  var _parseInput = parseInput(text, options.v2, options.extract),
      formattedPhoneNumber = _parseInput.number,
      ext = _parseInput.ext,
      error = _parseInput.error; // If the phone number is not viable then return nothing.


  if (!formattedPhoneNumber) {
    if (options.v2) {
      if (error === 'TOO_SHORT') {
        throw new ParseError('TOO_SHORT');
      }

      throw new ParseError('NOT_A_NUMBER');
    }

    return {};
  }

  var _parsePhoneNumber = parsePhoneNumber$3(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),
      country = _parsePhoneNumber.country,
      nationalNumber = _parsePhoneNumber.nationalNumber,
      countryCallingCode = _parsePhoneNumber.countryCallingCode,
      countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource,
      carrierCode = _parsePhoneNumber.carrierCode;

  if (!metadata.hasSelectedNumberingPlan()) {
    if (options.v2) {
      throw new ParseError('INVALID_COUNTRY');
    }

    return {};
  } // Validate national (significant) number length.


  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {
    // Won't throw here because the regexp already demands length > 1.

    /* istanbul ignore if */
    if (options.v2) {
      throw new ParseError('TOO_SHORT');
    } // Google's demo just throws an error in this case.


    return {};
  } // Validate national (significant) number length.
  //
  // A sidenote:
  //
  // They say that sometimes national (significant) numbers
  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).
  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36
  // Such numbers will just be discarded.
  //


  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {
    if (options.v2) {
      throw new ParseError('TOO_LONG');
    } // Google's demo just throws an error in this case.


    return {};
  }

  if (options.v2) {
    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);

    if (country) {
      phoneNumber.country = country;
    }

    if (carrierCode) {
      phoneNumber.carrierCode = carrierCode;
    }

    if (ext) {
      phoneNumber.ext = ext;
    }

    phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;
    return phoneNumber;
  } // Check if national phone number pattern matches the number.
  // National number pattern is different for each country,
  // even for those ones which are part of the "NANPA" group.


  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;

  if (!options.extended) {
    return valid ? result(country, nationalNumber, ext) : {};
  } // isInternational: countryCallingCode !== undefined


  return {
    country: country,
    countryCallingCode: countryCallingCode,
    carrierCode: carrierCode,
    valid: valid,
    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, metadata) ? true : false,
    phone: nationalNumber,
    ext: ext
  };
}
/**
 * Extracts a formatted phone number from text.
 * Doesn't guarantee that the extracted phone number
 * is a valid phone number (for example, doesn't validate its length).
 * @param  {string} text
 * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.
 * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.
 * @return {string}
 * @example
 * // Returns "(213) 373-4253".
 * extractFormattedPhoneNumber("Call (213) 373-4253 for assistance.")
 */

function _extractFormattedPhoneNumber(text, extract, throwOnError) {
  if (!text) {
    return;
  }

  if (text.length > MAX_INPUT_STRING_LENGTH) {
    if (throwOnError) {
      throw new ParseError('TOO_LONG');
    }

    return;
  }

  if (extract === false) {
    return text;
  } // Attempt to extract a possible number from the string passed in


  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);

  if (startsAt < 0) {
    return;
  }

  return text // Trim everything to the left of the phone number
  .slice(startsAt) // Remove trailing non-numerical characters
  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');
}
/**
 * @param  {string} text - Input.
 * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.
 * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.
 * @return {object} `{ ?number, ?ext }`.
 */


function parseInput(text, v2, extract) {
  // // Parse RFC 3966 phone number URI.
  // if (text && text.indexOf('tel:') === 0) {
  // 	return parseRFC3966(text)
  // }
  // let number = extractFormattedPhoneNumber(text, extract, v2)
  var number = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(text, {
    extractFormattedPhoneNumber: function extractFormattedPhoneNumber(text) {
      return _extractFormattedPhoneNumber(text, extract, v2);
    }
  }); // If the phone number is not viable, then abort.

  if (!number) {
    return {};
  }

  if (!isViablePhoneNumber(number)) {
    if (isViablePhoneNumberStart(number)) {
      return {
        error: 'TOO_SHORT'
      };
    }

    return {};
  } // Attempt to parse extension first, since it doesn't require region-specific
  // data and we want to have the non-normalised number here.


  var withExtensionStripped = extractExtension(number);

  if (withExtensionStripped.ext) {
    return withExtensionStripped;
  }

  return {
    number: number
  };
}
/**
 * Creates `parse()` result object.
 */


function result(country, nationalNumber, ext) {
  var result = {
    country: country,
    phone: nationalNumber
  };

  if (ext) {
    result.ext = ext;
  }

  return result;
}
/**
 * Parses a viable phone number.
 * @param {string} formattedPhoneNumber — Example: "(213) 373-4253".
 * @param {string} [defaultCountry]
 * @param {string} [defaultCallingCode]
 * @param {Metadata} metadata
 * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.
 */


function parsePhoneNumber$3(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {
  // Extract calling code from phone number.
  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),
      countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource,
      countryCallingCode = _extractCountryCallin.countryCallingCode,
      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.


  var country;

  if (countryCallingCode) {
    metadata.selectNumberingPlan(countryCallingCode);
  } // If `formattedPhoneNumber` is passed in "national" format
  // then `number` is defined and `countryCallingCode` is `undefined`.
  else if (number && (defaultCountry || defaultCallingCode)) {
    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);

    if (defaultCountry) {
      country = defaultCountry;
    }

    countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);
  } else return {};

  if (!number) {
    return {
      countryCallingCodeSource: countryCallingCodeSource,
      countryCallingCode: countryCallingCode
    };
  }

  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata),
      nationalNumber = _extractNationalNumbe.nationalNumber,
      carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries
  // corresponding to the same country phone code
  // (e.g. NANPA countries all having `1` country phone code).
  // Therefore, to reliably determine the exact country,
  // national (significant) number should have been parsed first.
  //
  // When `metadata.json` is generated, all "ambiguous" country phone codes
  // get their countries populated with the full set of
  // "phone number type" regular expressions.
  //


  var exactCountry = getCountryByCallingCode(countryCallingCode, {
    nationalNumber: nationalNumber,
    metadata: metadata
  });

  if (exactCountry) {
    country = exactCountry;
    /* istanbul ignore if */

    if (exactCountry === '001') ; else {
      metadata.country(country);
    }
  }

  return {
    country: country,
    countryCallingCode: countryCallingCode,
    countryCallingCodeSource: countryCallingCodeSource,
    nationalNumber: nationalNumber,
    carrierCode: carrierCode
  };
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function parsePhoneNumberWithError(text, options, metadata) {
  return parse$1(text, _objectSpread$2(_objectSpread$2({}, options), {}, {
    v2: true
  }), metadata);
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
// * input `text`
// * `options` object
// * `metadata` JSON

function normalizeArguments(args) {
  var _Array$prototype$slic = Array.prototype.slice.call(args),
      _Array$prototype$slic2 = _slicedToArray(_Array$prototype$slic, 4),
      arg_1 = _Array$prototype$slic2[0],
      arg_2 = _Array$prototype$slic2[1],
      arg_3 = _Array$prototype$slic2[2],
      arg_4 = _Array$prototype$slic2[3];

  var text;
  var options;
  var metadata; // If the phone number is passed as a string.
  // `parsePhoneNumber('88005553535', ...)`.

  if (typeof arg_1 === 'string') {
    text = arg_1;
  } else throw new TypeError('A text for parsing must be a string.'); // If "default country" argument is being passed then move it to `options`.
  // `parsePhoneNumber('88005553535', 'RU', [options], metadata)`.


  if (!arg_2 || typeof arg_2 === 'string') {
    if (arg_4) {
      options = arg_3;
      metadata = arg_4;
    } else {
      options = undefined;
      metadata = arg_3;
    }

    if (arg_2) {
      options = _objectSpread$1({
        defaultCountry: arg_2
      }, options);
    }
  } // `defaultCountry` is not passed.
  // Example: `parsePhoneNumber('+78005553535', [options], metadata)`.
  else if (isObject$1(arg_2)) {
    if (arg_3) {
      options = arg_2;
      metadata = arg_3;
    } else {
      metadata = arg_2;
    }
  } else throw new Error("Invalid second argument: ".concat(arg_2));

  return {
    text: text,
    options: options,
    metadata: metadata
  };
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function parsePhoneNumber$2(text, options, metadata) {
  // Validate `defaultCountry`.
  if (options && options.defaultCountry && !isSupportedCountry(options.defaultCountry, metadata)) {
    options = _objectSpread(_objectSpread({}, options), {}, {
      defaultCountry: undefined
    });
  } // Parse phone number.


  try {
    return parsePhoneNumberWithError(text, options, metadata);
  } catch (error) {
    /* istanbul ignore else */
    if (error instanceof ParseError) ; else {
      throw error;
    }
  }
}

function parsePhoneNumber$1() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return parsePhoneNumber$2(text, options, metadata);
}

function parsePhoneNumber() {
	return withMetadataArgument(parsePhoneNumber$1, arguments)
}

function validateAustralianData$1(records, columns, columnTypes) {
  const validation = {
    detected: false,
    results: {}
  };
  
  // Check each column for Australian patterns
  columns.forEach(col => {
    const values = records.map(r => r[col]).filter(v => v !== null && v !== undefined);
    
    if (values.length === 0) return;
    
    const columnValidation = [];
    
    // Check for postcodes
    const postcodeValidation = validatePostcodes$1(values);
    if (postcodeValidation.detected) {
      validation.detected = true;
      columnValidation.push(postcodeValidation);
    }
    
    // Check for phone numbers
    const phoneValidation = validatePhoneNumbers$1(values);
    if (phoneValidation.detected) {
      validation.detected = true;
      columnValidation.push(phoneValidation);
    }
    
    // Check for state codes
    const stateValidation = validateStateCodes(values);
    if (stateValidation.detected) {
      validation.detected = true;
      columnValidation.push(stateValidation);
    }
    
    // Check for ABN/ACN
    const abnValidation = validateABN$1(values);
    if (abnValidation.detected) {
      validation.detected = true;
      columnValidation.push(abnValidation);
    }
    
    // Check for currency
    const currencyValidation = validateCurrency(values);
    if (currencyValidation.detected) {
      validation.detected = true;
      columnValidation.push(currencyValidation);
    }
    
    if (columnValidation.length > 0) {
      validation.results[col] = columnValidation;
    }
  });
  
  return validation;
}

function validatePostcodes$1(values) {
  const postcodePattern = /^[0-9]{4}$/;
  const postcodes = values.filter(v => postcodePattern.test(String(v)));
  
  if (postcodes.length < values.length * 0.1) {
    return { detected: false };
  }
  
  // Australian postcode ranges by state
  const stateRanges = {
    NSW: [[1000, 2599], [2620, 2899], [2921, 2999]],
    VIC: [[3000, 3999]],
    QLD: [[4000, 4999]],
    SA: [[5000, 5999]],
    WA: [[6000, 6999]],
    TAS: [[7000, 7999]],
    NT: [[800, 899]]
  };
  
  const validPostcodes = [];
  const invalidPostcodes = [];
  const stateDistribution = {};
  
  postcodes.forEach(postcode => {
    const num = parseInt(postcode);
    let isValid = false;
    let state = null;
    
    for (const [stateName, ranges] of Object.entries(stateRanges)) {
      for (const [min, max] of ranges) {
        if (num >= min && num <= max) {
          isValid = true;
          state = stateName;
          break;
        }
      }
      if (isValid) break;
    }
    
    if (isValid) {
      validPostcodes.push(postcode);
      stateDistribution[state] = (stateDistribution[state] || 0) + 1;
    } else {
      invalidPostcodes.push(postcode);
    }
  });
  
  return {
    type: 'Australian Postcodes',
    detected: true,
    valid: validPostcodes.length > 0,
    validCount: validPostcodes.length,
    invalidCount: invalidPostcodes.length,
    percentage: (postcodes.length / values.length * 100).toFixed(1),
    details: {
      stateDistribution: Object.entries(stateDistribution)
        .sort((a, b) => b[1] - a[1])
        .map(([state, count]) => `${state}: ${count}`)
        .join(', '),
      invalidExamples: invalidPostcodes.slice(0, 5)
    }
  };
}

function validatePhoneNumbers$1(values) {
  const phonePatterns = [
    /^(?:\+?61|0)[2-478]\d{8}$/, // Landline
    /^(?:\+?61|0)4\d{8}$/, // Mobile
    /^13\d{4}$|^1300\d{6}$|^1800\d{6}$/ // Special numbers
  ];
  
  const phoneNumbers = values.filter(v => {
    const str = String(v).replace(/[\s\-\(\)]/g, '');
    return phonePatterns.some(pattern => pattern.test(str));
  });
  
  if (phoneNumbers.length < values.length * 0.1) {
    return { detected: false };
  }
  
  const validNumbers = [];
  const invalidNumbers = [];
  const types = {
    mobile: 0,
    landline: 0,
    special: 0
  };
  
  phoneNumbers.forEach(phone => {
    const cleaned = String(phone).replace(/[\s\-\(\)]/g, '');
    
    try {
      const parsed = parsePhoneNumber(cleaned, 'AU');
      if (parsed && parsed.isValid()) {
        validNumbers.push(phone);
        
        if (cleaned.match(/^(?:\+?61|0)4/)) {
          types.mobile++;
        } else if (cleaned.match(/^1[38]/)) {
          types.special++;
        } else {
          types.landline++;
        }
      } else {
        invalidNumbers.push(phone);
      }
    } catch {
      invalidNumbers.push(phone);
    }
  });
  
  return {
    type: 'Australian Phone Numbers',
    detected: true,
    valid: validNumbers.length > 0,
    validCount: validNumbers.length,
    invalidCount: invalidNumbers.length,
    percentage: (phoneNumbers.length / values.length * 100).toFixed(1),
    details: {
      types: `Mobile: ${types.mobile}, Landline: ${types.landline}, Special: ${types.special}`,
      invalidExamples: invalidNumbers.slice(0, 3)
    }
  };
}

function validateStateCodes(values) {
  const states = ['NSW', 'VIC', 'QLD', 'WA', 'SA', 'TAS', 'ACT', 'NT'];
  const statePattern = new RegExp(`^(${states.join('|')})$`, 'i');
  
  const stateCodes = values.filter(v => statePattern.test(String(v).trim()));
  
  if (stateCodes.length < values.length * 0.1) {
    return { detected: false };
  }
  
  const distribution = {};
  stateCodes.forEach(state => {
    const upperState = String(state).trim().toUpperCase();
    distribution[upperState] = (distribution[upperState] || 0) + 1;
  });
  
  return {
    type: 'Australian State Codes',
    detected: true,
    valid: true,
    validCount: stateCodes.length,
    percentage: (stateCodes.length / values.length * 100).toFixed(1),
    details: {
      distribution: Object.entries(distribution)
        .sort((a, b) => b[1] - a[1])
        .map(([state, count]) => `${state}: ${count}`)
        .join(', ')
    }
  };
}

function validateABN$1(values) {
  const abnPattern = /^(\d{2}\s?\d{3}\s?\d{3}\s?\d{3}|\d{11})$/;
  const acnPattern = /^(\d{3}\s?\d{3}\s?\d{3}|\d{9})$/;
  
  const abnNumbers = values.filter(v => {
    const str = String(v).trim();
    return abnPattern.test(str) || acnPattern.test(str);
  });
  
  if (abnNumbers.length < values.length * 0.05) {
    return { detected: false };
  }
  
  const validABNs = [];
  const invalidABNs = [];
  
  abnNumbers.forEach(abn => {
    const digits = String(abn).replace(/\s/g, '');
    
    if (digits.length === 11) {
      // ABN validation
      if (validateABNChecksum(digits)) {
        validABNs.push(abn);
      } else {
        invalidABNs.push(abn);
      }
    } else if (digits.length === 9) {
      // ACN validation (simplified)
      validABNs.push(abn);
    } else {
      invalidABNs.push(abn);
    }
  });
  
  return {
    type: 'Australian Business Numbers',
    detected: true,
    valid: validABNs.length > 0,
    validCount: validABNs.length,
    invalidCount: invalidABNs.length,
    percentage: (abnNumbers.length / values.length * 100).toFixed(1),
    details: {
      format: 'ABN (11 digits) or ACN (9 digits)',
      invalidExamples: invalidABNs.slice(0, 3)
    }
  };
}

function validateABNChecksum(abn) {
  if (abn.length !== 11) return false;
  
  const weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
  let sum = 0;
  
  // Subtract 1 from first digit
  const digits = abn.split('').map(Number);
  digits[0] -= 1;
  
  // Calculate weighted sum
  for (let i = 0; i < 11; i++) {
    sum += digits[i] * weights[i];
  }
  
  return sum % 89 === 0;
}

function validateCurrency(values) {
  const currencyPattern = /^\$[\d,]+\.?\d*$/;
  const currencyValues = values.filter(v => currencyPattern.test(String(v).trim()));
  
  if (currencyValues.length < values.length * 0.1) {
    return { detected: false };
  }
  
  const amounts = currencyValues.map(v => {
    const cleaned = String(v).replace(/[$,]/g, '');
    return parseFloat(cleaned);
  }).filter(amt => !isNaN(amt));
  
  const stats = {
    min: Math.min(...amounts),
    max: Math.max(...amounts),
    average: amounts.reduce((a, b) => a + b, 0) / amounts.length
  };
  
  // Check for GST patterns (10%)
  const gstAmounts = [];
  for (let i = 0; i < amounts.length; i++) {
    for (let j = i + 1; j < amounts.length; j++) {
      const ratio = amounts[i] / amounts[j];
      if (Math.abs(ratio - 1.1) < 0.001 || Math.abs(ratio - 0.909) < 0.001) {
        gstAmounts.push({ amount: amounts[i], gst: amounts[j] });
      }
    }
  }
  
  return {
    type: 'Australian Currency',
    detected: true,
    valid: true,
    validCount: currencyValues.length,
    percentage: (currencyValues.length / values.length * 100).toFixed(1),
    details: {
      range: `$${stats.min.toFixed(2)} - $${stats.max.toFixed(2)}`,
      average: `$${stats.average.toFixed(2)}`,
      gstPatterns: gstAmounts.length > 0 ? `${gstAmounts.length} potential GST relationships found` : 'No GST patterns detected'
    }
  };
}

function generateAustralianInsights(validation) {
  const insights = [];
  
  if (!validation.detected) {
    return insights;
  }
  
  // Geographic insights
  const postcodeColumns = Object.entries(validation.results)
    .filter(([_, validations]) => 
      validations.some(v => v.type === 'Australian Postcodes' && v.valid)
    );
  
  if (postcodeColumns.length > 0) {
    insights.push('Geographic data detected - consider state-based analysis');
  }
  
  // Contact data insights
  const phoneColumns = Object.entries(validation.results)
    .filter(([_, validations]) => 
      validations.some(v => v.type === 'Australian Phone Numbers' && v.valid)
    );
  
  if (phoneColumns.length > 0) {
    insights.push('Contact information present - ensure compliance with Privacy Act 1988');
  }
  
  // Business data insights
  const abnColumns = Object.entries(validation.results)
    .filter(([_, validations]) => 
      validations.some(v => v.type === 'Australian Business Numbers' && v.valid)
    );
  
  if (abnColumns.length > 0) {
    insights.push('Business identifiers found - can be enriched with ABR data');
  }
  
  // Financial insights
  const currencyColumns = Object.entries(validation.results)
    .filter(([_, validations]) => 
      validations.some(v => v.type === 'Australian Currency' && v.valid)
    );
  
  if (currencyColumns.length > 0) {
    insights.push('Financial data in AUD - check for GST implications');
  }
  
  return insights;
}

function assessMLReadiness(records, columns, columnTypes, analysis) {
  const totalRows = records.length;
  columns.length;
  
  // Initialize assessment
  const assessment = {
    overallScore: 0,
    featureQuality: [],
    dataQuality: {},
    recommendations: [],
    modelSuggestions: [],
    readinessLevel: 'low'
  };
  
  // Check minimum requirements
  if (totalRows < 50) {
    assessment.recommendations.push('Dataset too small for ML (< 50 rows)');
    assessment.readinessLevel = 'insufficient';
    return assessment;
  }
  
  // Assess data quality
  assessment.dataQuality = assessDataQuality(records, columns, columnTypes, analysis);
  
  // Assess feature quality
  assessment.featureQuality = assessFeatureQuality(records, columns, columnTypes, analysis);
  
  // Calculate overall score
  const scores = calculateReadinessScores(assessment, totalRows);
  assessment.overallScore = scores.overall;
  
  // Generate recommendations
  assessment.recommendations = generateMLRecommendations(assessment, analysis);
  
  // Suggest appropriate models
  assessment.modelSuggestions = suggestModels(columnTypes, analysis, assessment);
  
  // Determine readiness level
  assessment.readinessLevel = 
    assessment.overallScore >= 8 ? 'high' :
    assessment.overallScore >= 6 ? 'medium' :
    assessment.overallScore >= 4 ? 'low' :
    'insufficient';
  
  return assessment;
}

function assessDataQuality(records, columns, columnTypes, analysis) {
  const quality = {
    completeness: 0,
    consistency: 0,
    uniqueness: 0,
    validity: 0,
    issues: []
  };
  
  // Completeness
  quality.completeness = analysis.completeness || 0;
  if (quality.completeness < 0.8) {
    quality.issues.push(`Low data completeness (${(quality.completeness * 100).toFixed(1)}%)`);
  }
  
  // Consistency (based on outliers and patterns)
  const outlierRate = analysis.outlierRate || 0;
  quality.consistency = Math.max(0, 1 - outlierRate * 2);
  if (outlierRate > 0.1) {
    quality.issues.push(`High outlier rate (${(outlierRate * 100).toFixed(1)}%)`);
  }
  
  // Uniqueness (check for duplicate rows)
  const duplicateRate = (analysis.duplicateCount || 0) / records.length;
  quality.uniqueness = 1 - duplicateRate;
  if (duplicateRate > 0.05) {
    quality.issues.push(`${analysis.duplicateCount} duplicate rows found`);
  }
  
  // Validity (based on type detection confidence)
  let totalConfidence = 0;
  let confCount = 0;
  columns.forEach(col => {
    if (columnTypes[col].confidence) {
      totalConfidence += columnTypes[col].confidence;
      confCount++;
    }
  });
  quality.validity = confCount > 0 ? totalConfidence / confCount : 1;
  
  return quality;
}

function assessFeatureQuality(records, columns, columnTypes, analysis) {
  const features = [];
  
  columns.forEach(col => {
    const type = columnTypes[col];
    const values = records.map(r => r[col]);
    const nonNullValues = values.filter(v => v !== null && v !== undefined);
    
    const feature = {
      feature: col,
      type: type.type,
      quality: 'unknown',
      issues: [],
      recommendations: []
    };
    
    // Check completeness
    const completeness = nonNullValues.length / values.length;
    if (completeness < 0.5) {
      feature.quality = 'poor';
      feature.issues.push('High missing rate');
      feature.recommendations.push('Consider dropping or advanced imputation');
    }
    
    // Check variance
    if (['integer', 'float'].includes(type.type)) {
      const variance$1 = variance(nonNullValues.filter(v => typeof v === 'number'));
      const uniqueRatio = new Set(nonNullValues).size / nonNullValues.length;
      
      if (variance$1 === 0 || uniqueRatio < 0.01) {
        feature.quality = 'poor';
        feature.issues.push('Zero or near-zero variance');
        feature.recommendations.push('Remove constant feature');
      } else if (uniqueRatio > 0.95 && type.type !== 'identifier') {
        feature.quality = 'good';
        feature.assessment = 'High cardinality numeric feature';
      } else {
        feature.quality = 'good';
      }
      
      // Check for skewness
      const stats = analysis.columns?.find(c => c.name === col)?.stats;
      if (stats && Math.abs(stats.skewness) > 2) {
        feature.issues.push('Highly skewed distribution');
        feature.recommendations.push('Apply log or Box-Cox transformation');
      }
    }
    
    // Check categorical features
    if (type.type === 'categorical') {
      const cardinality = type.categories.length;
      const sampleRatio = cardinality / records.length;
      
      if (cardinality === 1) {
        feature.quality = 'poor';
        feature.issues.push('Single value only');
        feature.recommendations.push('Remove constant feature');
      } else if (cardinality > 50 && sampleRatio > 0.5) {
        feature.quality = 'fair';
        feature.issues.push('High cardinality');
        feature.recommendations.push('Consider target encoding or embedding');
      } else if (cardinality <= 10) {
        feature.quality = 'excellent';
        feature.assessment = 'Low cardinality - suitable for one-hot encoding';
      } else {
        feature.quality = 'good';
      }
    }
    
    // Check for identifiers
    if (type.type === 'identifier') {
      feature.quality = 'exclude';
      feature.assessment = 'Identifier column - exclude from features';
    }
    
    // Check date features
    if (type.type === 'date') {
      feature.quality = 'transform';
      feature.assessment = 'Date feature - extract components';
      feature.recommendations.push('Extract year, month, day, day_of_week features');
    }
    
    features.push(feature);
  });
  
  return features;
}

function calculateReadinessScores(assessment, totalRows, totalColumns) {
  const scores = {
    dataSize: 0,
    dataQuality: 0,
    featureQuality: 0,
    overall: 0
  };
  
  // Data size score (0-10)
  if (totalRows >= 10000) scores.dataSize = 10;
  else if (totalRows >= 5000) scores.dataSize = 8;
  else if (totalRows >= 1000) scores.dataSize = 6;
  else if (totalRows >= 500) scores.dataSize = 4;
  else if (totalRows >= 100) scores.dataSize = 2;
  else scores.dataSize = 1;
  
  // Data quality score (0-10)
  const qualityMetrics = assessment.dataQuality;
  scores.dataQuality = (
    qualityMetrics.completeness * 2.5 +
    qualityMetrics.consistency * 2.5 +
    qualityMetrics.uniqueness * 2.5 +
    qualityMetrics.validity * 2.5
  );
  
  // Feature quality score (0-10)
  const goodFeatures = assessment.featureQuality.filter(f => 
    ['good', 'excellent'].includes(f.quality)
  ).length;
  const totalFeatures = assessment.featureQuality.filter(f => 
    f.quality !== 'exclude'
  ).length;
  
  if (totalFeatures > 0) {
    scores.featureQuality = (goodFeatures / totalFeatures) * 10;
  }
  
  // Overall score (weighted average)
  scores.overall = (
    scores.dataSize * 0.2 +
    scores.dataQuality * 0.4 +
    scores.featureQuality * 0.4
  );
  
  return scores;
}

function generateMLRecommendations(assessment, analysis) {
  const recommendations = [];
  
  // Data quality recommendations
  assessment.dataQuality.issues.forEach(issue => {
    if (issue.includes('completeness')) {
      recommendations.push('Handle missing values with imputation or removal');
    }
    if (issue.includes('outlier')) {
      recommendations.push('Address outliers with robust scaling or removal');
    }
    if (issue.includes('duplicate')) {
      recommendations.push('Remove duplicate rows before modeling');
    }
  });
  
  // Feature recommendations
  const transformFeatures = assessment.featureQuality.filter(f => 
    f.recommendations.length > 0
  );
  
  if (transformFeatures.length > 0) {
    recommendations.push(`Transform ${transformFeatures.length} features as suggested`);
  }
  
  // Scaling recommendations
  const numericFeatures = assessment.featureQuality.filter(f => 
    ['integer', 'float'].includes(f.type) && f.quality !== 'exclude'
  );
  
  if (numericFeatures.length > 0) {
    recommendations.push('Standardize or normalize numeric features');
  }
  
  // Encoding recommendations
  const categoricalFeatures = assessment.featureQuality.filter(f => 
    f.type === 'categorical' && f.quality !== 'exclude'
  );
  
  if (categoricalFeatures.length > 0) {
    const highCardinality = categoricalFeatures.filter(f => 
      f.issues.some(i => i.includes('High cardinality'))
    );
    
    if (highCardinality.length > 0) {
      recommendations.push('Use target encoding for high-cardinality categorical features');
    } else {
      recommendations.push('Apply one-hot encoding to categorical features');
    }
  }
  
  // Class imbalance check (if target detected)
  if (analysis.cartAnalysis && analysis.cartAnalysis.targetVariable) {
    recommendations.push('Check for class imbalance in target variable');
  }
  
  // Feature engineering
  if (assessment.overallScore < 7) {
    recommendations.push('Consider feature engineering to create interaction terms');
  }
  
  // Cross-validation
  recommendations.push('Use cross-validation to avoid overfitting');
  
  return recommendations;
}

function suggestModels(columnTypes, analysis, assessment) {
  const suggestions = [];
  const numericColumns = Object.keys(columnTypes).filter(col => 
    ['integer', 'float'].includes(columnTypes[col].type)
  );
  Object.keys(columnTypes).filter(col => 
    columnTypes[col].type === 'categorical'
  );
  
  // Determine problem type
  let problemType = 'unknown';
  
  if (analysis.regressionAnalysis && analysis.regressionAnalysis.targetVariable) {
    problemType = 'regression';
    analysis.regressionAnalysis.targetVariable;
  } else if (analysis.cartAnalysis && analysis.cartAnalysis.targetVariable) {
    const targetType = columnTypes[analysis.cartAnalysis.targetVariable];
    if (targetType && targetType.type === 'categorical') {
      problemType = 'classification';
      analysis.cartAnalysis.targetVariable;
    } else {
      problemType = 'regression';
      analysis.cartAnalysis.targetVariable;
    }
  }
  
  // Regression models
  if (problemType === 'regression') {
    suggestions.push({
      type: 'Linear Regression',
      reason: 'Good baseline model for regression tasks',
      requirements: 'Assumes linear relationships'
    });
    
    if (assessment.overallScore >= 6) {
      suggestions.push({
        type: 'Random Forest Regressor',
        reason: 'Handles non-linear relationships and interactions well',
        requirements: 'No scaling required, handles mixed data types'
      });
      
      suggestions.push({
        type: 'Gradient Boosting (XGBoost/LightGBM)',
        reason: 'Often best performance for structured data',
        requirements: 'Requires hyperparameter tuning'
      });
    }
    
    if (numericColumns.length > 10) {
      suggestions.push({
        type: 'Ridge/Lasso Regression',
        reason: 'Good for high-dimensional data with regularization',
        requirements: 'Requires feature scaling'
      });
    }
  }
  
  // Classification models
  if (problemType === 'classification') {
    suggestions.push({
      type: 'Logistic Regression',
      reason: 'Simple, interpretable baseline for classification',
      requirements: 'Works well for linearly separable data'
    });
    
    if (assessment.overallScore >= 6) {
      suggestions.push({
        type: 'Random Forest Classifier',
        reason: 'Robust to outliers, handles imbalanced data well',
        requirements: 'No scaling required'
      });
      
      suggestions.push({
        type: 'Gradient Boosting Classifier',
        reason: 'High accuracy for complex patterns',
        requirements: 'Careful tuning to avoid overfitting'
      });
    }
    
    if (numericColumns.length > 2) {
      suggestions.push({
        type: 'Support Vector Machine',
        reason: 'Effective in high-dimensional spaces',
        requirements: 'Requires feature scaling'
      });
    }
  }
  
  // Clustering (unsupervised)
  if (problemType === 'unknown' && numericColumns.length >= 2) {
    suggestions.push({
      type: 'K-Means Clustering',
      reason: 'Discover natural groupings in data',
      requirements: 'Requires scaled features and choosing k'
    });
    
    if (assessment.overallScore >= 7) {
      suggestions.push({
        type: 'DBSCAN',
        reason: 'Finds clusters of arbitrary shape',
        requirements: 'Good for outlier detection'
      });
    }
  }
  
  // Deep learning
  if (assessment.overallScore >= 8 && 
      Object.keys(columnTypes).length > 50 && 
      analysis.rowCount > 10000) {
    suggestions.push({
      type: 'Neural Network',
      reason: 'Can capture complex non-linear patterns',
      requirements: 'Requires large dataset and careful architecture design'
    });
  }
  
  return suggestions;
}

// Removed import of deleted unifiedFormat.js - using local implementations

// Define missing exports that were previously in unifiedFormat.js
const colors = {
  primary: chalk.blue,
  success: chalk.green,
  warning: chalk.yellow,
  error: chalk.red,
  info: chalk.cyan,
  muted: chalk.gray
};

const createHeader = (text) => `\n${colors.primary('═'.repeat(60))}\n${colors.primary(text.toUpperCase().padStart((60 + text.length) / 2))}\n${colors.primary('═'.repeat(60))}`;
const createSubsection = (title, content = '') => `\n${colors.info(title)}\n${'─'.repeat(40)}\n${content}`;

function formatNumber(num, decimals = 2) {
  if (typeof num !== 'number' || isNaN(num)) return 'N/A';
  
  if (Math.abs(num) >= 1000000) {
    return (num / 1000000).toFixed(decimals) + 'M';
  } else if (Math.abs(num) >= 1000) {
    return (num / 1000).toFixed(decimals) + 'K';
  }
  
  return num.toFixed(decimals);
}

function formatCurrency(num, currency = '$') {
  if (typeof num !== 'number' || isNaN(num)) return 'N/A';
  return currency + num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function formatPercentage(num, decimals = 1) {
  if (typeof num !== 'number' || isNaN(num)) return 'N/A';
  return (num * 100).toFixed(decimals) + '%';
}

function formatFileSize(bytes) {
  const sizes = ['B', 'KB', 'MB', 'GB'];
  if (bytes === 0) return '0 B';
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sizes[i];
}

function createSection(title, content) {
  // Use unified formatting for consistency
  return createHeader(title) + content;
}

function createSubSection(title, content) {
  // Use unified formatting for consistency
  return createSubsection(title, content);
}

function bulletList(items) {
  return items.map(item => `- ${item}`).join('\n');
}

function numberedList(items) {
  return items.map((item, idx) => `${idx + 1}. ${item}`).join('\n');
}

function formatTimestamp() {
  return new Date().toISOString().replace('T', ' ').split('.')[0];
}

function formatSmallDatasetWarning(rowCount) {
  if (rowCount < 20) {
    return {
      warning: `⚠️  Small dataset detected (${rowCount} rows) - Statistical analysis may be unreliable`,
      analysisMode: 'full_scan',
      showFullData: rowCount < 10,
      confidenceMultiplier: 0.7
    };
  }
  return null;
}

function formatDataTable(records, columns) {
  if (!records || records.length === 0) return 'No data to display';
  
  // Calculate column widths
  const columnWidths = {};
  columns.forEach(col => {
    columnWidths[col] = Math.max(
      col.length,
      ...records.map(r => String(r[col] || '').length)
    );
    // Cap at reasonable width
    columnWidths[col] = Math.min(columnWidths[col], 30);
  });
  
  // Build header
  let table = '\n┌' + columns.map(col => '─'.repeat(columnWidths[col] + 2)).join('┬') + '┐\n';
  table += '│ ' + columns.map(col => col.padEnd(columnWidths[col])).join(' │ ') + ' │\n';
  table += '├' + columns.map(col => '─'.repeat(columnWidths[col] + 2)).join('┼') + '┤\n';
  
  // Build rows
  records.forEach(record => {
    table += '│ ' + columns.map(col => {
      let val = String(record[col] || '');
      if (val.length > columnWidths[col]) {
        val = val.substring(0, columnWidths[col] - 3) + '...';
      }
      return val.padEnd(columnWidths[col]);
    }).join(' │ ') + ' │\n';
  });
  
  table += '└' + columns.map(col => '─'.repeat(columnWidths[col] + 2)).join('┴') + '┘\n';
  
  return table;
}

function formatComprehensiveEDAReport(analysis) {
  let report = '';
  
  // Header
  report += createSection('EXPLORATORY DATA ANALYSIS REPORT', 
    `Dataset: ${analysis.fileName}\n` +
    `Generated: ${formatTimestamp()}\n` +
    `Analysis Depth: Comprehensive (auto-detected)`
  );
  
  // Handle empty dataset
  if (analysis.empty) {
    report += '\n\n⚠️  Empty dataset - no data to analyze';
    
    // Still include the required section headers
    report += createSubSection('DATASET OVERVIEW', 'No data available to analyze');
    report += createSubSection('COLUMN ANALYSIS', 'No columns to analyze');
    
    return report;
  }
  
  // Dataset Overview
  report += formatDatasetOverview(analysis);
  
  // Column Analysis with Enhanced Stats
  report += formatEnhancedColumnAnalysis(analysis);
  
  // Distribution Analysis
  if (analysis.distributionAnalysis) {
    report += formatDistributionAnalysis(analysis.distributionAnalysis);
  }
  
  // Outlier Analysis
  if (analysis.outlierAnalysis) {
    report += formatOutlierAnalysis(analysis.outlierAnalysis);
  }
  
  // Decision Tree Insights
  if (analysis.cartAnalysis && analysis.cartAnalysis.applicable) {
    report += formatCARTAnalysis(analysis.cartAnalysis);
  }
  
  // Regression Analysis
  if (analysis.regressionAnalysis && analysis.regressionAnalysis.applicable) {
    report += formatRegressionAnalysis(analysis.regressionAnalysis);
  }
  
  // Multivariate Relationships
  if (analysis.correlationAnalysis) {
    report += formatCorrelationAnalysis(analysis.correlationAnalysis);
  }
  
  // Advanced Statistical Tests
  if (analysis.advancedTests) {
    report += formatAdvancedTests(analysis.advancedTests);
  }
  
  // Australian Data Validation
  if (analysis.australianValidation && analysis.australianValidation.detected) {
    report += formatAustralianValidation(analysis.australianValidation);
  }
  
  // Time Series Analysis
  if (analysis.timeSeriesAnalysis && analysis.timeSeriesAnalysis.applicable) {
    report += formatTimeSeriesAnalysis(analysis.timeSeriesAnalysis);
  }
  
  // Pattern Detection & Anomalies
  if (analysis.patterns) {
    report += formatPatternDetection(analysis.patterns);
  }
  
  // ML Readiness Assessment
  if (analysis.mlReadiness) {
    report += formatMLReadiness(analysis.mlReadiness);
  }
  
  // Data Quality Summary
  report += formatDataQualitySummary(analysis);
  
  // Key Insights & Recommendations
  report += formatKeyInsights(analysis);
  
  // Suggested Deep-Dive Analyses
  report += formatSuggestedAnalyses$1(analysis);
  
  return report;
}

function formatDatasetOverview(analysis) {
  const items = [
    `Total rows: ${analysis.rowCount.toLocaleString()}`,
    `Total columns: ${analysis.columnCount}`,
    `File size: ${analysis.fileSize}`,
    `Memory usage: ~${estimateMemoryUsage(analysis)}`,
    `Numeric columns: ${analysis.numericColumnCount}`,
    `Categorical columns: ${analysis.categoricalColumnCount}`,
    analysis.dateColumns.length > 0 ? 
      `Date columns: ${analysis.dateColumns.join(', ')}` : 
      'No date columns detected',
    `Data completeness: ${formatPercentage(analysis.completeness)}`
  ];
  
  return createSubSection('DATASET OVERVIEW', bulletList(items));
}

function formatEnhancedColumnAnalysis(analysis) {
  let section = createSubSection('COLUMN ANALYSIS (Enhanced Statistics)', '');
  
  analysis.columns.forEach((col, idx) => {
    section += `\n[Column ${idx + 1}/${analysis.columns.length}] ${col.name}\n`;
    section += `Type: ${col.type} | Non-null: ${formatPercentage(col.nonNullRatio)}\n\n`;
    
    if (col.stats) {
      if (col.type === 'integer' || col.type === 'float') {
        section += formatNumericStats(col.stats);
      } else if (col.type === 'categorical') {
        section += formatCategoricalStats(col.stats);
      }
    }
    
    section += '\n' + '-'.repeat(60) + '\n';
  });
  
  return section;
}

function formatNumericStats(stats) {
  let result = 'CENTRAL TENDENCY:\n';
  result += `  Mean: ${formatNumber(stats.mean)} | Median: ${formatNumber(stats.median)} | Mode: ${formatNumber(stats.mode)}\n`;
  
  result += '\nSPREAD:\n';
  result += `  Std Dev: ${formatNumber(stats.standardDeviation)} | Variance: ${formatNumber(stats.variance)}\n`;
  result += `  IQR: ${formatNumber(stats.iqr)} | Range: [${formatNumber(stats.min)}, ${formatNumber(stats.max)}]\n`;
  result += `  CV: ${formatPercentage(stats.coefficientOfVariation / 100)}\n`;
  
  result += '\nPERCENTILES:\n';
  result += `  5th: ${formatNumber(stats.p5)} | 25th: ${formatNumber(stats.p25)} | `;
  result += `50th: ${formatNumber(stats.p50)} | 75th: ${formatNumber(stats.p75)} | `;
  result += `95th: ${formatNumber(stats.p95)}\n`;
  
  result += '\nSHAPE:\n';
  result += `  Skewness: ${formatNumber(stats.skewness, 3)} (${interpretSkewness(stats.skewness)})\n`;
  result += `  Kurtosis: ${formatNumber(stats.kurtosis, 3)} (${interpretKurtosis(stats.kurtosis)})\n`;
  
  if (stats.outliers) {
    result += '\nOUTLIERS:\n';
    result += `  IQR method: ${stats.outliers.iqr.length} outliers\n`;
    result += `  Z-score method: ${stats.outliers.zscore.length} outliers\n`;
  }
  
  return result;
}

function formatCategoricalStats(stats) {
  let result = 'CATEGORY STATISTICS:\n';
  result += `  Unique values: ${stats.uniqueCount}\n`;
  result += `  Mode: "${stats.mode}" (${formatPercentage(stats.modePercentage / 100)})\n`;
  result += `  Entropy: ${formatNumber(stats.entropy, 3)} | Normalized: ${formatNumber(stats.normalizedEntropy, 3)}\n`;
  
  result += '\nTOP VALUES:\n';
  stats.topValues.slice(0, 5).forEach(val => {
    result += `  "${val.value}": ${val.count} (${formatPercentage(val.percentage / 100)})\n`;
  });
  
  if (stats.rareCount > 0) {
    result += `\nRARE VALUES: ${stats.rareCount} categories < 1% (${formatPercentage(stats.rarePercentage / 100)} of data)\n`;
  }
  
  return result;
}

function formatDistributionAnalysis(distAnalysis) {
  let section = createSubSection('DISTRIBUTION DEEP DIVE', '');
  
  Object.entries(distAnalysis).forEach(([column, analysis]) => {
    section += `\n${column}:\n`;
    
    if (analysis.tests.normality) {
      section += formatNormalityTests(analysis.tests.normality);
    }
    
    if (analysis.tests.bestFit) {
      section += `\nBest Fit: ${analysis.tests.bestFit.distribution}\n`;
    }
    
    if (analysis.transformations && analysis.transformations.length > 0) {
      section += '\nRECOMMENDED TRANSFORMATIONS:\n';
      analysis.transformations.forEach(trans => {
        section += `  - ${trans.description}: `;
        section += `Skewness ${formatNumber(trans.originalSkewness, 2)} → ${formatNumber(trans.transformedSkewness, 2)}\n`;
      });
    }
  });
  
  return section;
}

function formatNormalityTests(normality) {
  let result = '\nNORMALITY TESTS:\n';
  
  if (normality.shapiroWilk) {
    result += `  Shapiro-Wilk: W=${formatNumber(normality.shapiroWilk.statistic, 3)} `;
    result += `(${normality.shapiroWilk.interpretation})\n`;
  }
  
  if (normality.jarqueBera) {
    result += `  Jarque-Bera: JB=${formatNumber(normality.jarqueBera.statistic, 2)} `;
    result += `p=${formatNumber(normality.jarqueBera.pValue, 3)}\n`;
  }
  
  result += `  Overall: ${normality.isNormal ? '✓ Normal' : '✗ Non-normal'}\n`;
  
  return result;
}

function formatOutlierAnalysis(outlierAnalysis) {
  let section = createSubSection('UNIVARIATE OUTLIER ANALYSIS', '');
  
  Object.entries(outlierAnalysis).forEach(([column, analysis]) => {
    if (!analysis || !analysis.methods) return;
    
    section += `\n[Column: ${column}]\n`;
    
    // Safe access to aggregated outliers with fallback
    const aggregatedCount = analysis.aggregated && Array.isArray(analysis.aggregated) 
      ? analysis.aggregated.length 
      : 0;
    section += `Statistical Outliers: ${aggregatedCount} records\n`;
    
    // Method summary
    if (analysis.methods.iqr && analysis.methods.iqr.totalOutliers > 0) {
      section += `  - IQR Method: ${analysis.methods.iqr.totalOutliers} outliers `;
      if (analysis.methods.iqr.outliers && analysis.methods.iqr.outliers.mild && analysis.methods.iqr.outliers.extreme) {
        section += `(${analysis.methods.iqr.outliers.mild.length} mild, ${analysis.methods.iqr.outliers.extreme.length} extreme)\n`;
      } else {
        section += '\n';
      }
    }
    
    if (analysis.methods.modifiedZScore && analysis.methods.modifiedZScore.totalOutliers > 0) {
      section += `  - Modified Z-Score: ${analysis.methods.modifiedZScore.totalOutliers} outliers `;
      section += `(threshold: 3.5)\n`;
    }
    
    // Top outliers
    if (analysis.aggregated && Array.isArray(analysis.aggregated) && analysis.aggregated.length > 0) {
      const topOutliers = analysis.aggregated
        .filter(o => o && (o.confidence === 'high' || o.confidence === 'very high'))
        .slice(0, 5)
        .map(o => formatNumber(o.value));
      
      if (topOutliers.length > 0) {
        section += `  - Top extreme values: [${topOutliers.join(', ')}]\n`;
      }
    }
    
    // Contextual analysis
    if (analysis.contextual && Array.isArray(analysis.contextual.patterns) && analysis.contextual.patterns.length > 0) {
      section += `  - Pattern: ${analysis.contextual.patterns[0]}\n`;
    }
    
    if (analysis.contextual && Array.isArray(analysis.contextual.recommendations) && analysis.contextual.recommendations.length > 0) {
      section += `  - Recommendation: ${analysis.contextual.recommendations[0]}\n`;
    }
  });
  
  return section;
}

function formatCARTAnalysis(cartAnalysis) {
  let section = createSubSection('DECISION TREE INSIGHTS', '');
  
  section += `Target Variable: ${cartAnalysis.targetVariable}\n`;
  section += `Tree Depth: ${cartAnalysis.treeDepth} | Model Quality: ${cartAnalysis.modelQuality.interpretation}\n\n`;
  
  section += 'KEY BUSINESS RULES DISCOVERED:\n';
  
  cartAnalysis.segments.slice(0, 5).forEach((segment, idx) => {
    section += `\n${idx + 1}. ${segment.type.toUpperCase()} SEGMENT (${segment.avgValue}):\n`;
    section += `   ${segment.description}\n`;
    section += `   ├─ Size: ${segment.size} customers (${segment.sizePercentage}%)\n`;
    section += `   ├─ Confidence: ${segment.confidence}%\n`;
    section += `   └─ Action: ${segment.actionability}\n`;
  });
  
  if (cartAnalysis.featureImportances.length > 0) {
    section += '\nFEATURE IMPORTANCE:\n';
    cartAnalysis.featureImportances.slice(0, 5).forEach(feat => {
      section += `  - ${feat.feature}: ${feat.importance}%\n`;
    });
  }
  
  return section;
}

function formatRegressionAnalysis(regression) {
  let section = createSubSection('REGRESSION ANALYSIS', '');
  
  section += `Target: ${regression.targetVariable} | Predictors: ${regression.predictors.join(', ')}\n\n`;
  
  if (regression.bestModel) {
    const model = regression.bestModel;
    section += `BEST MODEL: ${model.type}\n`;
    section += `  R²: ${formatNumber(model.r2, 3)} | Adjusted R²: ${formatNumber(model.adjustedR2, 3)}\n`;
    section += `  RMSE: ${formatNumber(model.rmse, 2)}\n`;
    
    if (model.fStatistic) {
      section += `  F-statistic: ${formatNumber(model.fStatistic.value, 2)} `;
      section += `(p=${formatNumber(model.fStatistic.pValue, 4)})\n`;
    }
    
    section += '\nCOEFFICIENTS:\n';
    model.coefficients.forEach(coef => {
      section += `  ${coef.name}: ${formatNumber(coef.value, 3)} `;
      section += `(SE=${formatNumber(coef.stdError, 3)}, p=${formatNumber(coef.pValue, 3)})`;
      section += coef.significant ? ' *' : '';
      section += '\n';
    });
  }
  
  if (regression.residualAnalysis) {
    section += formatResidualAnalysis(regression.residualAnalysis);
  }
  
  return section;
}

function formatResidualAnalysis(residuals) {
  let result = '\nRESIDUAL ANALYSIS:\n';
  
  if (residuals.normalityTest) {
    result += `  - Normality: ${residuals.normalityTest.interpretation}\n`;
  }
  
  if (residuals.homoscedasticityTest) {
    result += `  - Homoscedasticity: ${residuals.homoscedasticityTest.interpretation}\n`;
  }
  
  if (residuals.independenceTest) {
    result += `  - Independence: ${residuals.independenceTest.interpretation}\n`;
  }
  
  if (residuals.influential && residuals.influential.length > 0) {
    result += `  - Influential points: ${residuals.influential.length} detected\n`;
  }
  
  if (residuals.patterns && residuals.patterns.length > 0) {
    result += `  - Patterns: ${residuals.patterns.join('; ')}\n`;
  }
  
  return result;
}

function formatCorrelationAnalysis(correlations) {
  let section = createSubSection('MULTIVARIATE RELATIONSHIPS', '');
  
  if (correlations.pearson && correlations.pearson.length > 0) {
    section += 'PEARSON CORRELATIONS (Linear):\n';
    correlations.pearson.slice(0, 10).forEach(corr => {
      const strength = Math.abs(corr.value) > 0.7 ? 'Strong' : 
                      Math.abs(corr.value) > 0.5 ? 'Moderate' : 'Weak';
      const direction = corr.value > 0 ? 'positive' : 'negative';
      section += `  - ${corr.var1} ↔ ${corr.var2}: ${formatNumber(corr.value, 3)} `;
      section += `(${strength} ${direction})\n`;
    });
  }
  
  if (correlations.multicollinearity && correlations.multicollinearity.length > 0) {
    section += '\nMULTICOLLINEARITY CHECK:\n';
    correlations.multicollinearity.forEach(vif => {
      section += `  - ${vif.variable}: VIF=${formatNumber(vif.value, 2)} `;
      section += `(${vif.interpretation})\n`;
    });
  }
  
  return section;
}

function formatAustralianValidation(validation) {
  let section = createSubSection('AUSTRALIAN DATA VALIDATION', '');
  
  Object.entries(validation.results).forEach(([column, results]) => {
    section += `\n[${column}]\n`;
    
    results.forEach(result => {
      section += `  ${result.type}: `;
      if (result.valid) {
        section += `✓ ${result.validCount} valid entries\n`;
        if (result.details) {
          Object.entries(result.details).forEach(([key, value]) => {
            section += `    - ${key}: ${value}\n`;
          });
        }
      } else {
        section += `✗ ${result.invalidCount} invalid entries\n`;
        if (result.examples) {
          section += `    Examples: ${result.examples.slice(0, 3).join(', ')}\n`;
        }
      }
    });
  });
  
  return section;
}

function formatTimeSeriesAnalysis(timeSeries) {
  let section = createSubSection('TIME SERIES ANALYSIS', '');
  
  section += `Time Column: ${timeSeries.timeColumn}\n`;
  section += `Frequency: ${timeSeries.frequency}\n`;
  section += `Date Range: ${timeSeries.dateRange}\n\n`;
  
  if (timeSeries.trend) {
    section += 'TREND ANALYSIS:\n';
    section += `  - Type: ${timeSeries.trend.type}\n`;
    section += `  - Strength: ${formatNumber(timeSeries.trend.strength, 3)}\n`;
    if (timeSeries.trend.slope) {
      section += `  - Slope: ${formatNumber(timeSeries.trend.slope, 4)} per period\n`;
    }
  }
  
  if (timeSeries.seasonality) {
    section += '\nSEASONALITY:\n';
    section += `  - Period: ${timeSeries.seasonality.period}\n`;
    section += `  - Strength: ${formatNumber(timeSeries.seasonality.strength, 3)}\n`;
    if (timeSeries.seasonality.peaks) {
      section += `  - Peak periods: ${timeSeries.seasonality.peaks.join(', ')}\n`;
    }
  }
  
  if (timeSeries.stationarity) {
    section += '\nSTATIONARITY TESTS:\n';
    section += `  - ADF test: ${timeSeries.stationarity.adf.interpretation}\n`;
    section += `  - KPSS test: ${timeSeries.stationarity.kpss.interpretation}\n`;
  }
  
  return section;
}

function formatPatternDetection(patterns) {
  let section = createSubSection('PATTERN DETECTION & ANOMALIES', '');
  
  if (patterns.benfordLaw && patterns.benfordLaw.length > 0) {
    section += 'BENFORD\'S LAW ANALYSIS:\n';
    patterns.benfordLaw.forEach(result => {
      section += `  - ${result.column}: ${result.interpretation}\n`;
    });
    section += '\n';
  }
  
  if (patterns.businessRules && patterns.businessRules.length > 0) {
    section += 'DETECTED BUSINESS RULES:\n';
    patterns.businessRules.forEach(rule => {
      section += `  ${rule.column}:\n`;
      rule.rules.forEach(r => {
        section += `    - ${r}\n`;
      });
    });
    section += '\n';
  }
  
  if (patterns.duplicatePatterns && patterns.duplicatePatterns.length > 0) {
    section += 'DUPLICATE PATTERNS:\n';
    patterns.duplicatePatterns.forEach(dup => {
      section += `  - ${dup.type}: ${dup.count} duplicates (${dup.percentage}%)\n`;
    });
  }
  
  return section;
}

function formatMLReadiness(mlReadiness) {
  let section = createSubSection('ML READINESS ASSESSMENT', '');
  
  section += `Overall Score: ${mlReadiness.overallScore}/10\n\n`;
  
  section += 'FEATURE QUALITY:\n';
  mlReadiness.featureQuality.forEach(feat => {
    section += `  - ${feat.feature}: ${feat.assessment}\n`;
  });
  
  section += '\nDATA PREPARATION RECOMMENDATIONS:\n';
  mlReadiness.recommendations.forEach((rec, idx) => {
    section += `  ${idx + 1}. ${rec}\n`;
  });
  
  if (mlReadiness.modelSuggestions) {
    section += '\nSUGGESTED MODELS:\n';
    mlReadiness.modelSuggestions.forEach(model => {
      section += `  - ${model.type}: ${model.reason}\n`;
    });
  }
  
  return section;
}

function formatDataQualitySummary(analysis) {
  const items = [
    `Completeness: ${formatPercentage(analysis.completeness)} (${analysis.completenessLevel})`,
    `Duplicate rows: ${analysis.duplicateCount} ${analysis.duplicateCount === 0 ? '(excellent)' : '(consider deduplication)'}`,
    `Columns with >10% missing: ${analysis.highMissingColumns}`,
    `Data consistency: ${analysis.consistencyScore}/10`,
    `Outlier prevalence: ${formatPercentage(analysis.outlierRate)} of numeric data`
  ];
  
  return createSubSection('DATA QUALITY SUMMARY', bulletList(items));
}

function formatKeyInsights(analysis) {
  let section = createSubSection('KEY INSIGHTS & RECOMMENDATIONS', '');
  
  analysis.insights.forEach((insight, idx) => {
    section += `${idx + 1}. ${insight}\n`;
  });
  
  return section;
}

function formatSuggestedAnalyses$1(analysis) {
  let section = createSubSection('SUGGESTED DEEP-DIVE ANALYSES', '');
  
  analysis.suggestions.forEach((suggestion, idx) => {
    section += `${idx + 1}. ${suggestion.title}\n`;
    section += `   Rationale: ${suggestion.rationale}\n`;
    section += `   Approach: ${suggestion.approach}\n\n`;
  });
  
  return section;
}

// Helper functions
function interpretSkewness(skewness) {
  if (Math.abs(skewness) < 0.5) return 'symmetric';
  if (skewness > 2) return 'highly right-skewed';
  if (skewness > 1) return 'moderately right-skewed';
  if (skewness < -2) return 'highly left-skewed';
  if (skewness < -1) return 'moderately left-skewed';
  return 'slightly skewed';
}

function interpretKurtosis(kurtosis) {
  if (Math.abs(kurtosis) < 0.5) return 'normal tails';
  if (kurtosis > 1) return 'heavy tails';
  if (kurtosis < -1) return 'light tails';
  return 'near-normal tails';
}

function estimateMemoryUsage(analysis) {
  const bytesPerCell = 8; // Rough estimate
  const totalCells = analysis.rowCount * analysis.columnCount;
  const bytes = totalCells * bytesPerCell;
  
  if (bytes < 1024) return `${bytes} bytes`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
}

const is_object = function (obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};

class CsvError extends Error {
  constructor(code, message, options, ...contexts) {
    if (Array.isArray(message)) message = message.join(" ").trim();
    super(message);
    if (Error.captureStackTrace !== undefined) {
      Error.captureStackTrace(this, CsvError);
    }
    this.code = code;
    for (const context of contexts) {
      for (const key in context) {
        const value = context[key];
        this[key] = Buffer.isBuffer(value)
          ? value.toString(options.encoding)
          : value == null
            ? value
            : JSON.parse(JSON.stringify(value));
      }
    }
  }
}

const normalize_columns_array = function (columns) {
  const normalizedColumns = [];
  for (let i = 0, l = columns.length; i < l; i++) {
    const column = columns[i];
    if (column === undefined || column === null || column === false) {
      normalizedColumns[i] = { disabled: true };
    } else if (typeof column === "string") {
      normalizedColumns[i] = { name: column };
    } else if (is_object(column)) {
      if (typeof column.name !== "string") {
        throw new CsvError("CSV_OPTION_COLUMNS_MISSING_NAME", [
          "Option columns missing name:",
          `property "name" is required at position ${i}`,
          "when column is an object literal",
        ]);
      }
      normalizedColumns[i] = column;
    } else {
      throw new CsvError("CSV_INVALID_COLUMN_DEFINITION", [
        "Invalid column definition:",
        "expect a string or a literal object,",
        `got ${JSON.stringify(column)} at position ${i}`,
      ]);
    }
  }
  return normalizedColumns;
};

class ResizeableBuffer {
  constructor(size = 100) {
    this.size = size;
    this.length = 0;
    this.buf = Buffer.allocUnsafe(size);
  }
  prepend(val) {
    if (Buffer.isBuffer(val)) {
      const length = this.length + val.length;
      if (length >= this.size) {
        this.resize();
        if (length >= this.size) {
          throw Error("INVALID_BUFFER_STATE");
        }
      }
      const buf = this.buf;
      this.buf = Buffer.allocUnsafe(this.size);
      val.copy(this.buf, 0);
      buf.copy(this.buf, val.length);
      this.length += val.length;
    } else {
      const length = this.length++;
      if (length === this.size) {
        this.resize();
      }
      const buf = this.clone();
      this.buf[0] = val;
      buf.copy(this.buf, 1, 0, length);
    }
  }
  append(val) {
    const length = this.length++;
    if (length === this.size) {
      this.resize();
    }
    this.buf[length] = val;
  }
  clone() {
    return Buffer.from(this.buf.slice(0, this.length));
  }
  resize() {
    const length = this.length;
    this.size = this.size * 2;
    const buf = Buffer.allocUnsafe(this.size);
    this.buf.copy(buf, 0, 0, length);
    this.buf = buf;
  }
  toString(encoding) {
    if (encoding) {
      return this.buf.slice(0, this.length).toString(encoding);
    } else {
      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
    }
  }
  toJSON() {
    return this.toString("utf8");
  }
  reset() {
    this.length = 0;
  }
}

// white space characters
// https://en.wikipedia.org/wiki/Whitespace_character
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
// \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
const np = 12;
const cr$1 = 13; // `\r`, carriage return, 0x0D in hexadécimal, 13 in decimal
const nl$1 = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal
const space = 32;
const tab = 9;

const init_state = function (options) {
  return {
    bomSkipped: false,
    bufBytesStart: 0,
    castField: options.cast_function,
    commenting: false,
    // Current error encountered by a record
    error: undefined,
    enabled: options.from_line === 1,
    escaping: false,
    escapeIsQuote:
      Buffer.isBuffer(options.escape) &&
      Buffer.isBuffer(options.quote) &&
      Buffer.compare(options.escape, options.quote) === 0,
    // columns can be `false`, `true`, `Array`
    expectedRecordLength: Array.isArray(options.columns)
      ? options.columns.length
      : undefined,
    field: new ResizeableBuffer(20),
    firstLineToHeaders: options.cast_first_line_to_header,
    needMoreDataSize: Math.max(
      // Skip if the remaining buffer smaller than comment
      options.comment !== null ? options.comment.length : 0,
      // Skip if the remaining buffer can be delimiter
      ...options.delimiter.map((delimiter) => delimiter.length),
      // Skip if the remaining buffer can be escape sequence
      options.quote !== null ? options.quote.length : 0,
    ),
    previousBuf: undefined,
    quoting: false,
    stop: false,
    rawBuffer: new ResizeableBuffer(100),
    record: [],
    recordHasError: false,
    record_length: 0,
    recordDelimiterMaxLength:
      options.record_delimiter.length === 0
        ? 0
        : Math.max(...options.record_delimiter.map((v) => v.length)),
    trimChars: [
      Buffer.from(" ", options.encoding)[0],
      Buffer.from("\t", options.encoding)[0],
    ],
    wasQuoting: false,
    wasRowDelimiter: false,
    timchars: [
      Buffer.from(Buffer.from([cr$1], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([nl$1], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([np], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([space], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([tab], "utf8").toString(), options.encoding),
    ],
  };
};

const underscore = function (str) {
  return str.replace(/([A-Z])/g, function (_, match) {
    return "_" + match.toLowerCase();
  });
};

const normalize_options = function (opts) {
  const options = {};
  // Merge with user options
  for (const opt in opts) {
    options[underscore(opt)] = opts[opt];
  }
  // Normalize option `encoding`
  // Note: defined first because other options depends on it
  // to convert chars/strings into buffers.
  if (options.encoding === undefined || options.encoding === true) {
    options.encoding = "utf8";
  } else if (options.encoding === null || options.encoding === false) {
    options.encoding = null;
  } else if (
    typeof options.encoding !== "string" &&
    options.encoding !== null
  ) {
    throw new CsvError(
      "CSV_INVALID_OPTION_ENCODING",
      [
        "Invalid option encoding:",
        "encoding must be a string or null to return a buffer,",
        `got ${JSON.stringify(options.encoding)}`,
      ],
      options,
    );
  }
  // Normalize option `bom`
  if (
    options.bom === undefined ||
    options.bom === null ||
    options.bom === false
  ) {
    options.bom = false;
  } else if (options.bom !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_BOM",
      [
        "Invalid option bom:",
        "bom must be true,",
        `got ${JSON.stringify(options.bom)}`,
      ],
      options,
    );
  }
  // Normalize option `cast`
  options.cast_function = null;
  if (
    options.cast === undefined ||
    options.cast === null ||
    options.cast === false ||
    options.cast === ""
  ) {
    options.cast = undefined;
  } else if (typeof options.cast === "function") {
    options.cast_function = options.cast;
    options.cast = true;
  } else if (options.cast !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_CAST",
      [
        "Invalid option cast:",
        "cast must be true or a function,",
        `got ${JSON.stringify(options.cast)}`,
      ],
      options,
    );
  }
  // Normalize option `cast_date`
  if (
    options.cast_date === undefined ||
    options.cast_date === null ||
    options.cast_date === false ||
    options.cast_date === ""
  ) {
    options.cast_date = false;
  } else if (options.cast_date === true) {
    options.cast_date = function (value) {
      const date = Date.parse(value);
      return !isNaN(date) ? new Date(date) : value;
    };
  } else if (typeof options.cast_date !== "function") {
    throw new CsvError(
      "CSV_INVALID_OPTION_CAST_DATE",
      [
        "Invalid option cast_date:",
        "cast_date must be true or a function,",
        `got ${JSON.stringify(options.cast_date)}`,
      ],
      options,
    );
  }
  // Normalize option `columns`
  options.cast_first_line_to_header = null;
  if (options.columns === true) {
    // Fields in the first line are converted as-is to columns
    options.cast_first_line_to_header = undefined;
  } else if (typeof options.columns === "function") {
    options.cast_first_line_to_header = options.columns;
    options.columns = true;
  } else if (Array.isArray(options.columns)) {
    options.columns = normalize_columns_array(options.columns);
  } else if (
    options.columns === undefined ||
    options.columns === null ||
    options.columns === false
  ) {
    options.columns = false;
  } else {
    throw new CsvError(
      "CSV_INVALID_OPTION_COLUMNS",
      [
        "Invalid option columns:",
        "expect an array, a function or true,",
        `got ${JSON.stringify(options.columns)}`,
      ],
      options,
    );
  }
  // Normalize option `group_columns_by_name`
  if (
    options.group_columns_by_name === undefined ||
    options.group_columns_by_name === null ||
    options.group_columns_by_name === false
  ) {
    options.group_columns_by_name = false;
  } else if (options.group_columns_by_name !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
      [
        "Invalid option group_columns_by_name:",
        "expect an boolean,",
        `got ${JSON.stringify(options.group_columns_by_name)}`,
      ],
      options,
    );
  } else if (options.columns === false) {
    throw new CsvError(
      "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
      [
        "Invalid option group_columns_by_name:",
        "the `columns` mode must be activated.",
      ],
      options,
    );
  }
  // Normalize option `comment`
  if (
    options.comment === undefined ||
    options.comment === null ||
    options.comment === false ||
    options.comment === ""
  ) {
    options.comment = null;
  } else {
    if (typeof options.comment === "string") {
      options.comment = Buffer.from(options.comment, options.encoding);
    }
    if (!Buffer.isBuffer(options.comment)) {
      throw new CsvError(
        "CSV_INVALID_OPTION_COMMENT",
        [
          "Invalid option comment:",
          "comment must be a buffer or a string,",
          `got ${JSON.stringify(options.comment)}`,
        ],
        options,
      );
    }
  }
  // Normalize option `comment_no_infix`
  if (
    options.comment_no_infix === undefined ||
    options.comment_no_infix === null ||
    options.comment_no_infix === false
  ) {
    options.comment_no_infix = false;
  } else if (options.comment_no_infix !== true) {
    throw new CsvError(
      "CSV_INVALID_OPTION_COMMENT",
      [
        "Invalid option comment_no_infix:",
        "value must be a boolean,",
        `got ${JSON.stringify(options.comment_no_infix)}`,
      ],
      options,
    );
  }
  // Normalize option `delimiter`
  const delimiter_json = JSON.stringify(options.delimiter);
  if (!Array.isArray(options.delimiter))
    options.delimiter = [options.delimiter];
  if (options.delimiter.length === 0) {
    throw new CsvError(
      "CSV_INVALID_OPTION_DELIMITER",
      [
        "Invalid option delimiter:",
        "delimiter must be a non empty string or buffer or array of string|buffer,",
        `got ${delimiter_json}`,
      ],
      options,
    );
  }
  options.delimiter = options.delimiter.map(function (delimiter) {
    if (delimiter === undefined || delimiter === null || delimiter === false) {
      return Buffer.from(",", options.encoding);
    }
    if (typeof delimiter === "string") {
      delimiter = Buffer.from(delimiter, options.encoding);
    }
    if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
      throw new CsvError(
        "CSV_INVALID_OPTION_DELIMITER",
        [
          "Invalid option delimiter:",
          "delimiter must be a non empty string or buffer or array of string|buffer,",
          `got ${delimiter_json}`,
        ],
        options,
      );
    }
    return delimiter;
  });
  // Normalize option `escape`
  if (options.escape === undefined || options.escape === true) {
    options.escape = Buffer.from('"', options.encoding);
  } else if (typeof options.escape === "string") {
    options.escape = Buffer.from(options.escape, options.encoding);
  } else if (options.escape === null || options.escape === false) {
    options.escape = null;
  }
  if (options.escape !== null) {
    if (!Buffer.isBuffer(options.escape)) {
      throw new Error(
        `Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`,
      );
    }
  }
  // Normalize option `from`
  if (options.from === undefined || options.from === null) {
    options.from = 1;
  } else {
    if (typeof options.from === "string" && /\d+/.test(options.from)) {
      options.from = parseInt(options.from);
    }
    if (Number.isInteger(options.from)) {
      if (options.from < 0) {
        throw new Error(
          `Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`,
        );
      }
    } else {
      throw new Error(
        `Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`,
      );
    }
  }
  // Normalize option `from_line`
  if (options.from_line === undefined || options.from_line === null) {
    options.from_line = 1;
  } else {
    if (
      typeof options.from_line === "string" &&
      /\d+/.test(options.from_line)
    ) {
      options.from_line = parseInt(options.from_line);
    }
    if (Number.isInteger(options.from_line)) {
      if (options.from_line <= 0) {
        throw new Error(
          `Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`,
        );
      }
    } else {
      throw new Error(
        `Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`,
      );
    }
  }
  // Normalize options `ignore_last_delimiters`
  if (
    options.ignore_last_delimiters === undefined ||
    options.ignore_last_delimiters === null
  ) {
    options.ignore_last_delimiters = false;
  } else if (typeof options.ignore_last_delimiters === "number") {
    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
    if (options.ignore_last_delimiters === 0) {
      options.ignore_last_delimiters = false;
    }
  } else if (typeof options.ignore_last_delimiters !== "boolean") {
    throw new CsvError(
      "CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",
      [
        "Invalid option `ignore_last_delimiters`:",
        "the value must be a boolean value or an integer,",
        `got ${JSON.stringify(options.ignore_last_delimiters)}`,
      ],
      options,
    );
  }
  if (options.ignore_last_delimiters === true && options.columns === false) {
    throw new CsvError(
      "CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",
      [
        "The option `ignore_last_delimiters`",
        "requires the activation of the `columns` option",
      ],
      options,
    );
  }
  // Normalize option `info`
  if (
    options.info === undefined ||
    options.info === null ||
    options.info === false
  ) {
    options.info = false;
  } else if (options.info !== true) {
    throw new Error(
      `Invalid Option: info must be true, got ${JSON.stringify(options.info)}`,
    );
  }
  // Normalize option `max_record_size`
  if (
    options.max_record_size === undefined ||
    options.max_record_size === null ||
    options.max_record_size === false
  ) {
    options.max_record_size = 0;
  } else if (
    Number.isInteger(options.max_record_size) &&
    options.max_record_size >= 0
  ) ; else if (
    typeof options.max_record_size === "string" &&
    /\d+/.test(options.max_record_size)
  ) {
    options.max_record_size = parseInt(options.max_record_size);
  } else {
    throw new Error(
      `Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`,
    );
  }
  // Normalize option `objname`
  if (
    options.objname === undefined ||
    options.objname === null ||
    options.objname === false
  ) {
    options.objname = undefined;
  } else if (Buffer.isBuffer(options.objname)) {
    if (options.objname.length === 0) {
      throw new Error(`Invalid Option: objname must be a non empty buffer`);
    }
    if (options.encoding === null) ; else {
      options.objname = options.objname.toString(options.encoding);
    }
  } else if (typeof options.objname === "string") {
    if (options.objname.length === 0) {
      throw new Error(`Invalid Option: objname must be a non empty string`);
    }
    // Great, nothing to do
  } else if (typeof options.objname === "number") ; else {
    throw new Error(
      `Invalid Option: objname must be a string or a buffer, got ${options.objname}`,
    );
  }
  if (options.objname !== undefined) {
    if (typeof options.objname === "number") {
      if (options.columns !== false) {
        throw Error(
          "Invalid Option: objname index cannot be combined with columns or be defined as a field",
        );
      }
    } else {
      // A string or a buffer
      if (options.columns === false) {
        throw Error(
          "Invalid Option: objname field must be combined with columns or be defined as an index",
        );
      }
    }
  }
  // Normalize option `on_record`
  if (options.on_record === undefined || options.on_record === null) {
    options.on_record = undefined;
  } else if (typeof options.on_record !== "function") {
    throw new CsvError(
      "CSV_INVALID_OPTION_ON_RECORD",
      [
        "Invalid option `on_record`:",
        "expect a function,",
        `got ${JSON.stringify(options.on_record)}`,
      ],
      options,
    );
  }
  // Normalize option `on_skip`
  // options.on_skip ??= (err, chunk) => {
  //   this.emit('skip', err, chunk);
  // };
  if (
    options.on_skip !== undefined &&
    options.on_skip !== null &&
    typeof options.on_skip !== "function"
  ) {
    throw new Error(
      `Invalid Option: on_skip must be a function, got ${JSON.stringify(options.on_skip)}`,
    );
  }
  // Normalize option `quote`
  if (
    options.quote === null ||
    options.quote === false ||
    options.quote === ""
  ) {
    options.quote = null;
  } else {
    if (options.quote === undefined || options.quote === true) {
      options.quote = Buffer.from('"', options.encoding);
    } else if (typeof options.quote === "string") {
      options.quote = Buffer.from(options.quote, options.encoding);
    }
    if (!Buffer.isBuffer(options.quote)) {
      throw new Error(
        `Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`,
      );
    }
  }
  // Normalize option `raw`
  if (
    options.raw === undefined ||
    options.raw === null ||
    options.raw === false
  ) {
    options.raw = false;
  } else if (options.raw !== true) {
    throw new Error(
      `Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`,
    );
  }
  // Normalize option `record_delimiter`
  if (options.record_delimiter === undefined) {
    options.record_delimiter = [];
  } else if (
    typeof options.record_delimiter === "string" ||
    Buffer.isBuffer(options.record_delimiter)
  ) {
    if (options.record_delimiter.length === 0) {
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a non empty string or buffer,",
          `got ${JSON.stringify(options.record_delimiter)}`,
        ],
        options,
      );
    }
    options.record_delimiter = [options.record_delimiter];
  } else if (!Array.isArray(options.record_delimiter)) {
    throw new CsvError(
      "CSV_INVALID_OPTION_RECORD_DELIMITER",
      [
        "Invalid option `record_delimiter`:",
        "value must be a string, a buffer or array of string|buffer,",
        `got ${JSON.stringify(options.record_delimiter)}`,
      ],
      options,
    );
  }
  options.record_delimiter = options.record_delimiter.map(function (rd, i) {
    if (typeof rd !== "string" && !Buffer.isBuffer(rd)) {
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a string, a buffer or array of string|buffer",
          `at index ${i},`,
          `got ${JSON.stringify(rd)}`,
        ],
        options,
      );
    } else if (rd.length === 0) {
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a non empty string or buffer",
          `at index ${i},`,
          `got ${JSON.stringify(rd)}`,
        ],
        options,
      );
    }
    if (typeof rd === "string") {
      rd = Buffer.from(rd, options.encoding);
    }
    return rd;
  });
  // Normalize option `relax_column_count`
  if (typeof options.relax_column_count === "boolean") ; else if (
    options.relax_column_count === undefined ||
    options.relax_column_count === null
  ) {
    options.relax_column_count = false;
  } else {
    throw new Error(
      `Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`,
    );
  }
  if (typeof options.relax_column_count_less === "boolean") ; else if (
    options.relax_column_count_less === undefined ||
    options.relax_column_count_less === null
  ) {
    options.relax_column_count_less = false;
  } else {
    throw new Error(
      `Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`,
    );
  }
  if (typeof options.relax_column_count_more === "boolean") ; else if (
    options.relax_column_count_more === undefined ||
    options.relax_column_count_more === null
  ) {
    options.relax_column_count_more = false;
  } else {
    throw new Error(
      `Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`,
    );
  }
  // Normalize option `relax_quotes`
  if (typeof options.relax_quotes === "boolean") ; else if (
    options.relax_quotes === undefined ||
    options.relax_quotes === null
  ) {
    options.relax_quotes = false;
  } else {
    throw new Error(
      `Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`,
    );
  }
  // Normalize option `skip_empty_lines`
  if (typeof options.skip_empty_lines === "boolean") ; else if (
    options.skip_empty_lines === undefined ||
    options.skip_empty_lines === null
  ) {
    options.skip_empty_lines = false;
  } else {
    throw new Error(
      `Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`,
    );
  }
  // Normalize option `skip_records_with_empty_values`
  if (typeof options.skip_records_with_empty_values === "boolean") ; else if (
    options.skip_records_with_empty_values === undefined ||
    options.skip_records_with_empty_values === null
  ) {
    options.skip_records_with_empty_values = false;
  } else {
    throw new Error(
      `Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`,
    );
  }
  // Normalize option `skip_records_with_error`
  if (typeof options.skip_records_with_error === "boolean") ; else if (
    options.skip_records_with_error === undefined ||
    options.skip_records_with_error === null
  ) {
    options.skip_records_with_error = false;
  } else {
    throw new Error(
      `Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`,
    );
  }
  // Normalize option `rtrim`
  if (
    options.rtrim === undefined ||
    options.rtrim === null ||
    options.rtrim === false
  ) {
    options.rtrim = false;
  } else if (options.rtrim !== true) {
    throw new Error(
      `Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`,
    );
  }
  // Normalize option `ltrim`
  if (
    options.ltrim === undefined ||
    options.ltrim === null ||
    options.ltrim === false
  ) {
    options.ltrim = false;
  } else if (options.ltrim !== true) {
    throw new Error(
      `Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`,
    );
  }
  // Normalize option `trim`
  if (
    options.trim === undefined ||
    options.trim === null ||
    options.trim === false
  ) {
    options.trim = false;
  } else if (options.trim !== true) {
    throw new Error(
      `Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`,
    );
  }
  // Normalize options `trim`, `ltrim` and `rtrim`
  if (options.trim === true && opts.ltrim !== false) {
    options.ltrim = true;
  } else if (options.ltrim !== true) {
    options.ltrim = false;
  }
  if (options.trim === true && opts.rtrim !== false) {
    options.rtrim = true;
  } else if (options.rtrim !== true) {
    options.rtrim = false;
  }
  // Normalize option `to`
  if (options.to === undefined || options.to === null) {
    options.to = -1;
  } else {
    if (typeof options.to === "string" && /\d+/.test(options.to)) {
      options.to = parseInt(options.to);
    }
    if (Number.isInteger(options.to)) {
      if (options.to <= 0) {
        throw new Error(
          `Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`,
        );
      }
    } else {
      throw new Error(
        `Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`,
      );
    }
  }
  // Normalize option `to_line`
  if (options.to_line === undefined || options.to_line === null) {
    options.to_line = -1;
  } else {
    if (typeof options.to_line === "string" && /\d+/.test(options.to_line)) {
      options.to_line = parseInt(options.to_line);
    }
    if (Number.isInteger(options.to_line)) {
      if (options.to_line <= 0) {
        throw new Error(
          `Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`,
        );
      }
    } else {
      throw new Error(
        `Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`,
      );
    }
  }
  return options;
};

const isRecordEmpty = function (record) {
  return record.every(
    (field) =>
      field == null || (field.toString && field.toString().trim() === ""),
  );
};

const cr = 13; // `\r`, carriage return, 0x0D in hexadécimal, 13 in decimal
const nl = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal

const boms = {
  // Note, the following are equals:
  // Buffer.from("\ufeff")
  // Buffer.from([239, 187, 191])
  // Buffer.from('EFBBBF', 'hex')
  utf8: Buffer.from([239, 187, 191]),
  // Note, the following are equals:
  // Buffer.from "\ufeff", 'utf16le
  // Buffer.from([255, 254])
  utf16le: Buffer.from([255, 254]),
};

const transform = function (original_options = {}) {
  const info = {
    bytes: 0,
    comment_lines: 0,
    empty_lines: 0,
    invalid_field_length: 0,
    lines: 1,
    records: 0,
  };
  const options = normalize_options(original_options);
  return {
    info: info,
    original_options: original_options,
    options: options,
    state: init_state(options),
    __needMoreData: function (i, bufLen, end) {
      if (end) return false;
      const { encoding, escape, quote } = this.options;
      const { quoting, needMoreDataSize, recordDelimiterMaxLength } =
        this.state;
      const numOfCharLeft = bufLen - i - 1;
      const requiredLength = Math.max(
        needMoreDataSize,
        // Skip if the remaining buffer smaller than record delimiter
        // If "record_delimiter" is yet to be discovered:
        // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
        // 2. We set the length to windows line ending in the current encoding
        // Note, that encoding is known from user or bom discovery at that point
        // recordDelimiterMaxLength,
        recordDelimiterMaxLength === 0
          ? Buffer.from("\r\n", encoding).length
          : recordDelimiterMaxLength,
        // Skip if remaining buffer can be an escaped quote
        quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,
        // Skip if remaining buffer can be record delimiter following the closing quote
        quoting ? quote.length + recordDelimiterMaxLength : 0,
      );
      return numOfCharLeft < requiredLength;
    },
    // Central parser implementation
    parse: function (nextBuf, end, push, close) {
      const {
        bom,
        comment_no_infix,
        encoding,
        from_line,
        ltrim,
        max_record_size,
        raw,
        relax_quotes,
        rtrim,
        skip_empty_lines,
        to,
        to_line,
      } = this.options;
      let { comment, escape, quote, record_delimiter } = this.options;
      const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
      let buf;
      if (previousBuf === undefined) {
        if (nextBuf === undefined) {
          // Handle empty string
          close();
          return;
        } else {
          buf = nextBuf;
        }
      } else if (previousBuf !== undefined && nextBuf === undefined) {
        buf = previousBuf;
      } else {
        buf = Buffer.concat([previousBuf, nextBuf]);
      }
      // Handle UTF BOM
      if (bomSkipped === false) {
        if (bom === false) {
          this.state.bomSkipped = true;
        } else if (buf.length < 3) {
          // No enough data
          if (end === false) {
            // Wait for more data
            this.state.previousBuf = buf;
            return;
          }
        } else {
          for (const encoding in boms) {
            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {
              // Skip BOM
              const bomLength = boms[encoding].length;
              this.state.bufBytesStart += bomLength;
              buf = buf.slice(bomLength);
              // Renormalize original options with the new encoding
              this.options = normalize_options({
                ...this.original_options,
                encoding: encoding,
              });
              // Options will re-evaluate the Buffer with the new encoding
              ({ comment, escape, quote } = this.options);
              break;
            }
          }
          this.state.bomSkipped = true;
        }
      }
      const bufLen = buf.length;
      let pos;
      for (pos = 0; pos < bufLen; pos++) {
        // Ensure we get enough space to look ahead
        // There should be a way to move this out of the loop
        if (this.__needMoreData(pos, bufLen, end)) {
          break;
        }
        if (this.state.wasRowDelimiter === true) {
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
        if (to_line !== -1 && this.info.lines > to_line) {
          this.state.stop = true;
          close();
          return;
        }
        // Auto discovery of record_delimiter, unix, mac and windows supported
        if (this.state.quoting === false && record_delimiter.length === 0) {
          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(
            buf,
            pos,
          );
          if (record_delimiterCount) {
            record_delimiter = this.options.record_delimiter;
          }
        }
        const chr = buf[pos];
        if (raw === true) {
          rawBuffer.append(chr);
        }
        if (
          (chr === cr || chr === nl) &&
          this.state.wasRowDelimiter === false
        ) {
          this.state.wasRowDelimiter = true;
        }
        // Previous char was a valid escape char
        // treat the current char as a regular char
        if (this.state.escaping === true) {
          this.state.escaping = false;
        } else {
          // Escape is only active inside quoted fields
          // We are quoting, the char is an escape chr and there is a chr to escape
          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
          if (
            escape !== null &&
            this.state.quoting === true &&
            this.__isEscape(buf, pos, chr) &&
            pos + escape.length < bufLen
          ) {
            if (escapeIsQuote) {
              if (this.__isQuote(buf, pos + escape.length)) {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            } else {
              this.state.escaping = true;
              pos += escape.length - 1;
              continue;
            }
          }
          // Not currently escaping and chr is a quote
          // TODO: need to compare bytes instead of single char
          if (this.state.commenting === false && this.__isQuote(buf, pos)) {
            if (this.state.quoting === true) {
              const nextChr = buf[pos + quote.length];
              const isNextChrTrimable =
                rtrim && this.__isCharTrimable(buf, pos + quote.length);
              const isNextChrComment =
                comment !== null &&
                this.__compareBytes(comment, buf, pos + quote.length, nextChr);
              const isNextChrDelimiter = this.__isDelimiter(
                buf,
                pos + quote.length,
                nextChr,
              );
              const isNextChrRecordDelimiter =
                record_delimiter.length === 0
                  ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length)
                  : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
              // Escape a quote
              // Treat next char as a regular character
              if (
                escape !== null &&
                this.__isEscape(buf, pos, chr) &&
                this.__isQuote(buf, pos + escape.length)
              ) {
                pos += escape.length - 1;
              } else if (
                !nextChr ||
                isNextChrDelimiter ||
                isNextChrRecordDelimiter ||
                isNextChrComment ||
                isNextChrTrimable
              ) {
                this.state.quoting = false;
                this.state.wasQuoting = true;
                pos += quote.length - 1;
                continue;
              } else if (relax_quotes === false) {
                const err = this.__error(
                  new CsvError(
                    "CSV_INVALID_CLOSING_QUOTE",
                    [
                      "Invalid Closing Quote:",
                      `got "${String.fromCharCode(nextChr)}"`,
                      `at line ${this.info.lines}`,
                      "instead of delimiter, record delimiter, trimable character",
                      "(if activated) or comment",
                    ],
                    this.options,
                    this.__infoField(),
                  ),
                );
                if (err !== undefined) return err;
              } else {
                this.state.quoting = false;
                this.state.wasQuoting = true;
                this.state.field.prepend(quote);
                pos += quote.length - 1;
              }
            } else {
              if (this.state.field.length !== 0) {
                // In relax_quotes mode, treat opening quote preceded by chrs as regular
                if (relax_quotes === false) {
                  const info = this.__infoField();
                  const bom = Object.keys(boms)
                    .map((b) =>
                      boms[b].equals(this.state.field.toString()) ? b : false,
                    )
                    .filter(Boolean)[0];
                  const err = this.__error(
                    new CsvError(
                      "INVALID_OPENING_QUOTE",
                      [
                        "Invalid Opening Quote:",
                        `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,
                        bom ? `(${bom} bom)` : undefined,
                      ],
                      this.options,
                      info,
                      {
                        field: this.state.field,
                      },
                    ),
                  );
                  if (err !== undefined) return err;
                }
              } else {
                this.state.quoting = true;
                pos += quote.length - 1;
                continue;
              }
            }
          }
          if (this.state.quoting === false) {
            const recordDelimiterLength = this.__isRecordDelimiter(
              chr,
              buf,
              pos,
            );
            if (recordDelimiterLength !== 0) {
              // Do not emit comments which take a full line
              const skipCommentLine =
                this.state.commenting &&
                this.state.wasQuoting === false &&
                this.state.record.length === 0 &&
                this.state.field.length === 0;
              if (skipCommentLine) {
                this.info.comment_lines++;
                // Skip full comment line
              } else {
                // Activate records emition if above from_line
                if (
                  this.state.enabled === false &&
                  this.info.lines +
                    (this.state.wasRowDelimiter === true ? 1 : 0) >=
                    from_line
                ) {
                  this.state.enabled = true;
                  this.__resetField();
                  this.__resetRecord();
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                // Skip if line is empty and skip_empty_lines activated
                if (
                  skip_empty_lines === true &&
                  this.state.wasQuoting === false &&
                  this.state.record.length === 0 &&
                  this.state.field.length === 0
                ) {
                  this.info.empty_lines++;
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if (errField !== undefined) return errField;
                this.info.bytes =
                  this.state.bufBytesStart + pos + recordDelimiterLength;
                const errRecord = this.__onRecord(push);
                if (errRecord !== undefined) return errRecord;
                if (to !== -1 && this.info.records >= to) {
                  this.state.stop = true;
                  close();
                  return;
                }
              }
              this.state.commenting = false;
              pos += recordDelimiterLength - 1;
              continue;
            }
            if (this.state.commenting) {
              continue;
            }
            if (
              comment !== null &&
              (comment_no_infix === false ||
                (this.state.record.length === 0 &&
                  this.state.field.length === 0))
            ) {
              const commentCount = this.__compareBytes(comment, buf, pos, chr);
              if (commentCount !== 0) {
                this.state.commenting = true;
                continue;
              }
            }
            const delimiterLength = this.__isDelimiter(buf, pos, chr);
            if (delimiterLength !== 0) {
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField();
              if (errField !== undefined) return errField;
              pos += delimiterLength - 1;
              continue;
            }
          }
        }
        if (this.state.commenting === false) {
          if (
            max_record_size !== 0 &&
            this.state.record_length + this.state.field.length > max_record_size
          ) {
            return this.__error(
              new CsvError(
                "CSV_MAX_RECORD_SIZE",
                [
                  "Max Record Size:",
                  "record exceed the maximum number of tolerated bytes",
                  `of ${max_record_size}`,
                  `at line ${this.info.lines}`,
                ],
                this.options,
                this.__infoField(),
              ),
            );
          }
        }
        const lappend =
          ltrim === false ||
          this.state.quoting === true ||
          this.state.field.length !== 0 ||
          !this.__isCharTrimable(buf, pos);
        // rtrim in non quoting is handle in __onField
        const rappend = rtrim === false || this.state.wasQuoting === false;
        if (lappend === true && rappend === true) {
          this.state.field.append(chr);
        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {
          return this.__error(
            new CsvError(
              "CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",
              [
                "Invalid Closing Quote:",
                "found non trimable byte after quote",
                `at line ${this.info.lines}`,
              ],
              this.options,
              this.__infoField(),
            ),
          );
        } else {
          if (lappend === false) {
            pos += this.__isCharTrimable(buf, pos) - 1;
          }
          continue;
        }
      }
      if (end === true) {
        // Ensure we are not ending in a quoting state
        if (this.state.quoting === true) {
          const err = this.__error(
            new CsvError(
              "CSV_QUOTE_NOT_CLOSED",
              [
                "Quote Not Closed:",
                `the parsing is finished with an opening quote at line ${this.info.lines}`,
              ],
              this.options,
              this.__infoField(),
            ),
          );
          if (err !== undefined) return err;
        } else {
          // Skip last line if it has no characters
          if (
            this.state.wasQuoting === true ||
            this.state.record.length !== 0 ||
            this.state.field.length !== 0
          ) {
            this.info.bytes = this.state.bufBytesStart + pos;
            const errField = this.__onField();
            if (errField !== undefined) return errField;
            const errRecord = this.__onRecord(push);
            if (errRecord !== undefined) return errRecord;
          } else if (this.state.wasRowDelimiter === true) {
            this.info.empty_lines++;
          } else if (this.state.commenting === true) {
            this.info.comment_lines++;
          }
        }
      } else {
        this.state.bufBytesStart += pos;
        this.state.previousBuf = buf.slice(pos);
      }
      if (this.state.wasRowDelimiter === true) {
        this.info.lines++;
        this.state.wasRowDelimiter = false;
      }
    },
    __onRecord: function (push) {
      const {
        columns,
        group_columns_by_name,
        encoding,
        info,
        from,
        relax_column_count,
        relax_column_count_less,
        relax_column_count_more,
        raw,
        skip_records_with_empty_values,
      } = this.options;
      const { enabled, record } = this.state;
      if (enabled === false) {
        return this.__resetRecord();
      }
      // Convert the first line into column names
      const recordLength = record.length;
      if (columns === true) {
        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
          this.__resetRecord();
          return;
        }
        return this.__firstLineToColumns(record);
      }
      if (columns === false && this.info.records === 0) {
        this.state.expectedRecordLength = recordLength;
      }
      if (recordLength !== this.state.expectedRecordLength) {
        const err =
          columns === false
            ? new CsvError(
                "CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",
                [
                  "Invalid Record Length:",
                  `expect ${this.state.expectedRecordLength},`,
                  `got ${recordLength} on line ${this.info.lines}`,
                ],
                this.options,
                this.__infoField(),
                {
                  record: record,
                },
              )
            : new CsvError(
                "CSV_RECORD_INCONSISTENT_COLUMNS",
                [
                  "Invalid Record Length:",
                  `columns length is ${columns.length},`, // rename columns
                  `got ${recordLength} on line ${this.info.lines}`,
                ],
                this.options,
                this.__infoField(),
                {
                  record: record,
                },
              );
        if (
          relax_column_count === true ||
          (relax_column_count_less === true &&
            recordLength < this.state.expectedRecordLength) ||
          (relax_column_count_more === true &&
            recordLength > this.state.expectedRecordLength)
        ) {
          this.info.invalid_field_length++;
          this.state.error = err;
          // Error is undefined with skip_records_with_error
        } else {
          const finalErr = this.__error(err);
          if (finalErr) return finalErr;
        }
      }
      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
        this.__resetRecord();
        return;
      }
      if (this.state.recordHasError === true) {
        this.__resetRecord();
        this.state.recordHasError = false;
        return;
      }
      this.info.records++;
      if (from === 1 || this.info.records >= from) {
        const { objname } = this.options;
        // With columns, records are object
        if (columns !== false) {
          const obj = {};
          // Transform record array to an object
          for (let i = 0, l = record.length; i < l; i++) {
            if (columns[i] === undefined || columns[i].disabled) continue;
            // Turn duplicate columns into an array
            if (
              group_columns_by_name === true &&
              obj[columns[i].name] !== undefined
            ) {
              if (Array.isArray(obj[columns[i].name])) {
                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
              } else {
                obj[columns[i].name] = [obj[columns[i].name], record[i]];
              }
            } else {
              obj[columns[i].name] = record[i];
            }
          }
          // Without objname (default)
          if (raw === true || info === true) {
            const extRecord = Object.assign(
              { record: obj },
              raw === true
                ? { raw: this.state.rawBuffer.toString(encoding) }
                : {},
              info === true ? { info: this.__infoRecord() } : {},
            );
            const err = this.__push(
              objname === undefined ? extRecord : [obj[objname], extRecord],
              push,
            );
            if (err) {
              return err;
            }
          } else {
            const err = this.__push(
              objname === undefined ? obj : [obj[objname], obj],
              push,
            );
            if (err) {
              return err;
            }
          }
          // Without columns, records are array
        } else {
          if (raw === true || info === true) {
            const extRecord = Object.assign(
              { record: record },
              raw === true
                ? { raw: this.state.rawBuffer.toString(encoding) }
                : {},
              info === true ? { info: this.__infoRecord() } : {},
            );
            const err = this.__push(
              objname === undefined ? extRecord : [record[objname], extRecord],
              push,
            );
            if (err) {
              return err;
            }
          } else {
            const err = this.__push(
              objname === undefined ? record : [record[objname], record],
              push,
            );
            if (err) {
              return err;
            }
          }
        }
      }
      this.__resetRecord();
    },
    __firstLineToColumns: function (record) {
      const { firstLineToHeaders } = this.state;
      try {
        const headers =
          firstLineToHeaders === undefined
            ? record
            : firstLineToHeaders.call(null, record);
        if (!Array.isArray(headers)) {
          return this.__error(
            new CsvError(
              "CSV_INVALID_COLUMN_MAPPING",
              [
                "Invalid Column Mapping:",
                "expect an array from column function,",
                `got ${JSON.stringify(headers)}`,
              ],
              this.options,
              this.__infoField(),
              {
                headers: headers,
              },
            ),
          );
        }
        const normalizedHeaders = normalize_columns_array(headers);
        this.state.expectedRecordLength = normalizedHeaders.length;
        this.options.columns = normalizedHeaders;
        this.__resetRecord();
        return;
      } catch (err) {
        return err;
      }
    },
    __resetRecord: function () {
      if (this.options.raw === true) {
        this.state.rawBuffer.reset();
      }
      this.state.error = undefined;
      this.state.record = [];
      this.state.record_length = 0;
    },
    __onField: function () {
      const { cast, encoding, rtrim, max_record_size } = this.options;
      const { enabled, wasQuoting } = this.state;
      // Short circuit for the from_line options
      if (enabled === false) {
        return this.__resetField();
      }
      let field = this.state.field.toString(encoding);
      if (rtrim === true && wasQuoting === false) {
        field = field.trimRight();
      }
      if (cast === true) {
        const [err, f] = this.__cast(field);
        if (err !== undefined) return err;
        field = f;
      }
      this.state.record.push(field);
      // Increment record length if record size must not exceed a limit
      if (max_record_size !== 0 && typeof field === "string") {
        this.state.record_length += field.length;
      }
      this.__resetField();
    },
    __resetField: function () {
      this.state.field.reset();
      this.state.wasQuoting = false;
    },
    __push: function (record, push) {
      const { on_record } = this.options;
      if (on_record !== undefined) {
        const info = this.__infoRecord();
        try {
          record = on_record.call(null, record, info);
        } catch (err) {
          return err;
        }
        if (record === undefined || record === null) {
          return;
        }
      }
      push(record);
    },
    // Return a tuple with the error and the casted value
    __cast: function (field) {
      const { columns, relax_column_count } = this.options;
      const isColumns = Array.isArray(columns);
      // Dont loose time calling cast
      // because the final record is an object
      // and this field can't be associated to a key present in columns
      if (
        isColumns === true &&
        relax_column_count &&
        this.options.columns.length <= this.state.record.length
      ) {
        return [undefined, undefined];
      }
      if (this.state.castField !== null) {
        try {
          const info = this.__infoField();
          return [undefined, this.state.castField.call(null, field, info)];
        } catch (err) {
          return [err];
        }
      }
      if (this.__isFloat(field)) {
        return [undefined, parseFloat(field)];
      } else if (this.options.cast_date !== false) {
        const info = this.__infoField();
        return [undefined, this.options.cast_date.call(null, field, info)];
      }
      return [undefined, field];
    },
    // Helper to test if a character is a space or a line delimiter
    __isCharTrimable: function (buf, pos) {
      const isTrim = (buf, pos) => {
        const { timchars } = this.state;
        loop1: for (let i = 0; i < timchars.length; i++) {
          const timchar = timchars[i];
          for (let j = 0; j < timchar.length; j++) {
            if (timchar[j] !== buf[pos + j]) continue loop1;
          }
          return timchar.length;
        }
        return 0;
      };
      return isTrim(buf, pos);
    },
    // Keep it in case we implement the `cast_int` option
    // __isInt(value){
    //   // return Number.isInteger(parseInt(value))
    //   // return !isNaN( parseInt( obj ) );
    //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
    // }
    __isFloat: function (value) {
      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery
    },
    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {
      if (sourceBuf[0] !== firstByte) return 0;
      const sourceLength = sourceBuf.length;
      for (let i = 1; i < sourceLength; i++) {
        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;
      }
      return sourceLength;
    },
    __isDelimiter: function (buf, pos, chr) {
      const { delimiter, ignore_last_delimiters } = this.options;
      if (
        ignore_last_delimiters === true &&
        this.state.record.length === this.options.columns.length - 1
      ) {
        return 0;
      } else if (
        ignore_last_delimiters !== false &&
        typeof ignore_last_delimiters === "number" &&
        this.state.record.length === ignore_last_delimiters - 1
      ) {
        return 0;
      }
      loop1: for (let i = 0; i < delimiter.length; i++) {
        const del = delimiter[i];
        if (del[0] === chr) {
          for (let j = 1; j < del.length; j++) {
            if (del[j] !== buf[pos + j]) continue loop1;
          }
          return del.length;
        }
      }
      return 0;
    },
    __isRecordDelimiter: function (chr, buf, pos) {
      const { record_delimiter } = this.options;
      const recordDelimiterLength = record_delimiter.length;
      loop1: for (let i = 0; i < recordDelimiterLength; i++) {
        const rd = record_delimiter[i];
        const rdLength = rd.length;
        if (rd[0] !== chr) {
          continue;
        }
        for (let j = 1; j < rdLength; j++) {
          if (rd[j] !== buf[pos + j]) {
            continue loop1;
          }
        }
        return rd.length;
      }
      return 0;
    },
    __isEscape: function (buf, pos, chr) {
      const { escape } = this.options;
      if (escape === null) return false;
      const l = escape.length;
      if (escape[0] === chr) {
        for (let i = 0; i < l; i++) {
          if (escape[i] !== buf[pos + i]) {
            return false;
          }
        }
        return true;
      }
      return false;
    },
    __isQuote: function (buf, pos) {
      const { quote } = this.options;
      if (quote === null) return false;
      const l = quote.length;
      for (let i = 0; i < l; i++) {
        if (quote[i] !== buf[pos + i]) {
          return false;
        }
      }
      return true;
    },
    __autoDiscoverRecordDelimiter: function (buf, pos) {
      const { encoding } = this.options;
      // Note, we don't need to cache this information in state,
      // It is only called on the first line until we find out a suitable
      // record delimiter.
      const rds = [
        // Important, the windows line ending must be before mac os 9
        Buffer.from("\r\n", encoding),
        Buffer.from("\n", encoding),
        Buffer.from("\r", encoding),
      ];
      loop: for (let i = 0; i < rds.length; i++) {
        const l = rds[i].length;
        for (let j = 0; j < l; j++) {
          if (rds[i][j] !== buf[pos + j]) {
            continue loop;
          }
        }
        this.options.record_delimiter.push(rds[i]);
        this.state.recordDelimiterMaxLength = rds[i].length;
        return rds[i].length;
      }
      return 0;
    },
    __error: function (msg) {
      const { encoding, raw, skip_records_with_error } = this.options;
      const err = typeof msg === "string" ? new Error(msg) : msg;
      if (skip_records_with_error) {
        this.state.recordHasError = true;
        if (this.options.on_skip !== undefined) {
          this.options.on_skip(
            err,
            raw ? this.state.rawBuffer.toString(encoding) : undefined,
          );
        }
        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
        return undefined;
      } else {
        return err;
      }
    },
    __infoDataSet: function () {
      return {
        ...this.info,
        columns: this.options.columns,
      };
    },
    __infoRecord: function () {
      const { columns, raw, encoding } = this.options;
      return {
        ...this.__infoDataSet(),
        error: this.state.error,
        header: columns === true,
        index: this.state.record.length,
        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined,
      };
    },
    __infoField: function () {
      const { columns } = this.options;
      const isColumns = Array.isArray(columns);
      return {
        ...this.__infoRecord(),
        column:
          isColumns === true
            ? columns.length > this.state.record.length
              ? columns[this.state.record.length].name
              : null
            : this.state.record.length,
        quoting: this.state.wasQuoting,
      };
    },
  };
};

/*
CSV Parse

Please look at the [project documentation](https://csv.js.org/parse/) for
additional information.
*/


class Parser extends Transform {
  constructor(opts = {}) {
    super({ ...{ readableObjectMode: true }, ...opts, encoding: null });
    this.api = transform({
      on_skip: (err, chunk) => {
        this.emit("skip", err, chunk);
      },
      ...opts,
    });
    // Backward compatibility
    this.state = this.api.state;
    this.options = this.api.options;
    this.info = this.api.info;
  }
  // Implementation of `Transform._transform`
  _transform(buf, _, callback) {
    if (this.state.stop === true) {
      return;
    }
    const err = this.api.parse(
      buf,
      false,
      (record) => {
        this.push(record);
      },
      () => {
        this.push(null);
        this.end();
        // Fix #333 and break #410
        //   ko: api.stream.iterator.coffee
        //   ko with v21.4.0, ok with node v20.5.1: api.stream.finished # aborted (with generate())
        //   ko: api.stream.finished # aborted (with Readable)
        // this.destroy()
        // Fix #410 and partially break #333
        //   ok: api.stream.iterator.coffee
        //   ok: api.stream.finished # aborted (with generate())
        //   broken: api.stream.finished # aborted (with Readable)
        this.on("end", this.destroy);
      },
    );
    if (err !== undefined) {
      this.state.stop = true;
    }
    callback(err);
  }
  // Implementation of `Transform._flush`
  _flush(callback) {
    if (this.state.stop === true) {
      return;
    }
    const err = this.api.parse(
      undefined,
      true,
      (record) => {
        this.push(record);
      },
      () => {
        this.push(null);
        this.on("end", this.destroy);
      },
    );
    callback(err);
  }
}

const parse = function () {
  let data, options, callback;
  for (const i in arguments) {
    const argument = arguments[i];
    const type = typeof argument;
    if (
      data === undefined &&
      (typeof argument === "string" || Buffer.isBuffer(argument))
    ) {
      data = argument;
    } else if (options === undefined && is_object(argument)) {
      options = argument;
    } else if (callback === undefined && type === "function") {
      callback = argument;
    } else {
      throw new CsvError(
        "CSV_INVALID_ARGUMENT",
        ["Invalid argument:", `got ${JSON.stringify(argument)} at index ${i}`],
        options || {},
      );
    }
  }
  const parser = new Parser(options);
  if (callback) {
    const records =
      options === undefined || options.objname === undefined ? [] : {};
    parser.on("readable", function () {
      let record;
      while ((record = this.read()) !== null) {
        if (options === undefined || options.objname === undefined) {
          records.push(record);
        } else {
          records[record[0]] = record[1];
        }
      }
    });
    parser.on("error", function (err) {
      callback(err, undefined, parser.api.__infoDataSet());
    });
    parser.on("end", function () {
      callback(undefined, records, parser.api.__infoDataSet());
    });
  }
  if (data !== undefined) {
    const writer = function () {
      parser.write(data);
      parser.end();
    };
    // Support Deno, Rollup doesnt provide a shim for setImmediate
    if (typeof setImmediate === "function") {
      setImmediate(writer);
    } else {
      setTimeout(writer, 0);
    }
  }
  return parser;
};

var chardet = {};

var match$1;
var hasRequiredMatch;

function requireMatch () {
	if (hasRequiredMatch) return match$1;
	hasRequiredMatch = 1;
	match$1 = function(det, rec, confidence, name, lang) {
	  this.confidence = confidence;
	  this.name = name || rec.name(det);
	  this.lang = lang;
	};
	return match$1;
}

var utf8;
var hasRequiredUtf8;

function requireUtf8 () {
	if (hasRequiredUtf8) return utf8;
	hasRequiredUtf8 = 1;
	var Match = requireMatch();

	/**
	 * Charset recognizer for UTF-8
	 */
	utf8 = function() {
	  this.name = function() {
	    return 'UTF-8';
	  };
	  this.match = function(det) {

	    var hasBOM = false,
	      numValid = 0,
	      numInvalid = 0,
	      input = det.fRawInput,
	      trailBytes = 0,
	      confidence;

	    if (det.fRawLength >= 3 &&
	      (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {
	      hasBOM = true;
	    }

	    // Scan for multi-byte sequences
	    for (var i = 0; i < det.fRawLength; i++) {
	      var b = input[i];
	      if ((b & 0x80) == 0)
	        continue; // ASCII

	      // Hi bit on char found.  Figure out how long the sequence should be
	      if ((b & 0x0e0) == 0x0c0) {
	        trailBytes = 1;
	      } else if ((b & 0x0f0) == 0x0e0) {
	        trailBytes = 2;
	      } else if ((b & 0x0f8) == 0xf0) {
	        trailBytes = 3;
	      } else {
	        numInvalid++;
	        if (numInvalid > 5)
	          break;
	        trailBytes = 0;
	      }

	      // Verify that we've got the right number of trail bytes in the sequence
	      for (;;) {
	        i++;
	        if (i >= det.fRawLength)
	          break;

	        if ((input[i] & 0xc0) != 0x080) {
	          numInvalid++;
	          break;
	        }
	        if (--trailBytes == 0) {
	          numValid++;
	          break;
	        }
	      }
	    }

	    // Cook up some sort of confidence score, based on presense of a BOM
	    //    and the existence of valid and/or invalid multi-byte sequences.
	    confidence = 0;
	    if (hasBOM && numInvalid == 0)
	      confidence = 100;
	    else if (hasBOM && numValid > numInvalid * 10)
	      confidence = 80;
	    else if (numValid > 3 && numInvalid == 0)
	      confidence = 100;
	    else if (numValid > 0 && numInvalid == 0)
	      confidence = 80;
	    else if (numValid == 0 && numInvalid == 0)
	      // Plain ASCII.
	      confidence = 10;
	    else if (numValid > numInvalid * 10)
	      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.
	      confidence = 25;
	    else
	      return null

	    return new Match(det, this, confidence);
	  };
	};
	return utf8;
}

var unicode = {exports: {}};

var hasRequiredUnicode;

function requireUnicode () {
	if (hasRequiredUnicode) return unicode.exports;
	hasRequiredUnicode = 1;
	(function (module) {
		var util = require$$0$6,
		  Match = requireMatch();

		/**
		 * This class matches UTF-16 and UTF-32, both big- and little-endian. The
		 * BOM will be used if it is present.
		 */
		module.exports.UTF_16BE = function() {
		  this.name = function() {
		    return 'UTF-16BE';
		  };
		  this.match = function(det) {
		    var input = det.fRawInput;

		    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff)) {
		      return new Match(det, this, 100); // confidence = 100
		    }

		    // TODO: Do some statistics to check for unsigned UTF-16BE
		    return null;
		  };
		};

		module.exports.UTF_16LE = function() {
		  this.name = function() {
		    return 'UTF-16LE';
		  };
		  this.match = function(det) {
		    var input = det.fRawInput;

		    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {
		      // LE BOM is present.
		      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {
		        // It is probably UTF-32 LE, not UTF-16
		        return null;
		      }
		      return new Match(det, this, 100); // confidence = 100
		    }

		    // TODO: Do some statistics to check for unsigned UTF-16LE
		    return null;
		  };
		};

		function UTF_32() {}		UTF_32.prototype.match = function(det) {
		  var input      = det.fRawInput,
		    limit      = (det.fRawLength / 4) * 4,
		    numValid   = 0,
		    numInvalid = 0,
		    hasBOM     = false,
		    confidence = 0;

		  if (limit == 0) {
		    return null;
		  }

		  if (this.getChar(input, 0) == 0x0000FEFF) {
		    hasBOM = true;
		  }

		  for (var i = 0; i < limit; i += 4) {
		    var ch = this.getChar(input, i);

		    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {
		      numInvalid += 1;
		    } else {
		      numValid += 1;
		    }
		  }

		  // Cook up some sort of confidence score, based on presence of a BOM
		  //    and the existence of valid and/or invalid multi-byte sequences.
		  if (hasBOM && numInvalid == 0) {
		    confidence = 100;
		  } else if (hasBOM && numValid > numInvalid * 10) {
		    confidence = 80;
		  } else if (numValid > 3 && numInvalid == 0) {
		    confidence = 100;
		  } else if (numValid > 0 && numInvalid == 0) {
		    confidence = 80;
		  } else if (numValid > numInvalid * 10) {
		    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.
		    confidence = 25;
		  }

		  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
		  return confidence == 0 ? null : new Match(det, this, confidence);
		};

		module.exports.UTF_32BE = function() {
		  this.name = function() {
		    return 'UTF-32BE';
		  };
		  this.getChar = function(input, index) {
		    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |
		         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);
		  };
		};
		util.inherits(module.exports.UTF_32BE, UTF_32);

		module.exports.UTF_32LE = function() {
		  this.name = function() {
		    return 'UTF-32LE';
		  };
		  this.getChar = function(input, index) {
		    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |
		         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);
		  };
		};
		util.inherits(module.exports.UTF_32LE, UTF_32); 
	} (unicode));
	return unicode.exports;
}

var mbcs = {exports: {}};

var hasRequiredMbcs;

function requireMbcs () {
	if (hasRequiredMbcs) return mbcs.exports;
	hasRequiredMbcs = 1;
	(function (module) {
		var util = require$$0$6,
		  Match = requireMatch();

		/**
		 * Binary search implementation (recursive)
		 */
		function binarySearch(arr, searchValue) {
		  function find(arr, searchValue, left, right) {
		    if (right < left)
		      return -1;

		    /*
		    int mid = mid = (left + right) / 2;
		    There is a bug in the above line;
		    Joshua Bloch suggests the following replacement:
		    */
		    var mid = Math.floor((left + right) >>> 1);
		    if (searchValue > arr[mid])
		      return find(arr, searchValue, mid + 1, right);

		    if (searchValue < arr[mid])
		      return find(arr, searchValue, left, mid - 1);

		    return mid;
		  }
		  return find(arr, searchValue, 0, arr.length - 1);
		}
		// 'Character'  iterated character class.
		//    Recognizers for specific mbcs encodings make their 'characters' available
		//    by providing a nextChar() function that fills in an instance of iteratedChar
		//    with the next char from the input.
		//    The returned characters are not converted to Unicode, but remain as the raw
		//    bytes (concatenated into an int) from the codepage data.
		//
		//  For Asian charsets, use the raw input rather than the input that has been
		//   stripped of markup.  Detection only considers multi-byte chars, effectively
		//   stripping markup anyway, and double byte chars do occur in markup too.
		//
		function IteratedChar() {

		  this.charValue = 0; // 1-4 bytes from the raw input data
		  this.index     = 0;
		  this.nextIndex = 0;
		  this.error     = false;
		  this.done      = false;

		  this.reset = function() {
		    this.charValue = 0;
		    this.index     = -1;
		    this.nextIndex = 0;
		    this.error     = false;
		    this.done      = false;
		  };

		  this.nextByte = function(det) {
		    if (this.nextIndex >= det.fRawLength) {
		      this.done = true;
		      return -1;
		    }
		    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;
		    return byteValue;
		  };
		}


		/**
		 * Asian double or multi-byte - charsets.
		 * Match is determined mostly by the input data adhering to the
		 * encoding scheme for the charset, and, optionally,
		 * frequency-of-occurence of characters.
		 */

		function mbcs() {}
		/**
		 * Test the match of this charset with the input text data
		 *      which is obtained via the CharsetDetector object.
		 *
		 * @param det  The CharsetDetector, which contains the input text
		 *             to be checked for being in this charset.
		 * @return     Two values packed into one int  (Damn java, anyhow)
		 *             bits 0-7:  the match confidence, ranging from 0-100
		 *             bits 8-15: The match reason, an enum-like value.
		 */
		mbcs.prototype.match = function(det) {

		  var doubleByteCharCount = 0,
		    commonCharCount     = 0,
		    badCharCount        = 0,
		    totalCharCount      = 0,
		    confidence          = 0;

		  var iter = new IteratedChar();

		  detectBlock: {
		    for (iter.reset(); this.nextChar(iter, det);) {
		      totalCharCount++;
		      if (iter.error) {
		        badCharCount++;
		      } else {
		        var cv = iter.charValue & 0xFFFFFFFF;

		        if (cv <= 0xff) ; else {
		          doubleByteCharCount++;
		          if (this.commonChars != null) {
		            // NOTE: This assumes that there are no 4-byte common chars.
		            if (binarySearch(this.commonChars, cv) >= 0) {
		              commonCharCount++;
		            }
		          }
		        }
		      }
		      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {
		        // console.log('its here!')
		        // Bail out early if the byte data is not matching the encoding scheme.
		        break detectBlock;
		      }
		    }

		    if (doubleByteCharCount <= 10 && badCharCount== 0) {
		      // Not many multi-byte chars.
		      if (doubleByteCharCount == 0 && totalCharCount < 10) {
		        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.
		        // We don't have enough data to have any confidence.
		        // Statistical analysis of single byte non-ASCII charcters would probably help here.
		        confidence = 0;
		      }
		      else {
		        //   ASCII or ISO file?  It's probably not our encoding,
		        //   but is not incompatible with our encoding, so don't give it a zero.
		        confidence = 10;
		      }
		      break detectBlock;
		    }

		    //
		    //  No match if there are too many characters that don't fit the encoding scheme.
		    //    (should we have zero tolerance for these?)
		    //
		    if (doubleByteCharCount < 20 * badCharCount) {
		      confidence = 0;
		      break detectBlock;
		    }

		    if (this.commonChars == null) {
		      // We have no statistics on frequently occuring characters.
		      //  Assess confidence purely on having a reasonable number of
		      //  multi-byte characters (the more the better
		      confidence = 30 + doubleByteCharCount - 20 * badCharCount;
		      if (confidence > 100) {
		        confidence = 100;
		      }
		    } else {
		      //
		      // Frequency of occurence statistics exist.
		      //
		      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);
		      var scaleFactor = 90.0 / maxVal;
		      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
		      confidence = Math.min(confidence, 100);
		    }
		  }   // end of detectBlock:

		  return confidence == 0 ? null : new Match(det, this, confidence);
		};

		/**
		 * Get the next character (however many bytes it is) from the input data
		 *    Subclasses for specific charset encodings must implement this function
		 *    to get characters according to the rules of their encoding scheme.
		 *
		 *  This function is not a method of class iteratedChar only because
		 *   that would require a lot of extra derived classes, which is awkward.
		 * @param it  The iteratedChar 'struct' into which the returned char is placed.
		 * @param det The charset detector, which is needed to get at the input byte data
		 *            being iterated over.
		 * @return    True if a character was returned, false at end of input.
		 */

		mbcs.prototype.nextChar = function(iter, det) {};



		/**
		 * Shift-JIS charset recognizer.
		 */
		module.exports.sjis = function() {
		  this.name = function() {
		    return 'Shift-JIS';
		  };
		  this.language = function() {
		    return 'ja';
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,
		    0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,
		    0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,
		    0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,
		    0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,
		    0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa
		  ];

		  this.nextChar = function(iter, det) {
		    iter.index = iter.nextIndex;
		    iter.error = false;

		    var firstByte;
		    firstByte = iter.charValue = iter.nextByte(det);
		    if (firstByte < 0)
		      return false;

		    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))
		      return true;

		    var secondByte = iter.nextByte(det);
		    if (secondByte < 0)
		      return false;

		    iter.charValue = (firstByte << 8) | secondByte;
		    if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {
		      // Illegal second byte value.
		      iter.error = true;
		    }
		    return true;
		  };
		};
		util.inherits(module.exports.sjis, mbcs);



		/**
		 *   Big5 charset recognizer.
		 */
		module.exports.big5 = function() {
		  this.name = function() {
		    return 'Big5';
		  };
		  this.language = function() {
		    return 'zh';
		  };
		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,
		    0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,
		    0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,
		    0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,
		    0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,
		    0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,
		    0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,
		    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,
		    0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,
		    0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f
		  ];
		  this.nextChar = function(iter, det) {
		    iter.index = iter.nextIndex;
		    iter.error = false;

		    var firstByte = iter.charValue = iter.nextByte(det);

		    if (firstByte < 0)
		      return false;

		    // single byte character.
		    if (firstByte <= 0x7f || firstByte == 0xff)
		      return true;

		    var secondByte = iter.nextByte(det);

		    if (secondByte < 0)
		      return false;

		    iter.charValue = (iter.charValue << 8) | secondByte;

		    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)
		      iter.error = true;

		    return true;
		  };
		};
		util.inherits(module.exports.big5, mbcs);



		/**
		 *  EUC charset recognizers.  One abstract class that provides the common function
		 *  for getting the next character according to the EUC encoding scheme,
		 *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.
		 *
		 *  Get the next character value for EUC based encodings.
		 *  Character 'value' is simply the raw bytes that make up the character
		 *     packed into an int.
		 */
		function eucNextChar(iter, det) {
		  iter.index = iter.nextIndex;
		  iter.error = false;
		  var firstByte  = 0;
		  var secondByte = 0;
		  var thirdByte  = 0;
		  //int fourthByte = 0;
		  buildChar: {
		    firstByte = iter.charValue = iter.nextByte(det);
		    if (firstByte < 0) {
		      // Ran off the end of the input data
		      iter.done = true;
		      break buildChar;
		    }
		    if (firstByte <= 0x8d) {
		      // single byte char
		      break buildChar;
		    }
		    secondByte = iter.nextByte(det);
		    iter.charValue = (iter.charValue << 8) | secondByte;
		    if (firstByte >= 0xA1 && firstByte <= 0xfe) {
		      // Two byte Char
		      if (secondByte < 0xa1) {
		        iter.error = true;
		      }
		      break buildChar;
		    }
		    if (firstByte == 0x8e) {
		      // Code Set 2.
		      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.
		      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.
		      // We don't know which we've got.
		      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two
		      //   bytes will look like a well formed 2 byte char.
		      if (secondByte < 0xa1) {
		        iter.error = true;
		      }
		      break buildChar;
		    }
		    if (firstByte == 0x8f) {
		      // Code set 3.
		      // Three byte total char size, two bytes of actual char value.
		      thirdByte = iter.nextByte(det);
		      iter.charValue = (iter.charValue << 8) | thirdByte;
		      if (thirdByte < 0xa1) {
		        iter.error = true;
		      }
		    }
		  }
		  return iter.done == false;
		}


		/**
		 * The charset recognize for EUC-JP.  A singleton instance of this class
		 *    is created and kept by the public CharsetDetector class
		 */
		module.exports.euc_jp = function() {
		  this.name = function() {
		    return 'EUC-JP';
		  };
		  this.language = function() {
		    return 'ja';
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,
		    0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,
		    0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,
		    0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,
		    0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,
		    0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,
		    0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,
		    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,
		    0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,
		    0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1
		  ];

		  this.nextChar = eucNextChar;
		};
		util.inherits(module.exports.euc_jp, mbcs);



		/**
		 * The charset recognize for EUC-KR.  A singleton instance of this class
		 *    is created and kept by the public CharsetDetector class
		 */
		module.exports.euc_kr = function() {
		  this.name = function() {
		    return 'EUC-KR';
		  };
		  this.language = function() {
		    return 'ko';
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,
		    0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,
		    0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,
		    0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,
		    0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,
		    0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,
		    0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,
		    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,
		    0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,
		    0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad
		  ];

		  this.nextChar = eucNextChar;
		};
		util.inherits(module.exports.euc_kr, mbcs);



		/**
		 *   GB-18030 recognizer. Uses simplified Chinese statistics.
		 */
		module.exports.gb_18030 = function() {
		  this.name = function() {
		    return 'GB18030';
		  };
		  this.language = function() {
		    return 'zh';
		  };

		  /*
		   *  Get the next character value for EUC based encodings.
		   *  Character 'value' is simply the raw bytes that make up the character
		   *     packed into an int.
		   */
		  this.nextChar = function(iter, det) {
		    iter.index = iter.nextIndex;
		    iter.error = false;
		    var firstByte  = 0;
		    var secondByte = 0;
		    var thirdByte  = 0;
		    var fourthByte = 0;
		    buildChar: {
		      firstByte = iter.charValue = iter.nextByte(det);
		      if (firstByte < 0) {
		        // Ran off the end of the input data
		        iter.done = true;
		        break buildChar;
		      }
		      if (firstByte <= 0x80) {
		        // single byte char
		        break buildChar;
		      }
		      secondByte = iter.nextByte(det);
		      iter.charValue = (iter.charValue << 8) | secondByte;
		      if (firstByte >= 0x81 && firstByte <= 0xFE) {
		        // Two byte Char
		        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {
		          break buildChar;
		        }
		        // Four byte char
		        if (secondByte >= 0x30 && secondByte <= 0x39) {
		          thirdByte = iter.nextByte(det);
		          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {
		            fourthByte = iter.nextByte(det);
		            if (fourthByte >= 0x30 && fourthByte <= 0x39) {
		              iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;
		              break buildChar;
		            }
		          }
		        }
		        iter.error = true;
		        break buildChar;
		      }
		    }
		    return iter.done == false;
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,
		    0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,
		    0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,
		    0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,
		    0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,
		    0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,
		    0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,
		    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,
		    0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,
		    0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0
		  ];
		};
		util.inherits(module.exports.gb_18030, mbcs); 
	} (mbcs));
	return mbcs.exports;
}

var sbcs = {exports: {}};

var hasRequiredSbcs;

function requireSbcs () {
	if (hasRequiredSbcs) return sbcs.exports;
	hasRequiredSbcs = 1;
	(function (module) {
		var util = require$$0$6,
		  Match = requireMatch();

		/**
		 * This class recognizes single-byte encodings. Because the encoding scheme is so
		 * simple, language statistics are used to do the matching.
		 */

		function NGramParser(theNgramList, theByteMap) {
		  var N_GRAM_MASK = 0xFFFFFF;

		  this.byteIndex = 0;
		  this.ngram = 0;

		  this.ngramList = theNgramList;
		  this.byteMap = theByteMap;

		  this.ngramCount = 0;
		  this.hitCount = 0;

		  this.spaceChar;

		  /*
		   * Binary search for value in table, which must have exactly 64 entries.
		   */
		  this.search = function(table, value) {
		    var index = 0;

		    if (table[index + 32] <= value) index += 32;
		    if (table[index + 16] <= value) index += 16;
		    if (table[index + 8]  <= value) index += 8;
		    if (table[index + 4]  <= value) index += 4;
		    if (table[index + 2]  <= value) index += 2;
		    if (table[index + 1]  <= value) index += 1;
		    if (table[index]      > value)  index -= 1;

		    if (index < 0 || table[index] != value)
		      return -1;

		    return index;
		  };

		  this.lookup = function(thisNgram) {
		    this.ngramCount += 1;
		    if (this.search(this.ngramList, thisNgram) >= 0) {
		      this.hitCount += 1;
		    }
		  };

		  this.addByte = function(b) {
		    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;
		    this.lookup(this.ngram);
		  };

		  this.nextByte = function(det) {
		    if (this.byteIndex >= det.fInputLen)
		      return -1;

		    return det.fInputBytes[this.byteIndex++] & 0xFF;
		  };

		  this.parse = function(det, spaceCh) {
		    var b, ignoreSpace = false;
		    this.spaceChar = spaceCh;

		    while ((b = this.nextByte(det)) >= 0) {
		      var mb = this.byteMap[b];

		      // TODO: 0x20 might not be a space in all character sets...
		      if (mb != 0) {
		        if (!(mb == this.spaceChar && ignoreSpace)) {
		          this.addByte(mb);
		        }

		        ignoreSpace = (mb == this.spaceChar);
		      }
		    }

		    // TODO: Is this OK? The buffer could have ended in the middle of a word...
		    this.addByte(this.spaceChar);

		    var rawPercent = this.hitCount / this.ngramCount;

		    // TODO - This is a bit of a hack to take care of a case
		    // were we were getting a confidence of 135...
		    if (rawPercent > 0.33)
		      return 98;

		    return Math.floor(rawPercent * 300.0);
		  };
		}
		function NGramsPlusLang(la, ng) {
		  this.fLang = la;
		  this.fNGrams = ng;
		}
		function sbcs() {}		sbcs.prototype.spaceChar = 0x20;
		sbcs.prototype.ngrams = function() {};
		sbcs.prototype.byteMap = function() {};
		sbcs.prototype.match = function(det) {

		  var ngrams = this.ngrams();
		  var multiple = (Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang);

		  if (!multiple) {
		    var parser = new NGramParser(ngrams, this.byteMap());
		    var confidence = parser.parse(det, this.spaceChar);
		    return confidence <= 0 ? null : new Match(det, this, confidence);
		  }

		  var bestConfidenceSoFar = -1;
		  var lang = null;

		  for (var i = ngrams.length - 1; i >= 0; i--) {
		    var ngl = ngrams[i];

		    var parser = new NGramParser(ngl.fNGrams, this.byteMap());
		    var confidence = parser.parse(det, this.spaceChar);
		    if (confidence > bestConfidenceSoFar) {
		      bestConfidenceSoFar = confidence;
		      lang = ngl.fLang;
		    }
		  }

		  var name = this.name(det);
		  return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
		};


		module.exports.ISO_8859_1 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      new NGramsPlusLang('da', [
		        0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,
		        0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,
		        0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574,
		        0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,
		        0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67,
		        0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,
		        0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065,
		        0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572
		      ]),
		      new NGramsPlusLang('de', [
		        0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765,
		        0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,
		        0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E,
		        0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,
		        0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65,
		        0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,
		        0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368,
		        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572
		      ]),
		      new NGramsPlusLang('en', [
		        0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E,
		        0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,
		        0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465,
		        0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,
		        0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20,
		        0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,
		        0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169,
		        0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320
		      ]),
		      new NGramsPlusLang('es', [
		        0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E,
		        0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
		        0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369,
		        0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,
		        0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320,
		        0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,
		        0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573,
		        0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20
		      ]),
		      new NGramsPlusLang('fr', [
		        0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61,
		        0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,
		        0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520,
		        0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,
		        0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420,
		        0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,
		        0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064,
		        0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220
		      ]),
		      new NGramsPlusLang('it', [
		        0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E,
		        0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,
		        0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064,
		        0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,
		        0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20,
		        0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,
		        0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572,
		        0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F
		      ]),
		      new NGramsPlusLang('nl', [
		        0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765,
		        0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,
		        0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220,
		        0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,
		        0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520,
		        0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,
		        0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368,
		        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F
		      ]),
		      new NGramsPlusLang('no', [
		        0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,
		        0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,
		        0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574,
		        0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,
		        0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520,
		        0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,
		        0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465,
		        0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572
		      ]),
		      new NGramsPlusLang('pt', [
		        0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61,
		        0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
		        0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20,
		        0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,
		        0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120,
		        0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,
		        0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064,
		        0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F
		      ]),
		      new NGramsPlusLang('sv', [
		        0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E,
		        0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,
		        0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474,
		        0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,
		        0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564,
		        0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,
		        0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073,
		        0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,
		      ])
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1252' : 'ISO-8859-1';
		  };
		};
		util.inherits(module.exports.ISO_8859_1, sbcs);


		module.exports.ISO_8859_2 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20,
		      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,
		      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7,
		      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      new NGramsPlusLang('cs', [
		        0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64,
		        0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,
		        0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073,
		        0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,
		        0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E,
		        0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,
		        0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20,
		        0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,
		      ]),
		      new NGramsPlusLang('hu', [
		        0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F,
		        0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,
		        0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073,
		        0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,
		        0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920,
		        0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,
		        0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74,
		        0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,
		      ]),
		      new NGramsPlusLang('pl', [
		        0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61,
		        0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,
		        0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79,
		        0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,
		        0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920,
		        0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,
		        0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69,
		        0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,
		      ]),
		      new NGramsPlusLang('ro', [
		        0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469,
		        0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,
		        0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172,
		        0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,
		        0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063,
		        0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,
		        0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520,
		        0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,
		      ])
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1250' : 'ISO-8859-2';
		  };
		};
		util.inherits(module.exports.ISO_8859_2, sbcs);


		module.exports.ISO_8859_5 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0,
		      0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,
		      0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2,
		      0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,
		      0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF,
		      0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,
		      0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2,
		      0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520
		    ];
		  };

		  this.name = function(det) {
		    return 'ISO-8859-5';
		  };

		  this.language = function() {
		    return 'ru';
		  };
		};
		util.inherits(module.exports.ISO_8859_5, sbcs);


		module.exports.ISO_8859_6 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7,
		      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,
		      0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5,
		      0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,
		      0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,
		      0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,
		      0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4,
		      0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620
		    ];
		  };

		  this.name = function(det) {
		    return 'ISO-8859-6';
		  };

		  this.language = function() {
		    return 'ar';
		  };
		};
		util.inherits(module.exports.ISO_8859_6, sbcs);


		module.exports.ISO_8859_7 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20,
		      0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20, 0xFD, 0xFE,
		      0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5,
		      0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,
		      0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220,
		      0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,
		      0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0,
		      0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,
		      0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9,
		      0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1253' : 'ISO-8859-7';
		  };

		  this.language = function() {
		    return 'el';
		  };
		};
		util.inherits(module.exports.ISO_8859_7, sbcs);

		module.exports.ISO_8859_8 = function() {

		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      new NGramsPlusLang('he', [
		        0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5,
		        0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,
		        0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE,
		        0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,
		        0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0,
		        0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,
		        0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4,
		        0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,
		      ]),
		      new NGramsPlusLang('he', [
		        0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2,
		        0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,
		        0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4,
		        0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,
		        0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020,
		        0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,
		        0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420,
		        0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,
		      ])
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1255' : 'ISO-8859-8';
		  };

		  this.language = function() {
		    return 'he';
		  };

		};
		util.inherits(module.exports.ISO_8859_8, sbcs);


		module.exports.ISO_8859_9 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C,
		      0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,
		      0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261,
		      0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,
		      0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20,
		      0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,
		      0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E,
		      0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1254' : 'ISO-8859-9';
		  };

		  this.language = function() {
		    return 'tr';
		  };
		};
		util.inherits(module.exports.ISO_8859_9, sbcs);


		module.exports.windows_1251 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x90, 0x83, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,
		      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,
		      0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20,
		      0xB8, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0xBF,
		      0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20,
		      0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE, 0xBE, 0xBF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0,
		      0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,
		      0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2,
		      0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,
		      0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF,
		      0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,
		      0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2,
		      0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520
		    ];
		  };

		  this.name = function(det) {
		    return 'windows-1251';
		  };

		  this.language = function() {
		    return 'ru';
		  };
		};
		util.inherits(module.exports.windows_1251, sbcs);


		module.exports.windows_1256 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x81, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,
		      0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F,
		      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20, 0x20,
		      0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7,
		      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,
		      0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3,
		      0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,
		      0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,
		      0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,
		      0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1,
		      0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420
		    ];
		  };

		  this.name = function(det) {
		    return 'windows-1256';
		  };

		  this.language = function() {
		    return 'ar';
		  };
		};
		util.inherits(module.exports.windows_1256, sbcs);


		module.exports.KOI8_R = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF,
		      0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,
		      0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420,
		      0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,
		      0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3,
		      0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,
		      0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1,
		      0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF
		    ];
		  };

		  this.name = function(det) {
		    return 'KOI8-R';
		  };

		  this.language = function() {
		    return 'ru';
		  };
		};
		util.inherits(module.exports.KOI8_R, sbcs);


		/*
		module.exports.ISO_8859_7 = function() {
		  this.byteMap = function() {
		    return [

		    ];
		  };

		  this.ngrams = function() {
		    return [

		    ];
		  };

		  this.name = function(det) {
		    if (typeof det == 'undefined')
		      return 'ISO-8859-7';
		    return det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';
		  };

		  this.language = function() {
		    return 'el';
		  };
		};
		util.inherits(module.exports.ISO_8859_7, sbcs);
		*/ 
	} (sbcs));
	return sbcs.exports;
}

var iso2022 = {exports: {}};

var hasRequiredIso2022;

function requireIso2022 () {
	if (hasRequiredIso2022) return iso2022.exports;
	hasRequiredIso2022 = 1;
	(function (module) {
		var util = require$$0$6,
		  Match = requireMatch();


		/**
		 * This is a superclass for the individual detectors for
		 * each of the detectable members of the ISO 2022 family
		 * of encodings.
		 */

		function ISO_2022() {}

		ISO_2022.prototype.match = function(det) {

		  /**
		   * Matching function shared among the 2022 detectors JP, CN and KR
		   * Counts up the number of legal an unrecognized escape sequences in
		   * the sample of text, and computes a score based on the total number &
		   * the proportion that fit the encoding.
		   *
		   *
		   * @param text the byte buffer containing text to analyse
		   * @param textLen  the size of the text in the byte.
		   * @param escapeSequences the byte escape sequences to test for.
		   * @return match quality, in the range of 0-100.
		   */

		  var i, j;
		  var escN;
		  var hits   = 0;
		  var misses = 0;
		  var shifts = 0;
		  var quality;

		  // TODO: refactor me
		  var text = det.fInputBytes;
		  var textLen = det.fInputLen;

		  scanInput:
		    for (i = 0; i < textLen; i++) {
		      if (text[i] == 0x1b) {
		        checkEscapes:
		          for (escN = 0; escN < this.escapeSequences.length; escN++) {
		            var seq = this.escapeSequences[escN];

		            if ((textLen - i) < seq.length)
		              continue checkEscapes;

		            for (j = 1; j < seq.length; j++)
		              if (seq[j] != text[i + j])
		                continue checkEscapes;


		            hits++;
		            i += seq.length - 1;
		            continue scanInput;
		          }

		          misses++;
		      }

		      // Shift in/out
		      if (text[i] == 0x0e || text[i] == 0x0f)
		        shifts++;

		    }

		  if (hits == 0)
		    return null;

		  //
		  // Initial quality is based on relative proportion of recongized vs.
		  //   unrecognized escape sequences.
		  //   All good:  quality = 100;
		  //   half or less good: quality = 0;
		  //   linear inbetween.
		  quality = (100 * hits - 100 * misses) / (hits + misses);

		  // Back off quality if there were too few escape sequences seen.
		  //   Include shifts in this computation, so that KR does not get penalized
		  //   for having only a single Escape sequence, but many shifts.
		  if (hits + shifts < 5)
		    quality -= (5 - (hits + shifts)) * 10;

		  return quality <= 0 ? null : new Match(det, this, quality);
		};

		module.exports.ISO_2022_JP = function() {
		  this.name = function() {
		    return 'ISO-2022-JP';
		  };
		  this.escapeSequences = [
		    [ 0x1b, 0x24, 0x28, 0x43 ],   // KS X 1001:1992
		    [ 0x1b, 0x24, 0x28, 0x44 ],   // JIS X 212-1990
		    [ 0x1b, 0x24, 0x40 ],         // JIS C 6226-1978
		    [ 0x1b, 0x24, 0x41 ],         // GB 2312-80
		    [ 0x1b, 0x24, 0x42 ],         // JIS X 208-1983
		    [ 0x1b, 0x26, 0x40 ],         // JIS X 208 1990, 1997
		    [ 0x1b, 0x28, 0x42 ],         // ASCII
		    [ 0x1b, 0x28, 0x48 ],         // JIS-Roman
		    [ 0x1b, 0x28, 0x49 ],         // Half-width katakana
		    [ 0x1b, 0x28, 0x4a ],         // JIS-Roman
		    [ 0x1b, 0x2e, 0x41 ],         // ISO 8859-1
		    [ 0x1b, 0x2e, 0x46 ]          // ISO 8859-7
		  ];
		};
		util.inherits(module.exports.ISO_2022_JP, ISO_2022);



		module.exports.ISO_2022_KR = function() {
		  this.name = function() {
		    return 'ISO-2022-KR';
		  };
		  this.escapeSequences = [
		    [ 0x1b, 0x24, 0x29, 0x43 ]
		  ];
		};
		util.inherits(module.exports.ISO_2022_KR, ISO_2022);



		module.exports.ISO_2022_CN = function() {
		  this.name = function() {
		    return 'ISO-2022-CN';
		  };
		  this.escapeSequences = [
		    [ 0x1b, 0x24, 0x29, 0x41 ],   // GB 2312-80
		    [ 0x1b, 0x24, 0x29, 0x47 ],   // CNS 11643-1992 Plane 1
		    [ 0x1b, 0x24, 0x2A, 0x48 ],   // CNS 11643-1992 Plane 2
		    [ 0x1b, 0x24, 0x29, 0x45 ],   // ISO-IR-165
		    [ 0x1b, 0x24, 0x2B, 0x49 ],   // CNS 11643-1992 Plane 3
		    [ 0x1b, 0x24, 0x2B, 0x4A ],   // CNS 11643-1992 Plane 4
		    [ 0x1b, 0x24, 0x2B, 0x4B ],   // CNS 11643-1992 Plane 5
		    [ 0x1b, 0x24, 0x2B, 0x4C ],   // CNS 11643-1992 Plane 6
		    [ 0x1b, 0x24, 0x2B, 0x4D ],   // CNS 11643-1992 Plane 7
		    [ 0x1b, 0x4e ],               // SS2
		    [ 0x1b, 0x4f ]                // SS3
		  ];
		};
		util.inherits(module.exports.ISO_2022_CN, ISO_2022); 
	} (iso2022));
	return iso2022.exports;
}

var hasRequiredChardet;

function requireChardet () {
	if (hasRequiredChardet) return chardet;
	hasRequiredChardet = 1;
	var fs$1 = fs;

	var utf8  = requireUtf8(),
	  unicode = requireUnicode(),
	  mbcs    = requireMbcs(),
	  sbcs    = requireSbcs(),
	  iso2022 = requireIso2022();

	var self = chardet;

	var recognisers = [
	  new utf8,
	  new unicode.UTF_16BE,
	  new unicode.UTF_16LE,
	  new unicode.UTF_32BE,
	  new unicode.UTF_32LE,
	  new mbcs.sjis,
	  new mbcs.big5,
	  new mbcs.euc_jp,
	  new mbcs.euc_kr,
	  new mbcs.gb_18030,
	  new iso2022.ISO_2022_JP,
	  new iso2022.ISO_2022_KR,
	  new iso2022.ISO_2022_CN,
	  new sbcs.ISO_8859_1,
	  new sbcs.ISO_8859_2,
	  new sbcs.ISO_8859_5,
	  new sbcs.ISO_8859_6,
	  new sbcs.ISO_8859_7,
	  new sbcs.ISO_8859_8,
	  new sbcs.ISO_8859_9,
	  new sbcs.windows_1251,
	  new sbcs.windows_1256,
	  new sbcs.KOI8_R
	];

	chardet.detect = function(buffer, opts) {

	  // Tally up the byte occurence statistics.
	  var fByteStats = [];
	  for (var i = 0; i < 256; i++)
	    fByteStats[i] = 0;

	  for (var i = buffer.length - 1; i >= 0; i--)
	    fByteStats[buffer[i] & 0x00ff]++;

	  var fC1Bytes = false;
	  for (var i = 0x80; i <= 0x9F; i += 1) {
	    if (fByteStats[i] != 0) {
	      fC1Bytes = true;
	      break;
	    }
	  }

	  var context = {
	    fByteStats:  fByteStats,
	    fC1Bytes:    fC1Bytes,
	    fRawInput:   buffer,
	    fRawLength:  buffer.length,
	    fInputBytes: buffer,
	    fInputLen:   buffer.length
	  };

	  var matches = recognisers.map(function(rec) {
	    return rec.match(context);
	  }).filter(function(match) {
	    return !!match;
	  }).sort(function(a, b) {
	    return b.confidence - a.confidence;
	  });

	  if (opts && opts.returnAllMatches === true) {
	    return matches;
	  }
	  else {
	    return matches.length > 0 ? matches[0].name : null;
	  }
	};

	chardet.detectFile = function(filepath, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = undefined;
	  }

	  var fd;

	  var handler = function(err, buffer) {
	    if (fd) {
	      fs$1.closeSync(fd);
	    }

	    if (err) return cb(err, null);
	    cb(null, self.detect(buffer, opts));
	  };

	  if (opts && opts.sampleSize) {
	    fd = fs$1.openSync(filepath, 'r'),
	      sample = Buffer.allocUnsafe(opts.sampleSize);

	    fs$1.read(fd, sample, 0, opts.sampleSize, null, function(err) {
	      handler(err, sample);
	    });
	    return;
	  }

	  fs$1.readFile(filepath, handler);
	};

	chardet.detectFileSync = function(filepath, opts) {
	  if (opts && opts.sampleSize) {
	    var fd = fs$1.openSync(filepath, 'r'),
	      sample = Buffer.allocUnsafe(opts.sampleSize);

	    fs$1.readSync(fd, sample, 0, opts.sampleSize);
	    fs$1.closeSync(fd);
	    return self.detect(sample, opts);
	  }

	  return self.detect(fs$1.readFileSync(filepath), opts);
	};

	// Wrappers for the previous functions to return all encodings
	chardet.detectAll = function(buffer, opts) {
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  return self.detect(buffer, opts);
	};

	chardet.detectFileAll = function(filepath, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = undefined;
	  }
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  self.detectFile(filepath, opts, cb);
	};

	chardet.detectFileAllSync = function(filepath, opts) {
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  return self.detectFileSync(filepath, opts);
	};
	return chardet;
}

var chardetExports = requireChardet();

// Constants
const SAMPLE_THRESHOLD = 50 * 1024 * 1024; // 50MB
const MAX_MEMORY_ROWS = 100000; // Maximum rows to keep in memory
const MAX_ROWS_FOR_FULL_ANALYSIS = 50000;

// Enhanced path normalization for Windows
function normalizePath(filePath) {
  // Handle Windows paths with spaces and special characters
  let normalized = filePath;
  
  // Remove quotes if present
  normalized = normalized.replace(/^["']|["']$/g, '');
  
  // Convert forward slashes to backslashes on Windows
  if (os$1.platform() === 'win32') {
    normalized = normalized.replace(/\//g, '\\');
  }
  
  // Resolve to absolute path
  normalized = path$1.resolve(normalized);
  
  // On Windows, ensure proper drive letter format
  if (os$1.platform() === 'win32' && normalized.match(/^[a-z]:/i)) {
    normalized = normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }
  
  return normalized;
}

// Enhanced encoding detection with better fallback
function detectEncoding(filePath) {
  try {
    // Normalize the path first
    const normalizedPath = normalizePath(filePath);
    
    // Try chardet first
    const encoding = chardetExports.detectFileSync(normalizedPath, { sampleSize: 65536 });
    
    if (!encoding) {
      console.log(chalk.yellow('Could not detect encoding, checking for BOM...'));
      
      // Check for BOM
      const fd = openSync(normalizedPath, 'r');
      const buffer = Buffer.alloc(4); // Check 4 bytes for UTF-32
      readSync(fd, buffer, 0, 4, 0);
      closeSync(fd);
      
      // Check various BOMs
      if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
        return 'utf8'; // UTF-8 with BOM
      }
      if (buffer[0] === 0xFF && buffer[1] === 0xFE) {
        if (buffer[2] === 0x00 && buffer[3] === 0x00) {
          console.log(chalk.yellow('UTF-32LE detected, will use UTF-8 fallback'));
          return 'utf8'; // UTF-32LE (not supported, fallback)
        }
        return 'utf16le'; // UTF-16LE
      }
      if (buffer[0] === 0xFE && buffer[1] === 0xFF) {
        return 'utf16be'; // UTF-16BE
      }
      if (buffer[0] === 0x00 && buffer[1] === 0x00 && buffer[2] === 0xFE && buffer[3] === 0xFF) {
        console.log(chalk.yellow('UTF-32BE detected, will use UTF-8 fallback'));
        return 'utf8'; // UTF-32BE (not supported, fallback)
      }
      
      // Default to UTF-8
      return 'utf8';
    }
    
    if (encoding && encoding !== 'UTF-8' && encoding !== 'ascii') {
      console.log(chalk.yellow(`Detected ${encoding} encoding (will handle automatically)`));
    }
    
    // Enhanced encoding map with better Windows support
    const encodingMap = {
      'UTF-8': 'utf8',
      'ascii': 'ascii',
      'windows-1250': 'latin1',
      'windows-1251': 'win1251',
      'windows-1252': 'latin1',
      'ISO-8859-1': 'latin1',
      'ISO-8859-2': 'latin1',
      'UTF-16LE': 'utf16le',
      'UTF-16BE': 'utf16be',
      'UTF-32LE': 'utf8', // Fallback
      'UTF-32BE': 'utf8', // Fallback
      'Big5': 'utf8', // Fallback
      'GB2312': 'utf8', // Fallback
      'Shift_JIS': 'utf8', // Fallback
      'EUC-JP': 'utf8', // Fallback
      'EUC-KR': 'utf8' // Fallback
    };
    
    const mappedEncoding = encodingMap[encoding] || 'utf8';
    
    // Warn about unsupported encodings
    if (encoding && !encodingMap[encoding]) {
      console.log(chalk.yellow(`Warning: ${encoding} encoding not fully supported, using UTF-8 fallback`));
    }
    
    return mappedEncoding;
  } catch (error) {
    console.log(chalk.yellow('Encoding detection failed, defaulting to UTF-8'));
    return 'utf8';
  }
}

// Detect CSV delimiter with improved logic
function detectDelimiter(filePath, encoding = 'utf8') {
  try {
    const normalizedPath = normalizePath(filePath);
    const sample = readFileSync(normalizedPath, { encoding, end: 8192 }).toString();
    const lines = sample.split(/\r?\n/).filter(l => l.trim());
    
    if (lines.length < 2) return ',';
    
    const delimiters = [',', ';', '\t', '|'];
    const scores = {};
    
    // Test each delimiter
    for (const delimiter of delimiters) {
      const counts = lines.slice(0, Math.min(10, lines.length)).map(line => {
        // Count occurrences, considering quoted fields
        let count = 0;
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          if (line[i] === '"' && (i === 0 || line[i-1] !== '\\')) {
            inQuotes = !inQuotes;
          } else if (line[i] === delimiter && !inQuotes) {
            count++;
          }
        }
        return count;
      });
      
      // Calculate consistency score
      const avg = counts.reduce((a, b) => a + b, 0) / counts.length;
      if (avg > 0) {
        const variance = counts.reduce((sum, count) => 
          sum + Math.pow(count - avg, 2), 0) / counts.length;
        const consistency = avg / (variance + 1);
        scores[delimiter] = { avg, variance, consistency };
      } else {
        scores[delimiter] = { avg: 0, variance: 0, consistency: 0 };
      }
    }
    
    // Find best delimiter
    let bestDelimiter = ',';
    let bestScore = 0;
    
    for (const [delimiter, score] of Object.entries(scores)) {
      if (score.consistency > bestScore && score.avg > 0) {
        bestScore = score.consistency;
        bestDelimiter = delimiter;
      }
    }
    
    if (bestDelimiter !== ',') {
      console.log(chalk.yellow(`Detected delimiter: ${bestDelimiter === '\t' ? '\\t (tab)' : bestDelimiter}`));
    }
    
    return bestDelimiter;
  } catch (error) {
    console.log(chalk.yellow(`Delimiter detection failed: ${error.message}, using comma`));
    return ',';
  }
}

// Enhanced number parsing
function parseNumber(value) {
  if (typeof value === 'number') return value;
  if (typeof value !== 'string') return null;
  
  const trimmed = value.trim();
  
  // Reject date-like patterns before attempting number parsing
  if (/\d{4}-\d{2}-\d{2}/.test(trimmed) || 
      /\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4}/.test(trimmed)) {
    return null;
  }
  
  // Remove currency symbols and spaces
  let cleaned = trimmed.replace(/[$€£¥₹\s]/g, '');
  
  // Handle different decimal separators
  if (cleaned.includes(',') && cleaned.includes('.')) {
    // Determine which is decimal separator
    const lastComma = cleaned.lastIndexOf(',');
    const lastDot = cleaned.lastIndexOf('.');
    
    if (lastComma > lastDot) {
      // Comma is decimal separator (European format)
      cleaned = cleaned.replace(/\./g, '').replace(',', '.');
    } else {
      // Dot is decimal separator (US format)
      cleaned = cleaned.replace(/,/g, '');
    }
  } else if (cleaned.includes(',') && !cleaned.includes('.')) {
    // Check if comma is thousands separator or decimal
    const parts = cleaned.split(',');
    if (parts.length === 2 && parts[1].length <= 2) {
      // Likely decimal separator
      cleaned = cleaned.replace(',', '.');
    } else {
      // Likely thousands separator
      cleaned = cleaned.replace(/,/g, '');
    }
  }
  
  // Check for percentage
  if (cleaned.endsWith('%')) {
    const num = parseFloat(cleaned.slice(0, -1));
    return isNaN(num) ? null : num / 100;
  }
  
  // Try parsing
  const num = parseFloat(cleaned);
  return isNaN(num) ? null : num;
}

// Enhanced date parsing with Australian format priority
function parseDate$3(value, dateFormats = null) {
  if (value instanceof Date) return value;
  if (typeof value !== 'string') return null;
  
  const trimmed = value.trim();
  
  // Common date patterns with Australian priority
  const patterns = dateFormats || [
    // ISO formats
    /^\d{4}-\d{2}-\d{2}$/,
    /^\d{4}-\d{2}-\d{2}T/,
    /^\d{4}\/\d{2}\/\d{2}$/,
    // Australian format DD/MM/YYYY (prioritized)
    /^\d{1,2}\/\d{1,2}\/\d{4}$/,
    /^\d{1,2}-\d{1,2}-\d{4}$/,
    /^\d{1,2}\.\d{1,2}\.\d{4}$/,
    // Other formats
    /^\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i,
    /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}/i
  ];
  
  // Check if it matches date patterns
  const hasDatePattern = patterns.some(pattern => 
    pattern.test ? pattern.test(trimmed) : trimmed.match(pattern)
  );
  
  if (!hasDatePattern) return null;
  
  // For DD/MM/YYYY format (Australian), parse explicitly
  if (trimmed.match(/^\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{4}$/)) {
    const separator = trimmed.includes('/') ? '/' : trimmed.includes('-') ? '-' : '.';
    const parts = trimmed.split(separator);
    const day = parseInt(parts[0]);
    const month = parseInt(parts[1]);
    const year = parseInt(parts[2]);
    
    // Validate day and month
    if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {
      // Use Australian format (DD/MM/YYYY)
      const date = new Date(year, month - 1, day);
      
      // Verify the date is valid
      if (date.getDate() === day && date.getMonth() === month - 1 && date.getFullYear() === year) {
        return date;
      }
    }
  }
  
  // Try standard Date parsing for other formats
  const date = new Date(trimmed);
  return isNaN(date.getTime()) ? null : date;
}

// Progress callback wrapper for better UI feedback
function createProgressCallback(spinner, totalSize) {
  let lastUpdate = Date.now();
  const updateInterval = 250; // Update every 250ms
  
  return (progress, rowCount) => {
    const now = Date.now();
    if (now - lastUpdate >= updateInterval) {
      const percentage = Math.round(progress);
      const sizeProcessed = (totalSize * progress / 100 / 1024 / 1024).toFixed(1);
      const totalSizeMB = (totalSize / 1024 / 1024).toFixed(1);
      
      spinner.text = `Processing: ${percentage}% (${sizeProcessed}MB / ${totalSizeMB}MB) - ${rowCount.toLocaleString()} rows processed`;
      lastUpdate = now;
    }
  };
}

// Helper function to attempt parsing with a specific encoding
async function attemptParse(filePath, encoding, options = {}) {
  const normalizedPath = normalizePath(filePath);
  const delimiter = options.delimiter || detectDelimiter(normalizedPath, encoding);
  const fileSize = statSync(normalizedPath).size;
  
  // Progressive sampling logic
  let useSampling = false;
  let sampleRate = 1.0;
  
  if (fileSize > 100 * 1024 * 1024 && !options.noSampling) { // 100MB threshold
    const averageBytesPerRow = 80;
    const estimatedRows = fileSize / averageBytesPerRow;
    
    if (estimatedRows > MAX_ROWS_FOR_FULL_ANALYSIS) {
      useSampling = true;
      sampleRate = Math.min(MAX_ROWS_FOR_FULL_ANALYSIS / estimatedRows, 1);
      
      if (!options.quiet) {
        console.log(chalk.yellow(
          `Large file detected (~${Math.round(estimatedRows).toLocaleString()} estimated rows). ` +
          `Using ${(sampleRate * 100).toFixed(1)}% sampling for performance.`
        ));
      }
    }
  } else if (fileSize > SAMPLE_THRESHOLD && !options.noSampling) {
    useSampling = true;
    sampleRate = 1.0;
  }
  
  return await parseCSVWithEncoding(normalizedPath, encoding, delimiter, useSampling, sampleRate, options);
}

// Core parsing function with better error handling
async function parseCSVWithEncoding(filePath, encoding, delimiter, useSampling, sampleRate, options = {}) {
  const fileSize = statSync(filePath).size;
  const { onProgress } = options;
  
  if (useSampling && sampleRate === 1.0 && !options.quiet) {
    console.log(chalk.yellow(
      `Large file detected (${(fileSize / 1024 / 1024).toFixed(1)}MB). ` +
      `Using reservoir sampling for analysis...`
    ));
  }
  
  const records = [];
  const spinner = options.quiet ? null : ora('Reading CSV file...').start();
  
  // Create progress callback if spinner exists
  const progressCallback = spinner && fileSize > 1024 * 1024 ? 
    createProgressCallback(spinner, fileSize) : null;
  
  let rowCount = 0;
  let errorCount = 0;
  let skipCount = 0;
  let processedBytes = 0;
  
  // Handle headerless CSV files
  const hasHeader = options.header !== false;
  const parserOptions = {
    columns: hasHeader ? true : false,
    skip_empty_lines: true,
    trim: true,
    delimiter,
    encoding,
    relax_quotes: true,
    relax_column_count: true,
    quote: '"',
    escape: '"',
    skip_records_with_error: true,
    bom: true, // Handle BOM automatically
    max_record_size: 1048576, // 1MB max record size
    on_record: (record, { lines }) => {
      // Update progress via spinner
      if (spinner && lines % 1000 === 0) {
        const progress = (processedBytes / fileSize) * 100;
        if (progressCallback) {
          progressCallback(progress, lines);
        } else {
          spinner.text = `Processing row ${lines.toLocaleString()}...`;
        }
      }
      return record;
    },
    cast: (value) => {
      // Enhanced type casting with better error handling and debugging
      if (value === '' || value === null || value === undefined) return null;
      
      // Enhanced type casting
      if (typeof value === 'string') {
        const trimmed = value.trim();
        
        // Handle empty strings after trimming
        if (trimmed === '') return null;
        
        // Handle common null/undefined string representations
        if (['null', 'undefined', 'na', 'n/a', '#n/a', '#null!', 'nil', 'none'].includes(trimmed.toLowerCase())) {
          return null;
        }
        
        // Boolean values
        const lowerCase = trimmed.toLowerCase();
        if (['true', 'false', 'yes', 'no', '1', '0', 'y', 'n'].includes(lowerCase)) {
          return lowerCase === 'true' || lowerCase === 'yes' || lowerCase === '1' || lowerCase === 'y';
        }
        
        // Try number parsing (but be more conservative)
        if (/^[\d\s,.$€£¥₹%-]+$/.test(trimmed) && !/[a-zA-Z]/.test(trimmed)) {
          const num = parseNumber(trimmed);
          if (num !== null && !isNaN(num) && isFinite(num)) {
            return num;
          }
        }
        
        // Try date parsing (more conservative approach)
        if (trimmed.length >= 4 && /\d/.test(trimmed)) {
          const date = parseDate$3(trimmed);
          if (date !== null && date instanceof Date && !isNaN(date.getTime())) {
            return date;
          }
        }
        
        // Return the trimmed string if no conversion worked
        return trimmed;
      }
      
      // For non-string values, validate they're not problematic
      if (typeof value === 'number') {
        if (isNaN(value) || !isFinite(value)) {
          return null; // Convert problematic numbers to null
        }
        return value;
      }
      
      // Return the value as-is if it's already a proper type
      return value;
    }
  };

  const parser = parse({ ...parserOptions, ...options });

  parser.on('skip', (err) => {
    errorCount++;
    if (errorCount <= 5 && !options.quiet) {
      console.log(chalk.red(`\nSkipped row ${err.lines}: ${err.message}`));
    }
  });

  parser.on('error', (err) => {
    if (!options.quiet) {
      console.error(chalk.red(`\nParser error: ${err.message}`));
    }
  });

  try {
    await pipeline(
      createReadStream(filePath, { encoding })
        .on('data', (chunk) => {
          processedBytes += chunk.length;
          if (onProgress) {
            const progress = (processedBytes / fileSize) * 100;
            onProgress(progress, rowCount);
          }
        }),
      parser,
      async function* (source) {
        for await (const record of source) {
          rowCount++;
          
          // Convert array to object if headerless
          let processedRecord = record;
          if (!hasHeader && Array.isArray(record)) {
            processedRecord = {};
            record.forEach((value, index) => {
              processedRecord[`column${index + 1}`] = value;
            });
          }
          
          // Memory management - check less frequently to avoid spam
          let aggressiveSampling = false;
          if (rowCount % 50000 === 0) {  // Check every 50k rows instead of 5k
            const memoryStatus = checkMemoryUsage();
            if (memoryStatus.shouldUseAggressiveSampling && !aggressiveSampling) {
              if (!options.quiet && !records._memoryWarningShown) {
                console.warn(chalk.red(`\nHigh memory usage detected (${memoryStatus.heapUsedGB.toFixed(1)}GB), enabling aggressive sampling`));
                records._memoryWarningShown = true;  // Flag to avoid repeating message
              }
              aggressiveSampling = true;
            }
          }
          
          // Apply sampling
          if (useSampling || aggressiveSampling) {
            if (sampleRate < 1.0 || aggressiveSampling) {
              const effectiveRate = aggressiveSampling ? Math.min(sampleRate * 0.1, 0.01) : sampleRate;
              if (Math.random() < effectiveRate) {
                records.push(processedRecord);
              } else {
                skipCount++;
              }
            } else if (records.length >= MAX_MEMORY_ROWS) {
              // Reservoir sampling
              skipCount++;
              const j = Math.floor(Math.random() * rowCount);
              if (j < MAX_MEMORY_ROWS) {
                records[j] = processedRecord;
              }
            } else {
              records.push(processedRecord);
            }
          } else {
            records.push(processedRecord);
          }
          yield;
        }
      }
    );
    
    if (spinner) {
      spinner.succeed(`Processed ${rowCount.toLocaleString()} rows`);
    }
    
    if (errorCount > 0 && !options.quiet) {
      console.log(chalk.yellow(
        `⚠️  Encountered ${errorCount} problematic rows (skipped)`
      ));
    }
    
    if (skipCount > 0 && !options.quiet) {
      console.log(chalk.blue(
        `ℹ️  Sampled ${records.length.toLocaleString()} rows from ${rowCount.toLocaleString()} total rows`
      ));
    }
    
    return { success: true, data: records };
    
  } catch (error) {
    if (spinner) spinner.error({ text: 'Failed to parse CSV' });
    return { success: false, error };
  }
}

// Main parseCSV function with enhanced fallback mechanism
async function parseCSV(filePath, options = {}) {
  // Normalize the file path first
  const normalizedPath = normalizePath(filePath);
  
  // Check if file exists
  if (!existsSync(normalizedPath)) {
    throw new Error(`File not found: ${normalizedPath}`);
  }
  
  const detectedEncoding = options.encoding || detectEncoding(normalizedPath);
  const detectedDelimiter = detectDelimiter(normalizedPath, detectedEncoding);
  
  // Enhanced fallback encoding list
  const fallbackEncodings = ['utf8', 'latin1', 'utf16le', 'ascii'];
  const encodingsToTry = [detectedEncoding, ...fallbackEncodings.filter(e => e !== detectedEncoding)];
  
  let lastError = null;
  let attempts = [];
  let bestResult = null;
  let debugInfo = {
    fileSize: statSync(normalizedPath).size,
    detectedEncoding,
    detectedDelimiter,
    attempts: []
  };
  
  if (!options.quiet) {
    console.log(chalk.blue(`📊 Parsing CSV: ${normalizedPath}`));
    console.log(chalk.blue(`📏 File size: ${(debugInfo.fileSize / 1024 / 1024).toFixed(2)}MB`));
    console.log(chalk.blue(`🔤 Detected encoding: ${detectedEncoding}`));
    console.log(chalk.blue(`📋 Detected delimiter: ${detectedDelimiter === '\t' ? '\\t (tab)' : detectedDelimiter}`));
  }
  
  for (const encoding of encodingsToTry) {
    try {
      const result = await attemptParse(normalizedPath, encoding, { 
        ...options, 
        delimiter: detectedDelimiter,
        debugMode: true 
      });
      
      const attemptInfo = {
        encoding,
        success: result.success,
        recordCount: result.success ? result.data.length : 0,
        error: result.error?.message || null
      };
      
      debugInfo.attempts.push(attemptInfo);
      
      if (result.success) {
        // Validate the parsed data quality
        const dataQuality = validateParsedData(result.data, normalizedPath);
        attemptInfo.dataQuality = dataQuality;
        
        if (dataQuality.isAcceptable) {
          if (!options.quiet) {
            console.log(chalk.green(`✅ Successfully parsed with ${encoding} encoding`));
            console.log(chalk.green(`📊 Records: ${result.data.length.toLocaleString()}`));
            console.log(chalk.green(`📋 Columns: ${Object.keys(result.data[0] || {}).length}`));
            
            if (dataQuality.warnings.length > 0) {
              console.log(chalk.yellow('⚠️  Data quality warnings:'));
              dataQuality.warnings.forEach(warning => 
                console.log(chalk.yellow(`   • ${warning}`))
              );
            }
          }
          return result.data;
        } else {
          // Data quality is poor, try next encoding
          if (!options.quiet) {
            console.log(chalk.yellow(`⚠️  ${encoding} parsing succeeded but data quality is poor:`));
            dataQuality.issues.forEach(issue => 
              console.log(chalk.yellow(`   • ${issue}`))
            );
          }
          bestResult = bestResult || { result, encoding, dataQuality };
        }
      }
      
      lastError = result.error;
      attempts.push({ encoding, error: result.error?.message || 'Unknown error' });
      if (!options.quiet && encodingsToTry.indexOf(encoding) < encodingsToTry.length - 1) {
        console.log(chalk.yellow(`❌ Failed with ${encoding} encoding, trying next...`));
      }
      continue;
    } catch (e) {
      lastError = e;
      const attemptInfo = {
        encoding,
        success: false,
        recordCount: 0,
        error: e.message
      };
      debugInfo.attempts.push(attemptInfo);
      attempts.push({ encoding, error: e.message });
      if (!options.quiet && encodingsToTry.indexOf(encoding) < encodingsToTry.length - 1) {
        console.log(chalk.yellow(`❌ Failed with ${encoding} encoding: ${e.message}`));
      }
      continue;
    }
  }
  
  // If we have a result with poor quality, use it as fallback
  if (bestResult) {
    if (!options.quiet) {
      console.log(chalk.yellow('📊 Using best available result despite quality issues'));
    }
    return bestResult.result.data;
  }
  
  // Enhanced error message with debugging information
  const attemptDetails = attempts.map(a => `  • ${a.encoding}: ${a.error}`).join('\n');
  const errorMessage = `
🚨 CSV PARSING FAILED

📁 File: ${normalizedPath}
📏 Size: ${(debugInfo.fileSize / 1024 / 1024).toFixed(2)}MB
🔤 Detected encoding: ${detectedEncoding}
📋 Detected delimiter: ${detectedDelimiter === '\t' ? 'TAB' : detectedDelimiter}

❌ All encoding attempts failed:
${attemptDetails}

🔧 TROUBLESHOOTING SUGGESTIONS:

1. 📝 **Check file format**:
   • Ensure the file is actually a CSV (not Excel, XML, etc.)
   • Verify the file isn't corrupted or partially downloaded

2. 🔤 **Try manual encoding**:
   • Convert file to UTF-8 using a text editor
   • Check for non-standard characters in column headers

3. 📋 **Check delimiter**:
   • File might use semicolon (;) or tab (\\t) instead of comma
   • Special characters in data might be interfering

4. 🛠️ **Manual fixes**:
   • Remove or escape special characters from column names
   • Check for embedded newlines in data fields
   • Ensure all rows have the same number of columns

5. 🔍 **Debug mode**:
   • Run with --verbose flag for more detailed error information
   • Check the first few lines of the file manually

📞 If issues persist, please report this with a sample of your data structure.
`;
  
  throw new Error(errorMessage);
}

// Add data validation function
function validateParsedData(records, filePath) {
  const validation = {
    isAcceptable: true,
    warnings: [],
    issues: [],
    metrics: {}
  };
  
  // Check if we have any data
  if (!records || records.length === 0) {
    validation.isAcceptable = false;
    validation.issues.push('No records parsed from file');
    return validation;
  }
  
  // Check for columns
  const firstRecord = records[0];
  const columnCount = Object.keys(firstRecord || {}).length;
  validation.metrics.columnCount = columnCount;
  
  if (columnCount === 0) {
    validation.isAcceptable = false;
    validation.issues.push('No columns detected in parsed data');
    return validation;
  }
  
  // Check for undefined/null dominance
  let totalCells = 0;
  let undefinedCells = 0;
  let nullCells = 0;
  let emptyCells = 0;
  
  records.slice(0, Math.min(100, records.length)).forEach(record => {
    Object.values(record).forEach(value => {
      totalCells++;
      if (value === undefined) undefinedCells++;
      else if (value === null) nullCells++;
      else if (value === '') emptyCells++;
    });
  });
  
  const undefinedPercentage = (undefinedCells / totalCells) * 100;
  const nullPercentage = (nullCells / totalCells) * 100;
  const emptyPercentage = (emptyCells / totalCells) * 100;
  
  validation.metrics.undefinedPercentage = undefinedPercentage;
  validation.metrics.nullPercentage = nullPercentage;
  validation.metrics.emptyPercentage = emptyPercentage;
  
  // Flag as unacceptable if too many undefined values
  if (undefinedPercentage > 80) {
    validation.isAcceptable = false;
    validation.issues.push(`${undefinedPercentage.toFixed(1)}% of values are undefined - parsing likely failed`);
  } else if (undefinedPercentage > 50) {
    validation.warnings.push(`${undefinedPercentage.toFixed(1)}% of values are undefined`);
  }
  
  // Check for suspicious column names
  const columns = Object.keys(firstRecord);
  const suspiciousColumns = columns.filter(col => 
    col.includes('undefined') || 
    col.match(/^column\d+$/i) || 
    col.trim() === '' ||
    col.includes('\n') ||
    col.includes('\r')
  );
  
  if (suspiciousColumns.length > 0) {
    validation.warnings.push(`Suspicious column names detected: ${suspiciousColumns.join(', ')}`);
  }
  
  // Check data consistency across rows
  const columnCounts = records.slice(0, 10).map(record => Object.keys(record).length);
  const inconsistentColumns = new Set(columnCounts).size > 1;
  
  if (inconsistentColumns) {
    validation.warnings.push('Inconsistent column counts across rows - may indicate parsing issues');
  }
  
  // Reasonable record count check
  if (records.length < 2) {
    validation.warnings.push('Very few records parsed - file might be mostly headers or empty');
  }
  
  return validation;
}

// Enhanced column type detection
function detectColumnTypes(records) {
  if (records.length === 0) return {};
  
  const columns = Object.keys(records[0]);
  const columnTypes = {};
  
  // Sample records for type detection on large datasets
  const sampleSize = Math.min(1000, records.length);
  const sampledRecords = records.length > 1000 
    ? records.slice(0, sampleSize) 
    : records;
  
  for (const [index, column] of columns.entries()) {
    
    const values = sampledRecords.map(r => r[column]).filter(v => v !== null);
    
    if (values.length === 0) {
      columnTypes[column] = { 
        type: 'empty', 
        nullable: true,
        confidence: 1.0 
      };
      continue;
    }
    
    const analysis = analyzeColumnValues(values, records.length);
    columnTypes[column] = {
      ...analysis,
      nullable: records.some(r => r[column] === null),
      nullCount: records.filter(r => r[column] === null).length,
      nullPercentage: (records.filter(r => r[column] === null).length / records.length * 100).toFixed(1)
    };
  }
  return columnTypes;
}

// Enhanced column value analysis
function analyzeColumnValues(values, totalRecords) {
  const typeVotes = {
    integer: 0,
    float: 0,
    date: 0,
    email: 0,
    phone: 0,
    postcode: 0,
    boolean: 0,
    url: 0,
    currency: 0
  };
  
  const dateFormats = new Set();
  const sampleValues = [];
  
  for (const value of values) {
    // Keep sample values
    if (sampleValues.length < 5 && typeof value === 'string') {
      sampleValues.push(value);
    }
    
    // Check for boolean first
    if (typeof value === 'boolean') {
      typeVotes.boolean++;
      continue;
    }
    
    // Check for Date objects (created during CSV parsing)
    if (value instanceof Date) {
      typeVotes.date++;
      if (sampleValues.length < 5) {
        sampleValues.push(value.toISOString().split('T')[0]); // Add as YYYY-MM-DD string
      }
      continue;
    }
    
    // Check numbers
    if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        typeVotes.integer++;
      } else {
        typeVotes.float++;
      }
      continue;
    }
    
    if (typeof value === 'string') {
      const trimmed = value.trim();
      
      // Currency check
      if (/^[$€£¥₹][\d,]+\.?\d*$/.test(trimmed) || /^[\d,]+\.?\d*\s*[$€£¥₹]$/.test(trimmed)) {
        typeVotes.currency++;
        typeVotes.float++; // Also count as float
      }
      
      // Boolean check
      if (['true', 'false', 'yes', 'no', '1', '0', 'y', 'n'].includes(trimmed.toLowerCase())) {
        typeVotes.boolean++;
      }
      
      // Email check
      if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed)) {
        typeVotes.email++;
      }
      
      // URL check
      if (/^https?:\/\//.test(trimmed) || /^www\./.test(trimmed)) {
        typeVotes.url++;
      }
      
      // Phone check (enhanced for international formats)
      // But exclude date-like patterns first
      if (!/\d{4}-\d{2}-\d{2}/.test(trimmed) && 
          !/\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4}/.test(trimmed)) {
        const phoneDigits = trimmed.replace(/[^\d]/g, '');
        if (phoneDigits.length >= 8 && phoneDigits.length <= 15 && 
            /^[\d\s\-\+\(\)\.ext]+$/i.test(trimmed)) {
          typeVotes.phone++;
        }
      }
      
      // Australian postcode
      if (/^[0-9]{4}$/.test(trimmed)) {
        typeVotes.postcode++;
      }
      
      // Date detection
      if (value instanceof Date || 
          /\d{4}-\d{2}-\d{2}/.test(trimmed) ||
          /\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4}/.test(trimmed)) {
        typeVotes.date++;
        
        // Track date format
        if (/^\d{4}-\d{2}-\d{2}/.test(trimmed)) {
          dateFormats.add('YYYY-MM-DD');
        } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(trimmed)) {
          dateFormats.add('DD/MM/YYYY');
        } else if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(trimmed)) {
          dateFormats.add('DD-MM-YYYY');
        }
      }
      
      // Number check
      const num = parseNumber(trimmed);
      if (num !== null) {
        if (Number.isInteger(num)) {
          typeVotes.integer++;
        } else {
          typeVotes.float++;
        }
      }
    }
  }
  
  // Determine type with confidence
  const totalVotes = values.length;
  let bestType = 'string';
  let bestScore = 0;
  let confidence = 0;
  
  // Create prioritised list to handle ties (dates should win over numbers)
  const typePriority = ['date', 'email', 'url', 'phone', 'postcode', 'boolean', 'currency', 'float', 'integer'];
  
  for (const type of typePriority) {
    if (typeVotes[type] > 0) {
      const score = typeVotes[type] / totalVotes;
      if (score > bestScore || (score === bestScore && score > 0)) {
        bestScore = score;
        bestType = type;
        confidence = score;
      }
    }
  }
  
  // Special handling for numeric types
  if (bestType === 'integer' || bestType === 'float' || bestType === 'currency') {
    const numericVotes = typeVotes.integer + typeVotes.float + typeVotes.currency;
    if (numericVotes / totalVotes > 0.9) {
      bestType = typeVotes.float > 0 || typeVotes.currency > 0 ? 'float' : 'integer';
      confidence = numericVotes / totalVotes;
    }
  }
  
  // Check for categorical
  const uniqueValues = [...new Set(values.filter(v => typeof v === 'string'))];
  if (bestType === 'string' && uniqueValues.length < Math.min(20, totalRecords * 0.1)) {
    return {
      type: 'categorical',
      categories: uniqueValues.sort(),
      confidence: 1.0,
      uniqueCount: uniqueValues.length,
      sampleValues: sampleValues.slice(0, 3)
    };
  }
  
  // Check for identifier
  const allUniqueValues = [...new Set(values)];
  if (bestType === 'string' && allUniqueValues.length > totalRecords * 0.95) {
    return {
      type: 'identifier',
      confidence: allUniqueValues.length / totalRecords,
      uniqueCount: allUniqueValues.length,
      sampleValues: sampleValues.slice(0, 3)
    };
  }
  
  // Prepare result
  const result = {
    type: bestType,
    confidence: confidence,
    sampleValues: sampleValues.slice(0, 3)
  };
  
  // Add type-specific metadata
  if (bestType === 'date' && dateFormats.size > 0) {
    result.formats = Array.from(dateFormats);
  }
  
  if (bestType === 'integer' || bestType === 'float' || bestType === 'currency') {
    const numbers = values.map(v => parseNumber(v)).filter(n => n !== null);
    if (numbers.length > 0) {
      result.min = Math.min(...numbers);
      result.max = Math.max(...numbers);
      result.mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
      result.uniqueCount = [...new Set(numbers)].length;
    }
  }
  
  return result;
}

// Memory monitoring utility
function checkMemoryUsage() {
  const used = process.memoryUsage();
  const memoryUsageGB = used.heapUsed / (1024 * 1024 * 1024);
  const totalMemoryGB = os$1.totalmem() / (1024 * 1024 * 1024);
  const freeMemoryGB = os$1.freemem() / (1024 * 1024 * 1024);
  
  return {
    heapUsed: used.heapUsed,
    heapUsedGB: memoryUsageGB,
    totalMemoryGB,
    freeMemoryGB,
    memoryPercentage: (memoryUsageGB / totalMemoryGB) * 100,
    isHighMemory: memoryUsageGB > 1, // 1GB threshold
    shouldUseAggressiveSampling: memoryUsageGB > 1.5 // Don't use freeMemoryGB as it might be unreliable
  };
}

class OutputHandler {
  constructor(options = {}) {
    this.outputFile = options.output;
    this.buffer = '';
    this.originalLog = console.log;
    
    if (this.outputFile) {
      // Override console.log to capture output
      console.log = (...args) => {
        const text = args.join(' ');
        this.buffer += text + '\n';
      };
    }
  }
  
  finalize() {
    if (this.outputFile) {
      // Restore original console.log
      console.log = this.originalLog;
      
      // Write buffer to file
      writeFileSync(this.outputFile, this.buffer);
      console.log(chalk.green(`\n✓ Analysis saved to: ${this.outputFile}`));
      
      // Show preview
      const lines = this.buffer.split('\n').slice(0, 10);
      console.log(chalk.gray('\nPreview of saved analysis:'));
      lines.forEach(line => console.log(chalk.gray(line)));
      
      if (this.buffer.split('\n').length > 10) {
        console.log(chalk.gray('... (truncated)'));
      }
    }
  }
  
  restore() {
    // Restore console.log in case of error
    if (this.outputFile) {
      console.log = this.originalLog;
    }
  }
}

function createSamplingStrategy(records, analysisType) {
  const totalRows = records.length;
  
  // Define sampling thresholds
  const thresholds = {
    noSampling: 10000,      // No sampling needed
    lightSampling: 50000,   // Light sampling for some operations
    heavySampling: 100000,  // Heavy sampling for expensive operations
    streaming: 1000000      // Stream processing required
  };
  
  // Determine sampling strategy
  let strategy = {
    method: 'none',
    sampleSize: totalRows,
    samplingRate: 1.0,
    useStreaming: false,
    stratify: false
  };
  
  if (totalRows <= thresholds.noSampling) {
    return strategy;
  }
  
  // Analysis-specific sampling
  switch (analysisType) {
    case 'distribution':
    case 'outliers':
      if (totalRows > thresholds.heavySampling) {
        strategy = {
          method: 'stratified',
          sampleSize: Math.min(50000, Math.ceil(totalRows * 0.1)),
          samplingRate: 50000 / totalRows,
          useStreaming: false,
          stratify: true
        };
      } else if (totalRows > thresholds.lightSampling) {
        strategy = {
          method: 'random',
          sampleSize: Math.min(25000, Math.ceil(totalRows * 0.2)),
          samplingRate: 25000 / totalRows,
          useStreaming: false,
          stratify: false
        };
      }
      break;
      
    case 'regression':
    case 'cart':
      if (totalRows > thresholds.lightSampling) {
        strategy = {
          method: 'stratified',
          sampleSize: Math.min(10000, Math.ceil(totalRows * 0.2)),
          samplingRate: 10000 / totalRows,
          useStreaming: false,
          stratify: true
        };
      }
      break;
      
    case 'timeseries':
      // Time series should maintain temporal order
      if (totalRows > thresholds.heavySampling) {
        strategy = {
          method: 'systematic',
          sampleSize: Math.min(50000, totalRows),
          samplingRate: 50000 / totalRows,
          useStreaming: false,
          stratify: false
        };
      }
      break;
      
    case 'basic':
      // Basic statistics can use reservoir sampling for very large datasets
      if (totalRows > thresholds.streaming) {
        strategy = {
          method: 'reservoir',
          sampleSize: 100000,
          samplingRate: 100000 / totalRows,
          useStreaming: true,
          stratify: false
        };
      }
      break;
  }
  
  return strategy;
}

function performSampling(records, strategy, targetColumn = null) {
  if (strategy.method === 'none') {
    return records;
  }
  
  switch (strategy.method) {
    case 'random':
      return randomSample(records, strategy.sampleSize);
      
    case 'stratified':
      return stratifiedSample(records, strategy.sampleSize, targetColumn);
      
    case 'systematic':
      return systematicSample(records, strategy.sampleSize);
      
    case 'reservoir':
      return reservoirSample(records, strategy.sampleSize);
      
    default:
      return records;
  }
}

function randomSample(records, sampleSize) {
  if (sampleSize >= records.length) {
    return records;
  }
  
  // Fisher-Yates shuffle for first n elements
  const sampled = [...records];
  for (let i = 0; i < sampleSize; i++) {
    const j = Math.floor(Math.random() * (sampled.length - i)) + i;
    [sampled[i], sampled[j]] = [sampled[j], sampled[i]];
  }
  
  return sampled.slice(0, sampleSize);
}

function stratifiedSample(records, sampleSize, targetColumn) {
  if (!targetColumn || sampleSize >= records.length) {
    return randomSample(records, sampleSize);
  }
  
  // Group by target column
  const strata = {};
  records.forEach(record => {
    const key = String(record[targetColumn] || 'null');
    if (!strata[key]) {
      strata[key] = [];
    }
    strata[key].push(record);
  });
  
  // Calculate samples per stratum
  const sampled = [];
  Object.keys(strata).length;
  
  Object.entries(strata).forEach(([key, stratum]) => {
    const stratumRatio = stratum.length / records.length;
    const stratumSampleSize = Math.max(1, Math.round(sampleSize * stratumRatio));
    
    const stratumSample = randomSample(stratum, stratumSampleSize);
    sampled.push(...stratumSample);
  });
  
  // Adjust if we have too many or too few samples
  if (sampled.length > sampleSize) {
    return randomSample(sampled, sampleSize);
  }
  
  return sampled;
}

function systematicSample(records, sampleSize) {
  if (sampleSize >= records.length) {
    return records;
  }
  
  const interval = Math.floor(records.length / sampleSize);
  const start = Math.floor(Math.random() * interval);
  const sampled = [];
  
  for (let i = start; i < records.length && sampled.length < sampleSize; i += interval) {
    sampled.push(records[i]);
  }
  
  return sampled;
}

function reservoirSample(records, sampleSize) {
  if (sampleSize >= records.length) {
    return records;
  }
  
  // Algorithm R - Reservoir sampling
  const reservoir = records.slice(0, sampleSize);
  
  for (let i = sampleSize; i < records.length; i++) {
    const j = Math.floor(Math.random() * (i + 1));
    if (j < sampleSize) {
      reservoir[j] = records[i];
    }
  }
  
  return reservoir;
}

async function edaComprehensive(filePath, options = {}) {
  const outputHandler = new OutputHandler(options);
  const spinner = options.quiet ? null : ora('Performing comprehensive EDA analysis...').start();
  
  // Structured data mode for LLM consumption
  const structuredMode = options.structuredOutput || options.llmMode;
  
  // Set timeout for analysis (default 60 seconds for large datasets)
  const timeoutMs = options.timeout || 60000;
  
  const analysisPromise = performAnalysis();
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`⏱️  EDA analysis timed out after ${timeoutMs / 1000} seconds. This may indicate issues with the data format or file size.`));
    }, timeoutMs);
  });
  
  try {
    return await Promise.race([analysisPromise, timeoutPromise]);
  } catch (error) {
    outputHandler.restore();
    if (spinner) spinner.fail('Analysis failed or timed out');
    
    if (error.message.includes('timed out')) {
      console.error(chalk.red('🚨 EDA Analysis Timeout'));
      console.error(chalk.yellow('💡 Suggestions:'));
      console.error(chalk.yellow('   • Try using a smaller sample of your data'));
      console.error(chalk.yellow('   • Check if the CSV file has formatting issues'));
      console.error(chalk.yellow('   • Use --timeout flag to increase timeout (e.g., --timeout 60000 for 1 minute)'));
      console.error(chalk.yellow('   • Try the EDA function on a subset of columns'));
    } else {
      console.error(error.message);
    }
    
    if (!options.quiet) process.exit(1);
    throw error;
  }
  
  async function performAnalysis() {
    try {
      // Use preloaded data if available
      let records, columnTypes;
      if (options.preloadedData) {
        records = options.preloadedData.records;
        columnTypes = options.preloadedData.columnTypes;
      } else {
        // Parse CSV with enhanced error handling
        if (spinner) spinner.text = 'Reading CSV file...';
        try {
          records = await parseCSV(filePath, { quiet: options.quiet, header: options.header });
        } catch (parseError) {
          throw new Error(`CSV parsing failed: ${parseError.message}`);
        }
        
        // Validate parsed data
        if (!records || records.length === 0) {
          throw new Error('No data found in CSV file. Please check the file format and content.');
        }
        
        if (spinner) spinner.text = 'Detecting column types...';
        const typeStart = Date.now();
        try {
          columnTypes = detectColumnTypes(records);
          console.log(`Column type detection took ${Date.now() - typeStart}ms`);
        } catch (typeError) {
          throw new Error(`Column type detection failed: ${typeError.message}`);
        }
      }
      
      // Get file info
      const fileStats = statSync(filePath);
      const fileName = basename(filePath);
      const columns = Object.keys(columnTypes);
      
      // Handle large datasets with user notification
      const originalRecordCount = records.length;
      if (records.length > 10000) {
        console.log(chalk.yellow(`\n⚠️  Large dataset detected: ${records.length.toLocaleString()} rows`));
        
        if (records.length > 50000) {
          // Very large dataset - use sampling
          console.log(chalk.cyan('📊 Dataset is very large. Using intelligent sampling for performance.'));
          console.log(chalk.cyan(`   Processing a representative sample of ${Math.min(10000, records.length).toLocaleString()} rows...`));
          
          const samplingStrategy = createSamplingStrategy(records, 'basic');
          samplingStrategy.sampleSize = Math.min(10000, samplingStrategy.sampleSize);
          records = performSampling(records, samplingStrategy);
          
          if (spinner) spinner.text = `Analyzing ${records.length.toLocaleString()} sampled rows...`;
        } else {
          // Medium-large dataset - process all but with warning
          console.log(chalk.cyan('⏱️  This analysis may take up to 30 seconds...'));
          if (spinner) spinner.text = `Processing ${records.length.toLocaleString()} rows (this may take a moment)...`;
        }
      }
      
      // Handle empty dataset
      if (records.length === 0) {
        const report = formatComprehensiveEDAReport({
          fileName,
          rowCount: 0,
          columnCount: 0,
          empty: true
        });
        console.log(report);
        outputHandler.finalize();
        return;
      }
      
      // Add safety check for undefined values
      const sampleRecord = records[0];
      const undefinedCount = Object.values(sampleRecord).filter(v => v === undefined).length;
      if (undefinedCount > Object.keys(sampleRecord).length * 0.5) {
        console.log(chalk.yellow('⚠️  Warning: High number of undefined values detected in data.'));
        console.log(chalk.yellow('   This may indicate CSV parsing issues. Consider checking file encoding.'));
      }
      
      // Detect what analyses to run with timeout protection
      if (spinner) spinner.text = 'Detecting analysis requirements...';
      
      
      const analysisNeeds = detectAnalysisNeeds(records, columnTypes);
      
      // For very large datasets, disable expensive analyses
      if (records.length > 10000) {
        analysisNeeds.regression = false;
        analysisNeeds.cart = false;
        analysisNeeds.correlationAnalysis = false;
        analysisNeeds.timeSeries = false;
        analysisNeeds.mlReadiness = false;
      }
      
      // Initialize analysis object
      const analysis = {
        fileName,
        fileSize: formatFileSize(fileStats.size),
        rowCount: originalRecordCount,
        columnCount: columns.length,
        sampledRows: records.length < originalRecordCount ? records.length : undefined,
        columns: [],
        numericColumnCount: 0,
        categoricalColumnCount: 0,
        dateColumns: [],
        completeness: 0,
        duplicateCount: 0,
        insights: [],
        suggestions: [],
        processingTime: new Date()
      };
      
      // Basic column analysis with enhanced stats and timeout protection
      if (spinner) spinner.text = 'Calculating enhanced statistics...';
      
      const columnAnalyses = {};
      let totalNonNull = 0;
      
      // Process columns with timeout protection  
      const sampleForStats = records.slice(0, Math.min(5000, records.length));
      
      for (const column of columns) {
        try {
          const type = columnTypes[column];
          
          // For large datasets, estimate non-null ratio from sample
          const sampleValues = sampleForStats.map(r => r[column]);
          
          const nonNullInSample = sampleValues.filter(v => v !== null && v !== undefined).length;
          
          const nonNullRatio = nonNullInSample / sampleForStats.length;
          const estimatedNonNullCount = Math.round(nonNullRatio * records.length);
          
          // Use sampled values for stats
          const values = sampleValues.filter(v => v !== null && v !== undefined);
          
          const columnAnalysis = {
            name: column,
            type: type.type,
            nonNullRatio: nonNullRatio
          };
          
          totalNonNull += estimatedNonNullCount;
          
          // Add timeout protection for expensive calculations
          if (['integer', 'float'].includes(type.type) && values.length > 0) {
            
            const statsPromise = Promise.resolve(calculateEnhancedStats(values));
            const statsTimeout = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Stats calculation timeout')), 5000);
            });
            
            try {
              columnAnalysis.stats = await Promise.race([statsPromise, statsTimeout]);
              analysis.numericColumnCount++;
            } catch (statsError) {
              console.log(chalk.yellow(`⚠️  Skipping stats for column ${column}: ${statsError.message}`));
              columnAnalysis.stats = { error: 'Calculation timeout' };
              analysis.numericColumnCount++;
            }
          } else if (type.type === 'categorical' && values.length > 0) {
            try {
              columnAnalysis.stats = calculateCategoricalStats(values);
              analysis.categoricalColumnCount++;
            } catch (catError) {
              console.log(chalk.yellow(`⚠️  Skipping categorical stats for column ${column}: ${catError.message}`));
              columnAnalysis.stats = { error: 'Calculation failed' };
              analysis.categoricalColumnCount++;
            }
          } else if (type.type === 'date') {
            analysis.dateColumns.push(column);
          }
          
          analysis.columns.push(columnAnalysis);
          columnAnalyses[column] = columnAnalysis;
          
        } catch (columnError) {
          console.log(chalk.yellow(`⚠️  Error processing column ${column}: ${columnError.message}`));
          // Continue with next column
        }
      }
      
      
      analysis.completeness = totalNonNull / (records.length * columns.length);
      analysis.completenessLevel = analysis.completeness > 0.9 ? 'good' : 
                                   analysis.completeness > 0.7 ? 'fair' : 'poor';
      
      
      // Count duplicates with timeout protection
      try {
        if (spinner) spinner.text = 'Checking for duplicates...';
        const duplicatePromise = Promise.resolve((() => {
          const seen = new Set();
          let duplicates = 0;
          // Limit duplicate checking for very large datasets
          const checkLimit = Math.min(records.length, 10000);
          records.slice(0, checkLimit).forEach(record => {
            const key = JSON.stringify(record);
            if (seen.has(key)) duplicates++;
            else seen.add(key);
          });
          return duplicates;
        })());
        
        const duplicateTimeout = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Duplicate check timeout')), 5000);
        });
        
        analysis.duplicateCount = await Promise.race([duplicatePromise, duplicateTimeout]);
      } catch (dupError) {
        console.log(chalk.yellow(`⚠️  Skipping duplicate check: ${dupError.message}`));
        analysis.duplicateCount = 0;
      }
      
      // Distribution analysis
      if (analysisNeeds.distributionTesting) {
        if (spinner) spinner.text = 'Analyzing distributions...';
        analysis.distributionAnalysis = {};
        
        const numericColumns = columns.filter(col => 
          ['integer', 'float'].includes(columnTypes[col].type)
        );
        
        for (const col of numericColumns) {
          try {
            const values = records.map(r => r[col]);
            
            analysis.distributionAnalysis[col] = await analyzeDistribution$1(values);
          } catch (distError) {
            throw distError;
          }
        }
      }
      
      // Outlier analysis
      if (analysisNeeds.outlierAnalysis) {
        if (spinner) spinner.text = 'Detecting outliers...';
        analysis.outlierAnalysis = {};
        
        const numericColumns = columns.filter(col => 
          ['integer', 'float'].includes(columnTypes[col].type)
        );
        
        let totalOutliers = 0;
        for (const col of numericColumns) {
          try {
            const values = records.map(r => r[col]);
            
            const outlierResult = detectOutliers(values, col);
            
            analysis.outlierAnalysis[col] = outlierResult;
            if (outlierResult.aggregated) {
              totalOutliers += outlierResult.aggregated.length;
            }
          } catch (outlierError) {
            throw outlierError;
          }
        }
        
        analysis.outlierRate = totalOutliers / (records.length * numericColumns.length);
      }
      
      // CART analysis (skip for large datasets)
      if (analysisNeeds.cart && records.length < 5000) {
        if (spinner) spinner.text = 'Performing CART analysis...';
        
        try {
          const targets = findPotentialTargets(records, columnTypes);
          
          if (targets.length > 0) {
            analysis.cartAnalysis = performCARTAnalysis(
              records, 
              columns, 
              columnTypes, 
              targets[0].column
            );
          }
        } catch (cartError) {
          throw cartError;
        }
      } else if (analysisNeeds.cart) {
        analysis.cartAnalysis = { skipped: true, reason: 'Dataset too large' };
      }
      
      // Regression analysis (skip for large datasets)
      if (analysisNeeds.regression && records.length < 5000) {
        if (spinner) spinner.text = 'Performing regression analysis...';
        
        try {
          analysis.regressionAnalysis = performRegressionAnalysis(
            records, 
            columns, 
            columnTypes
          );
        } catch (regressionError) {
          throw regressionError;
        }
      } else if (analysisNeeds.regression) {
        analysis.regressionAnalysis = { skipped: true, reason: 'Dataset too large' };
      }
      
      // Correlation analysis (skip for large datasets)
      if (analysisNeeds.correlationAnalysis && records.length < 5000) {
        if (spinner) spinner.text = 'Analyzing correlations...';
        
        try {
          analysis.correlationAnalysis = performCorrelationAnalysis(records, columns, columnTypes);
        } catch (correlationError) {
          throw correlationError;
        }
      } else if (analysisNeeds.correlationAnalysis) {
        if (spinner) spinner.text = 'Skipping correlation analysis for large dataset...';
        analysis.correlationAnalysis = { skipped: true, reason: 'Dataset too large' };
      }
      
      // Pattern detection (limit for large datasets)
      if (analysisNeeds.patternDetection) {
        if (spinner) spinner.text = 'Detecting patterns...';
        
        try {
          const patternRecords = records.length > 5000 ? records.slice(0, 5000) : records;
          
          analysis.patterns = detectPatterns$1(patternRecords, columns, columnTypes);
          
          if (records.length > 5000) {
            analysis.patterns.note = 'Analyzed first 5000 rows for patterns';
          }
        } catch (patternError) {
          throw patternError;
        }
      }
      
      // Time series analysis (limit for large datasets)
      if (analysisNeeds.timeSeries && records.length < 10000) {
        if (spinner) spinner.text = 'Analyzing time series...';
        
        try {
          const dateColumn = analysis.dateColumns[0]; // Use first date column
          
          const numericColumns = columns.filter(col => 
            ['integer', 'float'].includes(columnTypes[col].type)
          );
          
          if (dateColumn && numericColumns.length > 0) {
            analysis.timeSeriesAnalysis = performTimeSeriesAnalysis(
              records, 
              dateColumn, 
              numericColumns
            );
          } else {
          }
        } catch (timeSeriesError) {
          throw timeSeriesError;
        }
      } else if (analysisNeeds.timeSeries) {
        analysis.timeSeriesAnalysis = { skipped: true, reason: 'Dataset too large for time series analysis' };
      }
      
      // Australian data validation
      if (analysisNeeds.australianData) {
        if (spinner) spinner.text = 'Validating Australian data patterns...';
        
        try {
          analysis.australianValidation = validateAustralianData$1(records, columns, columnTypes);
          
          if (analysis.australianValidation.detected) {
            const australianInsights = generateAustralianInsights(analysis.australianValidation);
            analysis.insights = [...(analysis.insights || []), ...australianInsights];
          }
        } catch (australianError) {
          throw australianError;
        }
      }
      
      // ML readiness assessment
      if (analysisNeeds.mlReadiness) {
        if (spinner) spinner.text = 'Assessing ML readiness...';
        
        try {
          analysis.mlReadiness = assessMLReadiness(records, columns, columnTypes, analysis);
        } catch (mlError) {
          throw mlError;
        }
      }
      
      // Generate insights
      try {
        analysis.insights = generateInsights(analysis);
      } catch (insightsError) {
        throw insightsError;
      }
      
      try {
        analysis.suggestions = generateSuggestions(analysis, analysisNeeds);
      } catch (suggestionsError) {
        throw suggestionsError;
      }
      
      // Calculate final metrics
      try {
        analysis.consistencyScore = calculateConsistencyScore(analysis);
        
        analysis.highMissingColumns = columns.filter(col => {
          const stats = columnAnalyses[col];
          return stats && (1 - stats.nonNullRatio) > 0.1;
        }).length;
      } catch (metricsError) {
        throw metricsError;
      }
      
      // Return structured data if requested for LLM consumption
      if (structuredMode) {
        try {
          if (spinner) spinner.succeed('Comprehensive EDA analysis complete!');
          
          const dataQuality = {
            completeness: analysis.completeness,
            duplicateRows: analysis.duplicateCount / analysis.rowCount,
            outlierPercentage: analysis.outlierRate || 0
          };
          
          const correlations = analysis.correlationAnalysis?.correlations || [];
          
          const distributions = analysis.distributionAnalysis ? 
            Object.entries(analysis.distributionAnalysis).map(([col, dist]) => ({
              column: col,
              ...dist
            })) : [];
          
          
          const summaryStats = analysis.columns.reduce((acc, col) => {
            acc[col.name] = col.stats;
            return acc;
          }, {});
          
          const columnNames = analysis.columns.map(col => col.name);
          
          return {
            analysis,
            structuredResults: {
              statisticalInsights: analysis.insights || [],
              dataQuality,
              correlations,
              distributions,
              timeSeries: analysis.timeSeriesAnalysis || null,
              summaryStats,
              mlReadiness: analysis.mlReadiness || { overallScore: 0.8, majorIssues: [] },
              columns: columnNames
            }
          };
        } catch (structuredError) {
          throw structuredError;
        }
      }
      
      // Format and output report
      try {
        const report = formatComprehensiveEDAReport(analysis);
        
        if (spinner) spinner.succeed('Comprehensive EDA analysis complete!');
        console.log(report);
        
        outputHandler.finalize();
      } catch (reportError) {
        throw reportError;
      }
      
    } catch (error) {
      outputHandler.restore();
      if (spinner) spinner.fail('Error during analysis');
      console.error(error.message);
      if (!options.quiet) process.exit(1);
      throw error;
    }
  }
}

function generateInsights(analysis) {
  const insights = [];
  
  // Data quality insights
  if (analysis.completeness < 0.8) {
    insights.push(`Data completeness is ${(analysis.completeness * 100).toFixed(1)}% - consider data imputation strategies`);
  }
  
  if (analysis.duplicateCount > analysis.rowCount * 0.05) {
    insights.push(`${analysis.duplicateCount} duplicate rows detected - investigate data collection process`);
  }
  
  // Distribution insights
  if (analysis.distributionAnalysis) {
    const nonNormal = Object.entries(analysis.distributionAnalysis)
      .filter(([_, dist]) => dist.tests && dist.tests.normality && !dist.tests.normality.isNormal);
    
    if (nonNormal.length > 0) {
      insights.push(`${nonNormal.length} numeric columns show non-normal distributions`);
    }
  }
  
  // Outlier insights
  if (analysis.outlierAnalysis && analysis.outlierRate > 0.05) {
    insights.push(`High outlier prevalence (${(analysis.outlierRate * 100).toFixed(1)}%) - review data quality`);
  }
  
  // Model insights
  if (analysis.regressionAnalysis && analysis.regressionAnalysis.bestModel) {
    const r2 = analysis.regressionAnalysis.bestModel.adjustedR2;
    if (r2 > 0.7) {
      insights.push(`Strong predictive relationships found (R²=${r2.toFixed(3)})`);
    }
  }
  
  if (analysis.cartAnalysis && analysis.cartAnalysis.segments) {
    insights.push(`${analysis.cartAnalysis.segments.length} distinct business segments identified`);
  }
  
  // Pattern insights
  if (analysis.patterns && analysis.patterns.benfordLaw) {
    const violations = analysis.patterns.benfordLaw.filter(b => !b.followsBenford);
    if (violations.length > 0) {
      insights.push('Potential data quality issues detected via Benford\'s Law');
    }
  }
  
  return insights.length > 0 ? insights : ['Dataset appears well-structured with no major issues'];
}

function generateSuggestions(analysis, analysisNeeds) {
  const suggestions = [];
  
  // Based on data characteristics
  if (analysis.numericColumnCount >= 3 && !analysisNeeds.regression) {
    suggestions.push({
      title: 'Multivariate Analysis',
      rationale: 'Multiple numeric columns available for deeper analysis',
      approach: 'Consider PCA or factor analysis to identify latent variables'
    });
  }
  
  if (analysis.dateColumns.length > 0 && !analysisNeeds.timeSeries) {
    suggestions.push({
      title: 'Time-based Aggregation',
      rationale: 'Date columns present but no clear time series pattern',
      approach: 'Aggregate by time periods to reveal hidden trends'
    });
  }
  
  // Based on findings
  if (analysis.outlierRate > 0.1) {
    suggestions.push({
      title: 'Robust Statistical Methods',
      rationale: 'High outlier prevalence may skew traditional analyses',
      approach: 'Use median-based statistics and robust regression techniques'
    });
  }
  
  if (analysis.patterns && analysis.patterns.duplicatePatterns.length > 0) {
    suggestions.push({
      title: 'Entity Resolution',
      rationale: 'Duplicate patterns suggest potential entity matching issues',
      approach: 'Implement fuzzy matching to identify related records'
    });
  }
  
  return suggestions;
}

function calculateConsistencyScore(analysis) {
  let score = 10;
  
  // Deduct for quality issues
  if (analysis.completeness < 0.9) score -= 2;
  if (analysis.duplicateCount > 0) score -= 1;
  if (analysis.outlierRate > 0.1) score -= 2;
  if (analysis.highMissingColumns > 0) score -= 1;
  
  // Deduct for consistency issues
  if (analysis.patterns && analysis.patterns.anomalies && analysis.patterns.anomalies.length > 0) {
    score -= analysis.patterns.anomalies.length * 0.5;
  }
  
  return Math.max(0, Math.round(score));
}

async function eda(filePath, options = {}) {
  // Use the new comprehensive EDA analysis
  return edaComprehensive(filePath, options);
}

function analyseCompleteness(data, headers) {
  const results = {
    dimension: 'Completeness',
    weight: 0.20,
    issues: [],
    metrics: {},
    score: 100
  };

  const totalRows = data.length;
  const columnStats = {};

  headers.forEach(header => {
    columnStats[header] = {
      nullCount: 0,
      emptyCount: 0,
      totalMissing: 0,
      missingPattern: [],
      requiredField: false,
      completenessRate: 100
    };
  });

  data.forEach((row, rowIndex) => {
    headers.forEach((header) => {
      const value = row[header];  // Access by column name, not index
      const stats = columnStats[header];

      if (value === null || value === undefined || value === '') {
        stats.nullCount++;
        stats.totalMissing++;
        stats.missingPattern.push(rowIndex);
      } else if (typeof value === 'string' && value.trim() === '') {
        stats.emptyCount++;
        stats.totalMissing++;
        stats.missingPattern.push(rowIndex);
      }
    });
  });

  headers.forEach(header => {
    const stats = columnStats[header];
    stats.completenessRate = totalRows > 0 
      ? ((totalRows - stats.totalMissing) / totalRows * 100).toFixed(2)
      : 100;

    const missingRate = 100 - stats.completenessRate;
    if (missingRate > 0) {
      const pattern = analyseMissingPattern(stats.missingPattern, totalRows);
      
      if (missingRate > 20) {
        results.issues.push({
          type: 'critical',
          field: header,
          message: `${missingRate.toFixed(1)}% missing values (${stats.totalMissing}/${totalRows} records)`,
          pattern: pattern,
          impact: missingRate > 50 ? 'Field may be unusable' : 'Significant data loss'
        });
        results.score -= 15;
      } else if (missingRate > 5) {
        results.issues.push({
          type: 'warning',
          field: header,
          message: `${missingRate.toFixed(1)}% missing values (${stats.totalMissing}/${totalRows} records)`,
          pattern: pattern,
          impact: 'May affect analysis accuracy'
        });
        results.score -= 5;
      } else if (missingRate > 0) {
        results.issues.push({
          type: 'observation',
          field: header,
          message: `${missingRate.toFixed(1)}% missing values (${stats.totalMissing}/${totalRows} records)`,
          pattern: pattern
        });
        results.score -= 1;
      }
    }

    if (stats.completenessRate === 100 && header.toLowerCase().includes('id')) {
      stats.requiredField = true;
    }
  });

  const overallCompleteness = headers.reduce((sum, header) => 
    sum + parseFloat(columnStats[header].completenessRate), 0) / headers.length;

  results.metrics = {
    overallCompleteness: overallCompleteness.toFixed(2),
    columnsWithMissing: Object.values(columnStats).filter(s => s.totalMissing > 0).length,
    totalMissingCells: Object.values(columnStats).reduce((sum, s) => sum + s.totalMissing, 0),
    columnStats: columnStats
  };

  results.score = Math.max(0, results.score);
  return results;
}

function analyseMissingPattern(missingIndices, totalRows) {
  if (missingIndices.length === 0) return 'None';
  
  const consecutiveRuns = [];
  let currentRun = [missingIndices[0]];
  
  for (let i = 1; i < missingIndices.length; i++) {
    if (missingIndices[i] === missingIndices[i-1] + 1) {
      currentRun.push(missingIndices[i]);
    } else {
      if (currentRun.length > 1) {
        consecutiveRuns.push(currentRun);
      }
      currentRun = [missingIndices[i]];
    }
  }
  if (currentRun.length > 1) {
    consecutiveRuns.push(currentRun);
  }

  if (consecutiveRuns.length > 0) {
    const longestRun = consecutiveRuns.reduce((max, run) => 
      run.length > max.length ? run : max, []);
    if (longestRun.length > totalRows * 0.1) {
      return `Systematic gaps (rows ${longestRun[0]}-${longestRun[longestRun.length-1]})`;
    }
  }

  const lastQuarter = Math.floor(totalRows * 0.75);
  const lastQuarterMissing = missingIndices.filter(i => i >= lastQuarter).length;
  if (lastQuarterMissing > missingIndices.length * 0.5) {
    return 'Missing at Random (MAR) - concentrated in recent records';
  }

  const everyNth = detectEveryNthPattern(missingIndices);
  if (everyNth) {
    return `Periodic pattern (every ${everyNth} records)`;
  }

  return 'Missing Completely at Random (MCAR)';
}

function detectEveryNthPattern(indices) {
  if (indices.length < 3) return null;
  
  const differences = [];
  for (let i = 1; i < indices.length; i++) {
    differences.push(indices[i] - indices[i-1]);
  }
  
  const mode = differences.reduce((acc, diff) => {
    acc[diff] = (acc[diff] || 0) + 1;
    return acc;
  }, {});
  
  const mostCommon = Object.entries(mode).sort((a, b) => b[1] - a[1])[0];
  if (mostCommon && mostCommon[1] > differences.length * 0.8) {
    return mostCommon[0];
  }
  
  return null;
}

var validator$1 = {exports: {}};

var toDate = {exports: {}};

var assertString = {exports: {}};

var hasRequiredAssertString;

function requireAssertString () {
	if (hasRequiredAssertString) return assertString.exports;
	hasRequiredAssertString = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = assertString;
		function assertString(input) {
		  if (input === undefined || input === null) throw new TypeError("Expected a string but received a ".concat(input));
		  if (input.constructor.name !== 'String') throw new TypeError("Expected a string but received a ".concat(input.constructor.name));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (assertString, assertString.exports));
	return assertString.exports;
}

var hasRequiredToDate;

function requireToDate () {
	if (hasRequiredToDate) return toDate.exports;
	hasRequiredToDate = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toDate;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function toDate(date) {
		  (0, _assertString.default)(date);
		  date = Date.parse(date);
		  return !isNaN(date) ? new Date(date) : null;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toDate, toDate.exports));
	return toDate.exports;
}

var toFloat = {exports: {}};

var isFloat$1 = {};

var nullUndefinedCheck = {exports: {}};

var hasRequiredNullUndefinedCheck;

function requireNullUndefinedCheck () {
	if (hasRequiredNullUndefinedCheck) return nullUndefinedCheck.exports;
	hasRequiredNullUndefinedCheck = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isNullOrUndefined;
		function isNullOrUndefined(value) {
		  return value === null || value === undefined;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (nullUndefinedCheck, nullUndefinedCheck.exports));
	return nullUndefinedCheck.exports;
}

var alpha = {};

var hasRequiredAlpha;

function requireAlpha () {
	if (hasRequiredAlpha) return alpha;
	hasRequiredAlpha = 1;

	Object.defineProperty(alpha, "__esModule", {
	  value: true
	});
	alpha.farsiLocales = alpha.englishLocales = alpha.dotDecimal = alpha.decimal = alpha.commaDecimal = alpha.bengaliLocales = alpha.arabicLocales = alpha.alphanumeric = alpha.alpha = void 0;
	var alpha$1 = alpha.alpha = {
	  'en-US': /^[A-Z]+$/i,
	  'az-AZ': /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
	  'bg-BG': /^[А-Я]+$/i,
	  'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
	  'da-DK': /^[A-ZÆØÅ]+$/i,
	  'de-DE': /^[A-ZÄÖÜß]+$/i,
	  'el-GR': /^[Α-ώ]+$/i,
	  'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
	  'fa-IR': /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
	  'fi-FI': /^[A-ZÅÄÖ]+$/i,
	  'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
	  'it-IT': /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
	  'ja-JP': /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
	  'nb-NO': /^[A-ZÆØÅ]+$/i,
	  'nl-NL': /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
	  'nn-NO': /^[A-ZÆØÅ]+$/i,
	  'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
	  'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
	  'pt-PT': /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
	  'ru-RU': /^[А-ЯЁ]+$/i,
	  'kk-KZ': /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
	  'sl-SI': /^[A-ZČĆĐŠŽ]+$/i,
	  'sk-SK': /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
	  'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
	  'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
	  'sv-SE': /^[A-ZÅÄÖ]+$/i,
	  'th-TH': /^[ก-๐\s]+$/i,
	  'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
	  'uk-UA': /^[А-ЩЬЮЯЄIЇҐі]+$/i,
	  'vi-VN': /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
	  'ko-KR': /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
	  'ku-IQ': /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
	  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
	  he: /^[א-ת]+$/,
	  fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
	  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
	  eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
	  'hi-IN': /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
	  'si-LK': /^[\u0D80-\u0DFF]+$/
	};
	var alphanumeric = alpha.alphanumeric = {
	  'en-US': /^[0-9A-Z]+$/i,
	  'az-AZ': /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
	  'bg-BG': /^[0-9А-Я]+$/i,
	  'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
	  'da-DK': /^[0-9A-ZÆØÅ]+$/i,
	  'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
	  'el-GR': /^[0-9Α-ω]+$/i,
	  'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
	  'fi-FI': /^[0-9A-ZÅÄÖ]+$/i,
	  'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
	  'it-IT': /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
	  'ja-JP': /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
	  'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
	  'nb-NO': /^[0-9A-ZÆØÅ]+$/i,
	  'nl-NL': /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
	  'nn-NO': /^[0-9A-ZÆØÅ]+$/i,
	  'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
	  'pt-PT': /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
	  'ru-RU': /^[0-9А-ЯЁ]+$/i,
	  'kk-KZ': /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
	  'sl-SI': /^[0-9A-ZČĆĐŠŽ]+$/i,
	  'sk-SK': /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
	  'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
	  'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
	  'sv-SE': /^[0-9A-ZÅÄÖ]+$/i,
	  'th-TH': /^[ก-๙\s]+$/i,
	  'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
	  'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
	  'ko-KR': /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
	  'ku-IQ': /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
	  'vi-VN': /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
	  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
	  he: /^[0-9א-ת]+$/,
	  fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
	  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
	  eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
	  'hi-IN': /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
	  'si-LK': /^[0-9\u0D80-\u0DFF]+$/
	};
	var decimal = alpha.decimal = {
	  'en-US': '.',
	  ar: '٫'
	};
	var englishLocales = alpha.englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
	for (var locale, i = 0; i < englishLocales.length; i++) {
	  locale = "en-".concat(englishLocales[i]);
	  alpha$1[locale] = alpha$1['en-US'];
	  alphanumeric[locale] = alphanumeric['en-US'];
	  decimal[locale] = decimal['en-US'];
	}

	// Source: http://www.localeplanet.com/java/
	var arabicLocales = alpha.arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
	for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
	  _locale = "ar-".concat(arabicLocales[_i]);
	  alpha$1[_locale] = alpha$1.ar;
	  alphanumeric[_locale] = alphanumeric.ar;
	  decimal[_locale] = decimal.ar;
	}
	var farsiLocales = alpha.farsiLocales = ['IR', 'AF'];
	for (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {
	  _locale2 = "fa-".concat(farsiLocales[_i2]);
	  alphanumeric[_locale2] = alphanumeric.fa;
	  decimal[_locale2] = decimal.ar;
	}
	var bengaliLocales = alpha.bengaliLocales = ['BD', 'IN'];
	for (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {
	  _locale3 = "bn-".concat(bengaliLocales[_i3]);
	  alpha$1[_locale3] = alpha$1.bn;
	  alphanumeric[_locale3] = alphanumeric.bn;
	  decimal[_locale3] = decimal['en-US'];
	}

	// Source: https://en.wikipedia.org/wiki/Decimal_mark
	var dotDecimal = alpha.dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];
	var commaDecimal = alpha.commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'id-ID', 'it-IT', 'ku-IQ', 'hi-IN', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'kk-KZ', 'si-LK', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN'];
	for (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {
	  decimal[dotDecimal[_i4]] = decimal['en-US'];
	}
	for (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {
	  decimal[commaDecimal[_i5]] = ',';
	}
	alpha$1['fr-CA'] = alpha$1['fr-FR'];
	alphanumeric['fr-CA'] = alphanumeric['fr-FR'];
	alpha$1['pt-BR'] = alpha$1['pt-PT'];
	alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
	decimal['pt-BR'] = decimal['pt-PT'];

	// see #862
	alpha$1['pl-Pl'] = alpha$1['pl-PL'];
	alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
	decimal['pl-Pl'] = decimal['pl-PL'];

	// see #1455
	alpha$1['fa-AF'] = alpha$1.fa;
	return alpha;
}

var hasRequiredIsFloat;

function requireIsFloat () {
	if (hasRequiredIsFloat) return isFloat$1;
	hasRequiredIsFloat = 1;

	Object.defineProperty(isFloat$1, "__esModule", {
	  value: true
	});
	isFloat$1.default = isFloat;
	isFloat$1.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	var _nullUndefinedCheck = _interopRequireDefault(/*@__PURE__*/ requireNullUndefinedCheck());
	var _alpha = /*@__PURE__*/ requireAlpha();
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function isFloat(str, options) {
	  (0, _assertString.default)(str);
	  options = options || {};
	  var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
	  if (str === '' || str === '.' || str === ',' || str === '-' || str === '+') {
	    return false;
	  }
	  var value = parseFloat(str.replace(',', '.'));
	  return float.test(str) && (!options.hasOwnProperty('min') || (0, _nullUndefinedCheck.default)(options.min) || value >= options.min) && (!options.hasOwnProperty('max') || (0, _nullUndefinedCheck.default)(options.max) || value <= options.max) && (!options.hasOwnProperty('lt') || (0, _nullUndefinedCheck.default)(options.lt) || value < options.lt) && (!options.hasOwnProperty('gt') || (0, _nullUndefinedCheck.default)(options.gt) || value > options.gt);
	}
	isFloat$1.locales = Object.keys(_alpha.decimal);
	return isFloat$1;
}

var hasRequiredToFloat;

function requireToFloat () {
	if (hasRequiredToFloat) return toFloat.exports;
	hasRequiredToFloat = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toFloat;
		var _isFloat = _interopRequireDefault(/*@__PURE__*/ requireIsFloat());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function toFloat(str) {
		  if (!(0, _isFloat.default)(str)) return NaN;
		  return parseFloat(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toFloat, toFloat.exports));
	return toFloat.exports;
}

var toInt = {exports: {}};

var hasRequiredToInt;

function requireToInt () {
	if (hasRequiredToInt) return toInt.exports;
	hasRequiredToInt = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toInt;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function toInt(str, radix) {
		  (0, _assertString.default)(str);
		  return parseInt(str, radix || 10);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toInt, toInt.exports));
	return toInt.exports;
}

var toBoolean = {exports: {}};

var hasRequiredToBoolean;

function requireToBoolean () {
	if (hasRequiredToBoolean) return toBoolean.exports;
	hasRequiredToBoolean = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toBoolean;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function toBoolean(str, strict) {
		  (0, _assertString.default)(str);
		  if (strict) {
		    return str === '1' || /^true$/i.test(str);
		  }
		  return str !== '0' && !/^false$/i.test(str) && str !== '';
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toBoolean, toBoolean.exports));
	return toBoolean.exports;
}

var equals = {exports: {}};

var hasRequiredEquals;

function requireEquals () {
	if (hasRequiredEquals) return equals.exports;
	hasRequiredEquals = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = equals;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function equals(str, comparison) {
		  (0, _assertString.default)(str);
		  return str === comparison;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (equals, equals.exports));
	return equals.exports;
}

var contains = {exports: {}};

var toString$1 = {exports: {}};

var hasRequiredToString;

function requireToString () {
	if (hasRequiredToString) return toString$1.exports;
	hasRequiredToString = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = toString;
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function toString(input) {
		  if (_typeof(input) === 'object' && input !== null) {
		    if (typeof input.toString === 'function') {
		      input = input.toString();
		    } else {
		      input = '[object Object]';
		    }
		  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
		    input = '';
		  }
		  return String(input);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (toString$1, toString$1.exports));
	return toString$1.exports;
}

var merge$1 = {exports: {}};

var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge$1.exports;
	hasRequiredMerge = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = merge;
		function merge() {
		  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		  var defaults = arguments.length > 1 ? arguments[1] : undefined;
		  for (var key in defaults) {
		    if (typeof obj[key] === 'undefined') {
		      obj[key] = defaults[key];
		    }
		  }
		  return obj;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (merge$1, merge$1.exports));
	return merge$1.exports;
}

var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains.exports;
	hasRequiredContains = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = contains;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _toString = _interopRequireDefault(/*@__PURE__*/ requireToString());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var defaultContainsOptions = {
		  ignoreCase: false,
		  minOccurrences: 1
		};
		function contains(str, elem, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaultContainsOptions);
		  if (options.ignoreCase) {
		    return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
		  }
		  return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (contains, contains.exports));
	return contains.exports;
}

var matches = {exports: {}};

var hasRequiredMatches;

function requireMatches () {
	if (hasRequiredMatches) return matches.exports;
	hasRequiredMatches = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = matches;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function matches(str, pattern, modifiers) {
		  (0, _assertString.default)(str);
		  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
		    pattern = new RegExp(pattern, modifiers);
		  }
		  return !!str.match(pattern);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (matches, matches.exports));
	return matches.exports;
}

var isEmail = {exports: {}};

var checkHost = {exports: {}};

var hasRequiredCheckHost;

function requireCheckHost () {
	if (hasRequiredCheckHost) return checkHost.exports;
	hasRequiredCheckHost = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = checkHost;
		function isRegExp(obj) {
		  return Object.prototype.toString.call(obj) === '[object RegExp]';
		}
		function checkHost(host, matches) {
		  for (var i = 0; i < matches.length; i++) {
		    var match = matches[i];
		    if (host === match || isRegExp(match) && match.test(host)) {
		      return true;
		    }
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (checkHost, checkHost.exports));
	return checkHost.exports;
}

var isByteLength = {exports: {}};

var hasRequiredIsByteLength;

function requireIsByteLength () {
	if (hasRequiredIsByteLength) return isByteLength.exports;
	hasRequiredIsByteLength = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isByteLength;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		/* eslint-disable prefer-rest-params */
		function isByteLength(str, options) {
		  (0, _assertString.default)(str);
		  var min;
		  var max;
		  if (_typeof(options) === 'object') {
		    min = options.min || 0;
		    max = options.max;
		  } else {
		    // backwards compatibility: isByteLength(str, min [, max])
		    min = arguments[1];
		    max = arguments[2];
		  }
		  var len = encodeURI(str).split(/%..|./).length - 1;
		  return len >= min && (typeof max === 'undefined' || len <= max);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isByteLength, isByteLength.exports));
	return isByteLength.exports;
}

var isFQDN = {exports: {}};

var hasRequiredIsFQDN;

function requireIsFQDN () {
	if (hasRequiredIsFQDN) return isFQDN.exports;
	hasRequiredIsFQDN = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isFQDN;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var default_fqdn_options = {
		  require_tld: true,
		  allow_underscores: false,
		  allow_trailing_dot: false,
		  allow_numeric_tld: false,
		  allow_wildcard: false,
		  ignore_max_length: false
		};
		function isFQDN(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_fqdn_options);

		  /* Remove the optional trailing dot before checking validity */
		  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
		    str = str.substring(0, str.length - 1);
		  }

		  /* Remove the optional wildcard before checking validity */
		  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
		    str = str.substring(2);
		  }
		  var parts = str.split('.');
		  var tld = parts[parts.length - 1];
		  if (options.require_tld) {
		    // disallow fqdns without tld
		    if (parts.length < 2) {
		      return false;
		    }
		    if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
		      return false;
		    }

		    // disallow spaces
		    if (/\s/.test(tld)) {
		      return false;
		    }
		  }

		  // reject numeric TLDs
		  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
		    return false;
		  }
		  return parts.every(function (part) {
		    if (part.length > 63 && !options.ignore_max_length) {
		      return false;
		    }
		    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
		      return false;
		    }

		    // disallow full-width chars
		    if (/[\uff01-\uff5e]/.test(part)) {
		      return false;
		    }

		    // disallow parts starting or ending with hyphen
		    if (/^-|-$/.test(part)) {
		      return false;
		    }
		    if (!options.allow_underscores && /_/.test(part)) {
		      return false;
		    }
		    return true;
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isFQDN, isFQDN.exports));
	return isFQDN.exports;
}

var isIP = {exports: {}};

var hasRequiredIsIP;

function requireIsIP () {
	if (hasRequiredIsIP) return isIP.exports;
	hasRequiredIsIP = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIP;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		/**
		11.3.  Examples

		   The following addresses

		             fe80::1234 (on the 1st link of the node)
		             ff02::5678 (on the 5th link of the node)
		             ff08::9abc (on the 10th organization of the node)

		   would be represented as follows:

		             fe80::1234%1
		             ff02::5678%5
		             ff08::9abc%10

		   (Here we assume a natural translation from a zone index to the
		   <zone_id> part, where the Nth zone of any scope is translated into
		   "N".)

		   If we use interface names as <zone_id>, those addresses could also be
		   represented as follows:

		            fe80::1234%ne0
		            ff02::5678%pvc1.3
		            ff08::9abc%interface10

		   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
		   to the 5th link, and "interface10" belongs to the 10th organization.
		 * * */
		var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
		var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
		var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
		var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
		var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z.]{1,})?$');
		function isIP(ipAddress) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(ipAddress);

		  // accessing 'arguments' for backwards compatibility: isIP(ipAddress [, version])
		  // eslint-disable-next-line prefer-rest-params
		  var version = (_typeof(options) === 'object' ? options.version : arguments[1]) || '';
		  if (!version) {
		    return isIP(ipAddress, {
		      version: 4
		    }) || isIP(ipAddress, {
		      version: 6
		    });
		  }
		  if (version.toString() === '4') {
		    return IPv4AddressRegExp.test(ipAddress);
		  }
		  if (version.toString() === '6') {
		    return IPv6AddressRegExp.test(ipAddress);
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIP, isIP.exports));
	return isIP.exports;
}

var hasRequiredIsEmail;

function requireIsEmail () {
	if (hasRequiredIsEmail) return isEmail.exports;
	hasRequiredIsEmail = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEmail;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _checkHost = _interopRequireDefault(/*@__PURE__*/ requireCheckHost());
		var _isByteLength = _interopRequireDefault(/*@__PURE__*/ requireIsByteLength());
		var _isFQDN = _interopRequireDefault(/*@__PURE__*/ requireIsFQDN());
		var _isIP = _interopRequireDefault(/*@__PURE__*/ requireIsIP());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var default_email_options = {
		  allow_display_name: false,
		  allow_underscores: false,
		  require_display_name: false,
		  allow_utf8_local_part: true,
		  require_tld: true,
		  blacklisted_chars: '',
		  ignore_max_length: false,
		  host_blacklist: [],
		  host_whitelist: []
		};

		/* eslint-disable max-len */
		/* eslint-disable no-control-regex */
		var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
		var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
		var gmailUserPart = /^[a-z\d]+$/;
		var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
		var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
		var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
		var defaultMaxEmailLength = 254;
		/* eslint-enable max-len */
		/* eslint-enable no-control-regex */

		/**
		 * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2
		 * @param {String} display_name
		 */
		function validateDisplayName(display_name) {
		  var display_name_without_quotes = display_name.replace(/^"(.+)"$/, '$1');
		  // display name with only spaces is not valid
		  if (!display_name_without_quotes.trim()) {
		    return false;
		  }

		  // check whether display name contains illegal character
		  var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
		  if (contains_illegal) {
		    // if contains illegal characters,
		    // must to be enclosed in double-quotes, otherwise it's not a valid display name
		    if (display_name_without_quotes === display_name) {
		      return false;
		    }

		    // the quotes in display name must start with character symbol \
		    var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
		    if (!all_start_with_back_slash) {
		      return false;
		    }
		  }
		  return true;
		}
		function isEmail(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_email_options);
		  if (options.require_display_name || options.allow_display_name) {
		    var display_email = str.match(splitNameAddress);
		    if (display_email) {
		      var display_name = display_email[1];

		      // Remove display name and angle brackets to get email address
		      // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)
		      str = str.replace(display_name, '').replace(/(^<|>$)/g, '');

		      // sometimes need to trim the last space to get the display name
		      // because there may be a space between display name and email address
		      // eg. myname <address@gmail.com>
		      // the display name is `myname` instead of `myname `, so need to trim the last space
		      if (display_name.endsWith(' ')) {
		        display_name = display_name.slice(0, -1);
		      }
		      if (!validateDisplayName(display_name)) {
		        return false;
		      }
		    } else if (options.require_display_name) {
		      return false;
		    }
		  }
		  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
		    return false;
		  }
		  var parts = str.split('@');
		  var domain = parts.pop();
		  var lower_domain = domain.toLowerCase();
		  if (options.host_blacklist.length > 0 && (0, _checkHost.default)(lower_domain, options.host_blacklist)) {
		    return false;
		  }
		  if (options.host_whitelist.length > 0 && !(0, _checkHost.default)(lower_domain, options.host_whitelist)) {
		    return false;
		  }
		  var user = parts.join('@');
		  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
		    /*
		    Previously we removed dots for gmail addresses before validating.
		    This was removed because it allows `multiple..dots@gmail.com`
		    to be reported as valid, but it is not.
		    Gmail only normalizes single dots, removing them from here is pointless,
		    should be done in normalizeEmail
		    */
		    user = user.toLowerCase();

		    // Removing sub-address from username before gmail validation
		    var username = user.split('+')[0];

		    // Dots are not included in gmail length restriction
		    if (!(0, _isByteLength.default)(username.replace(/\./g, ''), {
		      min: 6,
		      max: 30
		    })) {
		      return false;
		    }
		    var _user_parts = username.split('.');
		    for (var i = 0; i < _user_parts.length; i++) {
		      if (!gmailUserPart.test(_user_parts[i])) {
		        return false;
		      }
		    }
		  }
		  if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
		    max: 64
		  }) || !(0, _isByteLength.default)(domain, {
		    max: 254
		  }))) {
		    return false;
		  }
		  if (!(0, _isFQDN.default)(domain, {
		    require_tld: options.require_tld,
		    ignore_max_length: options.ignore_max_length,
		    allow_underscores: options.allow_underscores
		  })) {
		    if (!options.allow_ip_domain) {
		      return false;
		    }
		    if (!(0, _isIP.default)(domain)) {
		      if (!domain.startsWith('[') || !domain.endsWith(']')) {
		        return false;
		      }
		      var noBracketdomain = domain.slice(1, -1);
		      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
		        return false;
		      }
		    }
		  }
		  if (options.blacklisted_chars) {
		    if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), 'g')) !== -1) return false;
		  }
		  if (user[0] === '"' && user[user.length - 1] === '"') {
		    user = user.slice(1, user.length - 1);
		    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
		  }
		  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
		  var user_parts = user.split('.');
		  for (var _i = 0; _i < user_parts.length; _i++) {
		    if (!pattern.test(user_parts[_i])) {
		      return false;
		    }
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEmail, isEmail.exports));
	return isEmail.exports;
}

var isURL = {exports: {}};

var includesString = {exports: {}};

var hasRequiredIncludesString;

function requireIncludesString () {
	if (hasRequiredIncludesString) return includesString.exports;
	hasRequiredIncludesString = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;
		var includes = function includes(str, val) {
		  return str.indexOf(val) !== -1;
		};
		exports.default = includes;
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (includesString, includesString.exports));
	return includesString.exports;
}

var hasRequiredIsURL;

function requireIsURL () {
	if (hasRequiredIsURL) return isURL.exports;
	hasRequiredIsURL = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isURL;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _checkHost = _interopRequireDefault(/*@__PURE__*/ requireCheckHost());
		var _includesString = _interopRequireDefault(/*@__PURE__*/ requireIncludesString());
		var _isFQDN = _interopRequireDefault(/*@__PURE__*/ requireIsFQDN());
		var _isIP = _interopRequireDefault(/*@__PURE__*/ requireIsIP());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
		function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
		function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
		function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
		/*
		options for isURL method

		protocols - valid protocols can be modified with this option.
		require_tld - If set to false isURL will not check if the URL's host includes a top-level domain.
		require_protocol - if set to true isURL will return false if protocol is not present in the URL.
		require_host - if set to false isURL will not check if host is present in the URL.
		require_port - if set to true isURL will check if port is present in the URL.
		require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option.
		allow_underscores - if set to true, the validator will allow underscores in the URL.
		host_whitelist - if set to an array of strings or regexp, and the domain matches none of the strings
		                 defined in it, the validation fails.
		host_blacklist - if set to an array of strings or regexp, and the domain matches any of the strings
		                 defined in it, the validation fails.
		allow_trailing_dot - if set to true, the validator will allow the domain to end with
		                     a `.` character.
		allow_protocol_relative_urls - if set to true protocol relative URLs will be allowed.
		allow_fragments - if set to false isURL will return false if fragments are present.
		allow_query_components - if set to false isURL will return false if query components are present.
		disallow_auth - if set to true, the validator will fail if the URL contains an authentication
		                component, e.g. `http://username:password@example.com`
		validate_length - if set to false isURL will skip string length validation. `max_allowed_length`
		                  will be ignored if this is set as `false`.
		max_allowed_length - if set, isURL will not allow URLs longer than the specified value (default is
		                     2084 that IE maximum URL length).

		*/

		var default_url_options = {
		  protocols: ['http', 'https', 'ftp'],
		  require_tld: true,
		  require_protocol: false,
		  require_host: true,
		  require_port: false,
		  require_valid_protocol: true,
		  allow_underscores: false,
		  allow_trailing_dot: false,
		  allow_protocol_relative_urls: false,
		  allow_fragments: true,
		  allow_query_components: true,
		  validate_length: true,
		  max_allowed_length: 2084
		};
		var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
		function isURL(url, options) {
		  (0, _assertString.default)(url);
		  if (!url || /[\s<>]/.test(url)) {
		    return false;
		  }
		  if (url.indexOf('mailto:') === 0) {
		    return false;
		  }
		  options = (0, _merge.default)(options, default_url_options);
		  if (options.validate_length && url.length > options.max_allowed_length) {
		    return false;
		  }
		  if (!options.allow_fragments && (0, _includesString.default)(url, '#')) {
		    return false;
		  }
		  if (!options.allow_query_components && ((0, _includesString.default)(url, '?') || (0, _includesString.default)(url, '&'))) {
		    return false;
		  }
		  var protocol, auth, host, hostname, port, port_str, split, ipv6;
		  split = url.split('#');
		  url = split.shift();
		  split = url.split('?');
		  url = split.shift();
		  split = url.split('://');
		  if (split.length > 1) {
		    protocol = split.shift().toLowerCase();
		    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
		      return false;
		    }
		  } else if (options.require_protocol) {
		    return false;
		  } else if (url.slice(0, 2) === '//') {
		    if (!options.allow_protocol_relative_urls) {
		      return false;
		    }
		    split[0] = url.slice(2);
		  }
		  url = split.join('://');
		  if (url === '') {
		    return false;
		  }
		  split = url.split('/');
		  url = split.shift();
		  if (url === '' && !options.require_host) {
		    return true;
		  }
		  split = url.split('@');
		  if (split.length > 1) {
		    if (options.disallow_auth) {
		      return false;
		    }
		    if (split[0] === '') {
		      return false;
		    }
		    auth = split.shift();
		    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
		      return false;
		    }
		    var _auth$split = auth.split(':'),
		      _auth$split2 = _slicedToArray(_auth$split, 2),
		      user = _auth$split2[0],
		      password = _auth$split2[1];
		    if (user === '' && password === '') {
		      return false;
		    }
		  }
		  hostname = split.join('@');
		  port_str = null;
		  ipv6 = null;
		  var ipv6_match = hostname.match(wrapped_ipv6);
		  if (ipv6_match) {
		    host = '';
		    ipv6 = ipv6_match[1];
		    port_str = ipv6_match[2] || null;
		  } else {
		    split = hostname.split(':');
		    host = split.shift();
		    if (split.length) {
		      port_str = split.join(':');
		    }
		  }
		  if (port_str !== null && port_str.length > 0) {
		    port = parseInt(port_str, 10);
		    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
		      return false;
		    }
		  } else if (options.require_port) {
		    return false;
		  }
		  if (options.host_whitelist) {
		    return (0, _checkHost.default)(host, options.host_whitelist);
		  }
		  if (host === '' && !options.require_host) {
		    return true;
		  }
		  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
		    return false;
		  }
		  host = host || ipv6;
		  if (options.host_blacklist && (0, _checkHost.default)(host, options.host_blacklist)) {
		    return false;
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isURL, isURL.exports));
	return isURL.exports;
}

var isMACAddress = {exports: {}};

var hasRequiredIsMACAddress;

function requireIsMACAddress () {
	if (hasRequiredIsMACAddress) return isMACAddress.exports;
	hasRequiredIsMACAddress = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMACAddress;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
		var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
		var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
		var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
		var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
		var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
		function isMACAddress(str, options) {
		  (0, _assertString.default)(str);
		  if (options !== null && options !== void 0 && options.eui) {
		    options.eui = String(options.eui);
		  }
		  /**
		   * @deprecated `no_colons` TODO: remove it in the next major
		  */
		  if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
		    if (options.eui === '48') {
		      return macAddress48NoSeparators.test(str);
		    }
		    if (options.eui === '64') {
		      return macAddress64NoSeparators.test(str);
		    }
		    return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
		  }
		  if ((options === null || options === void 0 ? void 0 : options.eui) === '48') {
		    return macAddress48.test(str) || macAddress48WithDots.test(str);
		  }
		  if ((options === null || options === void 0 ? void 0 : options.eui) === '64') {
		    return macAddress64.test(str) || macAddress64WithDots.test(str);
		  }
		  return isMACAddress(str, {
		    eui: '48'
		  }) || isMACAddress(str, {
		    eui: '64'
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMACAddress, isMACAddress.exports));
	return isMACAddress.exports;
}

var isIPRange = {exports: {}};

var hasRequiredIsIPRange;

function requireIsIPRange () {
	if (hasRequiredIsIPRange) return isIPRange.exports;
	hasRequiredIsIPRange = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIPRange;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _isIP = _interopRequireDefault(/*@__PURE__*/ requireIsIP());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var subnetMaybe = /^\d{1,3}$/;
		var v4Subnet = 32;
		var v6Subnet = 128;
		function isIPRange(str) {
		  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
		  (0, _assertString.default)(str);
		  var parts = str.split('/');

		  // parts[0] -> ip, parts[1] -> subnet
		  if (parts.length !== 2) {
		    return false;
		  }
		  if (!subnetMaybe.test(parts[1])) {
		    return false;
		  }

		  // Disallow preceding 0 i.e. 01, 02, ...
		  if (parts[1].length > 1 && parts[1].startsWith('0')) {
		    return false;
		  }
		  var isValidIP = (0, _isIP.default)(parts[0], version);
		  if (!isValidIP) {
		    return false;
		  }

		  // Define valid subnet according to IP's version
		  var expectedSubnet = null;
		  switch (String(version)) {
		    case '4':
		      expectedSubnet = v4Subnet;
		      break;
		    case '6':
		      expectedSubnet = v6Subnet;
		      break;
		    default:
		      expectedSubnet = (0, _isIP.default)(parts[0], '6') ? v6Subnet : v4Subnet;
		  }
		  return parts[1] <= expectedSubnet && parts[1] >= 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIPRange, isIPRange.exports));
	return isIPRange.exports;
}

var isDate = {exports: {}};

var hasRequiredIsDate;

function requireIsDate () {
	if (hasRequiredIsDate) return isDate.exports;
	hasRequiredIsDate = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDate;
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
		function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
		function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: true } : { done: false, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = true, u = false; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = true, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
		function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
		function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
		var default_date_options = {
		  format: 'YYYY/MM/DD',
		  delimiters: ['/', '-'],
		  strictMode: false
		};
		function isValidFormat(format) {
		  return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
		}
		function zip(date, format) {
		  var zippedArr = [],
		    len = Math.max(date.length, format.length);
		  for (var i = 0; i < len; i++) {
		    zippedArr.push([date[i], format[i]]);
		  }
		  return zippedArr;
		}
		function isDate(input, options) {
		  if (typeof options === 'string') {
		    // Allow backward compatibility for old format isDate(input [, format])
		    options = (0, _merge.default)({
		      format: options
		    }, default_date_options);
		  } else {
		    options = (0, _merge.default)(options, default_date_options);
		  }
		  if (typeof input === 'string' && isValidFormat(options.format)) {
		    if (options.strictMode && input.length !== options.format.length) return false;
		    var formatDelimiter = options.delimiters.find(function (delimiter) {
		      return options.format.indexOf(delimiter) !== -1;
		    });
		    var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function (delimiter) {
		      return input.indexOf(delimiter) !== -1;
		    });
		    var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
		    var dateObj = {};
		    var _iterator = _createForOfIteratorHelper(dateAndFormat),
		      _step;
		    try {
		      for (_iterator.s(); !(_step = _iterator.n()).done;) {
		        var _step$value = _slicedToArray(_step.value, 2),
		          dateWord = _step$value[0],
		          formatWord = _step$value[1];
		        if (!dateWord || !formatWord || dateWord.length !== formatWord.length) {
		          return false;
		        }
		        dateObj[formatWord.charAt(0)] = dateWord;
		      }
		    } catch (err) {
		      _iterator.e(err);
		    } finally {
		      _iterator.f();
		    }
		    var fullYear = dateObj.y;

		    // Check if the year starts with a hyphen
		    if (fullYear.startsWith('-')) {
		      return false; // Hyphen before year is not allowed
		    }
		    if (dateObj.y.length === 2) {
		      var parsedYear = parseInt(dateObj.y, 10);
		      if (isNaN(parsedYear)) {
		        return false;
		      }
		      var currentYearLastTwoDigits = new Date().getFullYear() % 100;
		      if (parsedYear < currentYearLastTwoDigits) {
		        fullYear = "20".concat(dateObj.y);
		      } else {
		        fullYear = "19".concat(dateObj.y);
		      }
		    }
		    var month = dateObj.m;
		    if (dateObj.m.length === 1) {
		      month = "0".concat(dateObj.m);
		    }
		    var day = dateObj.d;
		    if (dateObj.d.length === 1) {
		      day = "0".concat(dateObj.d);
		    }
		    return new Date("".concat(fullYear, "-").concat(month, "-").concat(day, "T00:00:00.000Z")).getUTCDate() === +dateObj.d;
		  }
		  if (!options.strictMode) {
		    return Object.prototype.toString.call(input) === '[object Date]' && isFinite(input);
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDate, isDate.exports));
	return isDate.exports;
}

var isTime = {exports: {}};

var hasRequiredIsTime;

function requireIsTime () {
	if (hasRequiredIsTime) return isTime.exports;
	hasRequiredIsTime = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isTime;
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var default_time_options = {
		  hourFormat: 'hour24',
		  mode: 'default'
		};
		var formats = {
		  hour24: {
		    default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
		    withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/,
		    withOptionalSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$/
		  },
		  hour12: {
		    default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
		    withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/,
		    withOptionalSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9])(?::([0-5][0-9]))? (A|P)M$/
		  }
		};
		function isTime(input, options) {
		  options = (0, _merge.default)(options, default_time_options);
		  if (typeof input !== 'string') return false;
		  return formats[options.hourFormat][options.mode].test(input);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isTime, isTime.exports));
	return isTime.exports;
}

var isBoolean$1 = {exports: {}};

var includesArray = {exports: {}};

var hasRequiredIncludesArray;

function requireIncludesArray () {
	if (hasRequiredIncludesArray) return includesArray.exports;
	hasRequiredIncludesArray = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;
		var includes = function includes(arr, val) {
		  return arr.some(function (arrVal) {
		    return val === arrVal;
		  });
		};
		exports.default = includes;
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (includesArray, includesArray.exports));
	return includesArray.exports;
}

var hasRequiredIsBoolean;

function requireIsBoolean () {
	if (hasRequiredIsBoolean) return isBoolean$1.exports;
	hasRequiredIsBoolean = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBoolean;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _includesArray = _interopRequireDefault(/*@__PURE__*/ requireIncludesArray());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var defaultOptions = {
		  loose: false
		};
		var strictBooleans = ['true', 'false', '1', '0'];
		var looseBooleans = [].concat(strictBooleans, ['yes', 'no']);
		function isBoolean(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
		  (0, _assertString.default)(str);
		  if (options.loose) {
		    return (0, _includesArray.default)(looseBooleans, str.toLowerCase());
		  }
		  return (0, _includesArray.default)(strictBooleans, str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBoolean$1, isBoolean$1.exports));
	return isBoolean$1.exports;
}

var isLocale = {exports: {}};

var hasRequiredIsLocale;

function requireIsLocale () {
	if (hasRequiredIsLocale) return isLocale.exports;
	hasRequiredIsLocale = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLocale;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/*
		  = 3ALPHA              ; selected ISO 639 codes
		    *2("-" 3ALPHA)      ; permanently reserved
		 */
		var extlang = '([A-Za-z]{3}(-[A-Za-z]{3}){0,2})';

		/*
		  = 2*3ALPHA            ; shortest ISO 639 code
		    ["-" extlang]       ; sometimes followed by
		                        ; extended language subtags
		  / 4ALPHA              ; or reserved for future use
		  / 5*8ALPHA            ; or registered language subtag
		 */
		var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");

		/*
		  = 4ALPHA              ; ISO 15924 code
		 */
		var script = '([A-Za-z]{4})';

		/*
		  = 2ALPHA              ; ISO 3166-1 code
		  / 3DIGIT              ; UN M.49 code
		 */
		var region = '([A-Za-z]{2}|\\d{3})';

		/*
		  = 5*8alphanum         ; registered variants
		  / (DIGIT 3alphanum)
		 */
		var variant = '([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))';

		/*
		  = DIGIT               ; 0 - 9
		  / %x41-57             ; A - W
		  / %x59-5A             ; Y - Z
		  / %x61-77             ; a - w
		  / %x79-7A             ; y - z
		 */
		var singleton = '(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])';

		/*
		  = singleton 1*("-" (2*8alphanum))
		                        ; Single alphanumerics
		                        ; "x" reserved for private use
		 */
		var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");

		/*
		  = "x" 1*("-" (1*8alphanum))
		 */
		var privateuse = '(x(-[A-Za-z0-9]{1,8})+)';

		// irregular tags do not match the 'langtag' production and would not
		// otherwise be considered 'well-formed'. These tags are all valid, but
		// most are deprecated in favor of more modern subtags or subtag combination

		var irregular = '((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|' + '(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|' + '(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))';

		// regular tags match the 'langtag' production, but their subtags are not
		// extended language or variant subtags: their meaning is defined by
		// their registration and all of these are deprecated in favor of a more
		// modern subtag or sequence of subtags

		var regular = '((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|' + '(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))';

		/*
		  = irregular           ; non-redundant tags registered
		  / regular             ; during the RFC 3066 era

		 */
		var grandfathered = "(".concat(irregular, "|").concat(regular, ")");

		/*
		  RFC 5646 defines delimitation of subtags via a hyphen:

		      "Subtag" refers to a specific section of a tag, delimited by a
		      hyphen, such as the subtags 'zh', 'Hant', and 'CN' in the tag "zh-
		      Hant-CN".  Examples of subtags in this document are enclosed in
		      single quotes ('Hant')

		  However, we need to add "_" to maintain the existing behaviour.
		 */
		var delimiter = '(-|_)';

		/*
		  = language
		    ["-" script]
		    ["-" region]
		    *("-" variant)
		    *("-" extension)
		    ["-" privateuse]
		 */
		var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");

		/*
		  Regex implementation based on BCP RFC 5646
		  Tags for Identifying Languages
		  https://www.rfc-editor.org/rfc/rfc5646.html
		 */
		var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
		function isLocale(str) {
		  (0, _assertString.default)(str);
		  return languageTagRegex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLocale, isLocale.exports));
	return isLocale.exports;
}

var isAbaRouting = {exports: {}};

var hasRequiredIsAbaRouting;

function requireIsAbaRouting () {
	if (hasRequiredIsAbaRouting) return isAbaRouting.exports;
	hasRequiredIsAbaRouting = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isAbaRouting;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		// http://www.brainjar.com/js/validation/
		// https://www.aba.com/news-research/research-analysis/routing-number-policy-procedures
		// series reserved for future use are excluded
		var isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
		function isAbaRouting(str) {
		  (0, _assertString.default)(str);
		  if (!isRoutingReg.test(str)) return false;
		  var checkSumVal = 0;
		  for (var i = 0; i < str.length; i++) {
		    if (i % 3 === 0) checkSumVal += str[i] * 3;else if (i % 3 === 1) checkSumVal += str[i] * 7;else checkSumVal += str[i] * 1;
		  }
		  return checkSumVal % 10 === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isAbaRouting, isAbaRouting.exports));
	return isAbaRouting.exports;
}

var isAlpha = {};

var hasRequiredIsAlpha;

function requireIsAlpha () {
	if (hasRequiredIsAlpha) return isAlpha;
	hasRequiredIsAlpha = 1;

	Object.defineProperty(isAlpha, "__esModule", {
	  value: true
	});
	isAlpha.default = isAlpha$1;
	isAlpha.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	var _alpha = /*@__PURE__*/ requireAlpha();
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function isAlpha$1(_str) {
	  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  (0, _assertString.default)(_str);
	  var str = _str;
	  var ignore = options.ignore;
	  if (ignore) {
	    if (ignore instanceof RegExp) {
	      str = str.replace(ignore, '');
	    } else if (typeof ignore === 'string') {
	      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
	    } else {
	      throw new Error('ignore should be instance of a String or RegExp');
	    }
	  }
	  if (locale in _alpha.alpha) {
	    return _alpha.alpha[locale].test(str);
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	isAlpha.locales = Object.keys(_alpha.alpha);
	return isAlpha;
}

var isAlphanumeric = {};

var hasRequiredIsAlphanumeric;

function requireIsAlphanumeric () {
	if (hasRequiredIsAlphanumeric) return isAlphanumeric;
	hasRequiredIsAlphanumeric = 1;

	Object.defineProperty(isAlphanumeric, "__esModule", {
	  value: true
	});
	isAlphanumeric.default = isAlphanumeric$1;
	isAlphanumeric.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	var _alpha = /*@__PURE__*/ requireAlpha();
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	function isAlphanumeric$1(_str) {
	  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  (0, _assertString.default)(_str);
	  var str = _str;
	  var ignore = options.ignore;
	  if (ignore) {
	    if (ignore instanceof RegExp) {
	      str = str.replace(ignore, '');
	    } else if (typeof ignore === 'string') {
	      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
	    } else {
	      throw new Error('ignore should be instance of a String or RegExp');
	    }
	  }
	  if (locale in _alpha.alphanumeric) {
	    return _alpha.alphanumeric[locale].test(str);
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	isAlphanumeric.locales = Object.keys(_alpha.alphanumeric);
	return isAlphanumeric;
}

var isNumeric = {exports: {}};

var hasRequiredIsNumeric;

function requireIsNumeric () {
	if (hasRequiredIsNumeric) return isNumeric.exports;
	hasRequiredIsNumeric = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isNumeric;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _alpha = /*@__PURE__*/ requireAlpha();
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var numericNoSymbols = /^[0-9]+$/;
		function isNumeric(str, options) {
		  (0, _assertString.default)(str);
		  if (options && options.no_symbols) {
		    return numericNoSymbols.test(str);
		  }
		  return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : '.', "])?[0-9]+$")).test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isNumeric, isNumeric.exports));
	return isNumeric.exports;
}

var isPassportNumber = {};

var hasRequiredIsPassportNumber;

function requireIsPassportNumber () {
	if (hasRequiredIsPassportNumber) return isPassportNumber;
	hasRequiredIsPassportNumber = 1;

	Object.defineProperty(isPassportNumber, "__esModule", {
	  value: true
	});
	isPassportNumber.default = isPassportNumber$1;
	isPassportNumber.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	/**
	 * Reference:
	 * https://en.wikipedia.org/ -- Wikipedia
	 * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number
	 * https://countrycode.org/ -- Country Codes
	 */
	var passportRegexByCountryCode = {
	  AM: /^[A-Z]{2}\d{7}$/,
	  // ARMENIA
	  AR: /^[A-Z]{3}\d{6}$/,
	  // ARGENTINA
	  AT: /^[A-Z]\d{7}$/,
	  // AUSTRIA
	  AU: /^[A-Z]\d{7}$/,
	  // AUSTRALIA
	  AZ: /^[A-Z]{1}\d{8}$/,
	  // AZERBAIJAN
	  BE: /^[A-Z]{2}\d{6}$/,
	  // BELGIUM
	  BG: /^\d{9}$/,
	  // BULGARIA
	  BR: /^[A-Z]{2}\d{6}$/,
	  // BRAZIL
	  BY: /^[A-Z]{2}\d{7}$/,
	  // BELARUS
	  CA: /^[A-Z]{2}\d{6}$|^[A-Z]\d{6}[A-Z]{2}$/,
	  // CANADA
	  CH: /^[A-Z]\d{7}$/,
	  // SWITZERLAND
	  CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
	  // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
	  CY: /^[A-Z](\d{6}|\d{8})$/,
	  // CYPRUS
	  CZ: /^\d{8}$/,
	  // CZECH REPUBLIC
	  DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
	  // GERMANY
	  DK: /^\d{9}$/,
	  // DENMARK
	  DZ: /^\d{9}$/,
	  // ALGERIA
	  EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
	  // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
	  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
	  // SPAIN
	  FI: /^[A-Z]{2}\d{7}$/,
	  // FINLAND
	  FR: /^\d{2}[A-Z]{2}\d{5}$/,
	  // FRANCE
	  GB: /^\d{9}$/,
	  // UNITED KINGDOM
	  GR: /^[A-Z]{2}\d{7}$/,
	  // GREECE
	  HR: /^\d{9}$/,
	  // CROATIA
	  HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
	  // HUNGARY
	  IE: /^[A-Z0-9]{2}\d{7}$/,
	  // IRELAND
	  IN: /^[A-Z]{1}-?\d{7}$/,
	  // INDIA
	  ID: /^[A-C]\d{7}$/,
	  // INDONESIA
	  IR: /^[A-Z]\d{8}$/,
	  // IRAN
	  IS: /^(A)\d{7}$/,
	  // ICELAND
	  IT: /^[A-Z0-9]{2}\d{7}$/,
	  // ITALY
	  JM: /^[Aa]\d{7}$/,
	  // JAMAICA
	  JP: /^[A-Z]{2}\d{7}$/,
	  // JAPAN
	  KR: /^[MS]\d{8}$/,
	  // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
	  KZ: /^[a-zA-Z]\d{7}$/,
	  // KAZAKHSTAN
	  LI: /^[a-zA-Z]\d{5}$/,
	  // LIECHTENSTEIN
	  LT: /^[A-Z0-9]{8}$/,
	  // LITHUANIA
	  LU: /^[A-Z0-9]{8}$/,
	  // LUXEMBURG
	  LV: /^[A-Z0-9]{2}\d{7}$/,
	  // LATVIA
	  LY: /^[A-Z0-9]{8}$/,
	  // LIBYA
	  MT: /^\d{7}$/,
	  // MALTA
	  MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
	  // MOZAMBIQUE
	  MY: /^[AHK]\d{8}$/,
	  // MALAYSIA
	  MX: /^\d{10,11}$/,
	  // MEXICO
	  NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
	  // NETHERLANDS
	  NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
	  // NEW ZEALAND
	  PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
	  // PHILIPPINES
	  PK: /^[A-Z]{2}\d{7}$/,
	  // PAKISTAN
	  PL: /^[A-Z]{2}\d{7}$/,
	  // POLAND
	  PT: /^[A-Z]\d{6}$/,
	  // PORTUGAL
	  RO: /^\d{8,9}$/,
	  // ROMANIA
	  RU: /^\d{9}$/,
	  // RUSSIAN FEDERATION
	  SE: /^\d{8}$/,
	  // SWEDEN
	  SL: /^(P)[A-Z]\d{7}$/,
	  // SLOVENIA
	  SK: /^[0-9A-Z]\d{7}$/,
	  // SLOVAKIA
	  TH: /^[A-Z]{1,2}\d{6,7}$/,
	  // THAILAND
	  TR: /^[A-Z]\d{8}$/,
	  // TURKEY
	  UA: /^[A-Z]{2}\d{6}$/,
	  // UKRAINE
	  US: /^\d{9}$|^[A-Z]\d{8}$/,
	  // UNITED STATES
	  ZA: /^[TAMD]\d{8}$/ // SOUTH AFRICA
	};
	isPassportNumber.locales = Object.keys(passportRegexByCountryCode);

	/**
	 * Check if str is a valid passport number
	 * relative to provided ISO Country Code.
	 *
	 * @param {string} str
	 * @param {string} countryCode
	 * @return {boolean}
	 */
	function isPassportNumber$1(str, countryCode) {
	  (0, _assertString.default)(str);
	  /** Remove All Whitespaces, Convert to UPPERCASE */
	  var normalizedStr = str.replace(/\s/g, '').toUpperCase();
	  return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
	}
	return isPassportNumber;
}

var isPort = {exports: {}};

var isInt = {exports: {}};

var hasRequiredIsInt;

function requireIsInt () {
	if (hasRequiredIsInt) return isInt.exports;
	hasRequiredIsInt = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isInt;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _nullUndefinedCheck = _interopRequireDefault(/*@__PURE__*/ requireNullUndefinedCheck());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
		var intLeadingZeroes = /^[-+]?[0-9]+$/;
		function isInt(str, options) {
		  (0, _assertString.default)(str);
		  options = options || {};

		  // Get the regex to use for testing, based on whether
		  // leading zeroes are allowed or not.
		  var regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;

		  // Check min/max/lt/gt
		  var minCheckPassed = !options.hasOwnProperty('min') || (0, _nullUndefinedCheck.default)(options.min) || str >= options.min;
		  var maxCheckPassed = !options.hasOwnProperty('max') || (0, _nullUndefinedCheck.default)(options.max) || str <= options.max;
		  var ltCheckPassed = !options.hasOwnProperty('lt') || (0, _nullUndefinedCheck.default)(options.lt) || str < options.lt;
		  var gtCheckPassed = !options.hasOwnProperty('gt') || (0, _nullUndefinedCheck.default)(options.gt) || str > options.gt;
		  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isInt, isInt.exports));
	return isInt.exports;
}

var hasRequiredIsPort;

function requireIsPort () {
	if (hasRequiredIsPort) return isPort.exports;
	hasRequiredIsPort = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isPort;
		var _isInt = _interopRequireDefault(/*@__PURE__*/ requireIsInt());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isPort(str) {
		  return (0, _isInt.default)(str, {
		    allow_leading_zeroes: false,
		    min: 0,
		    max: 65535
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isPort, isPort.exports));
	return isPort.exports;
}

var isLowercase = {exports: {}};

var hasRequiredIsLowercase;

function requireIsLowercase () {
	if (hasRequiredIsLowercase) return isLowercase.exports;
	hasRequiredIsLowercase = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLowercase;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isLowercase(str) {
		  (0, _assertString.default)(str);
		  return str === str.toLowerCase();
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLowercase, isLowercase.exports));
	return isLowercase.exports;
}

var isUppercase = {exports: {}};

var hasRequiredIsUppercase;

function requireIsUppercase () {
	if (hasRequiredIsUppercase) return isUppercase.exports;
	hasRequiredIsUppercase = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isUppercase;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isUppercase(str) {
		  (0, _assertString.default)(str);
		  return str === str.toUpperCase();
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isUppercase, isUppercase.exports));
	return isUppercase.exports;
}

var isIMEI = {exports: {}};

var hasRequiredIsIMEI;

function requireIsIMEI () {
	if (hasRequiredIsIMEI) return isIMEI.exports;
	hasRequiredIsIMEI = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIMEI;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var imeiRegexWithoutHyphens = /^[0-9]{15}$/;
		var imeiRegexWithHyphens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
		function isIMEI(str, options) {
		  (0, _assertString.default)(str);
		  options = options || {};

		  // default regex for checking imei is the one without hyphens

		  var imeiRegex = imeiRegexWithoutHyphens;
		  if (options.allow_hyphens) {
		    imeiRegex = imeiRegexWithHyphens;
		  }
		  if (!imeiRegex.test(str)) {
		    return false;
		  }
		  str = str.replace(/-/g, '');
		  var sum = 0,
		    mul = 2,
		    l = 14;
		  for (var i = 0; i < l; i++) {
		    var digit = str.substring(l - i - 1, l - i);
		    var tp = parseInt(digit, 10) * mul;
		    if (tp >= 10) {
		      sum += tp % 10 + 1;
		    } else {
		      sum += tp;
		    }
		    if (mul === 1) {
		      mul += 1;
		    } else {
		      mul -= 1;
		    }
		  }
		  var chk = (10 - sum % 10) % 10;
		  if (chk !== parseInt(str.substring(14, 15), 10)) {
		    return false;
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIMEI, isIMEI.exports));
	return isIMEI.exports;
}

var isAscii = {exports: {}};

var hasRequiredIsAscii;

function requireIsAscii () {
	if (hasRequiredIsAscii) return isAscii.exports;
	hasRequiredIsAscii = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isAscii;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/* eslint-disable no-control-regex */
		var ascii = /^[\x00-\x7F]+$/;
		/* eslint-enable no-control-regex */

		function isAscii(str) {
		  (0, _assertString.default)(str);
		  return ascii.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isAscii, isAscii.exports));
	return isAscii.exports;
}

var isFullWidth$1 = {};

var hasRequiredIsFullWidth;

function requireIsFullWidth () {
	if (hasRequiredIsFullWidth) return isFullWidth$1;
	hasRequiredIsFullWidth = 1;

	Object.defineProperty(isFullWidth$1, "__esModule", {
	  value: true
	});
	isFullWidth$1.default = isFullWidth;
	isFullWidth$1.fullWidth = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var fullWidth = isFullWidth$1.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
	function isFullWidth(str) {
	  (0, _assertString.default)(str);
	  return fullWidth.test(str);
	}
	return isFullWidth$1;
}

var isHalfWidth = {};

var hasRequiredIsHalfWidth;

function requireIsHalfWidth () {
	if (hasRequiredIsHalfWidth) return isHalfWidth;
	hasRequiredIsHalfWidth = 1;

	Object.defineProperty(isHalfWidth, "__esModule", {
	  value: true
	});
	isHalfWidth.default = isHalfWidth$1;
	isHalfWidth.halfWidth = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var halfWidth = isHalfWidth.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
	function isHalfWidth$1(str) {
	  (0, _assertString.default)(str);
	  return halfWidth.test(str);
	}
	return isHalfWidth;
}

var isVariableWidth = {exports: {}};

var hasRequiredIsVariableWidth;

function requireIsVariableWidth () {
	if (hasRequiredIsVariableWidth) return isVariableWidth.exports;
	hasRequiredIsVariableWidth = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isVariableWidth;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _isFullWidth = /*@__PURE__*/ requireIsFullWidth();
		var _isHalfWidth = /*@__PURE__*/ requireIsHalfWidth();
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isVariableWidth(str) {
		  (0, _assertString.default)(str);
		  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isVariableWidth, isVariableWidth.exports));
	return isVariableWidth.exports;
}

var isMultibyte = {exports: {}};

var hasRequiredIsMultibyte;

function requireIsMultibyte () {
	if (hasRequiredIsMultibyte) return isMultibyte.exports;
	hasRequiredIsMultibyte = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMultibyte;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/* eslint-disable no-control-regex */
		var multibyte = /[^\x00-\x7F]/;
		/* eslint-enable no-control-regex */

		function isMultibyte(str) {
		  (0, _assertString.default)(str);
		  return multibyte.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMultibyte, isMultibyte.exports));
	return isMultibyte.exports;
}

var isSemVer = {exports: {}};

var multilineRegex = {exports: {}};

var hasRequiredMultilineRegex;

function requireMultilineRegex () {
	if (hasRequiredMultilineRegex) return multilineRegex.exports;
	hasRequiredMultilineRegex = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = multilineRegexp;
		/**
		 * Build RegExp object from an array
		 * of multiple/multi-line regexp parts
		 *
		 * @param {string[]} parts
		 * @param {string} flags
		 * @return {object} - RegExp object
		 */
		function multilineRegexp(parts, flags) {
		  var regexpAsStringLiteral = parts.join('');
		  return new RegExp(regexpAsStringLiteral, flags);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (multilineRegex, multilineRegex.exports));
	return multilineRegex.exports;
}

var hasRequiredIsSemVer;

function requireIsSemVer () {
	if (hasRequiredIsSemVer) return isSemVer.exports;
	hasRequiredIsSemVer = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isSemVer;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _multilineRegex = _interopRequireDefault(/*@__PURE__*/ requireMultilineRegex());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/**
		 * Regular Expression to match
		 * semantic versioning (SemVer)
		 * built from multi-line, multi-parts regexp
		 * Reference: https://semver.org/
		 */
		var semanticVersioningRegex = (0, _multilineRegex.default)(['^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)', '(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))', '?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$'], 'i');
		function isSemVer(str) {
		  (0, _assertString.default)(str);
		  return semanticVersioningRegex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isSemVer, isSemVer.exports));
	return isSemVer.exports;
}

var isSurrogatePair = {exports: {}};

var hasRequiredIsSurrogatePair;

function requireIsSurrogatePair () {
	if (hasRequiredIsSurrogatePair) return isSurrogatePair.exports;
	hasRequiredIsSurrogatePair = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isSurrogatePair;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
		function isSurrogatePair(str) {
		  (0, _assertString.default)(str);
		  return surrogatePair.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isSurrogatePair, isSurrogatePair.exports));
	return isSurrogatePair.exports;
}

var isDecimal = {exports: {}};

var hasRequiredIsDecimal;

function requireIsDecimal () {
	if (hasRequiredIsDecimal) return isDecimal.exports;
	hasRequiredIsDecimal = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDecimal;
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _includesArray = _interopRequireDefault(/*@__PURE__*/ requireIncludesArray());
		var _alpha = /*@__PURE__*/ requireAlpha();
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function decimalRegExp(options) {
		  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? '' : '?', "$"));
		  return regExp;
		}
		var default_decimal_options = {
		  force_decimal: false,
		  decimal_digits: '1,',
		  locale: 'en-US'
		};
		var blacklist = ['', '-', '+'];
		function isDecimal(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_decimal_options);
		  if (options.locale in _alpha.decimal) {
		    return !(0, _includesArray.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);
		  }
		  throw new Error("Invalid locale '".concat(options.locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDecimal, isDecimal.exports));
	return isDecimal.exports;
}

var isHexadecimal = {exports: {}};

var hasRequiredIsHexadecimal;

function requireIsHexadecimal () {
	if (hasRequiredIsHexadecimal) return isHexadecimal.exports;
	hasRequiredIsHexadecimal = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHexadecimal;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
		function isHexadecimal(str) {
		  (0, _assertString.default)(str);
		  return hexadecimal.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHexadecimal, isHexadecimal.exports));
	return isHexadecimal.exports;
}

var isOctal = {exports: {}};

var hasRequiredIsOctal;

function requireIsOctal () {
	if (hasRequiredIsOctal) return isOctal.exports;
	hasRequiredIsOctal = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isOctal;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var octal = /^(0o)?[0-7]+$/i;
		function isOctal(str) {
		  (0, _assertString.default)(str);
		  return octal.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isOctal, isOctal.exports));
	return isOctal.exports;
}

var isDivisibleBy = {exports: {}};

var hasRequiredIsDivisibleBy;

function requireIsDivisibleBy () {
	if (hasRequiredIsDivisibleBy) return isDivisibleBy.exports;
	hasRequiredIsDivisibleBy = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDivisibleBy;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _toFloat = _interopRequireDefault(/*@__PURE__*/ requireToFloat());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isDivisibleBy(str, num) {
		  (0, _assertString.default)(str);
		  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDivisibleBy, isDivisibleBy.exports));
	return isDivisibleBy.exports;
}

var isHexColor = {exports: {}};

var hasRequiredIsHexColor;

function requireIsHexColor () {
	if (hasRequiredIsHexColor) return isHexColor.exports;
	hasRequiredIsHexColor = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHexColor;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
		function isHexColor(str) {
		  (0, _assertString.default)(str);
		  return hexcolor.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHexColor, isHexColor.exports));
	return isHexColor.exports;
}

var isRgbColor = {exports: {}};

var hasRequiredIsRgbColor;

function requireIsRgbColor () {
	if (hasRequiredIsRgbColor) return isRgbColor.exports;
	hasRequiredIsRgbColor = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isRgbColor;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } /* eslint-disable prefer-rest-params */
		var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
		var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d\d?|1(\.0)?|0(\.0)?)\)$/;
		var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
		var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d\d?|1(\.0)?|0(\.0)?)\)$/;
		var startsWithRgb = /^rgba?/;
		function isRgbColor(str, options) {
		  (0, _assertString.default)(str);
		  // default options to true for percent and false for spaces
		  var allowSpaces = false;
		  var includePercentValues = true;
		  if (_typeof(options) !== 'object') {
		    if (arguments.length >= 2) {
		      includePercentValues = arguments[1];
		    }
		  } else {
		    allowSpaces = options.allowSpaces !== undefined ? options.allowSpaces : allowSpaces;
		    includePercentValues = options.includePercentValues !== undefined ? options.includePercentValues : includePercentValues;
		  }
		  if (allowSpaces) {
		    // make sure it starts with continous rgba? without spaces before stripping
		    if (!startsWithRgb.test(str)) {
		      return false;
		    }
		    // strip all whitespace
		    str = str.replace(/\s/g, '');
		  }
		  if (!includePercentValues) {
		    return rgbColor.test(str) || rgbaColor.test(str);
		  }
		  return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isRgbColor, isRgbColor.exports));
	return isRgbColor.exports;
}

var isHSL = {exports: {}};

var hasRequiredIsHSL;

function requireIsHSL () {
	if (hasRequiredIsHSL) return isHSL.exports;
	hasRequiredIsHSL = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHSL;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
		var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
		function isHSL(str) {
		  (0, _assertString.default)(str);

		  // Strip duplicate spaces before calling the validation regex (See  #1598 for more info)
		  var strippedStr = str.replace(/\s+/g, ' ').replace(/\s?(hsla?\(|\)|,)\s?/ig, '$1');
		  if (strippedStr.indexOf(',') !== -1) {
		    return hslComma.test(strippedStr);
		  }
		  return hslSpace.test(strippedStr);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHSL, isHSL.exports));
	return isHSL.exports;
}

var isISRC = {exports: {}};

var hasRequiredIsISRC;

function requireIsISRC () {
	if (hasRequiredIsISRC) return isISRC.exports;
	hasRequiredIsISRC = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISRC;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
		var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
		function isISRC(str) {
		  (0, _assertString.default)(str);
		  return isrc.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISRC, isISRC.exports));
	return isISRC.exports;
}

var isIBAN = {};

var hasRequiredIsIBAN;

function requireIsIBAN () {
	if (hasRequiredIsIBAN) return isIBAN;
	hasRequiredIsIBAN = 1;

	Object.defineProperty(isIBAN, "__esModule", {
	  value: true
	});
	isIBAN.default = isIBAN$1;
	isIBAN.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	var _includesArray = _interopRequireDefault(/*@__PURE__*/ requireIncludesArray());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	/**
	 * List of country codes with
	 * corresponding IBAN regular expression
	 * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
	 */
	var ibanRegexThroughCountryCode = {
	  AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
	  AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
	  AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
	  AT: /^(AT[0-9]{2})\d{16}$/,
	  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
	  BA: /^(BA[0-9]{2})\d{16}$/,
	  BE: /^(BE[0-9]{2})\d{12}$/,
	  BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
	  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
	  BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
	  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
	  CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
	  CR: /^(CR[0-9]{2})\d{18}$/,
	  CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
	  CZ: /^(CZ[0-9]{2})\d{20}$/,
	  DE: /^(DE[0-9]{2})\d{18}$/,
	  DK: /^(DK[0-9]{2})\d{14}$/,
	  DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
	  DZ: /^(DZ\d{24})$/,
	  EE: /^(EE[0-9]{2})\d{16}$/,
	  EG: /^(EG[0-9]{2})\d{25}$/,
	  ES: /^(ES[0-9]{2})\d{20}$/,
	  FI: /^(FI[0-9]{2})\d{14}$/,
	  FO: /^(FO[0-9]{2})\d{14}$/,
	  FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
	  GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
	  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
	  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
	  GL: /^(GL[0-9]{2})\d{14}$/,
	  GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
	  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
	  HR: /^(HR[0-9]{2})\d{17}$/,
	  HU: /^(HU[0-9]{2})\d{24}$/,
	  IE: /^(IE[0-9]{2})[A-Z]{4}\d{14}$/,
	  IL: /^(IL[0-9]{2})\d{19}$/,
	  IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
	  IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
	  IS: /^(IS[0-9]{2})\d{22}$/,
	  IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
	  JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
	  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
	  KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
	  LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
	  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
	  LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
	  LT: /^(LT[0-9]{2})\d{16}$/,
	  LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
	  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
	  MA: /^(MA[0-9]{26})$/,
	  MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
	  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
	  ME: /^(ME[0-9]{2})\d{18}$/,
	  MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
	  MR: /^(MR[0-9]{2})\d{23}$/,
	  MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
	  MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
	  MZ: /^(MZ[0-9]{2})\d{21}$/,
	  NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
	  NO: /^(NO[0-9]{2})\d{11}$/,
	  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
	  PL: /^(PL[0-9]{2})\d{24}$/,
	  PS: /^(PS[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
	  PT: /^(PT[0-9]{2})\d{21}$/,
	  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
	  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
	  RS: /^(RS[0-9]{2})\d{18}$/,
	  SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
	  SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
	  SE: /^(SE[0-9]{2})\d{20}$/,
	  SI: /^(SI[0-9]{2})\d{15}$/,
	  SK: /^(SK[0-9]{2})\d{20}$/,
	  SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
	  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
	  TL: /^(TL[0-9]{2})\d{19}$/,
	  TN: /^(TN[0-9]{2})\d{20}$/,
	  TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
	  UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
	  VA: /^(VA[0-9]{2})\d{18}$/,
	  VG: /^(VG[0-9]{2})[A-Z]{4}\d{16}$/,
	  XK: /^(XK[0-9]{2})\d{16}$/
	};

	/**
	 * Check if the country codes passed are valid using the
	 * ibanRegexThroughCountryCode as a reference
	 *
	 * @param {array} countryCodeArray
	 * @return {boolean}
	 */

	function hasOnlyValidCountryCodes(countryCodeArray) {
	  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function (countryCode) {
	    return !(countryCode in ibanRegexThroughCountryCode);
	  });
	  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
	    return false;
	  }
	  return true;
	}

	/**
	 * Check whether string has correct universal IBAN format
	 * The IBAN consists of up to 34 alphanumeric characters, as follows:
	 * Country Code using ISO 3166-1 alpha-2, two letters
	 * check digits, two digits and
	 * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.
	 * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]
	 *
	 * @param {string} str - string under validation
	 * @param {object} options - object to pass the countries to be either whitelisted or blacklisted
	 * @return {boolean}
	 */
	function hasValidIbanFormat(str, options) {
	  // Strip white spaces and hyphens
	  var strippedStr = str.replace(/[\s\-]+/gi, '').toUpperCase();
	  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
	  var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
	  if (options.whitelist) {
	    if (!hasOnlyValidCountryCodes(options.whitelist)) {
	      return false;
	    }
	    var isoCountryCodeInWhiteList = (0, _includesArray.default)(options.whitelist, isoCountryCode);
	    if (!isoCountryCodeInWhiteList) {
	      return false;
	    }
	  }
	  if (options.blacklist) {
	    var isoCountryCodeInBlackList = (0, _includesArray.default)(options.blacklist, isoCountryCode);
	    if (isoCountryCodeInBlackList) {
	      return false;
	    }
	  }
	  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
	}

	/**
	   * Check whether string has valid IBAN Checksum
	   * by performing basic mod-97 operation and
	   * the remainder should equal 1
	   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string
	   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35
	   * -- Interpret the string as a decimal integer and
	   * -- compute the remainder on division by 97 (mod 97)
	   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
	   *
	   * @param {string} str
	   * @return {boolean}
	   */
	function hasValidIbanChecksum(str) {
	  var strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic
	  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
	  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function (char) {
	    return char.charCodeAt(0) - 55;
	  });
	  var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function (acc, value) {
	    return Number(acc + value) % 97;
	  }, '');
	  return remainder === 1;
	}
	function isIBAN$1(str) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  (0, _assertString.default)(str);
	  return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
	}
	isIBAN.locales = Object.keys(ibanRegexThroughCountryCode);
	return isIBAN;
}

var isBIC = {exports: {}};

var isISO31661Alpha2 = {};

var hasRequiredIsISO31661Alpha2;

function requireIsISO31661Alpha2 () {
	if (hasRequiredIsISO31661Alpha2) return isISO31661Alpha2;
	hasRequiredIsISO31661Alpha2 = 1;

	Object.defineProperty(isISO31661Alpha2, "__esModule", {
	  value: true
	});
	isISO31661Alpha2.CountryCodes = void 0;
	isISO31661Alpha2.default = isISO31661Alpha2$1;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	var validISO31661Alpha2CountriesCodes = new Set(['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW']);
	function isISO31661Alpha2$1(str) {
	  (0, _assertString.default)(str);
	  return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
	}
	isISO31661Alpha2.CountryCodes = validISO31661Alpha2CountriesCodes;
	return isISO31661Alpha2;
}

var hasRequiredIsBIC;

function requireIsBIC () {
	if (hasRequiredIsBIC) return isBIC.exports;
	hasRequiredIsBIC = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBIC;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _isISO31661Alpha = /*@__PURE__*/ requireIsISO31661Alpha2();
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		// https://en.wikipedia.org/wiki/ISO_9362
		var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
		function isBIC(str) {
		  (0, _assertString.default)(str);

		  // toUpperCase() should be removed when a new major version goes out that changes
		  // the regex to [A-Z] (per the spec).
		  var countryCode = str.slice(4, 6).toUpperCase();
		  if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== 'XK') {
		    return false;
		  }
		  return isBICReg.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBIC, isBIC.exports));
	return isBIC.exports;
}

var isMD5 = {exports: {}};

var hasRequiredIsMD5;

function requireIsMD5 () {
	if (hasRequiredIsMD5) return isMD5.exports;
	hasRequiredIsMD5 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMD5;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var md5 = /^[a-f0-9]{32}$/;
		function isMD5(str) {
		  (0, _assertString.default)(str);
		  return md5.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMD5, isMD5.exports));
	return isMD5.exports;
}

var isHash = {exports: {}};

var hasRequiredIsHash;

function requireIsHash () {
	if (hasRequiredIsHash) return isHash.exports;
	hasRequiredIsHash = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isHash;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var lengths = {
		  md5: 32,
		  md4: 32,
		  sha1: 40,
		  sha256: 64,
		  sha384: 96,
		  sha512: 128,
		  ripemd128: 32,
		  ripemd160: 40,
		  tiger128: 32,
		  tiger160: 40,
		  tiger192: 48,
		  crc32: 8,
		  crc32b: 8
		};
		function isHash(str, algorithm) {
		  (0, _assertString.default)(str);
		  var hash = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
		  return hash.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isHash, isHash.exports));
	return isHash.exports;
}

var isJWT = {exports: {}};

var isBase64 = {exports: {}};

var hasRequiredIsBase64;

function requireIsBase64 () {
	if (hasRequiredIsBase64) return isBase64.exports;
	hasRequiredIsBase64 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBase64;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var base64WithPadding = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/;
		var base64WithoutPadding = /^[A-Za-z0-9+/]+$/;
		var base64UrlWithPadding = /^(?:[A-Za-z0-9_-]{4})*(?:[A-Za-z0-9_-]{2}==|[A-Za-z0-9_-]{3}=|[A-Za-z0-9_-]{4})$/;
		var base64UrlWithoutPadding = /^[A-Za-z0-9_-]+$/;
		function isBase64(str, options) {
		  var _options;
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, {
		    urlSafe: false,
		    padding: !((_options = options) !== null && _options !== void 0 && _options.urlSafe)
		  });
		  if (str === '') return true;
		  var regex;
		  if (options.urlSafe) {
		    regex = options.padding ? base64UrlWithPadding : base64UrlWithoutPadding;
		  } else {
		    regex = options.padding ? base64WithPadding : base64WithoutPadding;
		  }
		  return (!options.padding || str.length % 4 === 0) && regex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBase64, isBase64.exports));
	return isBase64.exports;
}

var hasRequiredIsJWT;

function requireIsJWT () {
	if (hasRequiredIsJWT) return isJWT.exports;
	hasRequiredIsJWT = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isJWT;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _isBase = _interopRequireDefault(/*@__PURE__*/ requireIsBase64());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isJWT(str) {
		  (0, _assertString.default)(str);
		  var dotSplit = str.split('.');
		  var len = dotSplit.length;
		  if (len !== 3) {
		    return false;
		  }
		  return dotSplit.reduce(function (acc, currElem) {
		    return acc && (0, _isBase.default)(currElem, {
		      urlSafe: true
		    });
		  }, true);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isJWT, isJWT.exports));
	return isJWT.exports;
}

var isJSON = {exports: {}};

var hasRequiredIsJSON;

function requireIsJSON () {
	if (hasRequiredIsJSON) return isJSON.exports;
	hasRequiredIsJSON = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isJSON;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _includesArray = _interopRequireDefault(/*@__PURE__*/ requireIncludesArray());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		var default_json_options = {
		  allow_primitives: false
		};
		function isJSON(str, options) {
		  (0, _assertString.default)(str);
		  try {
		    options = (0, _merge.default)(options, default_json_options);
		    var primitives = [];
		    if (options.allow_primitives) {
		      primitives = [null, false, true];
		    }
		    var obj = JSON.parse(str);
		    return (0, _includesArray.default)(primitives, obj) || !!obj && _typeof(obj) === 'object';
		  } catch (e) {/* ignore */}
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isJSON, isJSON.exports));
	return isJSON.exports;
}

var isEmpty = {exports: {}};

var hasRequiredIsEmpty;

function requireIsEmpty () {
	if (hasRequiredIsEmpty) return isEmpty.exports;
	hasRequiredIsEmpty = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEmpty;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var default_is_empty_options = {
		  ignore_whitespace: false
		};
		function isEmpty(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_is_empty_options);
		  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEmpty, isEmpty.exports));
	return isEmpty.exports;
}

var isLength = {exports: {}};

var hasRequiredIsLength;

function requireIsLength () {
	if (hasRequiredIsLength) return isLength.exports;
	hasRequiredIsLength = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLength;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		/* eslint-disable prefer-rest-params */
		function isLength(str, options) {
		  (0, _assertString.default)(str);
		  var min;
		  var max;
		  if (_typeof(options) === 'object') {
		    min = options.min || 0;
		    max = options.max;
		  } else {
		    // backwards compatibility: isLength(str, min [, max])
		    min = arguments[1] || 0;
		    max = arguments[2];
		  }
		  var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
		  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
		  var len = str.length - presentationSequences.length - surrogatePairs.length;
		  var isInsideRange = len >= min && (typeof max === 'undefined' || len <= max);
		  if (isInsideRange && Array.isArray(options === null || options === void 0 ? void 0 : options.discreteLengths)) {
		    return options.discreteLengths.some(function (discreteLen) {
		      return discreteLen === len;
		    });
		  }
		  return isInsideRange;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLength, isLength.exports));
	return isLength.exports;
}

var isULID = {exports: {}};

var hasRequiredIsULID;

function requireIsULID () {
	if (hasRequiredIsULID) return isULID.exports;
	hasRequiredIsULID = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isULID;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isULID(str) {
		  (0, _assertString.default)(str);
		  return /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isULID, isULID.exports));
	return isULID.exports;
}

var isUUID = {exports: {}};

var hasRequiredIsUUID;

function requireIsUUID () {
	if (hasRequiredIsUUID) return isUUID.exports;
	hasRequiredIsUUID = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isUUID;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var uuid = {
		  1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  6: /^[0-9A-F]{8}-[0-9A-F]{4}-6[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  8: /^[0-9A-F]{8}-[0-9A-F]{4}-8[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
		  nil: /^00000000-0000-0000-0000-000000000000$/i,
		  max: /^ffffffff-ffff-ffff-ffff-ffffffffffff$/i,
		  loose: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
		  // From https://github.com/uuidjs/uuid/blob/main/src/regex.js
		  all: /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i
		};
		function isUUID(str, version) {
		  (0, _assertString.default)(str);
		  if (version === undefined || version === null) {
		    version = 'all';
		  }
		  return version in uuid ? uuid[version].test(str) : false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isUUID, isUUID.exports));
	return isUUID.exports;
}

var isMongoId = {exports: {}};

var hasRequiredIsMongoId;

function requireIsMongoId () {
	if (hasRequiredIsMongoId) return isMongoId.exports;
	hasRequiredIsMongoId = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMongoId;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _isHexadecimal = _interopRequireDefault(/*@__PURE__*/ requireIsHexadecimal());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isMongoId(str) {
		  (0, _assertString.default)(str);
		  return (0, _isHexadecimal.default)(str) && str.length === 24;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMongoId, isMongoId.exports));
	return isMongoId.exports;
}

var isAfter = {exports: {}};

var hasRequiredIsAfter;

function requireIsAfter () {
	if (hasRequiredIsAfter) return isAfter.exports;
	hasRequiredIsAfter = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isAfter;
		var _toDate = _interopRequireDefault(/*@__PURE__*/ requireToDate());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function isAfter(date, options) {
		  // For backwards compatibility:
		  // isAfter(str [, date]), i.e. `options` could be used as argument for the legacy `date`
		  var comparisonDate = (_typeof(options) === 'object' ? options.comparisonDate : options) || Date().toString();
		  var comparison = (0, _toDate.default)(comparisonDate);
		  var original = (0, _toDate.default)(date);
		  return !!(original && comparison && original > comparison);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isAfter, isAfter.exports));
	return isAfter.exports;
}

var isBefore = {exports: {}};

var hasRequiredIsBefore;

function requireIsBefore () {
	if (hasRequiredIsBefore) return isBefore.exports;
	hasRequiredIsBefore = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBefore;
		var _toDate = _interopRequireDefault(/*@__PURE__*/ requireToDate());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function isBefore(date, options) {
		  // For backwards compatibility:
		  // isBefore(str [, date]), i.e. `options` could be used as argument for the legacy `date`
		  var comparisonDate = (_typeof(options) === 'object' ? options.comparisonDate : options) || Date().toString();
		  var comparison = (0, _toDate.default)(comparisonDate);
		  var original = (0, _toDate.default)(date);
		  return !!(original && comparison && original < comparison);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBefore, isBefore.exports));
	return isBefore.exports;
}

var isIn = {exports: {}};

var hasRequiredIsIn;

function requireIsIn () {
	if (hasRequiredIsIn) return isIn.exports;
	hasRequiredIsIn = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIn;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _toString = _interopRequireDefault(/*@__PURE__*/ requireToString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function isIn(str, options) {
		  (0, _assertString.default)(str);
		  var i;
		  if (Object.prototype.toString.call(options) === '[object Array]') {
		    var array = [];
		    for (i in options) {
		      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
		      // istanbul ignore else
		      if ({}.hasOwnProperty.call(options, i)) {
		        array[i] = (0, _toString.default)(options[i]);
		      }
		    }
		    return array.indexOf(str) >= 0;
		  } else if (_typeof(options) === 'object') {
		    return options.hasOwnProperty(str);
		  } else if (options && typeof options.indexOf === 'function') {
		    return options.indexOf(str) >= 0;
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIn, isIn.exports));
	return isIn.exports;
}

var isLuhnNumber = {exports: {}};

var hasRequiredIsLuhnNumber;

function requireIsLuhnNumber () {
	if (hasRequiredIsLuhnNumber) return isLuhnNumber.exports;
	hasRequiredIsLuhnNumber = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLuhnNumber;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isLuhnNumber(str) {
		  (0, _assertString.default)(str);
		  var sanitized = str.replace(/[- ]+/g, '');
		  var sum = 0;
		  var digit;
		  var tmpNum;
		  var shouldDouble;
		  for (var i = sanitized.length - 1; i >= 0; i--) {
		    digit = sanitized.substring(i, i + 1);
		    tmpNum = parseInt(digit, 10);
		    if (shouldDouble) {
		      tmpNum *= 2;
		      if (tmpNum >= 10) {
		        sum += tmpNum % 10 + 1;
		      } else {
		        sum += tmpNum;
		      }
		    } else {
		      sum += tmpNum;
		    }
		    shouldDouble = !shouldDouble;
		  }
		  return !!(sum % 10 === 0 ? sanitized : false);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLuhnNumber, isLuhnNumber.exports));
	return isLuhnNumber.exports;
}

var isCreditCard = {exports: {}};

var hasRequiredIsCreditCard;

function requireIsCreditCard () {
	if (hasRequiredIsCreditCard) return isCreditCard.exports;
	hasRequiredIsCreditCard = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isCreditCard;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _isLuhnNumber = _interopRequireDefault(/*@__PURE__*/ requireIsLuhnNumber());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var cards = {
		  amex: /^3[47][0-9]{13}$/,
		  dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
		  discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
		  jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
		  mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
		  // /^[25][1-7][0-9]{14}$/;
		  unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
		  visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
		};
		var allCards = function () {
		  var tmpCardsArray = [];
		  for (var cardProvider in cards) {
		    // istanbul ignore else
		    if (cards.hasOwnProperty(cardProvider)) {
		      tmpCardsArray.push(cards[cardProvider]);
		    }
		  }
		  return tmpCardsArray;
		}();
		function isCreditCard(card) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(card);
		  var provider = options.provider;
		  var sanitized = card.replace(/[- ]+/g, '');
		  if (provider && provider.toLowerCase() in cards) {
		    // specific provider in the list
		    if (!cards[provider.toLowerCase()].test(sanitized)) {
		      return false;
		    }
		  } else if (provider && !(provider.toLowerCase() in cards)) {
		    /* specific provider not in the list */
		    throw new Error("".concat(provider, " is not a valid credit card provider."));
		  } else if (!allCards.some(function (cardProvider) {
		    return cardProvider.test(sanitized);
		  })) {
		    // no specific provider
		    return false;
		  }
		  return (0, _isLuhnNumber.default)(card);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isCreditCard, isCreditCard.exports));
	return isCreditCard.exports;
}

var isIdentityCard = {exports: {}};

var hasRequiredIsIdentityCard;

function requireIsIdentityCard () {
	if (hasRequiredIsIdentityCard) return isIdentityCard.exports;
	hasRequiredIsIdentityCard = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isIdentityCard;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _includesArray = _interopRequireDefault(/*@__PURE__*/ requireIncludesArray());
		var _isInt = _interopRequireDefault(/*@__PURE__*/ requireIsInt());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var validators = {
		  PL: function PL(str) {
		    (0, _assertString.default)(str);
		    var weightOfDigits = {
		      1: 1,
		      2: 3,
		      3: 7,
		      4: 9,
		      5: 1,
		      6: 3,
		      7: 7,
		      8: 9,
		      9: 1,
		      10: 3,
		      11: 0
		    };
		    if (str != null && str.length === 11 && (0, _isInt.default)(str, {
		      allow_leading_zeroes: true
		    })) {
		      var digits = str.split('').slice(0, -1);
		      var sum = digits.reduce(function (acc, digit, index) {
		        return acc + Number(digit) * weightOfDigits[index + 1];
		      }, 0);
		      var modulo = sum % 10;
		      var lastDigit = Number(str.charAt(str.length - 1));
		      if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
		        return true;
		      }
		    }
		    return false;
		  },
		  ES: function ES(str) {
		    (0, _assertString.default)(str);
		    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
		    var charsValue = {
		      X: 0,
		      Y: 1,
		      Z: 2
		    };
		    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];

		    // sanitize user input
		    var sanitized = str.trim().toUpperCase();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }

		    // validate the control digit
		    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) {
		      return charsValue[char];
		    });
		    return sanitized.endsWith(controlDigits[number % 23]);
		  },
		  FI: function FI(str) {
		    // https://dvv.fi/en/personal-identity-code#:~:text=control%20character%20for%20a-,personal,-identity%20code%20calculated
		    (0, _assertString.default)(str);
		    if (str.length !== 11) {
		      return false;
		    }
		    if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
		      return false;
		    }
		    var checkDigits = '0123456789ABCDEFHJKLMNPRSTUVWXY';
		    var idAsNumber = parseInt(str.slice(0, 6), 10) * 1000 + parseInt(str.slice(7, 10), 10);
		    var remainder = idAsNumber % 31;
		    var checkDigit = checkDigits[remainder];
		    return checkDigit === str.slice(10, 11);
		  },
		  IN: function IN(str) {
		    var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;

		    // multiplication table
		    var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];

		    // permutation table
		    var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }
		    var c = 0;
		    var invertedArray = sanitized.replace(/\s/g, '').split('').map(Number).reverse();
		    invertedArray.forEach(function (val, i) {
		      c = d[c][p[i % 8][val]];
		    });
		    return c === 0;
		  },
		  IR: function IR(str) {
		    if (!str.match(/^\d{10}$/)) return false;
		    str = "0000".concat(str).slice(str.length - 6);
		    if (parseInt(str.slice(3, 9), 10) === 0) return false;
		    var lastNumber = parseInt(str.slice(9, 10), 10);
		    var sum = 0;
		    for (var i = 0; i < 9; i++) {
		      sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
		    }
		    sum %= 11;
		    return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
		  },
		  IT: function IT(str) {
		    if (str.length !== 9) return false;
		    if (str === 'CA00000AA') return false; // https://it.wikipedia.org/wiki/Carta_d%27identit%C3%A0_elettronica_italiana
		    return str.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1;
		  },
		  NO: function NO(str) {
		    var sanitized = str.trim();
		    if (isNaN(Number(sanitized))) return false;
		    if (sanitized.length !== 11) return false;
		    if (sanitized === '00000000000') return false;

		    // https://no.wikipedia.org/wiki/F%C3%B8dselsnummer
		    var f = sanitized.split('').map(Number);
		    var k1 = (11 - (3 * f[0] + 7 * f[1] + 6 * f[2] + 1 * f[3] + 8 * f[4] + 9 * f[5] + 4 * f[6] + 5 * f[7] + 2 * f[8]) % 11) % 11;
		    var k2 = (11 - (5 * f[0] + 4 * f[1] + 3 * f[2] + 2 * f[3] + 7 * f[4] + 6 * f[5] + 5 * f[6] + 4 * f[7] + 3 * f[8] + 2 * k1) % 11) % 11;
		    if (k1 !== f[9] || k2 !== f[10]) return false;
		    return true;
		  },
		  TH: function TH(str) {
		    if (!str.match(/^[1-8]\d{12}$/)) return false;

		    // validate check digit
		    var sum = 0;
		    for (var i = 0; i < 12; i++) {
		      sum += parseInt(str[i], 10) * (13 - i);
		    }
		    return str[12] === ((11 - sum % 11) % 10).toString();
		  },
		  LK: function LK(str) {
		    var old_nic = /^[1-9]\d{8}[vx]$/i;
		    var new_nic = /^[1-9]\d{11}$/i;
		    if (str.length === 10 && old_nic.test(str)) return true;else if (str.length === 12 && new_nic.test(str)) return true;
		    return false;
		  },
		  'he-IL': function heIL(str) {
		    var DNI = /^\d{9}$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }
		    var id = sanitized;
		    var sum = 0,
		      incNum;
		    for (var i = 0; i < id.length; i++) {
		      incNum = Number(id[i]) * (i % 2 + 1); // Multiply number by 1 or 2
		      sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total
		    }
		    return sum % 10 === 0;
		  },
		  'ar-LY': function arLY(str) {
		    // Libya National Identity Number NIN is 12 digits, the first digit is either 1 or 2
		    var NIN = /^(1|2)\d{11}$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!NIN.test(sanitized)) {
		      return false;
		    }
		    return true;
		  },
		  'ar-TN': function arTN(str) {
		    var DNI = /^\d{8}$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    if (!DNI.test(sanitized)) {
		      return false;
		    }
		    return true;
		  },
		  'zh-CN': function zhCN(str) {
		    var provincesAndCities = ['11',
		    // 北京
		    '12',
		    // 天津
		    '13',
		    // 河北
		    '14',
		    // 山西
		    '15',
		    // 内蒙古
		    '21',
		    // 辽宁
		    '22',
		    // 吉林
		    '23',
		    // 黑龙江
		    '31',
		    // 上海
		    '32',
		    // 江苏
		    '33',
		    // 浙江
		    '34',
		    // 安徽
		    '35',
		    // 福建
		    '36',
		    // 江西
		    '37',
		    // 山东
		    '41',
		    // 河南
		    '42',
		    // 湖北
		    '43',
		    // 湖南
		    '44',
		    // 广东
		    '45',
		    // 广西
		    '46',
		    // 海南
		    '50',
		    // 重庆
		    '51',
		    // 四川
		    '52',
		    // 贵州
		    '53',
		    // 云南
		    '54',
		    // 西藏
		    '61',
		    // 陕西
		    '62',
		    // 甘肃
		    '63',
		    // 青海
		    '64',
		    // 宁夏
		    '65',
		    // 新疆
		    '71',
		    // 台湾
		    '81',
		    // 香港
		    '82',
		    // 澳门
		    '91' // 国外
		    ];
		    var powers = ['7', '9', '10', '5', '8', '4', '2', '1', '6', '3', '7', '9', '10', '5', '8', '4', '2'];
		    var parityBit = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];
		    var checkAddressCode = function checkAddressCode(addressCode) {
		      return (0, _includesArray.default)(provincesAndCities, addressCode);
		    };
		    var checkBirthDayCode = function checkBirthDayCode(birDayCode) {
		      var yyyy = parseInt(birDayCode.substring(0, 4), 10);
		      var mm = parseInt(birDayCode.substring(4, 6), 10);
		      var dd = parseInt(birDayCode.substring(6), 10);
		      var xdata = new Date(yyyy, mm - 1, dd);
		      if (xdata > new Date()) {
		        return false;
		        // eslint-disable-next-line max-len
		      } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
		        return true;
		      }
		      return false;
		    };
		    var getParityBit = function getParityBit(idCardNo) {
		      var id17 = idCardNo.substring(0, 17);
		      var power = 0;
		      for (var i = 0; i < 17; i++) {
		        power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
		      }
		      var mod = power % 11;
		      return parityBit[mod];
		    };
		    var checkParityBit = function checkParityBit(idCardNo) {
		      return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
		    };
		    var check15IdCardNo = function check15IdCardNo(idCardNo) {
		      var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
		      if (!check) return false;
		      var addressCode = idCardNo.substring(0, 2);
		      check = checkAddressCode(addressCode);
		      if (!check) return false;
		      var birDayCode = "19".concat(idCardNo.substring(6, 12));
		      check = checkBirthDayCode(birDayCode);
		      if (!check) return false;
		      return true;
		    };
		    var check18IdCardNo = function check18IdCardNo(idCardNo) {
		      var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
		      if (!check) return false;
		      var addressCode = idCardNo.substring(0, 2);
		      check = checkAddressCode(addressCode);
		      if (!check) return false;
		      var birDayCode = idCardNo.substring(6, 14);
		      check = checkBirthDayCode(birDayCode);
		      if (!check) return false;
		      return checkParityBit(idCardNo);
		    };
		    var checkIdCardNo = function checkIdCardNo(idCardNo) {
		      var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
		      if (!check) return false;
		      if (idCardNo.length === 15) {
		        return check15IdCardNo(idCardNo);
		      }
		      return check18IdCardNo(idCardNo);
		    };
		    return checkIdCardNo(str);
		  },
		  'zh-HK': function zhHK(str) {
		    // sanitize user input
		    str = str.trim();

		    // HKID number starts with 1 or 2 letters, followed by 6 digits,
		    // then a checksum contained in square / round brackets or nothing
		    var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
		    var regexIsDigit = /^[0-9]$/;

		    // convert the user input to all uppercase and apply regex
		    str = str.toUpperCase();
		    if (!regexHKID.test(str)) return false;
		    str = str.replace(/\[|\]|\(|\)/g, '');
		    if (str.length === 8) str = "3".concat(str);
		    var checkSumVal = 0;
		    for (var i = 0; i <= 7; i++) {
		      var convertedChar = void 0;
		      if (!regexIsDigit.test(str[i])) convertedChar = (str[i].charCodeAt(0) - 55) % 11;else convertedChar = str[i];
		      checkSumVal += convertedChar * (9 - i);
		    }
		    checkSumVal %= 11;
		    var checkSumConverted;
		    if (checkSumVal === 0) checkSumConverted = '0';else if (checkSumVal === 1) checkSumConverted = 'A';else checkSumConverted = String(11 - checkSumVal);
		    if (checkSumConverted === str[str.length - 1]) return true;
		    return false;
		  },
		  'zh-TW': function zhTW(str) {
		    var ALPHABET_CODES = {
		      A: 10,
		      B: 11,
		      C: 12,
		      D: 13,
		      E: 14,
		      F: 15,
		      G: 16,
		      H: 17,
		      I: 34,
		      J: 18,
		      K: 19,
		      L: 20,
		      M: 21,
		      N: 22,
		      O: 35,
		      P: 23,
		      Q: 24,
		      R: 25,
		      S: 26,
		      T: 27,
		      U: 28,
		      V: 29,
		      W: 32,
		      X: 30,
		      Y: 31,
		      Z: 33
		    };
		    var sanitized = str.trim().toUpperCase();
		    if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;
		    return Array.from(sanitized).reduce(function (sum, number, index) {
		      if (index === 0) {
		        var code = ALPHABET_CODES[number];
		        return code % 10 * 9 + Math.floor(code / 10);
		      }
		      if (index === 9) {
		        return (10 - sum % 10 - Number(number)) % 10 === 0;
		      }
		      return sum + Number(number) * (9 - index);
		    }, 0);
		  },
		  PK: function PK(str) {
		    // Pakistani National Identity Number CNIC is 13 digits
		    var CNIC = /^[1-7][0-9]{4}-[0-9]{7}-[1-9]$/;

		    // sanitize user input
		    var sanitized = str.trim();

		    // validate the data structure
		    return CNIC.test(sanitized);
		  }
		};
		function isIdentityCard(str, locale) {
		  (0, _assertString.default)(str);
		  if (locale in validators) {
		    return validators[locale](str);
		  } else if (locale === 'any') {
		    for (var key in validators) {
		      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
		      // istanbul ignore else
		      if (validators.hasOwnProperty(key)) {
		        var validator = validators[key];
		        if (validator(str)) {
		          return true;
		        }
		      }
		    }
		    return false;
		  }
		  throw new Error("Invalid locale '".concat(locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isIdentityCard, isIdentityCard.exports));
	return isIdentityCard.exports;
}

var isEAN = {exports: {}};

var hasRequiredIsEAN;

function requireIsEAN () {
	if (hasRequiredIsEAN) return isEAN.exports;
	hasRequiredIsEAN = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEAN;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/**
		 * The most commonly used EAN standard is
		 * the thirteen-digit EAN-13, while the
		 * less commonly used 8-digit EAN-8 barcode was
		 * introduced for use on small packages.
		 * Also EAN/UCC-14 is used for Grouping of individual
		 * trade items above unit level(Intermediate, Carton or Pallet).
		 * For more info about EAN-14 checkout: https://www.gtin.info/itf-14-barcodes/
		 * EAN consists of:
		 * GS1 prefix, manufacturer code, product code and check digit
		 * Reference: https://en.wikipedia.org/wiki/International_Article_Number
		 * Reference: https://www.gtin.info/
		 */

		/**
		 * Define EAN Lengths; 8 for EAN-8; 13 for EAN-13; 14 for EAN-14
		 * and Regular Expression for valid EANs (EAN-8, EAN-13, EAN-14),
		 * with exact numeric matching of 8 or 13 or 14 digits [0-9]
		 */
		var LENGTH_EAN_8 = 8;
		var LENGTH_EAN_14 = 14;
		var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;

		/**
		 * Get position weight given:
		 * EAN length and digit index/position
		 *
		 * @param {number} length
		 * @param {number} index
		 * @return {number}
		 */
		function getPositionWeightThroughLengthAndIndex(length, index) {
		  if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
		    return index % 2 === 0 ? 3 : 1;
		  }
		  return index % 2 === 0 ? 1 : 3;
		}

		/**
		 * Calculate EAN Check Digit
		 * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit
		 *
		 * @param {string} ean
		 * @return {number}
		 */
		function calculateCheckDigit(ean) {
		  var checksum = ean.slice(0, -1).split('').map(function (char, index) {
		    return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
		  }).reduce(function (acc, partialSum) {
		    return acc + partialSum;
		  }, 0);
		  var remainder = 10 - checksum % 10;
		  return remainder < 10 ? remainder : 0;
		}

		/**
		 * Check if string is valid EAN:
		 * Matches EAN-8/EAN-13/EAN-14 regex
		 * Has valid check digit.
		 *
		 * @param {string} str
		 * @return {boolean}
		 */
		function isEAN(str) {
		  (0, _assertString.default)(str);
		  var actualCheckDigit = Number(str.slice(-1));
		  return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEAN, isEAN.exports));
	return isEAN.exports;
}

var isISIN = {exports: {}};

var hasRequiredIsISIN;

function requireIsISIN () {
	if (hasRequiredIsISIN) return isISIN.exports;
	hasRequiredIsISIN = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISIN;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

		// this link details how the check digit is calculated:
		// https://www.isin.org/isin-format/. it is a little bit
		// odd in that it works with digits, not numbers. in order
		// to make only one pass through the ISIN characters, the
		// each alpha character is handled as 2 characters within
		// the loop.

		function isISIN(str) {
		  (0, _assertString.default)(str);
		  if (!isin.test(str)) {
		    return false;
		  }
		  var double = true;
		  var sum = 0;
		  // convert values
		  for (var i = str.length - 2; i >= 0; i--) {
		    if (str[i] >= 'A' && str[i] <= 'Z') {
		      var value = str[i].charCodeAt(0) - 55;
		      var lo = value % 10;
		      var hi = Math.trunc(value / 10);
		      // letters have two digits, so handle the low order
		      // and high order digits separately.
		      for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
		        var digit = _arr[_i];
		        if (double) {
		          if (digit >= 5) {
		            sum += 1 + (digit - 5) * 2;
		          } else {
		            sum += digit * 2;
		          }
		        } else {
		          sum += digit;
		        }
		        double = !double;
		      }
		    } else {
		      var _digit = str[i].charCodeAt(0) - '0'.charCodeAt(0);
		      if (double) {
		        if (_digit >= 5) {
		          sum += 1 + (_digit - 5) * 2;
		        } else {
		          sum += _digit * 2;
		        }
		      } else {
		        sum += _digit;
		      }
		      double = !double;
		    }
		  }
		  var check = Math.trunc((sum + 9) / 10) * 10 - sum;
		  return +str[str.length - 1] === check;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISIN, isISIN.exports));
	return isISIN.exports;
}

var isISBN = {exports: {}};

var hasRequiredIsISBN;

function requireIsISBN () {
	if (hasRequiredIsISBN) return isISBN.exports;
	hasRequiredIsISBN = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISBN;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
		var possibleIsbn13 = /^(?:[0-9]{13})$/;
		var factor = [1, 3];
		function isISBN(isbn, options) {
		  (0, _assertString.default)(isbn);

		  // For backwards compatibility:
		  // isISBN(str [, version]), i.e. `options` could be used as argument for the legacy `version`
		  var version = String((options === null || options === void 0 ? void 0 : options.version) || options);
		  if (!(options !== null && options !== void 0 && options.version || options)) {
		    return isISBN(isbn, {
		      version: 10
		    }) || isISBN(isbn, {
		      version: 13
		    });
		  }
		  var sanitizedIsbn = isbn.replace(/[\s-]+/g, '');
		  var checksum = 0;
		  if (version === '10') {
		    if (!possibleIsbn10.test(sanitizedIsbn)) {
		      return false;
		    }
		    for (var i = 0; i < version - 1; i++) {
		      checksum += (i + 1) * sanitizedIsbn.charAt(i);
		    }
		    if (sanitizedIsbn.charAt(9) === 'X') {
		      checksum += 10 * 10;
		    } else {
		      checksum += 10 * sanitizedIsbn.charAt(9);
		    }
		    if (checksum % 11 === 0) {
		      return true;
		    }
		  } else if (version === '13') {
		    if (!possibleIsbn13.test(sanitizedIsbn)) {
		      return false;
		    }
		    for (var _i = 0; _i < 12; _i++) {
		      checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
		    }
		    if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
		      return true;
		    }
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISBN, isISBN.exports));
	return isISBN.exports;
}

var isISSN = {exports: {}};

var hasRequiredIsISSN;

function requireIsISSN () {
	if (hasRequiredIsISSN) return isISSN.exports;
	hasRequiredIsISSN = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISSN;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var issn = '^\\d{4}-?\\d{3}[\\dX]$';
		function isISSN(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(str);
		  var testIssn = issn;
		  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
		  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');
		  if (!testIssn.test(str)) {
		    return false;
		  }
		  var digits = str.replace('-', '').toUpperCase();
		  var checksum = 0;
		  for (var i = 0; i < digits.length; i++) {
		    var digit = digits[i];
		    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
		  }
		  return checksum % 11 === 0;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISSN, isISSN.exports));
	return isISSN.exports;
}

var isTaxID = {exports: {}};

var algorithms = {};

var hasRequiredAlgorithms;

function requireAlgorithms () {
	if (hasRequiredAlgorithms) return algorithms;
	hasRequiredAlgorithms = 1;

	Object.defineProperty(algorithms, "__esModule", {
	  value: true
	});
	algorithms.iso7064Check = iso7064Check;
	algorithms.luhnCheck = luhnCheck;
	algorithms.reverseMultiplyAndSum = reverseMultiplyAndSum;
	algorithms.verhoeffCheck = verhoeffCheck;
	/**
	 * Algorithmic validation functions
	 * May be used as is or implemented in the workflow of other validators.
	 */

	/*
	 * ISO 7064 validation function
	 * Called with a string of numbers (incl. check digit)
	 * to validate according to ISO 7064 (MOD 11, 10).
	 */
	function iso7064Check(str) {
	  var checkvalue = 10;
	  for (var i = 0; i < str.length - 1; i++) {
	    checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
	  }
	  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
	  return checkvalue === parseInt(str[10], 10);
	}

	/*
	 * Luhn (mod 10) validation function
	 * Called with a string of numbers (incl. check digit)
	 * to validate according to the Luhn algorithm.
	 */
	function luhnCheck(str) {
	  var checksum = 0;
	  var second = false;
	  for (var i = str.length - 1; i >= 0; i--) {
	    if (second) {
	      var product = parseInt(str[i], 10) * 2;
	      if (product > 9) {
	        // sum digits of product and add to checksum
	        checksum += product.toString().split('').map(function (a) {
	          return parseInt(a, 10);
	        }).reduce(function (a, b) {
	          return a + b;
	        }, 0);
	      } else {
	        checksum += product;
	      }
	    } else {
	      checksum += parseInt(str[i], 10);
	    }
	    second = !second;
	  }
	  return checksum % 10 === 0;
	}

	/*
	 * Reverse TIN multiplication and summation helper function
	 * Called with an array of single-digit integers and a base multiplier
	 * to calculate the sum of the digits multiplied in reverse.
	 * Normally used in variations of MOD 11 algorithmic checks.
	 */
	function reverseMultiplyAndSum(digits, base) {
	  var total = 0;
	  for (var i = 0; i < digits.length; i++) {
	    total += digits[i] * (base - i);
	  }
	  return total;
	}

	/*
	 * Verhoeff validation helper function
	 * Called with a string of numbers
	 * to validate according to the Verhoeff algorithm.
	 */
	function verhoeffCheck(str) {
	  var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
	  var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];

	  // Copy (to prevent replacement) and reverse
	  var str_copy = str.split('').reverse().join('');
	  var checksum = 0;
	  for (var i = 0; i < str_copy.length; i++) {
	    checksum = d_table[checksum][p_table[i % 8][parseInt(str_copy[i], 10)]];
	  }
	  return checksum === 0;
	}
	return algorithms;
}

var hasRequiredIsTaxID;

function requireIsTaxID () {
	if (hasRequiredIsTaxID) return isTaxID.exports;
	hasRequiredIsTaxID = 1;
	(function (module, exports) {

		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isTaxID;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var algorithms = _interopRequireWildcard(/*@__PURE__*/ requireAlgorithms());
		var _isDate = _interopRequireDefault(/*@__PURE__*/ requireIsDate());
		function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
		function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
		function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
		function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
		function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
		/**
		 * TIN Validation
		 * Validates Tax Identification Numbers (TINs) from the US, EU member states and the United Kingdom.
		 *
		 * EU-UK:
		 * National TIN validity is calculated using public algorithms as made available by DG TAXUD.
		 *
		 * See `https://ec.europa.eu/taxation_customs/tin/specs/FS-TIN%20Algorithms-Public.docx` for more information.
		 *
		 * US:
		 * An Employer Identification Number (EIN), also known as a Federal Tax Identification Number,
		 *  is used to identify a business entity.
		 *
		 * NOTES:
		 *  - Prefix 47 is being reserved for future use
		 *  - Prefixes 26, 27, 45, 46 and 47 were previously assigned by the Philadelphia campus.
		 *
		 * See `http://www.irs.gov/Businesses/Small-Businesses-&-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes`
		 * for more information.
		 */

		// Locale functions

		/*
		 * bg-BG validation function
		 * (Edinen graždanski nomer (EGN/ЕГН), persons only)
		 * Checks if birth date (first six digits) is valid and calculates check (last) digit
		 */
		function bgBgCheck(tin) {
		  // Extract full year, normalize month and check birth date validity
		  var century_year = tin.slice(0, 2);
		  var month = parseInt(tin.slice(2, 4), 10);
		  if (month > 40) {
		    month -= 40;
		    century_year = "20".concat(century_year);
		  } else if (month > 20) {
		    month -= 20;
		    century_year = "18".concat(century_year);
		  } else {
		    century_year = "19".concat(century_year);
		  }
		  if (month < 10) {
		    month = "0".concat(month);
		  }
		  var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });

		  // Calculate checksum by multiplying digits with fixed values
		  var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
		  var checksum = 0;
		  for (var i = 0; i < multip_lookup.length; i++) {
		    checksum += digits[i] * multip_lookup[i];
		  }
		  checksum = checksum % 11 === 10 ? 0 : checksum % 11;
		  return checksum === digits[9];
		}

		/**
		 * Check if an input is a valid Canadian SIN (Social Insurance Number)
		 *
		 * The Social Insurance Number (SIN) is a 9 digit number that
		 * you need to work in Canada or to have access to government programs and benefits.
		 *
		 * https://en.wikipedia.org/wiki/Social_Insurance_Number
		 * https://www.canada.ca/en/employment-social-development/services/sin.html
		 * https://www.codercrunch.com/challenge/819302488/sin-validator
		 *
		 * @param {string} input
		 * @return {boolean}
		 */
		function isCanadianSIN(input) {
		  var digitsArray = input.split('');
		  var even = digitsArray.filter(function (_, idx) {
		    return idx % 2;
		  }).map(function (i) {
		    return Number(i) * 2;
		  }).join('').split('');
		  var total = digitsArray.filter(function (_, idx) {
		    return !(idx % 2);
		  }).concat(even).map(function (i) {
		    return Number(i);
		  }).reduce(function (acc, cur) {
		    return acc + cur;
		  });
		  return total % 10 === 0;
		}

		/*
		 * cs-CZ validation function
		 * (Rodné číslo (RČ), persons only)
		 * Checks if birth date (first six digits) is valid and divisibility by 11
		 * Material not in DG TAXUD document sourced from:
		 * -`https://lorenc.info/3MA381/overeni-spravnosti-rodneho-cisla.htm`
		 * -`https://www.mvcr.cz/clanek/rady-a-sluzby-dokumenty-rodne-cislo.aspx`
		 */
		function csCzCheck(tin) {
		  tin = tin.replace(/\W/, '');

		  // Extract full year from TIN length
		  var full_year = parseInt(tin.slice(0, 2), 10);
		  if (tin.length === 10) {
		    if (full_year < 54) {
		      full_year = "20".concat(full_year);
		    } else {
		      full_year = "19".concat(full_year);
		    }
		  } else {
		    if (tin.slice(6) === '000') {
		      return false;
		    } // Three-zero serial not assigned before 1954
		    if (full_year < 54) {
		      full_year = "19".concat(full_year);
		    } else {
		      return false; // No 18XX years seen in any of the resources
		    }
		  }
		  // Add missing zero if needed
		  if (full_year.length === 3) {
		    full_year = [full_year.slice(0, 2), '0', full_year.slice(2)].join('');
		  }

		  // Extract month from TIN and normalize
		  var month = parseInt(tin.slice(2, 4), 10);
		  if (month > 50) {
		    month -= 50;
		  }
		  if (month > 20) {
		    // Month-plus-twenty was only introduced in 2004
		    if (parseInt(full_year, 10) < 2004) {
		      return false;
		    }
		    month -= 20;
		  }
		  if (month < 10) {
		    month = "0".concat(month);
		  }

		  // Check date validity
		  var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Verify divisibility by 11
		  if (tin.length === 10) {
		    if (parseInt(tin, 10) % 11 !== 0) {
		      // Some numbers up to and including 1985 are still valid if
		      // check (last) digit equals 0 and modulo of first 9 digits equals 10
		      var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
		      if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
		        if (parseInt(tin.slice(9), 10) !== 0) {
		          return false;
		        }
		      } else {
		        return false;
		      }
		    }
		  }
		  return true;
		}

		/*
		 * de-AT validation function
		 * (Abgabenkontonummer, persons/entities)
		 * Verify TIN validity by calling luhnCheck()
		 */
		function deAtCheck(tin) {
		  return algorithms.luhnCheck(tin);
		}

		/*
		 * de-DE validation function
		 * (Steueridentifikationsnummer (Steuer-IdNr.), persons only)
		 * Tests for single duplicate/triplicate value, then calculates ISO 7064 check (last) digit
		 * Partial implementation of spec (same result with both algorithms always)
		 */
		function deDeCheck(tin) {
		  // Split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });

		  // Fill array with strings of number positions
		  var occurrences = [];
		  for (var i = 0; i < digits.length - 1; i++) {
		    occurrences.push('');
		    for (var j = 0; j < digits.length - 1; j++) {
		      if (digits[i] === digits[j]) {
		        occurrences[i] += j;
		      }
		    }
		  }

		  // Remove digits with one occurrence and test for only one duplicate/triplicate
		  occurrences = occurrences.filter(function (a) {
		    return a.length > 1;
		  });
		  if (occurrences.length !== 2 && occurrences.length !== 3) {
		    return false;
		  }

		  // In case of triplicate value only two digits are allowed next to each other
		  if (occurrences[0].length === 3) {
		    var trip_locations = occurrences[0].split('').map(function (a) {
		      return parseInt(a, 10);
		    });
		    var recurrent = 0; // Amount of neighbor occurrences
		    for (var _i = 0; _i < trip_locations.length - 1; _i++) {
		      if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
		        recurrent += 1;
		      }
		    }
		    if (recurrent === 2) {
		      return false;
		    }
		  }
		  return algorithms.iso7064Check(tin);
		}

		/*
		 * dk-DK validation function
		 * (CPR-nummer (personnummer), persons only)
		 * Checks if birth date (first six digits) is valid and assigned to century (seventh) digit,
		 * and calculates check (last) digit
		 */
		function dkDkCheck(tin) {
		  tin = tin.replace(/\W/, '');

		  // Extract year, check if valid for given century digit and add century
		  var year = parseInt(tin.slice(4, 6), 10);
		  var century_digit = tin.slice(6, 7);
		  switch (century_digit) {
		    case '0':
		    case '1':
		    case '2':
		    case '3':
		      year = "19".concat(year);
		      break;
		    case '4':
		    case '9':
		      if (year < 37) {
		        year = "20".concat(year);
		      } else {
		        year = "19".concat(year);
		      }
		      break;
		    default:
		      if (year < 37) {
		        year = "20".concat(year);
		      } else if (year > 58) {
		        year = "18".concat(year);
		      } else {
		        return false;
		      }
		      break;
		  }
		  // Add missing zero if needed
		  if (year.length === 3) {
		    year = [year.slice(0, 2), '0', year.slice(2)].join('');
		  }
		  // Check date validity
		  var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  var weight = 4;
		  // Multiply by weight and add to checksum
		  for (var i = 0; i < 9; i++) {
		    checksum += digits[i] * weight;
		    weight -= 1;
		    if (weight === 1) {
		      weight = 7;
		    }
		  }
		  checksum %= 11;
		  if (checksum === 1) {
		    return false;
		  }
		  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
		}

		/*
		 * el-CY validation function
		 * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons only)
		 * Verify TIN validity by calculating ASCII value of check (last) character
		 */
		function elCyCheck(tin) {
		  // split digits into an array for further processing
		  var digits = tin.slice(0, 8).split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  // add digits in even places
		  for (var i = 1; i < digits.length; i += 2) {
		    checksum += digits[i];
		  }

		  // add digits in odd places
		  for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
		    if (digits[_i2] < 2) {
		      checksum += 1 - digits[_i2];
		    } else {
		      checksum += 2 * (digits[_i2] - 2) + 5;
		      if (digits[_i2] > 4) {
		        checksum += 2;
		      }
		    }
		  }
		  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
		}

		/*
		 * el-GR validation function
		 * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons/entities)
		 * Verify TIN validity by calculating check (last) digit
		 * Algorithm not in DG TAXUD document- sourced from:
		 * - `http://epixeirisi.gr/%CE%9A%CE%A1%CE%99%CE%A3%CE%99%CE%9C%CE%91-%CE%98%CE%95%CE%9C%CE%91%CE%A4%CE%91-%CE%A6%CE%9F%CE%A1%CE%9F%CE%9B%CE%9F%CE%93%CE%99%CE%91%CE%A3-%CE%9A%CE%91%CE%99-%CE%9B%CE%9F%CE%93%CE%99%CE%A3%CE%A4%CE%99%CE%9A%CE%97%CE%A3/23791/%CE%91%CF%81%CE%B9%CE%B8%CE%BC%CF%8C%CF%82-%CE%A6%CE%BF%CF%81%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CE%BA%CE%BF%CF%8D-%CE%9C%CE%B7%CF%84%CF%81%CF%8E%CE%BF%CF%85`
		 */
		function elGrCheck(tin) {
		  // split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  for (var i = 0; i < 8; i++) {
		    checksum += digits[i] * Math.pow(2, 8 - i);
		  }
		  return checksum % 11 % 10 === digits[8];
		}

		/*
		 * en-GB validation function (should go here if needed)
		 * (National Insurance Number (NINO) or Unique Taxpayer Reference (UTR),
		 * persons/entities respectively)
		 */

		/*
		 * en-IE validation function
		 * (Personal Public Service Number (PPS No), persons only)
		 * Verify TIN validity by calculating check (second to last) character
		 */
		function enIeCheck(tin) {
		  var checksum = algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {
		    return parseInt(a, 10);
		  }), 8);
		  if (tin.length === 9 && tin[8] !== 'W') {
		    checksum += (tin[8].charCodeAt(0) - 64) * 9;
		  }
		  checksum %= 23;
		  if (checksum === 0) {
		    return tin[7].toUpperCase() === 'W';
		  }
		  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
		}

		// Valid US IRS campus prefixes
		var enUsCampusPrefix = {
		  andover: ['10', '12'],
		  atlanta: ['60', '67'],
		  austin: ['50', '53'],
		  brookhaven: ['01', '02', '03', '04', '05', '06', '11', '13', '14', '16', '21', '22', '23', '25', '34', '51', '52', '54', '55', '56', '57', '58', '59', '65'],
		  cincinnati: ['30', '32', '35', '36', '37', '38', '61'],
		  fresno: ['15', '24'],
		  internet: ['20', '26', '27', '45', '46', '47'],
		  kansas: ['40', '44'],
		  memphis: ['94', '95'],
		  ogden: ['80', '90'],
		  philadelphia: ['33', '39', '41', '42', '43', '46', '48', '62', '63', '64', '66', '68', '71', '72', '73', '74', '75', '76', '77', '81', '82', '83', '84', '85', '86', '87', '88', '91', '92', '93', '98', '99'],
		  sba: ['31']
		};

		// Return an array of all US IRS campus prefixes
		function enUsGetPrefixes() {
		  var prefixes = [];
		  for (var location in enUsCampusPrefix) {
		    // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
		    // istanbul ignore else
		    if (enUsCampusPrefix.hasOwnProperty(location)) {
		      prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
		    }
		  }
		  return prefixes;
		}

		/*
		 * en-US validation function
		 * Verify that the TIN starts with a valid IRS campus prefix
		 */
		function enUsCheck(tin) {
		  return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
		}

		/*
		 * es-AR validation function
		 * Clave Única de Identificación Tributaria (CUIT/CUIL)
		 * Sourced from:
		 * - https://servicioscf.afip.gob.ar/publico/abc/ABCpaso2.aspx?id_nivel1=3036&id_nivel2=3040&p=Conceptos%20b%C3%A1sicos
		 * - https://es.wikipedia.org/wiki/Clave_%C3%9Anica_de_Identificaci%C3%B3n_Tributaria
		 */

		function esArCheck(tin) {
		  var accum = 0;
		  var digits = tin.split('');
		  var digit = parseInt(digits.pop(), 10);
		  for (var i = 0; i < digits.length; i++) {
		    accum += digits[9 - i] * (2 + i % 6);
		  }
		  var verif = 11 - accum % 11;
		  if (verif === 11) {
		    verif = 0;
		  } else if (verif === 10) {
		    verif = 9;
		  }
		  return digit === verif;
		}

		/*
		 * es-ES validation function
		 * (Documento Nacional de Identidad (DNI)
		 * or Número de Identificación de Extranjero (NIE), persons only)
		 * Verify TIN validity by calculating check (last) character
		 */
		function esEsCheck(tin) {
		  // Split characters into an array for further processing
		  var chars = tin.toUpperCase().split('');

		  // Replace initial letter if needed
		  if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
		    var lead_replace = 0;
		    switch (chars[0]) {
		      case 'Y':
		        lead_replace = 1;
		        break;
		      case 'Z':
		        lead_replace = 2;
		        break;
		    }
		    chars.splice(0, 1, lead_replace);
		    // Fill with zeros if smaller than proper
		  } else {
		    while (chars.length < 9) {
		      chars.unshift(0);
		    }
		  }

		  // Calculate checksum and check according to lookup
		  var lookup = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];
		  chars = chars.join('');
		  var checksum = parseInt(chars.slice(0, 8), 10) % 23;
		  return chars[8] === lookup[checksum];
		}

		/*
		 * et-EE validation function
		 * (Isikukood (IK), persons only)
		 * Checks if birth date (century digit and six following) is valid and calculates check (last) digit
		 * Material not in DG TAXUD document sourced from:
		 * - `https://www.oecd.org/tax/automatic-exchange/crs-implementation-and-assistance/tax-identification-numbers/Estonia-TIN.pdf`
		 */
		function etEeCheck(tin) {
		  // Extract year and add century
		  var full_year = tin.slice(1, 3);
		  var century_digit = tin.slice(0, 1);
		  switch (century_digit) {
		    case '1':
		    case '2':
		      full_year = "18".concat(full_year);
		      break;
		    case '3':
		    case '4':
		      full_year = "19".concat(full_year);
		      break;
		    default:
		      full_year = "20".concat(full_year);
		      break;
		  }
		  // Check date validity
		  var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 0;
		  var weight = 1;
		  // Multiply by weight and add to checksum
		  for (var i = 0; i < 10; i++) {
		    checksum += digits[i] * weight;
		    weight += 1;
		    if (weight === 10) {
		      weight = 1;
		    }
		  }
		  // Do again if modulo 11 of checksum is 10
		  if (checksum % 11 === 10) {
		    checksum = 0;
		    weight = 3;
		    for (var _i3 = 0; _i3 < 10; _i3++) {
		      checksum += digits[_i3] * weight;
		      weight += 1;
		      if (weight === 10) {
		        weight = 1;
		      }
		    }
		    if (checksum % 11 === 10) {
		      return digits[10] === 0;
		    }
		  }
		  return checksum % 11 === digits[10];
		}

		/*
		 * fi-FI validation function
		 * (Henkilötunnus (HETU), persons only)
		 * Checks if birth date (first six digits plus century symbol) is valid
		 * and calculates check (last) digit
		 */
		function fiFiCheck(tin) {
		  // Extract year and add century
		  var full_year = tin.slice(4, 6);
		  var century_symbol = tin.slice(6, 7);
		  switch (century_symbol) {
		    case '+':
		      full_year = "18".concat(full_year);
		      break;
		    case '-':
		      full_year = "19".concat(full_year);
		      break;
		    default:
		      full_year = "20".concat(full_year);
		      break;
		  }
		  // Check date validity
		  var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Calculate check character
		  var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
		  if (checksum < 10) {
		    return checksum === parseInt(tin.slice(10), 10);
		  }
		  checksum -= 10;
		  var letters_lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];
		  return letters_lookup[checksum] === tin.slice(10);
		}

		/*
		 * fr/nl-BE validation function
		 * (Numéro national (N.N.), persons only)
		 * Checks if birth date (first six digits) is valid and calculates check (last two) digits
		 */
		function frBeCheck(tin) {
		  // Zero month/day value is acceptable
		  if (tin.slice(2, 4) !== '00' || tin.slice(4, 6) !== '00') {
		    // Extract date from first six digits of TIN
		    var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
		    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		      return false;
		    }
		  }
		  var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
		  var checkdigits = parseInt(tin.slice(9, 11), 10);
		  if (checksum !== checkdigits) {
		    checksum = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
		    if (checksum !== checkdigits) {
		      return false;
		    }
		  }
		  return true;
		}

		/*
		 * fr-FR validation function
		 * (Numéro fiscal de référence (numéro SPI), persons only)
		 * Verify TIN validity by calculating check (last three) digits
		 */
		function frFrCheck(tin) {
		  tin = tin.replace(/\s/g, '');
		  var checksum = parseInt(tin.slice(0, 10), 10) % 511;
		  var checkdigits = parseInt(tin.slice(10, 13), 10);
		  return checksum === checkdigits;
		}

		/*
		 * fr/lb-LU validation function
		 * (numéro d’identification personnelle, persons only)
		 * Verify birth date validity and run Luhn and Verhoeff checks
		 */
		function frLuCheck(tin) {
		  // Extract date and check validity
		  var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Run Luhn check
		  if (!algorithms.luhnCheck(tin.slice(0, 12))) {
		    return false;
		  }
		  // Remove Luhn check digit and run Verhoeff check
		  return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
		}

		/*
		 * hr-HR validation function
		 * (Osobni identifikacijski broj (OIB), persons/entities)
		 * Verify TIN validity by calling iso7064Check(digits)
		 */
		function hrHrCheck(tin) {
		  return algorithms.iso7064Check(tin);
		}

		/*
		 * hu-HU validation function
		 * (Adóazonosító jel, persons only)
		 * Verify TIN validity by calculating check (last) digit
		 */
		function huHuCheck(tin) {
		  // split digits into an array for further processing
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var checksum = 8;
		  for (var i = 1; i < 9; i++) {
		    checksum += digits[i] * (i + 1);
		  }
		  return checksum % 11 === digits[9];
		}

		/*
		 * lt-LT validation function (should go here if needed)
		 * (Asmens kodas, persons/entities respectively)
		 * Current validation check is alias of etEeCheck- same format applies
		 */

		/*
		 * it-IT first/last name validity check
		 * Accepts it-IT TIN-encoded names as a three-element character array and checks their validity
		 * Due to lack of clarity between resources ("Are only Italian consonants used?
		 * What happens if a person has X in their name?" etc.) only two test conditions
		 * have been implemented:
		 * Vowels may only be followed by other vowels or an X character
		 * and X characters after vowels may only be followed by other X characters.
		 */
		function itItNameCheck(name) {
		  // true at the first occurrence of a vowel
		  var vowelflag = false;

		  // true at the first occurrence of an X AFTER vowel
		  // (to properly handle last names with X as consonant)
		  var xflag = false;
		  for (var i = 0; i < 3; i++) {
		    if (!vowelflag && /[AEIOU]/.test(name[i])) {
		      vowelflag = true;
		    } else if (!xflag && vowelflag && name[i] === 'X') {
		      xflag = true;
		    } else if (i > 0) {
		      if (vowelflag && !xflag) {
		        if (!/[AEIOU]/.test(name[i])) {
		          return false;
		        }
		      }
		      if (xflag) {
		        if (!/X/.test(name[i])) {
		          return false;
		        }
		      }
		    }
		  }
		  return true;
		}

		/*
		 * it-IT validation function
		 * (Codice fiscale (TIN-IT), persons only)
		 * Verify name, birth date and codice catastale validity
		 * and calculate check character.
		 * Material not in DG-TAXUD document sourced from:
		 * `https://en.wikipedia.org/wiki/Italian_fiscal_code`
		 */
		function itItCheck(tin) {
		  // Capitalize and split characters into an array for further processing
		  var chars = tin.toUpperCase().split('');

		  // Check first and last name validity calling itItNameCheck()
		  if (!itItNameCheck(chars.slice(0, 3))) {
		    return false;
		  }
		  if (!itItNameCheck(chars.slice(3, 6))) {
		    return false;
		  }

		  // Convert letters in number spaces back to numbers if any
		  var number_locations = [6, 7, 9, 10, 12, 13, 14];
		  var number_replace = {
		    L: '0',
		    M: '1',
		    N: '2',
		    P: '3',
		    Q: '4',
		    R: '5',
		    S: '6',
		    T: '7',
		    U: '8',
		    V: '9'
		  };
		  for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
		    var i = _number_locations[_i4];
		    if (chars[i] in number_replace) {
		      chars.splice(i, 1, number_replace[chars[i]]);
		    }
		  }

		  // Extract month and day, and check date validity
		  var month_replace = {
		    A: '01',
		    B: '02',
		    C: '03',
		    D: '04',
		    E: '05',
		    H: '06',
		    L: '07',
		    M: '08',
		    P: '09',
		    R: '10',
		    S: '11',
		    T: '12'
		  };
		  var month = month_replace[chars[8]];
		  var day = parseInt(chars[9] + chars[10], 10);
		  if (day > 40) {
		    day -= 40;
		  }
		  if (day < 10) {
		    day = "0".concat(day);
		  }
		  var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
		  if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		    return false;
		  }

		  // Calculate check character by adding up even and odd characters as numbers
		  var checksum = 0;
		  for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
		    var char_to_int = parseInt(chars[_i5], 10);
		    if (isNaN(char_to_int)) {
		      char_to_int = chars[_i5].charCodeAt(0) - 65;
		    }
		    checksum += char_to_int;
		  }
		  var odd_convert = {
		    // Maps of characters at odd places
		    A: 1,
		    B: 0,
		    C: 5,
		    D: 7,
		    E: 9,
		    F: 13,
		    G: 15,
		    H: 17,
		    I: 19,
		    J: 21,
		    K: 2,
		    L: 4,
		    M: 18,
		    N: 20,
		    O: 11,
		    P: 3,
		    Q: 6,
		    R: 8,
		    S: 12,
		    T: 14,
		    U: 16,
		    V: 10,
		    W: 22,
		    X: 25,
		    Y: 24,
		    Z: 23,
		    0: 1,
		    1: 0
		  };
		  for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
		    var _char_to_int = 0;
		    if (chars[_i6] in odd_convert) {
		      _char_to_int = odd_convert[chars[_i6]];
		    } else {
		      var multiplier = parseInt(chars[_i6], 10);
		      _char_to_int = 2 * multiplier + 1;
		      if (multiplier > 4) {
		        _char_to_int += 2;
		      }
		    }
		    checksum += _char_to_int;
		  }
		  if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
		    return false;
		  }
		  return true;
		}

		/*
		 * lv-LV validation function
		 * (Personas kods (PK), persons only)
		 * Check validity of birth date and calculate check (last) digit
		 * Support only for old format numbers (not starting with '32', issued before 2017/07/01)
		 * Material not in DG TAXUD document sourced from:
		 * `https://boot.ritakafija.lv/forums/index.php?/topic/88314-personas-koda-algoritms-%C4%8Deksumma/`
		 */
		function lvLvCheck(tin) {
		  tin = tin.replace(/\W/, '');
		  // Extract date from TIN
		  var day = tin.slice(0, 2);
		  if (day !== '32') {
		    // No date/checksum check if new format
		    var month = tin.slice(2, 4);
		    if (month !== '00') {
		      // No date check if unknown month
		      var full_year = tin.slice(4, 6);
		      switch (tin[6]) {
		        case '0':
		          full_year = "18".concat(full_year);
		          break;
		        case '1':
		          full_year = "19".concat(full_year);
		          break;
		        default:
		          full_year = "20".concat(full_year);
		          break;
		      }
		      // Check date validity
		      var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
		      if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		        return false;
		      }
		    }

		    // Calculate check digit
		    var checksum = 1101;
		    var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
		    for (var i = 0; i < tin.length - 1; i++) {
		      checksum -= parseInt(tin[i], 10) * multip_lookup[i];
		    }
		    return parseInt(tin[10], 10) === checksum % 11;
		  }
		  return true;
		}

		/*
		 * mt-MT validation function
		 * (Identity Card Number or Unique Taxpayer Reference, persons/entities)
		 * Verify Identity Card Number structure (no other tests found)
		 */
		function mtMtCheck(tin) {
		  if (tin.length !== 9) {
		    // No tests for UTR
		    var chars = tin.toUpperCase().split('');
		    // Fill with zeros if smaller than proper
		    while (chars.length < 8) {
		      chars.unshift(0);
		    }
		    // Validate format according to last character
		    switch (tin[7]) {
		      case 'A':
		      case 'P':
		        if (parseInt(chars[6], 10) === 0) {
		          return false;
		        }
		        break;
		      default:
		        {
		          var first_part = parseInt(chars.join('').slice(0, 5), 10);
		          if (first_part > 32000) {
		            return false;
		          }
		          var second_part = parseInt(chars.join('').slice(5, 7), 10);
		          if (first_part === second_part) {
		            return false;
		          }
		        }
		    }
		  }
		  return true;
		}

		/*
		 * nl-NL validation function
		 * (Burgerservicenummer (BSN) or Rechtspersonen Samenwerkingsverbanden Informatie Nummer (RSIN),
		 * persons/entities respectively)
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function nlNlCheck(tin) {
		  return algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
		    return parseInt(a, 10);
		  }), 9) % 11 === parseInt(tin[8], 10);
		}

		/*
		 * pl-PL validation function
		 * (Powszechny Elektroniczny System Ewidencji Ludności (PESEL)
		 * or Numer identyfikacji podatkowej (NIP), persons/entities)
		 * Verify TIN validity by validating birth date (PESEL) and calculating check (last) digit
		 */
		function plPlCheck(tin) {
		  // NIP
		  if (tin.length === 10) {
		    // Calculate last digit by multiplying with lookup
		    var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
		    var _checksum = 0;
		    for (var i = 0; i < lookup.length; i++) {
		      _checksum += parseInt(tin[i], 10) * lookup[i];
		    }
		    _checksum %= 11;
		    if (_checksum === 10) {
		      return false;
		    }
		    return _checksum === parseInt(tin[9], 10);
		  }

		  // PESEL
		  // Extract full year using month
		  var full_year = tin.slice(0, 2);
		  var month = parseInt(tin.slice(2, 4), 10);
		  if (month > 80) {
		    full_year = "18".concat(full_year);
		    month -= 80;
		  } else if (month > 60) {
		    full_year = "22".concat(full_year);
		    month -= 60;
		  } else if (month > 40) {
		    full_year = "21".concat(full_year);
		    month -= 40;
		  } else if (month > 20) {
		    full_year = "20".concat(full_year);
		    month -= 20;
		  } else {
		    full_year = "19".concat(full_year);
		  }
		  // Add leading zero to month if needed
		  if (month < 10) {
		    month = "0".concat(month);
		  }
		  // Check date validity
		  var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }

		  // Calculate last digit by multiplying with odd one-digit numbers except 5
		  var checksum = 0;
		  var multiplier = 1;
		  for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
		    checksum += parseInt(tin[_i7], 10) * multiplier % 10;
		    multiplier += 2;
		    if (multiplier > 10) {
		      multiplier = 1;
		    } else if (multiplier === 5) {
		      multiplier += 2;
		    }
		  }
		  checksum = 10 - checksum % 10;
		  return checksum === parseInt(tin[10], 10);
		}

		/*
		* pt-BR validation function
		* (Cadastro de Pessoas Físicas (CPF, persons)
		* Cadastro Nacional de Pessoas Jurídicas (CNPJ, entities)
		* Both inputs will be validated
		*/

		function ptBrCheck(tin) {
		  if (tin.length === 11) {
		    var _sum;
		    var remainder;
		    _sum = 0;
		    if (
		    // Reject known invalid CPFs
		    tin === '11111111111' || tin === '22222222222' || tin === '33333333333' || tin === '44444444444' || tin === '55555555555' || tin === '66666666666' || tin === '77777777777' || tin === '88888888888' || tin === '99999999999' || tin === '00000000000') return false;
		    for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
		    remainder = _sum * 10 % 11;
		    if (remainder === 10) remainder = 0;
		    if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;
		    _sum = 0;
		    for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
		    remainder = _sum * 10 % 11;
		    if (remainder === 10) remainder = 0;
		    if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;
		    return true;
		  }
		  if (
		  // Reject know invalid CNPJs
		  tin === '00000000000000' || tin === '11111111111111' || tin === '22222222222222' || tin === '33333333333333' || tin === '44444444444444' || tin === '55555555555555' || tin === '66666666666666' || tin === '77777777777777' || tin === '88888888888888' || tin === '99999999999999') {
		    return false;
		  }
		  var length = tin.length - 2;
		  var identifiers = tin.substring(0, length);
		  var verificators = tin.substring(length);
		  var sum = 0;
		  var pos = length - 7;
		  for (var _i9 = length; _i9 >= 1; _i9--) {
		    sum += identifiers.charAt(length - _i9) * pos;
		    pos -= 1;
		    if (pos < 2) {
		      pos = 9;
		    }
		  }
		  var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
		  if (result !== parseInt(verificators.charAt(0), 10)) {
		    return false;
		  }
		  length += 1;
		  identifiers = tin.substring(0, length);
		  sum = 0;
		  pos = length - 7;
		  for (var _i0 = length; _i0 >= 1; _i0--) {
		    sum += identifiers.charAt(length - _i0) * pos;
		    pos -= 1;
		    if (pos < 2) {
		      pos = 9;
		    }
		  }
		  result = sum % 11 < 2 ? 0 : 11 - sum % 11;
		  if (result !== parseInt(verificators.charAt(1), 10)) {
		    return false;
		  }
		  return true;
		}

		/*
		 * pt-PT validation function
		 * (Número de identificação fiscal (NIF), persons/entities)
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function ptPtCheck(tin) {
		  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
		    return parseInt(a, 10);
		  }), 9) % 11;
		  if (checksum > 9) {
		    return parseInt(tin[8], 10) === 0;
		  }
		  return checksum === parseInt(tin[8], 10);
		}

		/*
		 * ro-RO validation function
		 * (Cod Numeric Personal (CNP) or Cod de înregistrare fiscală (CIF),
		 * persons only)
		 * Verify CNP validity by calculating check (last) digit (test not found for CIF)
		 * Material not in DG TAXUD document sourced from:
		 * `https://en.wikipedia.org/wiki/National_identification_number#Romania`
		 */
		function roRoCheck(tin) {
		  if (tin.slice(0, 4) !== '9000') {
		    // No test found for this format
		    // Extract full year using century digit if possible
		    var full_year = tin.slice(1, 3);
		    switch (tin[0]) {
		      case '1':
		      case '2':
		        full_year = "19".concat(full_year);
		        break;
		      case '3':
		      case '4':
		        full_year = "18".concat(full_year);
		        break;
		      case '5':
		      case '6':
		        full_year = "20".concat(full_year);
		        break;
		    }

		    // Check date validity
		    var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
		    if (date.length === 8) {
		      if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		        return false;
		      }
		    } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		      return false;
		    }

		    // Calculate check digit
		    var digits = tin.split('').map(function (a) {
		      return parseInt(a, 10);
		    });
		    var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
		    var checksum = 0;
		    for (var i = 0; i < multipliers.length; i++) {
		      checksum += digits[i] * multipliers[i];
		    }
		    if (checksum % 11 === 10) {
		      return digits[12] === 1;
		    }
		    return digits[12] === checksum % 11;
		  }
		  return true;
		}

		/*
		 * sk-SK validation function
		 * (Rodné číslo (RČ) or bezvýznamové identifikačné číslo (BIČ), persons only)
		 * Checks validity of pre-1954 birth numbers (rodné číslo) only
		 * Due to the introduction of the pseudo-random BIČ it is not possible to test
		 * post-1954 birth numbers without knowing whether they are BIČ or RČ beforehand
		 */
		function skSkCheck(tin) {
		  if (tin.length === 9) {
		    tin = tin.replace(/\W/, '');
		    if (tin.slice(6) === '000') {
		      return false;
		    } // Three-zero serial not assigned before 1954

		    // Extract full year from TIN length
		    var full_year = parseInt(tin.slice(0, 2), 10);
		    if (full_year > 53) {
		      return false;
		    }
		    if (full_year < 10) {
		      full_year = "190".concat(full_year);
		    } else {
		      full_year = "19".concat(full_year);
		    }

		    // Extract month from TIN and normalize
		    var month = parseInt(tin.slice(2, 4), 10);
		    if (month > 50) {
		      month -= 50;
		    }
		    if (month < 10) {
		      month = "0".concat(month);
		    }

		    // Check date validity
		    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
		    if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		      return false;
		    }
		  }
		  return true;
		}

		/*
		 * sl-SI validation function
		 * (Davčna številka, persons/entities)
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function slSiCheck(tin) {
		  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {
		    return parseInt(a, 10);
		  }), 8) % 11;
		  if (checksum === 10) {
		    return parseInt(tin[7], 10) === 0;
		  }
		  return checksum === parseInt(tin[7], 10);
		}

		/*
		 * sv-SE validation function
		 * (Personnummer or samordningsnummer, persons only)
		 * Checks validity of birth date and calls luhnCheck() to validate check (last) digit
		 */
		function svSeCheck(tin) {
		  // Make copy of TIN and normalize to two-digit year form
		  var tin_copy = tin.slice(0);
		  if (tin.length > 11) {
		    tin_copy = tin_copy.slice(2);
		  }

		  // Extract date of birth
		  var full_year = '';
		  var month = tin_copy.slice(2, 4);
		  var day = parseInt(tin_copy.slice(4, 6), 10);
		  if (tin.length > 11) {
		    full_year = tin.slice(0, 4);
		  } else {
		    full_year = tin.slice(0, 2);
		    if (tin.length === 11 && day < 60) {
		      // Extract full year from centenarian symbol
		      // Should work just fine until year 10000 or so
		      var current_year = new Date().getFullYear().toString();
		      var current_century = parseInt(current_year.slice(0, 2), 10);
		      current_year = parseInt(current_year, 10);
		      if (tin[6] === '-') {
		        if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
		          full_year = "".concat(current_century - 1).concat(full_year);
		        } else {
		          full_year = "".concat(current_century).concat(full_year);
		        }
		      } else {
		        full_year = "".concat(current_century - 1).concat(full_year);
		        if (current_year - parseInt(full_year, 10) < 100) {
		          return false;
		        }
		      }
		    }
		  }

		  // Normalize day and check date validity
		  if (day > 60) {
		    day -= 60;
		  }
		  if (day < 10) {
		    day = "0".concat(day);
		  }
		  var date = "".concat(full_year, "/").concat(month, "/").concat(day);
		  if (date.length === 8) {
		    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {
		      return false;
		    }
		  } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {
		    return false;
		  }
		  return algorithms.luhnCheck(tin.replace(/\W/, ''));
		}

		/**
		 * uk-UA validation function
		 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
		 */
		function ukUaCheck(tin) {
		  // Calculate check digit
		  var digits = tin.split('').map(function (a) {
		    return parseInt(a, 10);
		  });
		  var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
		  var checksum = 0;
		  for (var i = 0; i < multipliers.length; i++) {
		    checksum += digits[i] * multipliers[i];
		  }
		  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;
		}

		// Locale lookup objects

		/*
		 * Tax id regex formats for various locales
		 *
		 * Where not explicitly specified in DG-TAXUD document both
		 * uppercase and lowercase letters are acceptable.
		 */
		var taxIdFormat = {
		  'bg-BG': /^\d{10}$/,
		  'cs-CZ': /^\d{6}\/{0,1}\d{3,4}$/,
		  'de-AT': /^\d{9}$/,
		  'de-DE': /^[1-9]\d{10}$/,
		  'dk-DK': /^\d{6}-{0,1}\d{4}$/,
		  'el-CY': /^[09]\d{7}[A-Z]$/,
		  'el-GR': /^([0-4]|[7-9])\d{8}$/,
		  'en-CA': /^\d{9}$/,
		  'en-GB': /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
		  'en-IE': /^\d{7}[A-W][A-IW]{0,1}$/i,
		  'en-US': /^\d{2}[- ]{0,1}\d{7}$/,
		  'es-AR': /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
		  'es-ES': /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
		  'et-EE': /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
		  'fi-FI': /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
		  'fr-BE': /^\d{11}$/,
		  'fr-FR': /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
		  // Conforms both to official spec and provided example
		  'fr-LU': /^\d{13}$/,
		  'hr-HR': /^\d{11}$/,
		  'hu-HU': /^8\d{9}$/,
		  'it-IT': /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
		  'lv-LV': /^\d{6}-{0,1}\d{5}$/,
		  // Conforms both to DG TAXUD spec and original research
		  'mt-MT': /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
		  'nl-NL': /^\d{9}$/,
		  'pl-PL': /^\d{10,11}$/,
		  'pt-BR': /(?:^\d{11}$)|(?:^\d{14}$)/,
		  'pt-PT': /^\d{9}$/,
		  'ro-RO': /^\d{13}$/,
		  'sk-SK': /^\d{6}\/{0,1}\d{3,4}$/,
		  'sl-SI': /^[1-9]\d{7}$/,
		  'sv-SE': /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
		  'uk-UA': /^\d{10}$/
		};
		// taxIdFormat locale aliases
		taxIdFormat['lb-LU'] = taxIdFormat['fr-LU'];
		taxIdFormat['lt-LT'] = taxIdFormat['et-EE'];
		taxIdFormat['nl-BE'] = taxIdFormat['fr-BE'];
		taxIdFormat['fr-CA'] = taxIdFormat['en-CA'];

		// Algorithmic tax id check functions for various locales
		var taxIdCheck = {
		  'bg-BG': bgBgCheck,
		  'cs-CZ': csCzCheck,
		  'de-AT': deAtCheck,
		  'de-DE': deDeCheck,
		  'dk-DK': dkDkCheck,
		  'el-CY': elCyCheck,
		  'el-GR': elGrCheck,
		  'en-CA': isCanadianSIN,
		  'en-IE': enIeCheck,
		  'en-US': enUsCheck,
		  'es-AR': esArCheck,
		  'es-ES': esEsCheck,
		  'et-EE': etEeCheck,
		  'fi-FI': fiFiCheck,
		  'fr-BE': frBeCheck,
		  'fr-FR': frFrCheck,
		  'fr-LU': frLuCheck,
		  'hr-HR': hrHrCheck,
		  'hu-HU': huHuCheck,
		  'it-IT': itItCheck,
		  'lv-LV': lvLvCheck,
		  'mt-MT': mtMtCheck,
		  'nl-NL': nlNlCheck,
		  'pl-PL': plPlCheck,
		  'pt-BR': ptBrCheck,
		  'pt-PT': ptPtCheck,
		  'ro-RO': roRoCheck,
		  'sk-SK': skSkCheck,
		  'sl-SI': slSiCheck,
		  'sv-SE': svSeCheck,
		  'uk-UA': ukUaCheck
		};
		// taxIdCheck locale aliases
		taxIdCheck['lb-LU'] = taxIdCheck['fr-LU'];
		taxIdCheck['lt-LT'] = taxIdCheck['et-EE'];
		taxIdCheck['nl-BE'] = taxIdCheck['fr-BE'];
		taxIdCheck['fr-CA'] = taxIdCheck['en-CA'];

		// Regexes for locales where characters should be omitted before checking format
		var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
		var sanitizeRegexes = {
		  'de-AT': allsymbols,
		  'de-DE': /[\/\\]/g,
		  'fr-BE': allsymbols
		};
		// sanitizeRegexes locale aliases
		sanitizeRegexes['nl-BE'] = sanitizeRegexes['fr-BE'];

		/*
		 * Validator function
		 * Return true if the passed string is a valid tax identification number
		 * for the specified locale.
		 * Throw an error exception if the locale is not supported.
		 */
		function isTaxID(str) {
		  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
		  (0, _assertString.default)(str);
		  // Copy TIN to avoid replacement if sanitized
		  var strcopy = str.slice(0);
		  if (locale in taxIdFormat) {
		    if (locale in sanitizeRegexes) {
		      strcopy = strcopy.replace(sanitizeRegexes[locale], '');
		    }
		    if (!taxIdFormat[locale].test(strcopy)) {
		      return false;
		    }
		    if (locale in taxIdCheck) {
		      return taxIdCheck[locale](strcopy);
		    }
		    // Fallthrough; not all locales have algorithmic checks
		    return true;
		  }
		  throw new Error("Invalid locale '".concat(locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isTaxID, isTaxID.exports));
	return isTaxID.exports;
}

var isMobilePhone = {};

var hasRequiredIsMobilePhone;

function requireIsMobilePhone () {
	if (hasRequiredIsMobilePhone) return isMobilePhone;
	hasRequiredIsMobilePhone = 1;

	Object.defineProperty(isMobilePhone, "__esModule", {
	  value: true
	});
	isMobilePhone.default = isMobilePhone$1;
	isMobilePhone.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	/* eslint-disable max-len */
	var phones = {
	  'am-AM': /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
	  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
	  'ar-BH': /^(\+?973)?(3|6)\d{7}$/,
	  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
	  'ar-LB': /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
	  'ar-EG': /^((\+?20)|0)?1[0125]\d{8}$/,
	  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
	  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
	  'ar-KW': /^(\+?965)([569]\d{7}|41\d{6})$/,
	  'ar-LY': /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
	  'ar-MA': /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
	  'ar-OM': /^((\+|00)968)?([79][1-9])\d{6}$/,
	  'ar-PS': /^(\+?970|0)5[6|9](\d{7})$/,
	  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
	  'ar-SD': /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
	  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
	  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
	  'az-AZ': /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
	  'bs-BA': /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
	  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
	  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
	  'bn-BD': /^(\+?880|0)1[13456789][0-9]{8}$/,
	  'ca-AD': /^(\+376)?[346]\d{5}$/,
	  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
	  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
	  'de-DE': /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
	  'de-AT': /^(\+43|0)\d{1,4}\d{3,12}$/,
	  'de-CH': /^(\+41|0)([1-9])\d{1,9}$/,
	  'de-LU': /^(\+352)?((6\d1)\d{6})$/,
	  'dv-MV': /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
	  'el-GR': /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
	  'el-CY': /^(\+?357?)?(9(9|7|6|5|4)\d{6})$/,
	  'en-AI': /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
	  'en-AU': /^(\+?61|0)4\d{8}$/,
	  'en-AG': /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
	  'en-BM': /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
	  'en-BS': /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
	  'en-GB': /^(\+?44|0)7[1-9]\d{8}$/,
	  'en-GG': /^(\+?44|0)1481\d{6}$/,
	  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|53|28|55|59)\d{7}$/,
	  'en-GY': /^(\+592|0)6\d{6}$/,
	  'en-HK': /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
	  'en-MO': /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
	  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
	  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
	  'en-JM': /^(\+?876)?\d{7}$/,
	  'en-KE': /^(\+?254|0)(7|1)\d{8}$/,
	  'fr-CF': /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
	  'en-SS': /^(\+?211|0)(9[1257])\d{7}$/,
	  'en-KI': /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
	  'en-KN': /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
	  'en-LS': /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
	  'en-MT': /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
	  'en-MU': /^(\+?230|0)?\d{8}$/,
	  'en-MW': /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
	  'en-NA': /^(\+?264|0)(6|8)\d{7}$/,
	  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
	  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
	  'en-PG': /^(\+?675|0)?(7\d|8[18])\d{6}$/,
	  'en-PK': /^((00|\+)?92|0)3[0-6]\d{8}$/,
	  'en-PH': /^(09|\+639)\d{9}$/,
	  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
	  'en-SG': /^(\+65)?[3689]\d{7}$/,
	  'en-SL': /^(\+?232|0)\d{8}$/,
	  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
	  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
	  'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
	  'en-ZA': /^(\+?27|0)\d{9}$/,
	  'en-ZM': /^(\+?26)?0[79][567]\d{7}$/,
	  'en-ZW': /^(\+263)[0-9]{9}$/,
	  'en-BW': /^(\+?267)?(7[1-8]{1})\d{6}$/,
	  'es-AR': /^\+?549(11|[2368]\d)\d{8}$/,
	  'es-BO': /^(\+?591)?(6|7)\d{7}$/,
	  'es-CO': /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
	  'es-CL': /^(\+?56|0)[2-9]\d{1}\d{7}$/,
	  'es-CR': /^(\+506)?[2-8]\d{7}$/,
	  'es-CU': /^(\+53|0053)?5\d{7}$/,
	  'es-DO': /^(\+?1)?8[024]9\d{7}$/,
	  'es-HN': /^(\+?504)?[9|8|3|2]\d{7}$/,
	  'es-EC': /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
	  'es-ES': /^(\+?34)?[6|7]\d{8}$/,
	  'es-GT': /^(\+?502)?[2|6|7]\d{7}$/,
	  'es-PE': /^(\+?51)?9\d{8}$/,
	  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
	  'es-NI': /^(\+?505)\d{7,8}$/,
	  'es-PA': /^(\+?507)\d{7,8}$/,
	  'es-PY': /^(\+?595|0)9[9876]\d{7}$/,
	  'es-SV': /^(\+?503)?[67]\d{7}$/,
	  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
	  'es-VE': /^(\+?58)?(2|4)\d{9}$/,
	  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
	  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
	  'fi-FI': /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
	  'fj-FJ': /^(\+?679)?\s?\d{3}\s?\d{4}$/,
	  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
	  'fr-BF': /^(\+226|0)[67]\d{7}$/,
	  'fr-BJ': /^(\+229)\d{8}$/,
	  'fr-CD': /^(\+?243|0)?(8|9)\d{8}$/,
	  'fr-CM': /^(\+?237)6[0-9]{8}$/,
	  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
	  'fr-GF': /^(\+?594|0|00594)[67]\d{8}$/,
	  'fr-GP': /^(\+?590|0|00590)[67]\d{8}$/,
	  'fr-MQ': /^(\+?596|0|00596)[67]\d{8}$/,
	  'fr-PF': /^(\+?689)?8[789]\d{6}$/,
	  'fr-RE': /^(\+?262|0|00262)[67]\d{8}$/,
	  'fr-WF': /^(\+681)?\d{6}$/,
	  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
	  'hu-HU': /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
	  'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
	  'ir-IR': /^(\+98|0)?9\d{9}$/,
	  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
	  'it-SM': /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
	  'ja-JP': /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
	  'ka-GE': /^(\+?995)?(79\d{7}|5\d{8})$/,
	  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
	  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
	  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
	  'ky-KG': /^(\+996\s?)?(22[0-9]|50[0-9]|55[0-9]|70[0-9]|75[0-9]|77[0-9]|880|990|995|996|997|998)\s?\d{3}\s?\d{3}$/,
	  'lt-LT': /^(\+370|8)\d{8}$/,
	  'lv-LV': /^(\+?371)2\d{7}$/,
	  'mg-MG': /^((\+?261|0)(2|3)\d)?\d{7}$/,
	  'mn-MN': /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
	  'my-MM': /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
	  'ms-MY': /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
	  'mz-MZ': /^(\+?258)?8[234567]\d{7}$/,
	  'nb-NO': /^(\+?47)?[49]\d{7}$/,
	  'ne-NP': /^(\+?977)?9[78]\d{8}$/,
	  'nl-BE': /^(\+?32|0)4\d{8}$/,
	  'nl-NL': /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
	  'nl-AW': /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
	  'nn-NO': /^(\+?47)?[49]\d{7}$/,
	  'pl-PL': /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
	  'pt-BR': /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
	  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
	  'pt-AO': /^(\+?244)?9\d{8}$/,
	  'ro-MD': /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
	  'ro-RO': /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
	  'ru-RU': /^(\+?7|8)?9\d{9}$/,
	  'si-LK': /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
	  'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
	  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
	  'so-SO': /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
	  'sq-AL': /^(\+355|0)6[2-9]\d{7}$/,
	  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
	  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
	  'tg-TJ': /^(\+?992)?[5][5]\d{7}$/,
	  'th-TH': /^(\+66|66|0)\d{9}$/,
	  'tr-TR': /^(\+?90|0)?5\d{9}$/,
	  'tk-TM': /^(\+993|993|8)\d{8}$/,
	  'uk-UA': /^(\+?38)?0(50|6[36-8]|7[357]|9[1-9])\d{7}$/,
	  'uz-UZ': /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
	  'vi-VN': /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
	  'zh-CN': /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
	  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
	  'dz-BT': /^(\+?975|0)?(17|16|77|02)\d{6}$/,
	  'ar-YE': /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
	  'ar-EH': /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
	  'fa-AF': /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/,
	  'mk-MK': /^(\+?389|0)?((?:2[2-9]\d{6}|(?:3[1-4]|4[2-8])\d{6}|500\d{5}|5[2-9]\d{6}|7[0-9][2-9]\d{5}|8[1-9]\d{6}|800\d{5}|8009\d{4}))$/
	};
	/* eslint-enable max-len */

	// aliases
	phones['en-CA'] = phones['en-US'];
	phones['fr-CA'] = phones['en-CA'];
	phones['fr-BE'] = phones['nl-BE'];
	phones['zh-HK'] = phones['en-HK'];
	phones['zh-MO'] = phones['en-MO'];
	phones['ga-IE'] = phones['en-IE'];
	phones['fr-CH'] = phones['de-CH'];
	phones['it-CH'] = phones['fr-CH'];
	function isMobilePhone$1(str, locale, options) {
	  (0, _assertString.default)(str);
	  if (options && options.strictMode && !str.startsWith('+')) {
	    return false;
	  }
	  if (Array.isArray(locale)) {
	    return locale.some(function (key) {
	      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
	      // istanbul ignore else
	      if (phones.hasOwnProperty(key)) {
	        var phone = phones[key];
	        if (phone.test(str)) {
	          return true;
	        }
	      }
	      return false;
	    });
	  } else if (locale in phones) {
	    return phones[locale].test(str);
	    // alias falsey locale as 'any'
	  } else if (!locale || locale === 'any') {
	    for (var key in phones) {
	      // istanbul ignore else
	      if (phones.hasOwnProperty(key)) {
	        var phone = phones[key];
	        if (phone.test(str)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	isMobilePhone.locales = Object.keys(phones);
	return isMobilePhone;
}

var isEthereumAddress = {exports: {}};

var hasRequiredIsEthereumAddress;

function requireIsEthereumAddress () {
	if (hasRequiredIsEthereumAddress) return isEthereumAddress.exports;
	hasRequiredIsEthereumAddress = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isEthereumAddress;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var eth = /^(0x)[0-9a-f]{40}$/i;
		function isEthereumAddress(str) {
		  (0, _assertString.default)(str);
		  return eth.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isEthereumAddress, isEthereumAddress.exports));
	return isEthereumAddress.exports;
}

var isCurrency = {exports: {}};

var hasRequiredIsCurrency;

function requireIsCurrency () {
	if (hasRequiredIsCurrency) return isCurrency.exports;
	hasRequiredIsCurrency = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isCurrency;
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function currencyRegex(options) {
		  var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
		  options.digits_after_decimal.forEach(function (digit, index) {
		    if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
		  });
		  var symbol = "(".concat(options.symbol.replace(/\W/, function (m) {
		      return "\\".concat(m);
		    }), ")").concat(options.require_symbol ? '' : '?'),
		    negative = '-?',
		    whole_dollar_amount_without_sep = '[1-9]\\d*',
		    whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"),
		    valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
		    whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join('|'), ")?"),
		    decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? '' : '?');
		  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');

		  // default is negative sign before symbol, but there are two other options (besides parens)
		  if (options.allow_negatives && !options.parens_for_negatives) {
		    if (options.negative_sign_after_digits) {
		      pattern += negative;
		    } else if (options.negative_sign_before_digits) {
		      pattern = negative + pattern;
		    }
		  }

		  // South African Rand, for example, uses R 123 (space) and R-123 (no space)
		  if (options.allow_negative_sign_placeholder) {
		    pattern = "( (?!\\-))?".concat(pattern);
		  } else if (options.allow_space_after_symbol) {
		    pattern = " ?".concat(pattern);
		  } else if (options.allow_space_after_digits) {
		    pattern += '( (?!$))?';
		  }
		  if (options.symbol_after_digits) {
		    pattern += symbol;
		  } else {
		    pattern = symbol + pattern;
		  }
		  if (options.allow_negatives) {
		    if (options.parens_for_negatives) {
		      pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
		    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
		      pattern = negative + pattern;
		    }
		  }

		  // ensure there's a dollar and/or decimal amount, and that
		  // it doesn't start with a space or a negative sign followed by a space
		  return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
		}
		var default_currency_options = {
		  symbol: '$',
		  require_symbol: false,
		  allow_space_after_symbol: false,
		  symbol_after_digits: false,
		  allow_negatives: true,
		  parens_for_negatives: false,
		  negative_sign_before_digits: false,
		  negative_sign_after_digits: false,
		  allow_negative_sign_placeholder: false,
		  thousands_separator: ',',
		  decimal_separator: '.',
		  allow_decimal: true,
		  require_decimal: false,
		  digits_after_decimal: [2],
		  allow_space_after_digits: false
		};
		function isCurrency(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, default_currency_options);
		  return currencyRegex(options).test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isCurrency, isCurrency.exports));
	return isCurrency.exports;
}

var isBtcAddress = {exports: {}};

var hasRequiredIsBtcAddress;

function requireIsBtcAddress () {
	if (hasRequiredIsBtcAddress) return isBtcAddress.exports;
	hasRequiredIsBtcAddress = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBtcAddress;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var bech32 = /^(bc1|tb1|bc1p|tb1p)[ac-hj-np-z02-9]{39,58}$/;
		var base58 = /^(1|2|3|m)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
		function isBtcAddress(str) {
		  (0, _assertString.default)(str);
		  return bech32.test(str) || base58.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBtcAddress, isBtcAddress.exports));
	return isBtcAddress.exports;
}

var isISO6346 = {};

var hasRequiredIsISO6346;

function requireIsISO6346 () {
	if (hasRequiredIsISO6346) return isISO6346;
	hasRequiredIsISO6346 = 1;

	Object.defineProperty(isISO6346, "__esModule", {
	  value: true
	});
	isISO6346.isFreightContainerID = void 0;
	isISO6346.isISO6346 = isISO6346$1;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	// https://en.wikipedia.org/wiki/ISO_6346
	// according to ISO6346 standard, checksum digit is mandatory for freight container but recommended
	// for other container types (J and Z)
	var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
	var isDigit = /^[0-9]$/;
	function isISO6346$1(str) {
	  (0, _assertString.default)(str);
	  str = str.toUpperCase();
	  if (!isISO6346Str.test(str)) return false;
	  if (str.length === 11) {
	    var sum = 0;
	    for (var i = 0; i < str.length - 1; i++) {
	      if (!isDigit.test(str[i])) {
	        var convertedCode = void 0;
	        var letterCode = str.charCodeAt(i) - 55;
	        if (letterCode < 11) convertedCode = letterCode;else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;else convertedCode = 34 + letterCode % 31;
	        sum += convertedCode * Math.pow(2, i);
	      } else sum += str[i] * Math.pow(2, i);
	    }
	    var checkSumDigit = sum % 11;
	    if (checkSumDigit === 10) checkSumDigit = 0;
	    return Number(str[str.length - 1]) === checkSumDigit;
	  }
	  return true;
	}
	isISO6346.isFreightContainerID = isISO6346$1;
	return isISO6346;
}

var isISO6391 = {exports: {}};

var hasRequiredIsISO6391;

function requireIsISO6391 () {
	if (hasRequiredIsISO6391) return isISO6391.exports;
	hasRequiredIsISO6391 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO6391;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var isISO6391Set = new Set(['aa', 'ab', 'ae', 'af', 'ak', 'am', 'an', 'ar', 'as', 'av', 'ay', 'az', 'az', 'ba', 'be', 'bg', 'bh', 'bi', 'bm', 'bn', 'bo', 'br', 'bs', 'ca', 'ce', 'ch', 'co', 'cr', 'cs', 'cu', 'cv', 'cy', 'da', 'de', 'dv', 'dz', 'ee', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'ff', 'fi', 'fj', 'fo', 'fr', 'fy', 'ga', 'gd', 'gl', 'gn', 'gu', 'gv', 'ha', 'he', 'hi', 'ho', 'hr', 'ht', 'hu', 'hy', 'hz', 'ia', 'id', 'ie', 'ig', 'ii', 'ik', 'io', 'is', 'it', 'iu', 'ja', 'jv', 'ka', 'kg', 'ki', 'kj', 'kk', 'kl', 'km', 'kn', 'ko', 'kr', 'ks', 'ku', 'kv', 'kw', 'ky', 'la', 'lb', 'lg', 'li', 'ln', 'lo', 'lt', 'lu', 'lv', 'mg', 'mh', 'mi', 'mk', 'ml', 'mn', 'mr', 'ms', 'mt', 'my', 'na', 'nb', 'nd', 'ne', 'ng', 'nl', 'nn', 'no', 'nr', 'nv', 'ny', 'oc', 'oj', 'om', 'or', 'os', 'pa', 'pi', 'pl', 'ps', 'pt', 'qu', 'rm', 'rn', 'ro', 'ru', 'rw', 'sa', 'sc', 'sd', 'se', 'sg', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'ss', 'st', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'ti', 'tk', 'tl', 'tn', 'to', 'tr', 'ts', 'tt', 'tw', 'ty', 'ug', 'uk', 'ur', 'uz', 've', 'vi', 'vo', 'wa', 'wo', 'xh', 'yi', 'yo', 'za', 'zh', 'zu']);
		function isISO6391(str) {
		  (0, _assertString.default)(str);
		  return isISO6391Set.has(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO6391, isISO6391.exports));
	return isISO6391.exports;
}

var isISO8601 = {exports: {}};

var hasRequiredIsISO8601;

function requireIsISO8601 () {
	if (hasRequiredIsISO8601) return isISO8601.exports;
	hasRequiredIsISO8601 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO8601;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/* eslint-disable max-len */
		// from http://goo.gl/0ejHHW
		var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
		// same as above, except with a strict 'T' separator between date and time
		var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
		/* eslint-enable max-len */
		var isValidDate = function isValidDate(str) {
		  // str must have passed the ISO8601 check
		  // this check is meant to catch invalid dates
		  // like 2009-02-31
		  // first check for ordinal dates
		  var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
		  if (ordinalMatch) {
		    var oYear = Number(ordinalMatch[1]);
		    var oDay = Number(ordinalMatch[2]);
		    // if is leap year
		    if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;
		    return oDay <= 365;
		  }
		  var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
		  var year = match[1];
		  var month = match[2];
		  var day = match[3];
		  var monthString = month ? "0".concat(month).slice(-2) : month;
		  var dayString = day ? "0".concat(day).slice(-2) : day;

		  // create a date object and compare
		  var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
		  if (month && day) {
		    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
		  }
		  return true;
		};
		function isISO8601(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		  (0, _assertString.default)(str);
		  var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
		  if (check && options.strict) return isValidDate(str);
		  return check;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO8601, isISO8601.exports));
	return isISO8601.exports;
}

var isRFC3339 = {exports: {}};

var hasRequiredIsRFC3339;

function requireIsRFC3339 () {
	if (hasRequiredIsRFC3339) return isRFC3339.exports;
	hasRequiredIsRFC3339 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isRFC3339;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */

		var dateFullYear = /[0-9]{4}/;
		var dateMonth = /(0[1-9]|1[0-2])/;
		var dateMDay = /([12]\d|0[1-9]|3[01])/;
		var timeHour = /([01][0-9]|2[0-3])/;
		var timeMinute = /[0-5][0-9]/;
		var timeSecond = /([0-5][0-9]|60)/;
		var timeSecFrac = /(\.[0-9]+)?/;
		var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
		var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
		var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
		var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
		var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
		var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
		function isRFC3339(str) {
		  (0, _assertString.default)(str);
		  return rfc3339.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isRFC3339, isRFC3339.exports));
	return isRFC3339.exports;
}

var isISO15924 = {};

var hasRequiredIsISO15924;

function requireIsISO15924 () {
	if (hasRequiredIsISO15924) return isISO15924;
	hasRequiredIsISO15924 = 1;

	Object.defineProperty(isISO15924, "__esModule", {
	  value: true
	});
	isISO15924.ScriptCodes = void 0;
	isISO15924.default = isISO15924$1;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	// from https://www.unicode.org/iso15924/iso15924-codes.html
	var validISO15924Codes = new Set(['Adlm', 'Afak', 'Aghb', 'Ahom', 'Arab', 'Aran', 'Armi', 'Armn', 'Avst', 'Bali', 'Bamu', 'Bass', 'Batk', 'Beng', 'Bhks', 'Blis', 'Bopo', 'Brah', 'Brai', 'Bugi', 'Buhd', 'Cakm', 'Cans', 'Cari', 'Cham', 'Cher', 'Chis', 'Chrs', 'Cirt', 'Copt', 'Cpmn', 'Cprt', 'Cyrl', 'Cyrs', 'Deva', 'Diak', 'Dogr', 'Dsrt', 'Dupl', 'Egyd', 'Egyh', 'Egyp', 'Elba', 'Elym', 'Ethi', 'Gara', 'Geok', 'Geor', 'Glag', 'Gong', 'Gonm', 'Goth', 'Gran', 'Grek', 'Gujr', 'Gukh', 'Guru', 'Hanb', 'Hang', 'Hani', 'Hano', 'Hans', 'Hant', 'Hatr', 'Hebr', 'Hira', 'Hluw', 'Hmng', 'Hmnp', 'Hrkt', 'Hung', 'Inds', 'Ital', 'Jamo', 'Java', 'Jpan', 'Jurc', 'Kali', 'Kana', 'Kawi', 'Khar', 'Khmr', 'Khoj', 'Kitl', 'Kits', 'Knda', 'Kore', 'Kpel', 'Krai', 'Kthi', 'Lana', 'Laoo', 'Latf', 'Latg', 'Latn', 'Leke', 'Lepc', 'Limb', 'Lina', 'Linb', 'Lisu', 'Loma', 'Lyci', 'Lydi', 'Mahj', 'Maka', 'Mand', 'Mani', 'Marc', 'Maya', 'Medf', 'Mend', 'Merc', 'Mero', 'Mlym', 'Modi', 'Mong', 'Moon', 'Mroo', 'Mtei', 'Mult', 'Mymr', 'Nagm', 'Nand', 'Narb', 'Nbat', 'Newa', 'Nkdb', 'Nkgb', 'Nkoo', 'Nshu', 'Ogam', 'Olck', 'Onao', 'Orkh', 'Orya', 'Osge', 'Osma', 'Ougr', 'Palm', 'Pauc', 'Pcun', 'Pelm', 'Perm', 'Phag', 'Phli', 'Phlp', 'Phlv', 'Phnx', 'Plrd', 'Piqd', 'Prti', 'Psin', 'Qaaa', 'Qaab', 'Qaac', 'Qaad', 'Qaae', 'Qaaf', 'Qaag', 'Qaah', 'Qaai', 'Qaaj', 'Qaak', 'Qaal', 'Qaam', 'Qaan', 'Qaao', 'Qaap', 'Qaaq', 'Qaar', 'Qaas', 'Qaat', 'Qaau', 'Qaav', 'Qaaw', 'Qaax', 'Qaay', 'Qaaz', 'Qaba', 'Qabb', 'Qabc', 'Qabd', 'Qabe', 'Qabf', 'Qabg', 'Qabh', 'Qabi', 'Qabj', 'Qabk', 'Qabl', 'Qabm', 'Qabn', 'Qabo', 'Qabp', 'Qabq', 'Qabr', 'Qabs', 'Qabt', 'Qabu', 'Qabv', 'Qabw', 'Qabx', 'Ranj', 'Rjng', 'Rohg', 'Roro', 'Runr', 'Samr', 'Sara', 'Sarb', 'Saur', 'Sgnw', 'Shaw', 'Shrd', 'Shui', 'Sidd', 'Sidt', 'Sind', 'Sinh', 'Sogd', 'Sogo', 'Sora', 'Soyo', 'Sund', 'Sunu', 'Sylo', 'Syrc', 'Syre', 'Syrj', 'Syrn', 'Tagb', 'Takr', 'Tale', 'Talu', 'Taml', 'Tang', 'Tavt', 'Tayo', 'Telu', 'Teng', 'Tfng', 'Tglg', 'Thaa', 'Thai', 'Tibt', 'Tirh', 'Tnsa', 'Todr', 'Tols', 'Toto', 'Tutg', 'Ugar', 'Vaii', 'Visp', 'Vith', 'Wara', 'Wcho', 'Wole', 'Xpeo', 'Xsux', 'Yezi', 'Yiii', 'Zanb', 'Zinh', 'Zmth', 'Zsye', 'Zsym', 'Zxxx', 'Zyyy', 'Zzzz']);
	function isISO15924$1(str) {
	  (0, _assertString.default)(str);
	  return validISO15924Codes.has(str);
	}
	isISO15924.ScriptCodes = validISO15924Codes;
	return isISO15924;
}

var isISO31661Alpha3 = {exports: {}};

var hasRequiredIsISO31661Alpha3;

function requireIsISO31661Alpha3 () {
	if (hasRequiredIsISO31661Alpha3) return isISO31661Alpha3.exports;
	hasRequiredIsISO31661Alpha3 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO31661Alpha3;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
		var validISO31661Alpha3CountriesCodes = new Set(['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE']);
		function isISO31661Alpha3(str) {
		  (0, _assertString.default)(str);
		  return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO31661Alpha3, isISO31661Alpha3.exports));
	return isISO31661Alpha3.exports;
}

var isISO31661Numeric = {exports: {}};

var hasRequiredIsISO31661Numeric;

function requireIsISO31661Numeric () {
	if (hasRequiredIsISO31661Numeric) return isISO31661Numeric.exports;
	hasRequiredIsISO31661Numeric = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isISO31661Numeric;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		// from https://en.wikipedia.org/wiki/ISO_3166-1_numeric
		var validISO31661NumericCountriesCodes = new Set(['004', '008', '010', '012', '016', '020', '024', '028', '031', '032', '036', '040', '044', '048', '050', '051', '052', '056', '060', '064', '068', '070', '072', '074', '076', '084', '086', '090', '092', '096', '100', '104', '108', '112', '116', '120', '124', '132', '136', '140', '144', '148', '152', '156', '158', '162', '166', '170', '174', '175', '178', '180', '184', '188', '191', '192', '196', '203', '204', '208', '212', '214', '218', '222', '226', '231', '232', '233', '234', '238', '239', '242', '246', '248', '250', '254', '258', '260', '262', '266', '268', '270', '275', '276', '288', '292', '296', '300', '304', '308', '312', '316', '320', '324', '328', '332', '334', '336', '340', '344', '348', '352', '356', '360', '364', '368', '372', '376', '380', '384', '388', '392', '398', '400', '404', '408', '410', '414', '417', '418', '422', '426', '428', '430', '434', '438', '440', '442', '446', '450', '454', '458', '462', '466', '470', '474', '478', '480', '484', '492', '496', '498', '499', '500', '504', '508', '512', '516', '520', '524', '528', '531', '533', '534', '535', '540', '548', '554', '558', '562', '566', '570', '574', '578', '580', '581', '583', '584', '585', '586', '591', '598', '600', '604', '608', '612', '616', '620', '624', '626', '630', '634', '638', '642', '643', '646', '652', '654', '659', '660', '662', '663', '666', '670', '674', '678', '682', '686', '688', '690', '694', '702', '703', '704', '705', '706', '710', '716', '724', '728', '729', '732', '740', '744', '748', '752', '756', '760', '762', '764', '768', '772', '776', '780', '784', '788', '792', '795', '796', '798', '800', '804', '807', '818', '826', '831', '832', '833', '834', '840', '850', '854', '858', '860', '862', '876', '882', '887', '894']);
		function isISO31661Numeric(str) {
		  (0, _assertString.default)(str);
		  return validISO31661NumericCountriesCodes.has(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isISO31661Numeric, isISO31661Numeric.exports));
	return isISO31661Numeric.exports;
}

var isISO4217 = {};

var hasRequiredIsISO4217;

function requireIsISO4217 () {
	if (hasRequiredIsISO4217) return isISO4217;
	hasRequiredIsISO4217 = 1;

	Object.defineProperty(isISO4217, "__esModule", {
	  value: true
	});
	isISO4217.CurrencyCodes = void 0;
	isISO4217.default = isISO4217$1;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	// from https://en.wikipedia.org/wiki/ISO_4217
	var validISO4217CurrencyCodes = new Set(['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYN', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLE', 'SLL', 'SOS', 'SRD', 'SSP', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'UYI', 'UYU', 'UYW', 'UZS', 'VED', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XAG', 'XAU', 'XBA', 'XBB', 'XBC', 'XBD', 'XCD', 'XDR', 'XOF', 'XPD', 'XPF', 'XPT', 'XSU', 'XTS', 'XUA', 'XXX', 'YER', 'ZAR', 'ZMW', 'ZWL']);
	function isISO4217$1(str) {
	  (0, _assertString.default)(str);
	  return validISO4217CurrencyCodes.has(str.toUpperCase());
	}
	isISO4217.CurrencyCodes = validISO4217CurrencyCodes;
	return isISO4217;
}

var isBase32 = {exports: {}};

var hasRequiredIsBase32;

function requireIsBase32 () {
	if (hasRequiredIsBase32) return isBase32.exports;
	hasRequiredIsBase32 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBase32;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var base32 = /^[A-Z2-7]+=*$/;
		var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
		var defaultBase32Options = {
		  crockford: false
		};
		function isBase32(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaultBase32Options);
		  if (options.crockford) {
		    return crockfordBase32.test(str);
		  }
		  var len = str.length;
		  if (len % 8 === 0 && base32.test(str)) {
		    return true;
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBase32, isBase32.exports));
	return isBase32.exports;
}

var isBase58 = {exports: {}};

var hasRequiredIsBase58;

function requireIsBase58 () {
	if (hasRequiredIsBase58) return isBase58.exports;
	hasRequiredIsBase58 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isBase58;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		// Accepted chars - 123456789ABCDEFGH JKLMN PQRSTUVWXYZabcdefghijk mnopqrstuvwxyz
		var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
		function isBase58(str) {
		  (0, _assertString.default)(str);
		  if (base58Reg.test(str)) {
		    return true;
		  }
		  return false;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isBase58, isBase58.exports));
	return isBase58.exports;
}

var isDataURI = {exports: {}};

var hasRequiredIsDataURI;

function requireIsDataURI () {
	if (hasRequiredIsDataURI) return isDataURI.exports;
	hasRequiredIsDataURI = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isDataURI;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
		var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
		var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
		function isDataURI(str) {
		  (0, _assertString.default)(str);
		  var data = str.split(',');
		  if (data.length < 2) {
		    return false;
		  }
		  var attributes = data.shift().trim().split(';');
		  var schemeAndMediaType = attributes.shift();
		  if (schemeAndMediaType.slice(0, 5) !== 'data:') {
		    return false;
		  }
		  var mediaType = schemeAndMediaType.slice(5);
		  if (mediaType !== '' && !validMediaType.test(mediaType)) {
		    return false;
		  }
		  for (var i = 0; i < attributes.length; i++) {
		    if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') && !validAttribute.test(attributes[i])) {
		      return false;
		    }
		  }
		  for (var _i = 0; _i < data.length; _i++) {
		    if (!validData.test(data[_i])) {
		      return false;
		    }
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isDataURI, isDataURI.exports));
	return isDataURI.exports;
}

var isMagnetURI = {exports: {}};

var hasRequiredIsMagnetURI;

function requireIsMagnetURI () {
	if (hasRequiredIsMagnetURI) return isMagnetURI.exports;
	hasRequiredIsMagnetURI = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMagnetURI;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
		function isMagnetURI(url) {
		  (0, _assertString.default)(url);
		  if (url.indexOf('magnet:?') !== 0) {
		    return false;
		  }
		  return magnetURIComponent.test(url);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMagnetURI, isMagnetURI.exports));
	return isMagnetURI.exports;
}

var isMailtoURI = {exports: {}};

var trim = {exports: {}};

var rtrim = {exports: {}};

var hasRequiredRtrim;

function requireRtrim () {
	if (hasRequiredRtrim) return rtrim.exports;
	hasRequiredRtrim = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = rtrim;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function rtrim(str, chars) {
		  (0, _assertString.default)(str);
		  if (chars) {
		    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
		    var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "]+$"), 'g');
		    return str.replace(pattern, '');
		  }
		  // Use a faster and more safe than regex trim method https://blog.stevenlevithan.com/archives/faster-trim-javascript
		  var strIndex = str.length - 1;
		  while (/\s/.test(str.charAt(strIndex))) {
		    strIndex -= 1;
		  }
		  return str.slice(0, strIndex + 1);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (rtrim, rtrim.exports));
	return rtrim.exports;
}

var ltrim = {exports: {}};

var hasRequiredLtrim;

function requireLtrim () {
	if (hasRequiredLtrim) return ltrim.exports;
	hasRequiredLtrim = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = ltrim;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function ltrim(str, chars) {
		  (0, _assertString.default)(str);
		  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
		  var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "]+"), 'g') : /^\s+/g;
		  return str.replace(pattern, '');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (ltrim, ltrim.exports));
	return ltrim.exports;
}

var hasRequiredTrim;

function requireTrim () {
	if (hasRequiredTrim) return trim.exports;
	hasRequiredTrim = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = trim;
		var _rtrim = _interopRequireDefault(/*@__PURE__*/ requireRtrim());
		var _ltrim = _interopRequireDefault(/*@__PURE__*/ requireLtrim());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function trim(str, chars) {
		  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (trim, trim.exports));
	return trim.exports;
}

var hasRequiredIsMailtoURI;

function requireIsMailtoURI () {
	if (hasRequiredIsMailtoURI) return isMailtoURI.exports;
	hasRequiredIsMailtoURI = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMailtoURI;
		var _trim = _interopRequireDefault(/*@__PURE__*/ requireTrim());
		var _isEmail = _interopRequireDefault(/*@__PURE__*/ requireIsEmail());
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
		function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
		function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: true } : { done: false, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = true, u = false; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = true, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
		function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
		function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
		function parseMailtoQueryString(queryString) {
		  var allowedParams = new Set(['subject', 'body', 'cc', 'bcc']),
		    query = {
		      cc: '',
		      bcc: ''
		    };
		  var isParseFailed = false;
		  var queryParams = queryString.split('&');
		  if (queryParams.length > 4) {
		    return false;
		  }
		  var _iterator = _createForOfIteratorHelper(queryParams),
		    _step;
		  try {
		    for (_iterator.s(); !(_step = _iterator.n()).done;) {
		      var q = _step.value;
		      var _q$split = q.split('='),
		        _q$split2 = _slicedToArray(_q$split, 2),
		        key = _q$split2[0],
		        value = _q$split2[1];

		      // checked for invalid and duplicated query params
		      if (key && !allowedParams.has(key)) {
		        isParseFailed = true;
		        break;
		      }
		      if (value && (key === 'cc' || key === 'bcc')) {
		        query[key] = value;
		      }
		      if (key) {
		        allowedParams.delete(key);
		      }
		    }
		  } catch (err) {
		    _iterator.e(err);
		  } finally {
		    _iterator.f();
		  }
		  return isParseFailed ? false : query;
		}
		function isMailtoURI(url, options) {
		  (0, _assertString.default)(url);
		  if (url.indexOf('mailto:') !== 0) {
		    return false;
		  }
		  var _url$replace$split = url.replace('mailto:', '').split('?'),
		    _url$replace$split2 = _slicedToArray(_url$replace$split, 2),
		    to = _url$replace$split2[0],
		    _url$replace$split2$ = _url$replace$split2[1],
		    queryString = _url$replace$split2$ === void 0 ? '' : _url$replace$split2$;
		  if (!to && !queryString) {
		    return true;
		  }
		  var query = parseMailtoQueryString(queryString);
		  if (!query) {
		    return false;
		  }
		  return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(',').every(function (email) {
		    email = (0, _trim.default)(email, ' ');
		    if (email) {
		      return (0, _isEmail.default)(email, options);
		    }
		    return true;
		  });
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMailtoURI, isMailtoURI.exports));
	return isMailtoURI.exports;
}

var isMimeType = {exports: {}};

var hasRequiredIsMimeType;

function requireIsMimeType () {
	if (hasRequiredIsMimeType) return isMimeType.exports;
	hasRequiredIsMimeType = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isMimeType;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		/*
		  Checks if the provided string matches to a correct Media type format (MIME type)

		  This function only checks is the string format follows the
		  established rules by the according RFC specifications.
		  This function supports 'charset' in textual media types
		  (https://tools.ietf.org/html/rfc6657).

		  This function does not check against all the media types listed
		  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
		  because of lightness purposes : it would require to include
		  all these MIME types in this library, which would weigh it
		  significantly. This kind of effort maybe is not worth for the use that
		  this function has in this entire library.

		  More information in the RFC specifications :
		  - https://tools.ietf.org/html/rfc2045
		  - https://tools.ietf.org/html/rfc2046
		  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
		  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
		*/

		// Match simple MIME types
		// NB :
		//   Subtype length must not exceed 100 characters.
		//   This rule does not comply to the RFC specs (what is the max length ?).
		var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i; // eslint-disable-line max-len

		// Handle "charset" in "text/*"
		var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len

		// Handle "boundary" in "multipart/*"
		var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len

		function isMimeType(str) {
		  (0, _assertString.default)(str);
		  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isMimeType, isMimeType.exports));
	return isMimeType.exports;
}

var isLatLong = {exports: {}};

var hasRequiredIsLatLong;

function requireIsLatLong () {
	if (hasRequiredIsLatLong) return isLatLong.exports;
	hasRequiredIsLatLong = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLatLong;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		var _includesString = _interopRequireDefault(/*@__PURE__*/ requireIncludesString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
		var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
		var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
		var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
		var defaultLatLongOptions = {
		  checkDMS: false
		};
		function isLatLong(str, options) {
		  (0, _assertString.default)(str);
		  options = (0, _merge.default)(options, defaultLatLongOptions);
		  if (!(0, _includesString.default)(str, ',')) return false;
		  var pair = str.split(',');
		  if (pair[0].startsWith('(') && !pair[1].endsWith(')') || pair[1].endsWith(')') && !pair[0].startsWith('(')) return false;
		  if (options.checkDMS) {
		    return latDMS.test(pair[0]) && longDMS.test(pair[1]);
		  }
		  return lat.test(pair[0]) && long.test(pair[1]);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLatLong, isLatLong.exports));
	return isLatLong.exports;
}

var isPostalCode = {};

var hasRequiredIsPostalCode;

function requireIsPostalCode () {
	if (hasRequiredIsPostalCode) return isPostalCode;
	hasRequiredIsPostalCode = 1;

	Object.defineProperty(isPostalCode, "__esModule", {
	  value: true
	});
	isPostalCode.default = isPostalCode$1;
	isPostalCode.locales = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	// common patterns
	var threeDigit = /^\d{3}$/;
	var fourDigit = /^\d{4}$/;
	var fiveDigit = /^\d{5}$/;
	var sixDigit = /^\d{6}$/;
	var patterns = {
	  AD: /^AD\d{3}$/,
	  AT: fourDigit,
	  AU: fourDigit,
	  AZ: /^AZ\d{4}$/,
	  BA: /^([7-8]\d{4}$)/,
	  BD: /^([1-8][0-9]{3}|9[0-4][0-9]{2})$/,
	  BE: fourDigit,
	  BG: fourDigit,
	  BR: /^\d{5}-?\d{3}$/,
	  BY: /^2[1-4]\d{4}$/,
	  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
	  CH: fourDigit,
	  CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
	  CO: /^(05|08|11|13|15|17|18|19|20|23|25|27|41|44|47|50|52|54|63|66|68|70|73|76|81|85|86|88|91|94|95|97|99)(\d{4})$/,
	  CZ: /^\d{3}\s?\d{2}$/,
	  DE: fiveDigit,
	  DK: fourDigit,
	  DO: fiveDigit,
	  DZ: fiveDigit,
	  EE: fiveDigit,
	  ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
	  FI: fiveDigit,
	  FR: /^(?:(?:0[1-9]|[1-8]\d|9[0-5])\d{3}|97[1-46]\d{2})$/,
	  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
	  GR: /^\d{3}\s?\d{2}$/,
	  HR: /^([1-5]\d{4}$)/,
	  HT: /^HT\d{4}$/,
	  HU: fourDigit,
	  ID: fiveDigit,
	  IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
	  IL: /^(\d{5}|\d{7})$/,
	  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
	  IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
	  IS: threeDigit,
	  IT: fiveDigit,
	  JP: /^\d{3}\-\d{4}$/,
	  KE: fiveDigit,
	  KR: /^(\d{5}|\d{6})$/,
	  LI: /^(948[5-9]|949[0-7])$/,
	  LT: /^LT\-\d{5}$/,
	  LU: fourDigit,
	  LV: /^LV\-\d{4}$/,
	  LK: fiveDigit,
	  MG: threeDigit,
	  MX: fiveDigit,
	  MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
	  MY: fiveDigit,
	  NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
	  NO: fourDigit,
	  NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
	  NZ: fourDigit,
	  // https://www.pakpost.gov.pk/postcodes.php
	  PK: fiveDigit,
	  PL: /^\d{2}\-\d{3}$/,
	  PR: /^00[679]\d{2}([ -]\d{4})?$/,
	  PT: /^\d{4}\-\d{3}?$/,
	  RO: sixDigit,
	  RU: sixDigit,
	  SA: fiveDigit,
	  SE: /^[1-9]\d{2}\s?\d{2}$/,
	  SG: sixDigit,
	  SI: fourDigit,
	  SK: /^\d{3}\s?\d{2}$/,
	  TH: fiveDigit,
	  TN: fourDigit,
	  TW: /^\d{3}(\d{2,3})?$/,
	  UA: fiveDigit,
	  US: /^\d{5}(-\d{4})?$/,
	  ZA: fourDigit,
	  ZM: fiveDigit
	};
	isPostalCode.locales = Object.keys(patterns);
	function isPostalCode$1(str, locale) {
	  (0, _assertString.default)(str);
	  if (locale in patterns) {
	    return patterns[locale].test(str);
	  } else if (locale === 'any') {
	    for (var key in patterns) {
	      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
	      // istanbul ignore else
	      if (patterns.hasOwnProperty(key)) {
	        var pattern = patterns[key];
	        if (pattern.test(str)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	  throw new Error("Invalid locale '".concat(locale, "'"));
	}
	return isPostalCode;
}

var _escape = {exports: {}};

var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape.exports;
	hasRequired_escape = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = escape;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function escape(str) {
		  (0, _assertString.default)(str);
		  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (_escape, _escape.exports));
	return _escape.exports;
}

var _unescape = {exports: {}};

var hasRequired_unescape;

function require_unescape () {
	if (hasRequired_unescape) return _unescape.exports;
	hasRequired_unescape = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = unescape;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function unescape(str) {
		  (0, _assertString.default)(str);
		  return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`').replace(/&amp;/g, '&');
		  // &amp; replacement has to be the last one to prevent
		  // bugs with intermediate strings containing escape sequences
		  // See: https://github.com/validatorjs/validator.js/issues/1827
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (_unescape, _unescape.exports));
	return _unescape.exports;
}

var stripLow = {exports: {}};

var blacklist = {exports: {}};

var hasRequiredBlacklist;

function requireBlacklist () {
	if (hasRequiredBlacklist) return blacklist.exports;
	hasRequiredBlacklist = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = blacklist;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function blacklist(str, chars) {
		  (0, _assertString.default)(str);
		  return str.replace(new RegExp("[".concat(chars, "]+"), 'g'), '');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (blacklist, blacklist.exports));
	return blacklist.exports;
}

var hasRequiredStripLow;

function requireStripLow () {
	if (hasRequiredStripLow) return stripLow.exports;
	hasRequiredStripLow = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = stripLow;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		var _blacklist = _interopRequireDefault(/*@__PURE__*/ requireBlacklist());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function stripLow(str, keep_new_lines) {
		  (0, _assertString.default)(str);
		  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
		  return (0, _blacklist.default)(str, chars);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (stripLow, stripLow.exports));
	return stripLow.exports;
}

var whitelist = {exports: {}};

var hasRequiredWhitelist;

function requireWhitelist () {
	if (hasRequiredWhitelist) return whitelist.exports;
	hasRequiredWhitelist = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = whitelist;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function whitelist(str, chars) {
		  (0, _assertString.default)(str);
		  return str.replace(new RegExp("[^".concat(chars, "]+"), 'g'), '');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (whitelist, whitelist.exports));
	return whitelist.exports;
}

var isWhitelisted = {exports: {}};

var hasRequiredIsWhitelisted;

function requireIsWhitelisted () {
	if (hasRequiredIsWhitelisted) return isWhitelisted.exports;
	hasRequiredIsWhitelisted = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isWhitelisted;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		function isWhitelisted(str, chars) {
		  (0, _assertString.default)(str);
		  for (var i = str.length - 1; i >= 0; i--) {
		    if (chars.indexOf(str[i]) === -1) {
		      return false;
		    }
		  }
		  return true;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isWhitelisted, isWhitelisted.exports));
	return isWhitelisted.exports;
}

var normalizeEmail = {exports: {}};

var hasRequiredNormalizeEmail;

function requireNormalizeEmail () {
	if (hasRequiredNormalizeEmail) return normalizeEmail.exports;
	hasRequiredNormalizeEmail = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = normalizeEmail;
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var default_normalize_email_options = {
		  // The following options apply to all email addresses
		  // Lowercases the local part of the email address.
		  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
		  // The domain is always lowercased, as per RFC 1035
		  all_lowercase: true,
		  // The following conversions are specific to GMail
		  // Lowercases the local part of the GMail address (known to be case-insensitive)
		  gmail_lowercase: true,
		  // Removes dots from the local part of the email address, as that's ignored by GMail
		  gmail_remove_dots: true,
		  // Removes the subaddress (e.g. "+foo") from the email address
		  gmail_remove_subaddress: true,
		  // Conversts the googlemail.com domain to gmail.com
		  gmail_convert_googlemaildotcom: true,
		  // The following conversions are specific to Outlook.com / Windows Live / Hotmail
		  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
		  outlookdotcom_lowercase: true,
		  // Removes the subaddress (e.g. "+foo") from the email address
		  outlookdotcom_remove_subaddress: true,
		  // The following conversions are specific to Yahoo
		  // Lowercases the local part of the Yahoo address (known to be case-insensitive)
		  yahoo_lowercase: true,
		  // Removes the subaddress (e.g. "-foo") from the email address
		  yahoo_remove_subaddress: true,
		  // The following conversions are specific to Yandex
		  // Lowercases the local part of the Yandex address (known to be case-insensitive)
		  yandex_lowercase: true,
		  // all yandex domains are equal, this explicitly sets the domain to 'yandex.ru'
		  yandex_convert_yandexru: true,
		  // The following conversions are specific to iCloud
		  // Lowercases the local part of the iCloud address (known to be case-insensitive)
		  icloud_lowercase: true,
		  // Removes the subaddress (e.g. "+foo") from the email address
		  icloud_remove_subaddress: true
		};

		// List of domains used by iCloud
		var icloud_domains = ['icloud.com', 'me.com'];

		// List of domains used by Outlook.com and its predecessors
		// This list is likely incomplete.
		// Partial reference:
		// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/
		var outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com'];

		// List of domains used by Yahoo Mail
		// This list is likely incomplete
		var yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com'];

		// List of domains used by yandex.ru
		var yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru'];

		// replace single dots, but not multiple consecutive dots
		function dotsReplacer(match) {
		  if (match.length > 1) {
		    return match;
		  }
		  return '';
		}
		function normalizeEmail(email, options) {
		  options = (0, _merge.default)(options, default_normalize_email_options);
		  var raw_parts = email.split('@');
		  var domain = raw_parts.pop();
		  var user = raw_parts.join('@');
		  var parts = [user, domain];

		  // The domain is always lowercased, as it's case-insensitive per RFC 1035
		  parts[1] = parts[1].toLowerCase();
		  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
		    // Address is GMail
		    if (options.gmail_remove_subaddress) {
		      parts[0] = parts[0].split('+')[0];
		    }
		    if (options.gmail_remove_dots) {
		      // this does not replace consecutive dots like example..email@gmail.com
		      parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.gmail_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
		  } else if (icloud_domains.indexOf(parts[1]) >= 0) {
		    // Address is iCloud
		    if (options.icloud_remove_subaddress) {
		      parts[0] = parts[0].split('+')[0];
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.icloud_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
		    // Address is Outlook.com
		    if (options.outlookdotcom_remove_subaddress) {
		      parts[0] = parts[0].split('+')[0];
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.outlookdotcom_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
		    // Address is Yahoo
		    if (options.yahoo_remove_subaddress) {
		      var components = parts[0].split('-');
		      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
		    }
		    if (!parts[0].length) {
		      return false;
		    }
		    if (options.all_lowercase || options.yahoo_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		  } else if (yandex_domains.indexOf(parts[1]) >= 0) {
		    if (options.all_lowercase || options.yandex_lowercase) {
		      parts[0] = parts[0].toLowerCase();
		    }
		    parts[1] = options.yandex_convert_yandexru ? 'yandex.ru' : parts[1];
		  } else if (options.all_lowercase) {
		    // Any other address
		    parts[0] = parts[0].toLowerCase();
		  }
		  return parts.join('@');
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (normalizeEmail, normalizeEmail.exports));
	return normalizeEmail.exports;
}

var isSlug = {exports: {}};

var hasRequiredIsSlug;

function requireIsSlug () {
	if (hasRequiredIsSlug) return isSlug.exports;
	hasRequiredIsSlug = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isSlug;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
		function isSlug(str) {
		  (0, _assertString.default)(str);
		  return charsetRegex.test(str);
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isSlug, isSlug.exports));
	return isSlug.exports;
}

var isLicensePlate = {exports: {}};

var hasRequiredIsLicensePlate;

function requireIsLicensePlate () {
	if (hasRequiredIsLicensePlate) return isLicensePlate.exports;
	hasRequiredIsLicensePlate = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isLicensePlate;
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var validators = {
		  'cs-CZ': function csCZ(str) {
		    return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
		  },
		  'de-DE': function deDE(str) {
		    return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|AÖ|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|BÖ|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|FÜ|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|GÖ|GP|GR|GS|GT|GÜ|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|LÖ|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|MÜ|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|NÖ|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|TÜ|ÜB|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|WÜ|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BÜD|BUL|BÜR|BÜS|BÜZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DÜW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FLÖ|FOR|FRG|FRI|FRW|FTL|FÜS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HMÜ|HOG|HOH|HOL|HOM|HOR|HÖS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JÜL|KEH|KEL|KEM|KIB|KLE|KLZ|KÖN|KÖT|KÖZ|KRU|KÜN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LÖB|LOS|LRO|LSZ|LÜN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MÜB|MÜR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|ÖHR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PLÖ|PRÜ|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RÜD|RÜG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SLÜ|SLZ|SMÜ|SOB|SOG|SOK|SÖM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SÜW|SWA|SZB|TBB|TDO|TET|TIR|TÖL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WÜM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
		  },
		  'de-LI': function deLI(str) {
		    return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
		  },
		  'en-IN': function enIN(str) {
		    return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
		  },
		  'en-SG': function enSG(str) {
		    return /^[A-Z]{3}[ -]?[\d]{4}[ -]?[A-Z]{1}$/.test(str);
		  },
		  'es-AR': function esAR(str) {
		    return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
		  },
		  'fi-FI': function fiFI(str) {
		    return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
		  },
		  'hu-HU': function huHU(str) {
		    return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
		  },
		  'pt-BR': function ptBR(str) {
		    return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
		  },
		  'pt-PT': function ptPT(str) {
		    return /^(([A-Z]{2}[ -·]?[0-9]{2}[ -·]?[0-9]{2})|([0-9]{2}[ -·]?[A-Z]{2}[ -·]?[0-9]{2})|([0-9]{2}[ -·]?[0-9]{2}[ -·]?[A-Z]{2})|([A-Z]{2}[ -·]?[0-9]{2}[ -·]?[A-Z]{2}))$/.test(str);
		  },
		  'sq-AL': function sqAL(str) {
		    return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
		  },
		  'sv-SE': function svSE(str) {
		    return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-ZÅÄÖ ]{2,7}$)/.test(str.trim());
		  },
		  'en-PK': function enPK(str) {
		    return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(str.trim());
		  }
		};
		function isLicensePlate(str, locale) {
		  (0, _assertString.default)(str);
		  if (locale in validators) {
		    return validators[locale](str);
		  } else if (locale === 'any') {
		    for (var key in validators) {
		      /* eslint guard-for-in: 0 */
		      var validator = validators[key];
		      if (validator(str)) {
		        return true;
		      }
		    }
		    return false;
		  }
		  throw new Error("Invalid locale '".concat(locale, "'"));
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isLicensePlate, isLicensePlate.exports));
	return isLicensePlate.exports;
}

var isStrongPassword = {exports: {}};

var hasRequiredIsStrongPassword;

function requireIsStrongPassword () {
	if (hasRequiredIsStrongPassword) return isStrongPassword.exports;
	hasRequiredIsStrongPassword = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = isStrongPassword;
		var _merge = _interopRequireDefault(/*@__PURE__*/ requireMerge());
		var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var upperCaseRegex = /^[A-Z]$/;
		var lowerCaseRegex = /^[a-z]$/;
		var numberRegex = /^[0-9]$/;
		var symbolRegex = /^[-#!$@£%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/;
		var defaultOptions = {
		  minLength: 8,
		  minLowercase: 1,
		  minUppercase: 1,
		  minNumbers: 1,
		  minSymbols: 1,
		  returnScore: false,
		  pointsPerUnique: 1,
		  pointsPerRepeat: 0.5,
		  pointsForContainingLower: 10,
		  pointsForContainingUpper: 10,
		  pointsForContainingNumber: 10,
		  pointsForContainingSymbol: 10
		};

		/* Counts number of occurrences of each char in a string
		 * could be moved to util/ ?
		*/
		function countChars(str) {
		  var result = {};
		  Array.from(str).forEach(function (char) {
		    var curVal = result[char];
		    if (curVal) {
		      result[char] += 1;
		    } else {
		      result[char] = 1;
		    }
		  });
		  return result;
		}

		/* Return information about a password */
		function analyzePassword(password) {
		  var charMap = countChars(password);
		  var analysis = {
		    length: password.length,
		    uniqueChars: Object.keys(charMap).length,
		    uppercaseCount: 0,
		    lowercaseCount: 0,
		    numberCount: 0,
		    symbolCount: 0
		  };
		  Object.keys(charMap).forEach(function (char) {
		    /* istanbul ignore else */
		    if (upperCaseRegex.test(char)) {
		      analysis.uppercaseCount += charMap[char];
		    } else if (lowerCaseRegex.test(char)) {
		      analysis.lowercaseCount += charMap[char];
		    } else if (numberRegex.test(char)) {
		      analysis.numberCount += charMap[char];
		    } else if (symbolRegex.test(char)) {
		      analysis.symbolCount += charMap[char];
		    }
		  });
		  return analysis;
		}
		function scorePassword(analysis, scoringOptions) {
		  var points = 0;
		  points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
		  points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
		  if (analysis.lowercaseCount > 0) {
		    points += scoringOptions.pointsForContainingLower;
		  }
		  if (analysis.uppercaseCount > 0) {
		    points += scoringOptions.pointsForContainingUpper;
		  }
		  if (analysis.numberCount > 0) {
		    points += scoringOptions.pointsForContainingNumber;
		  }
		  if (analysis.symbolCount > 0) {
		    points += scoringOptions.pointsForContainingSymbol;
		  }
		  return points;
		}
		function isStrongPassword(str) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		  (0, _assertString.default)(str);
		  var analysis = analyzePassword(str);
		  options = (0, _merge.default)(options || {}, defaultOptions);
		  if (options.returnScore) {
		    return scorePassword(analysis, options);
		  }
		  return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
		}
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (isStrongPassword, isStrongPassword.exports));
	return isStrongPassword.exports;
}

var isVAT = {};

var hasRequiredIsVAT;

function requireIsVAT () {
	if (hasRequiredIsVAT) return isVAT;
	hasRequiredIsVAT = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	Object.defineProperty(isVAT, "__esModule", {
	  value: true
	});
	isVAT.default = isVAT$1;
	isVAT.vatMatchers = void 0;
	var _assertString = _interopRequireDefault(/*@__PURE__*/ requireAssertString());
	var algorithms = _interopRequireWildcard(/*@__PURE__*/ requireAlgorithms());
	function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	var AU = function AU(str) {
	  var match = str.match(/^(AU)?(\d{11})$/);
	  if (!match) {
	    return false;
	  }
	  // @see {@link https://abr.business.gov.au/Help/AbnFormat}
	  var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
	  str = str.replace(/^AU/, '');
	  var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);
	  var total = 0;
	  for (var i = 0; i < 11; i++) {
	    total += weights[i] * ABN.charAt(i);
	  }
	  return total !== 0 && total % 89 === 0;
	};
	var CH = function CH(str) {
	  // @see {@link https://www.ech.ch/de/ech/ech-0097/5.2.0}
	  var hasValidCheckNumber = function hasValidCheckNumber(digits) {
	    var lastDigit = digits.pop(); // used as check number
	    var weights = [5, 4, 3, 2, 7, 6, 5, 4];
	    var calculatedCheckNumber = (11 - digits.reduce(function (acc, el, idx) {
	      return acc + el * weights[idx];
	    }, 0) % 11) % 11;
	    return lastDigit === calculatedCheckNumber;
	  };

	  // @see {@link https://www.estv.admin.ch/estv/de/home/mehrwertsteuer/uid/mwst-uid-nummer.html}
	  return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function (el) {
	    return +el;
	  }));
	};
	var PT = function PT(str) {
	  var match = str.match(/^(PT)?(\d{9})$/);
	  if (!match) {
	    return false;
	  }
	  var tin = match[2];
	  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
	    return parseInt(a, 10);
	  }), 9) % 11;
	  if (checksum > 9) {
	    return parseInt(tin[8], 10) === 0;
	  }
	  return checksum === parseInt(tin[8], 10);
	};
	var vatMatchers = isVAT.vatMatchers = {
	  /**
	   * European Union VAT identification numbers
	   */
	  AT: function AT(str) {
	    return /^(AT)?U\d{8}$/.test(str);
	  },
	  BE: function BE(str) {
	    return /^(BE)?\d{10}$/.test(str);
	  },
	  BG: function BG(str) {
	    return /^(BG)?\d{9,10}$/.test(str);
	  },
	  HR: function HR(str) {
	    return /^(HR)?\d{11}$/.test(str);
	  },
	  CY: function CY(str) {
	    return /^(CY)?\w{9}$/.test(str);
	  },
	  CZ: function CZ(str) {
	    return /^(CZ)?\d{8,10}$/.test(str);
	  },
	  DK: function DK(str) {
	    return /^(DK)?\d{8}$/.test(str);
	  },
	  EE: function EE(str) {
	    return /^(EE)?\d{9}$/.test(str);
	  },
	  FI: function FI(str) {
	    return /^(FI)?\d{8}$/.test(str);
	  },
	  FR: function FR(str) {
	    return /^(FR)?\w{2}\d{9}$/.test(str);
	  },
	  DE: function DE(str) {
	    return /^(DE)?\d{9}$/.test(str);
	  },
	  EL: function EL(str) {
	    return /^(EL)?\d{9}$/.test(str);
	  },
	  HU: function HU(str) {
	    return /^(HU)?\d{8}$/.test(str);
	  },
	  IE: function IE(str) {
	    return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
	  },
	  IT: function IT(str) {
	    return /^(IT)?\d{11}$/.test(str);
	  },
	  LV: function LV(str) {
	    return /^(LV)?\d{11}$/.test(str);
	  },
	  LT: function LT(str) {
	    return /^(LT)?\d{9,12}$/.test(str);
	  },
	  LU: function LU(str) {
	    return /^(LU)?\d{8}$/.test(str);
	  },
	  MT: function MT(str) {
	    return /^(MT)?\d{8}$/.test(str);
	  },
	  NL: function NL(str) {
	    return /^(NL)?\d{9}B\d{2}$/.test(str);
	  },
	  PL: function PL(str) {
	    return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
	  },
	  PT: PT,
	  RO: function RO(str) {
	    return /^(RO)?\d{2,10}$/.test(str);
	  },
	  SK: function SK(str) {
	    return /^(SK)?\d{10}$/.test(str);
	  },
	  SI: function SI(str) {
	    return /^(SI)?\d{8}$/.test(str);
	  },
	  ES: function ES(str) {
	    return /^(ES)?\w\d{7}[A-Z]$/.test(str);
	  },
	  SE: function SE(str) {
	    return /^(SE)?\d{12}$/.test(str);
	  },
	  /**
	   * VAT numbers of non-EU countries
	   */
	  AL: function AL(str) {
	    return /^(AL)?\w{9}[A-Z]$/.test(str);
	  },
	  MK: function MK(str) {
	    return /^(MK)?\d{13}$/.test(str);
	  },
	  AU: AU,
	  BY: function BY(str) {
	    return /^(УНП )?\d{9}$/.test(str);
	  },
	  CA: function CA(str) {
	    return /^(CA)?\d{9}$/.test(str);
	  },
	  IS: function IS(str) {
	    return /^(IS)?\d{5,6}$/.test(str);
	  },
	  IN: function IN(str) {
	    return /^(IN)?\d{15}$/.test(str);
	  },
	  ID: function ID(str) {
	    return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
	  },
	  IL: function IL(str) {
	    return /^(IL)?\d{9}$/.test(str);
	  },
	  KZ: function KZ(str) {
	    return /^(KZ)?\d{12}$/.test(str);
	  },
	  NZ: function NZ(str) {
	    return /^(NZ)?\d{9}$/.test(str);
	  },
	  NG: function NG(str) {
	    return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
	  },
	  NO: function NO(str) {
	    return /^(NO)?\d{9}MVA$/.test(str);
	  },
	  PH: function PH(str) {
	    return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
	  },
	  RU: function RU(str) {
	    return /^(RU)?(\d{10}|\d{12})$/.test(str);
	  },
	  SM: function SM(str) {
	    return /^(SM)?\d{5}$/.test(str);
	  },
	  SA: function SA(str) {
	    return /^(SA)?\d{15}$/.test(str);
	  },
	  RS: function RS(str) {
	    return /^(RS)?\d{9}$/.test(str);
	  },
	  CH: CH,
	  TR: function TR(str) {
	    return /^(TR)?\d{10}$/.test(str);
	  },
	  UA: function UA(str) {
	    return /^(UA)?\d{12}$/.test(str);
	  },
	  GB: function GB(str) {
	    return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
	  },
	  UZ: function UZ(str) {
	    return /^(UZ)?\d{9}$/.test(str);
	  },
	  /**
	   * VAT numbers of Latin American countries
	   */
	  AR: function AR(str) {
	    return /^(AR)?\d{11}$/.test(str);
	  },
	  BO: function BO(str) {
	    return /^(BO)?\d{7}$/.test(str);
	  },
	  BR: function BR(str) {
	    return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
	  },
	  CL: function CL(str) {
	    return /^(CL)?\d{8}-\d{1}$/.test(str);
	  },
	  CO: function CO(str) {
	    return /^(CO)?\d{10}$/.test(str);
	  },
	  CR: function CR(str) {
	    return /^(CR)?\d{9,12}$/.test(str);
	  },
	  EC: function EC(str) {
	    return /^(EC)?\d{13}$/.test(str);
	  },
	  SV: function SV(str) {
	    return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
	  },
	  GT: function GT(str) {
	    return /^(GT)?\d{7}-\d{1}$/.test(str);
	  },
	  HN: function HN(str) {
	    return /^(HN)?$/.test(str);
	  },
	  MX: function MX(str) {
	    return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
	  },
	  NI: function NI(str) {
	    return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
	  },
	  PA: function PA(str) {
	    return /^(PA)?$/.test(str);
	  },
	  PY: function PY(str) {
	    return /^(PY)?\d{6,8}-\d{1}$/.test(str);
	  },
	  PE: function PE(str) {
	    return /^(PE)?\d{11}$/.test(str);
	  },
	  DO: function DO(str) {
	    return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
	  },
	  UY: function UY(str) {
	    return /^(UY)?\d{12}$/.test(str);
	  },
	  VE: function VE(str) {
	    return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
	  }
	};
	function isVAT$1(str, countryCode) {
	  (0, _assertString.default)(str);
	  (0, _assertString.default)(countryCode);
	  if (countryCode in vatMatchers) {
	    return vatMatchers[countryCode](str);
	  }
	  throw new Error("Invalid country code: '".concat(countryCode, "'"));
	}
	return isVAT;
}

var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator$1.exports;
	hasRequiredValidator = 1;
	(function (module, exports) {

		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;
		var _toDate = _interopRequireDefault(/*@__PURE__*/ requireToDate());
		var _toFloat = _interopRequireDefault(/*@__PURE__*/ requireToFloat());
		var _toInt = _interopRequireDefault(/*@__PURE__*/ requireToInt());
		var _toBoolean = _interopRequireDefault(/*@__PURE__*/ requireToBoolean());
		var _equals = _interopRequireDefault(/*@__PURE__*/ requireEquals());
		var _contains = _interopRequireDefault(/*@__PURE__*/ requireContains());
		var _matches = _interopRequireDefault(/*@__PURE__*/ requireMatches());
		var _isEmail = _interopRequireDefault(/*@__PURE__*/ requireIsEmail());
		var _isURL = _interopRequireDefault(/*@__PURE__*/ requireIsURL());
		var _isMACAddress = _interopRequireDefault(/*@__PURE__*/ requireIsMACAddress());
		var _isIP = _interopRequireDefault(/*@__PURE__*/ requireIsIP());
		var _isIPRange = _interopRequireDefault(/*@__PURE__*/ requireIsIPRange());
		var _isFQDN = _interopRequireDefault(/*@__PURE__*/ requireIsFQDN());
		var _isDate = _interopRequireDefault(/*@__PURE__*/ requireIsDate());
		var _isTime = _interopRequireDefault(/*@__PURE__*/ requireIsTime());
		var _isBoolean = _interopRequireDefault(/*@__PURE__*/ requireIsBoolean());
		var _isLocale = _interopRequireDefault(/*@__PURE__*/ requireIsLocale());
		var _isAbaRouting = _interopRequireDefault(/*@__PURE__*/ requireIsAbaRouting());
		var _isAlpha = _interopRequireWildcard(/*@__PURE__*/ requireIsAlpha());
		var _isAlphanumeric = _interopRequireWildcard(/*@__PURE__*/ requireIsAlphanumeric());
		var _isNumeric = _interopRequireDefault(/*@__PURE__*/ requireIsNumeric());
		var _isPassportNumber = _interopRequireWildcard(/*@__PURE__*/ requireIsPassportNumber());
		var _isPort = _interopRequireDefault(/*@__PURE__*/ requireIsPort());
		var _isLowercase = _interopRequireDefault(/*@__PURE__*/ requireIsLowercase());
		var _isUppercase = _interopRequireDefault(/*@__PURE__*/ requireIsUppercase());
		var _isIMEI = _interopRequireDefault(/*@__PURE__*/ requireIsIMEI());
		var _isAscii = _interopRequireDefault(/*@__PURE__*/ requireIsAscii());
		var _isFullWidth = _interopRequireDefault(/*@__PURE__*/ requireIsFullWidth());
		var _isHalfWidth = _interopRequireDefault(/*@__PURE__*/ requireIsHalfWidth());
		var _isVariableWidth = _interopRequireDefault(/*@__PURE__*/ requireIsVariableWidth());
		var _isMultibyte = _interopRequireDefault(/*@__PURE__*/ requireIsMultibyte());
		var _isSemVer = _interopRequireDefault(/*@__PURE__*/ requireIsSemVer());
		var _isSurrogatePair = _interopRequireDefault(/*@__PURE__*/ requireIsSurrogatePair());
		var _isInt = _interopRequireDefault(/*@__PURE__*/ requireIsInt());
		var _isFloat = _interopRequireWildcard(/*@__PURE__*/ requireIsFloat());
		var _isDecimal = _interopRequireDefault(/*@__PURE__*/ requireIsDecimal());
		var _isHexadecimal = _interopRequireDefault(/*@__PURE__*/ requireIsHexadecimal());
		var _isOctal = _interopRequireDefault(/*@__PURE__*/ requireIsOctal());
		var _isDivisibleBy = _interopRequireDefault(/*@__PURE__*/ requireIsDivisibleBy());
		var _isHexColor = _interopRequireDefault(/*@__PURE__*/ requireIsHexColor());
		var _isRgbColor = _interopRequireDefault(/*@__PURE__*/ requireIsRgbColor());
		var _isHSL = _interopRequireDefault(/*@__PURE__*/ requireIsHSL());
		var _isISRC = _interopRequireDefault(/*@__PURE__*/ requireIsISRC());
		var _isIBAN = _interopRequireWildcard(/*@__PURE__*/ requireIsIBAN());
		var _isBIC = _interopRequireDefault(/*@__PURE__*/ requireIsBIC());
		var _isMD = _interopRequireDefault(/*@__PURE__*/ requireIsMD5());
		var _isHash = _interopRequireDefault(/*@__PURE__*/ requireIsHash());
		var _isJWT = _interopRequireDefault(/*@__PURE__*/ requireIsJWT());
		var _isJSON = _interopRequireDefault(/*@__PURE__*/ requireIsJSON());
		var _isEmpty = _interopRequireDefault(/*@__PURE__*/ requireIsEmpty());
		var _isLength = _interopRequireDefault(/*@__PURE__*/ requireIsLength());
		var _isByteLength = _interopRequireDefault(/*@__PURE__*/ requireIsByteLength());
		var _isULID = _interopRequireDefault(/*@__PURE__*/ requireIsULID());
		var _isUUID = _interopRequireDefault(/*@__PURE__*/ requireIsUUID());
		var _isMongoId = _interopRequireDefault(/*@__PURE__*/ requireIsMongoId());
		var _isAfter = _interopRequireDefault(/*@__PURE__*/ requireIsAfter());
		var _isBefore = _interopRequireDefault(/*@__PURE__*/ requireIsBefore());
		var _isIn = _interopRequireDefault(/*@__PURE__*/ requireIsIn());
		var _isLuhnNumber = _interopRequireDefault(/*@__PURE__*/ requireIsLuhnNumber());
		var _isCreditCard = _interopRequireDefault(/*@__PURE__*/ requireIsCreditCard());
		var _isIdentityCard = _interopRequireDefault(/*@__PURE__*/ requireIsIdentityCard());
		var _isEAN = _interopRequireDefault(/*@__PURE__*/ requireIsEAN());
		var _isISIN = _interopRequireDefault(/*@__PURE__*/ requireIsISIN());
		var _isISBN = _interopRequireDefault(/*@__PURE__*/ requireIsISBN());
		var _isISSN = _interopRequireDefault(/*@__PURE__*/ requireIsISSN());
		var _isTaxID = _interopRequireDefault(/*@__PURE__*/ requireIsTaxID());
		var _isMobilePhone = _interopRequireWildcard(/*@__PURE__*/ requireIsMobilePhone());
		var _isEthereumAddress = _interopRequireDefault(/*@__PURE__*/ requireIsEthereumAddress());
		var _isCurrency = _interopRequireDefault(/*@__PURE__*/ requireIsCurrency());
		var _isBtcAddress = _interopRequireDefault(/*@__PURE__*/ requireIsBtcAddress());
		var _isISO = /*@__PURE__*/ requireIsISO6346();
		var _isISO2 = _interopRequireDefault(/*@__PURE__*/ requireIsISO6391());
		var _isISO3 = _interopRequireDefault(/*@__PURE__*/ requireIsISO8601());
		var _isRFC = _interopRequireDefault(/*@__PURE__*/ requireIsRFC3339());
		var _isISO4 = _interopRequireDefault(/*@__PURE__*/ requireIsISO15924());
		var _isISO31661Alpha = _interopRequireDefault(/*@__PURE__*/ requireIsISO31661Alpha2());
		var _isISO31661Alpha2 = _interopRequireDefault(/*@__PURE__*/ requireIsISO31661Alpha3());
		var _isISO31661Numeric = _interopRequireDefault(/*@__PURE__*/ requireIsISO31661Numeric());
		var _isISO5 = _interopRequireDefault(/*@__PURE__*/ requireIsISO4217());
		var _isBase = _interopRequireDefault(/*@__PURE__*/ requireIsBase32());
		var _isBase2 = _interopRequireDefault(/*@__PURE__*/ requireIsBase58());
		var _isBase3 = _interopRequireDefault(/*@__PURE__*/ requireIsBase64());
		var _isDataURI = _interopRequireDefault(/*@__PURE__*/ requireIsDataURI());
		var _isMagnetURI = _interopRequireDefault(/*@__PURE__*/ requireIsMagnetURI());
		var _isMailtoURI = _interopRequireDefault(/*@__PURE__*/ requireIsMailtoURI());
		var _isMimeType = _interopRequireDefault(/*@__PURE__*/ requireIsMimeType());
		var _isLatLong = _interopRequireDefault(/*@__PURE__*/ requireIsLatLong());
		var _isPostalCode = _interopRequireWildcard(/*@__PURE__*/ requireIsPostalCode());
		var _ltrim = _interopRequireDefault(/*@__PURE__*/ requireLtrim());
		var _rtrim = _interopRequireDefault(/*@__PURE__*/ requireRtrim());
		var _trim = _interopRequireDefault(/*@__PURE__*/ requireTrim());
		var _escape = _interopRequireDefault(/*@__PURE__*/ require_escape());
		var _unescape = _interopRequireDefault(/*@__PURE__*/ require_unescape());
		var _stripLow = _interopRequireDefault(/*@__PURE__*/ requireStripLow());
		var _whitelist = _interopRequireDefault(/*@__PURE__*/ requireWhitelist());
		var _blacklist = _interopRequireDefault(/*@__PURE__*/ requireBlacklist());
		var _isWhitelisted = _interopRequireDefault(/*@__PURE__*/ requireIsWhitelisted());
		var _normalizeEmail = _interopRequireDefault(/*@__PURE__*/ requireNormalizeEmail());
		var _isSlug = _interopRequireDefault(/*@__PURE__*/ requireIsSlug());
		var _isLicensePlate = _interopRequireDefault(/*@__PURE__*/ requireIsLicensePlate());
		var _isStrongPassword = _interopRequireDefault(/*@__PURE__*/ requireIsStrongPassword());
		var _isVAT = _interopRequireDefault(/*@__PURE__*/ requireIsVAT());
		function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
		function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
		var version = '13.15.15';
		var validator = {
		  version: version,
		  toDate: _toDate.default,
		  toFloat: _toFloat.default,
		  toInt: _toInt.default,
		  toBoolean: _toBoolean.default,
		  equals: _equals.default,
		  contains: _contains.default,
		  matches: _matches.default,
		  isEmail: _isEmail.default,
		  isURL: _isURL.default,
		  isMACAddress: _isMACAddress.default,
		  isIP: _isIP.default,
		  isIPRange: _isIPRange.default,
		  isFQDN: _isFQDN.default,
		  isBoolean: _isBoolean.default,
		  isIBAN: _isIBAN.default,
		  isBIC: _isBIC.default,
		  isAbaRouting: _isAbaRouting.default,
		  isAlpha: _isAlpha.default,
		  isAlphaLocales: _isAlpha.locales,
		  isAlphanumeric: _isAlphanumeric.default,
		  isAlphanumericLocales: _isAlphanumeric.locales,
		  isNumeric: _isNumeric.default,
		  isPassportNumber: _isPassportNumber.default,
		  passportNumberLocales: _isPassportNumber.locales,
		  isPort: _isPort.default,
		  isLowercase: _isLowercase.default,
		  isUppercase: _isUppercase.default,
		  isAscii: _isAscii.default,
		  isFullWidth: _isFullWidth.default,
		  isHalfWidth: _isHalfWidth.default,
		  isVariableWidth: _isVariableWidth.default,
		  isMultibyte: _isMultibyte.default,
		  isSemVer: _isSemVer.default,
		  isSurrogatePair: _isSurrogatePair.default,
		  isInt: _isInt.default,
		  isIMEI: _isIMEI.default,
		  isFloat: _isFloat.default,
		  isFloatLocales: _isFloat.locales,
		  isDecimal: _isDecimal.default,
		  isHexadecimal: _isHexadecimal.default,
		  isOctal: _isOctal.default,
		  isDivisibleBy: _isDivisibleBy.default,
		  isHexColor: _isHexColor.default,
		  isRgbColor: _isRgbColor.default,
		  isHSL: _isHSL.default,
		  isISRC: _isISRC.default,
		  isMD5: _isMD.default,
		  isHash: _isHash.default,
		  isJWT: _isJWT.default,
		  isJSON: _isJSON.default,
		  isEmpty: _isEmpty.default,
		  isLength: _isLength.default,
		  isLocale: _isLocale.default,
		  isByteLength: _isByteLength.default,
		  isULID: _isULID.default,
		  isUUID: _isUUID.default,
		  isMongoId: _isMongoId.default,
		  isAfter: _isAfter.default,
		  isBefore: _isBefore.default,
		  isIn: _isIn.default,
		  isLuhnNumber: _isLuhnNumber.default,
		  isCreditCard: _isCreditCard.default,
		  isIdentityCard: _isIdentityCard.default,
		  isEAN: _isEAN.default,
		  isISIN: _isISIN.default,
		  isISBN: _isISBN.default,
		  isISSN: _isISSN.default,
		  isMobilePhone: _isMobilePhone.default,
		  isMobilePhoneLocales: _isMobilePhone.locales,
		  isPostalCode: _isPostalCode.default,
		  isPostalCodeLocales: _isPostalCode.locales,
		  isEthereumAddress: _isEthereumAddress.default,
		  isCurrency: _isCurrency.default,
		  isBtcAddress: _isBtcAddress.default,
		  isISO6346: _isISO.isISO6346,
		  isFreightContainerID: _isISO.isFreightContainerID,
		  isISO6391: _isISO2.default,
		  isISO8601: _isISO3.default,
		  isISO15924: _isISO4.default,
		  isRFC3339: _isRFC.default,
		  isISO31661Alpha2: _isISO31661Alpha.default,
		  isISO31661Alpha3: _isISO31661Alpha2.default,
		  isISO31661Numeric: _isISO31661Numeric.default,
		  isISO4217: _isISO5.default,
		  isBase32: _isBase.default,
		  isBase58: _isBase2.default,
		  isBase64: _isBase3.default,
		  isDataURI: _isDataURI.default,
		  isMagnetURI: _isMagnetURI.default,
		  isMailtoURI: _isMailtoURI.default,
		  isMimeType: _isMimeType.default,
		  isLatLong: _isLatLong.default,
		  ltrim: _ltrim.default,
		  rtrim: _rtrim.default,
		  trim: _trim.default,
		  escape: _escape.default,
		  unescape: _unescape.default,
		  stripLow: _stripLow.default,
		  whitelist: _whitelist.default,
		  blacklist: _blacklist.default,
		  isWhitelisted: _isWhitelisted.default,
		  normalizeEmail: _normalizeEmail.default,
		  toString: toString,
		  isSlug: _isSlug.default,
		  isStrongPassword: _isStrongPassword.default,
		  isTaxID: _isTaxID.default,
		  isDate: _isDate.default,
		  isTime: _isTime.default,
		  isLicensePlate: _isLicensePlate.default,
		  isVAT: _isVAT.default,
		  ibanLocales: _isIBAN.locales
		};
		exports.default = validator;
		module.exports = exports.default;
		module.exports.default = exports.default; 
	} (validator$1, validator$1.exports));
	return validator$1.exports;
}

var validatorExports = /*@__PURE__*/ requireValidator();
var validator = /*@__PURE__*/getDefaultExportFromCjs(validatorExports);

function analyseValidity(data, headers, columnTypes) {
  const results = {
    dimension: 'Validity',
    weight: 0.20,
    issues: [],
    metrics: {},
    score: 100
  };

  const validationRules = detectValidationRules(data, headers, columnTypes);
  const columnValidation = {};

  headers.forEach((header) => {
    const columnData = data.map(row => row[header]).filter(val => val !== null && val !== '');
    const rules = validationRules[header];
    
    columnValidation[header] = {
      totalValues: columnData.length,
      invalidValues: [],
      validationErrors: {},
      formatConsistency: 100
    };

    if (!rules || columnData.length === 0) return;

    const validation = columnValidation[header];

    columnData.forEach((value, index) => {
      let isValid = true;
      const errors = [];

      if (rules.type === 'email' && !validator.isEmail(String(value))) {
        isValid = false;
        errors.push('Invalid email format');
      }

      if (rules.type === 'url' && !validator.isURL(String(value))) {
        isValid = false;
        errors.push('Invalid URL format');
      }

      if (rules.type === 'numeric') {
        const numValue = parseFloat(value);
        if (isNaN(numValue)) {
          isValid = false;
          errors.push('Not a valid number');
        } else {
          if (rules.min !== undefined && numValue < rules.min) {
            isValid = false;
            errors.push(`Value below minimum (${rules.min})`);
          }
          if (rules.max !== undefined && numValue > rules.max) {
            isValid = false;
            errors.push(`Value above maximum (${rules.max})`);
          }
        }
      }

      if (rules.type === 'date') {
        const dateFormats = detectDateFormat(columnData.slice(0, 100));
        if (!isValidDate(value, dateFormats)) {
          isValid = false;
          errors.push('Invalid date format');
        }
      }

      if (rules.pattern && !new RegExp(rules.pattern).test(String(value))) {
        isValid = false;
        errors.push(`Doesn't match expected pattern: ${rules.patternDescription}`);
      }

      if (rules.length && String(value).length !== rules.length) {
        isValid = false;
        errors.push(`Expected length: ${rules.length}, actual: ${String(value).length}`);
      }

      if (!isValid) {
        validation.invalidValues.push({ value, index, errors });
        errors.forEach(error => {
          validation.validationErrors[error] = (validation.validationErrors[error] || 0) + 1;
        });
      }
    });

    const invalidRate = (validation.invalidValues.length / validation.totalValues * 100);
    validation.formatConsistency = 100 - invalidRate;

    if (invalidRate > 10) {
      results.issues.push({
        type: 'critical',
        field: header,
        message: `${invalidRate.toFixed(1)}% invalid values (${validation.invalidValues.length}/${validation.totalValues})`,
        errors: Object.entries(validation.validationErrors)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([error, count]) => `${error}: ${count} occurrences`),
        examples: validation.invalidValues.slice(0, 3).map(v => v.value)
      });
      results.score -= 15;
    } else if (invalidRate > 2) {
      results.issues.push({
        type: 'warning',
        field: header,
        message: `${invalidRate.toFixed(1)}% invalid values (${validation.invalidValues.length}/${validation.totalValues})`,
        errors: Object.entries(validation.validationErrors)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 2)
          .map(([error, count]) => `${error}: ${count}`)
      });
      results.score -= 5;
    } else if (invalidRate > 0) {
      results.issues.push({
        type: 'observation',
        field: header,
        message: `${validation.invalidValues.length} invalid values found`,
        examples: validation.invalidValues.slice(0, 2).map(v => v.value)
      });
      results.score -= 1;
    }
  });

  const overallValidity = headers.reduce((sum, header) => 
    sum + (columnValidation[header]?.formatConsistency || 100), 0) / headers.length;

  results.metrics = {
    overallValidity: overallValidity.toFixed(2),
    columnsWithInvalidData: Object.values(columnValidation).filter(v => v.invalidValues.length > 0).length,
    totalInvalidValues: Object.values(columnValidation).reduce((sum, v) => sum + v.invalidValues.length, 0),
    validationRules: validationRules,
    columnValidation: columnValidation
  };

  results.score = Math.max(0, results.score);
  return results;
}

function detectValidationRules(data, headers, columnTypes) {
  const rules = {};

  headers.forEach((header) => {
    const columnData = data.map(row => row[header]).filter(val => val !== null && val !== '');
    if (columnData.length === 0) return;

    const headerLower = header.toLowerCase();
    const type = columnTypes[header];

    if (headerLower.includes('email')) {
      rules[header] = { type: 'email' };
    } else if (headerLower.includes('url') || headerLower.includes('website')) {
      rules[header] = { type: 'url' };
    } else if (headerLower.includes('phone') || headerLower.includes('mobile')) {
      rules[header] = { type: 'phone', pattern: detectPhonePattern(columnData) };
    } else if (headerLower.includes('postcode') || headerLower.includes('zip')) {
      rules[header] = { type: 'postcode', pattern: detectPostcodePattern(columnData) };
    } else if (type === 'date' || headerLower.includes('date') || headerLower.includes('time')) {
      rules[header] = { type: 'date' };
    } else if (type === 'numeric') {
      const numericData = columnData.map(v => parseFloat(v)).filter(v => !isNaN(v));
      if (numericData.length > 0) {
        rules[header] = {
          type: 'numeric',
          min: Math.min(...numericData),
          max: Math.max(...numericData)
        };
      }
    } else if (headerLower.includes('code') || headerLower.includes('id')) {
      const pattern = detectCodePattern(columnData);
      if (pattern) {
        rules[header] = { 
          type: 'code', 
          pattern: pattern.regex,
          patternDescription: pattern.description,
          length: pattern.length
        };
      }
    }
  });

  return rules;
}

function detectPhonePattern(values) {
  const auMobilePattern = /^(?:\+?61|0)?4\d{8}$/;
  const auLandlinePattern = /^(?:\+?61|0)?[2-9]\d{8}$/;
  
  const sample = values.slice(0, 100);
  let mobileMatches = 0;
  let landlineMatches = 0;

  sample.forEach(value => {
    const cleaned = String(value).replace(/[\s\-\(\)]/g, '');
    if (auMobilePattern.test(cleaned)) mobileMatches++;
    if (auLandlinePattern.test(cleaned)) landlineMatches++;
  });

  if (mobileMatches > sample.length * 0.8) {
    return '^(?:\\+?61|0)?4\\d{8}$';
  } else if (landlineMatches > sample.length * 0.8) {
    return '^(?:\\+?61|0)?[2-9]\\d{8}$';
  }
  
  return null;
}

function detectPostcodePattern(values) {
  const auPostcodePattern = /^[0-9]{4}$/;
  const usZipPattern = /^[0-9]{5}(-[0-9]{4})?$/;
  
  const sample = values.slice(0, 100);
  let auMatches = 0;
  let usMatches = 0;

  sample.forEach(value => {
    const cleaned = String(value).trim();
    if (auPostcodePattern.test(cleaned)) auMatches++;
    if (usZipPattern.test(cleaned)) usMatches++;
  });

  if (auMatches > sample.length * 0.8) {
    return '^[0-9]{4}$';
  } else if (usMatches > sample.length * 0.8) {
    return '^[0-9]{5}(-[0-9]{4})?$';
  }
  
  return null;
}

function detectCodePattern(values) {
  const sample = values.slice(0, 100).map(v => String(v));
  
  const lengths = sample.map(v => v.length);
  const uniqueLengths = [...new Set(lengths)];
  
  if (uniqueLengths.length === 1) {
    const length = uniqueLengths[0];
    
    const patterns = [
      { regex: '^[A-Z0-9]+$', desc: 'Alphanumeric uppercase' },
      { regex: '^[0-9]+$', desc: 'Numeric only' },
      { regex: '^[A-Z]+$', desc: 'Letters only uppercase' },
      { regex: '^[A-Z]{2,3}-[0-9]{4,6}$', desc: 'Pattern like XX-1234' }
    ];

    for (const pattern of patterns) {
      const matches = sample.filter(v => new RegExp(pattern.regex).test(v)).length;
      if (matches > sample.length * 0.95) {
        return {
          regex: pattern.regex,
          description: pattern.desc,
          length: length
        };
      }
    }
  }
  
  return null;
}

function detectDateFormat(values) {
  const formats = [
    'YYYY-MM-DD',
    'DD/MM/YYYY',
    'MM/DD/YYYY',
    'DD-MM-YYYY',
    'YYYY/MM/DD'
  ];
  
  return formats;
}

function isValidDate(value, formats) {
  if (!value || value === '') return false;
  
  // Handle Date objects that were created during CSV parsing
  if (value instanceof Date) {
    // If it's already a Date object, check if it's valid
    const isValidDateObject = !isNaN(value.getTime());
    if (isValidDateObject) {
      const year = value.getFullYear();
      return year >= 1900 && year <= 2100;
    }
    return false;
  }
  
  const dateStr = String(value).trim();
  
  // Common date patterns
  const patterns = {
    'YYYY-MM-DD': /^\d{4}-\d{2}-\d{2}$/,
    'DD/MM/YYYY': /^\d{2}\/\d{2}\/\d{4}$/,
    'MM/DD/YYYY': /^\d{2}\/\d{2}\/\d{4}$/,
    'DD-MM-YYYY': /^\d{2}-\d{2}-\d{4}$/,
    'YYYY/MM/DD': /^\d{4}\/\d{2}\/\d{2}$/
  };
  
  // Try parsing as-is first for ISO formats
  try {
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      const year = date.getFullYear();
      // Check for valid ISO date format (YYYY-MM-DD) first
      if (patterns['YYYY-MM-DD'].test(dateStr) && year >= 1900 && year <= 2100) {
        return true;
      }
    }
  } catch (e) {
    // Continue to pattern matching
  }
  
  // Try each format pattern
  for (const format of formats || Object.keys(patterns)) {
    if (patterns[format] && patterns[format].test(dateStr)) {
      return true;
    }
  }
  
  return false;
}

function analyseAccuracy(data, headers, columnTypes) {
  const results = {
    dimension: 'Accuracy',
    weight: 0.20,
    issues: [],
    metrics: {},
    score: 100
  };

  const accuracyChecks = {};

  headers.forEach((header) => {
    const columnData = data.map(row => row[header]).filter(val => val !== null && val !== '');
    const type = columnTypes[header];

    accuracyChecks[header] = {
      outliers: [],
      impossibleValues: [],
      statisticalAnomalies: [],
      businessRuleViolations: []
    };

    if (type === 'numeric' && columnData.length > 0) {
      const numericData = columnData.map(v => parseFloat(v)).filter(v => !isNaN(v));
      
      if (numericData.length > 10) {
        const outliers = detectStatisticalOutliers(numericData);
        const impossible = detectImpossibleValues(numericData, header);
        const anomalies = detectStatisticalAnomalies$1(numericData, header);

        accuracyChecks[header].outliers = outliers;
        accuracyChecks[header].impossibleValues = impossible;
        accuracyChecks[header].statisticalAnomalies = anomalies;

        if (outliers.severe.length > 0) {
          results.issues.push({
            type: 'critical',
            field: header,
            message: `${outliers.severe.length} severe outliers detected`,
            details: `Values beyond 3 standard deviations: ${outliers.severe.slice(0, 5).join(', ')}${outliers.severe.length > 5 ? '...' : ''}`,
            impact: 'May indicate data entry errors or system issues'
          });
          results.score -= 10;
        }

        if (impossible.length > 0) {
          results.issues.push({
            type: 'critical',
            field: header,
            message: `${impossible.length} impossible values found`,
            examples: impossible.slice(0, 5).map(v => v.value),
            reasons: impossible.slice(0, 3).map(v => v.reason)
          });
          results.score -= 15;
        }

        if (anomalies.length > 0) {
          anomalies.forEach(anomaly => {
            results.issues.push({
              type: anomaly.severity,
              field: header,
              message: anomaly.message,
              details: anomaly.details,
              statisticalTest: anomaly.test
            });
            results.score -= anomaly.severity === 'critical' ? 10 : 5;
          });
        }
      }
    }

    const businessRules = detectBusinessRuleViolations(columnData, header, data, headers);
    if (businessRules.length > 0) {
      accuracyChecks[header].businessRuleViolations = businessRules;
      businessRules.forEach(rule => {
        results.issues.push({
          type: rule.severity,
          field: header,
          message: rule.message,
          violationCount: rule.count,
          confidence: rule.confidence
        });
        results.score -= rule.severity === 'critical' ? 10 : 5;
      });
    }
  });

  const referentialIssues = checkReferentialIntegrity(data, headers);
  if (referentialIssues.length > 0) {
    results.issues.push(...referentialIssues);
    referentialIssues.forEach(issue => {
      results.score -= issue.type === 'critical' ? 10 : 5;
    });
  }

  results.metrics = {
    totalOutliers: Object.values(accuracyChecks).reduce((sum, check) => 
      sum + (check.outliers?.severe?.length || 0) + (check.outliers?.moderate?.length || 0), 0),
    totalImpossibleValues: Object.values(accuracyChecks).reduce((sum, check) => 
      sum + check.impossibleValues.length, 0),
    totalBusinessRuleViolations: Object.values(accuracyChecks).reduce((sum, check) => 
      sum + check.businessRuleViolations.reduce((s, r) => s + r.count, 0), 0),
    accuracyChecks: accuracyChecks
  };

  results.score = Math.max(0, results.score);
  return results;
}

function detectStatisticalOutliers(values) {
  if (values.length < 10) return { severe: [], moderate: [] };

  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  const q1 = quantile(values, 0.25);
  const q3 = quantile(values, 0.75);
  const iqr = q3 - q1;

  const outliers = {
    severe: [],
    moderate: []
  };

  values.forEach(value => {
    const zScore = Math.abs((value - mean) / stdDev);
    
    if (zScore > 3) {
      outliers.severe.push(value);
    } else if (zScore > 2) {
      outliers.moderate.push(value);
    }

    if (value < q1 - 3 * iqr || value > q3 + 3 * iqr) {
      if (!outliers.severe.includes(value)) {
        outliers.severe.push(value);
      }
    } else if (value < q1 - 1.5 * iqr || value > q3 + 1.5 * iqr) {
      if (!outliers.moderate.includes(value) && !outliers.severe.includes(value)) {
        outliers.moderate.push(value);
      }
    }
  });

  return outliers;
}

function detectImpossibleValues(values, fieldName) {
  const impossible = [];
  const fieldLower = fieldName.toLowerCase();

  values.forEach(value => {
    if (fieldLower.includes('age')) {
      if (value < 0 || value > 150) {
        impossible.push({ value, reason: 'Age outside valid range (0-150)' });
      }
    } else if (fieldLower.includes('percentage') || fieldLower.includes('percent')) {
      if (value < 0 || value > 100) {
        impossible.push({ value, reason: 'Percentage outside 0-100 range' });
      }
    } else if (fieldLower.includes('price') || fieldLower.includes('amount') || fieldLower.includes('cost')) {
      if (value < 0) {
        impossible.push({ value, reason: 'Negative monetary value' });
      }
    } else if (fieldLower.includes('quantity') || fieldLower.includes('count')) {
      if (value < 0 || !Number.isInteger(value)) {
        impossible.push({ value, reason: 'Invalid quantity (must be non-negative integer)' });
      }
    } else if (fieldLower.includes('year')) {
      const currentYear = new Date().getFullYear();
      if (value < 1900 || value > currentYear + 10) {
        impossible.push({ value, reason: `Year outside reasonable range (1900-${currentYear + 10})` });
      }
    }
  });

  return impossible;
}

function detectStatisticalAnomalies$1(values, fieldName) {
  const anomalies = [];

  if (values.length > 100) {
    const benfordResult = checkBenfordsLaw(values, fieldName);
    if (benfordResult) {
      anomalies.push(benfordResult);
    }

    const roundNumberBias = checkRoundNumberBias(values);
    if (roundNumberBias) {
      anomalies.push(roundNumberBias);
    }
  }

  const distributionAnomaly = checkDistributionAnomaly(values);
  if (distributionAnomaly) {
    anomalies.push(distributionAnomaly);
  }

  return anomalies;
}

function checkBenfordsLaw(values, fieldName) {
  const applicableFields = ['revenue', 'amount', 'sales', 'transaction', 'price'];
  const fieldLower = fieldName.toLowerCase();
  
  if (!applicableFields.some(field => fieldLower.includes(field))) {
    return null;
  }

  const positiveValues = values.filter(v => v > 0);
  if (positiveValues.length < 100) return null;

  const firstDigitCounts = Array(9).fill(0);
  const expectedBenford = [30.1, 17.6, 12.5, 9.7, 7.9, 6.7, 5.8, 5.1, 4.6];

  positiveValues.forEach(value => {
    const firstDigit = parseInt(value.toString().replace('.', '')[0]);
    if (firstDigit >= 1 && firstDigit <= 9) {
      firstDigitCounts[firstDigit - 1]++;
    }
  });

  firstDigitCounts.map(count => 
    (count / positiveValues.length) * 100
  );

  let chiSquare = 0;
  for (let i = 0; i < 9; i++) {
    const expected = expectedBenford[i] * positiveValues.length / 100;
    const observed = firstDigitCounts[i];
    if (expected > 0) {
      chiSquare += Math.pow(observed - expected, 2) / expected;
    }
  }

  if (chiSquare > 21.666) {
    return {
      test: "Benford's Law",
      severity: 'warning',
      message: "Distribution doesn't follow Benford's Law",
      details: `Chi-square: ${chiSquare.toFixed(2)}, p-value < 0.01`,
      interpretation: 'Possible data manipulation or artificial values'
    };
  }

  return null;
}

function checkRoundNumberBias(values) {
  const roundNumbers = values.filter(v => {
    const str = v.toString();
    return v % 10 === 0 || v % 100 === 0 || v % 1000 === 0 ||
           str.endsWith('00') || str.endsWith('000');
  });

  const roundPercentage = (roundNumbers.length / values.length) * 100;
  const expectedPercentage = 10;

  if (roundPercentage > expectedPercentage * 3) {
    return {
      test: 'Round Number Bias',
      severity: 'warning',
      message: `Excessive round numbers detected (${roundPercentage.toFixed(1)}% vs expected ~${expectedPercentage}%)`,
      details: `${roundNumbers.length} round numbers out of ${values.length} values`,
      interpretation: 'Likely manual entries or estimates'
    };
  }

  return null;
}

function checkDistributionAnomaly(values) {
  if (values.length < 30) return null;

  const mean = mean$2(values);
  const median$1 = median(values);
  standardDeviation(values);
  
  const skewness = sampleSkewness(values);
  const kurtosis = values.length > 3 ? calculateKurtosis(values) : null;

  if (Math.abs(skewness) > 2) {
    return {
      test: 'Distribution Skewness',
      severity: 'observation',
      message: `Highly ${skewness > 0 ? 'right' : 'left'}-skewed distribution`,
      details: `Skewness: ${skewness.toFixed(2)}, Mean: ${mean.toFixed(2)}, Median: ${median$1.toFixed(2)}`,
      interpretation: skewness > 0 ? 'Long tail of high values' : 'Long tail of low values'
    };
  }

  if (kurtosis && Math.abs(kurtosis - 3) > 3) {
    return {
      test: 'Distribution Kurtosis',
      severity: 'observation',
      message: kurtosis > 3 ? 'Heavy-tailed distribution' : 'Light-tailed distribution',
      details: `Kurtosis: ${kurtosis.toFixed(2)} (normal = 3)`,
      interpretation: kurtosis > 3 ? 'More outliers than normal' : 'Fewer outliers than normal'
    };
  }

  return null;
}

function calculateKurtosis(values) {
  const n = values.length;
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  
  let sum = 0;
  values.forEach(value => {
    sum += Math.pow((value - mean) / stdDev, 4);
  });
  
  return (n * (n + 1) / ((n - 1) * (n - 2) * (n - 3))) * sum - 
         (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3));
}

function detectBusinessRuleViolations(columnData, header, allData, allHeaders) {
  const violations = [];
  const headerLower = header.toLowerCase();

  if (headerLower.includes('total') || headerLower.includes('sum')) {
    const relatedColumns = findRelatedColumns(header, allHeaders);
    if (relatedColumns.length > 0) {
      let violationCount = 0;
      allData.forEach((row, rowIndex) => {
        const total = parseFloat(row[header]);
        if (!isNaN(total)) {
          const sum = relatedColumns.reduce((acc, relCol) => {
            const val = parseFloat(row[relCol.header]);
            return acc + (isNaN(val) ? 0 : val);
          }, 0);
          
          if (Math.abs(total - sum) > 0.01) {
            violationCount++;
          }
        }
      });

      if (violationCount > 0) {
        violations.push({
          rule: 'Calculated Field Consistency',
          message: `${header} doesn't match sum of related fields`,
          count: violationCount,
          confidence: ((allData.length - violationCount) / allData.length * 100).toFixed(1) + '%',
          severity: violationCount > allData.length * 0.1 ? 'critical' : 'warning'
        });
      }
    }
  }

  return violations;
}

function findRelatedColumns(totalColumn, allHeaders) {
  const related = [];
  const baseName = totalColumn.toLowerCase()
    .replace('total', '')
    .replace('sum', '')
    .trim();

  allHeaders.forEach((header, index) => {
    const headerLower = header.toLowerCase();
    if (header !== totalColumn && 
        (headerLower.includes(baseName) || baseName.includes(headerLower)) &&
        !headerLower.includes('total') && 
        !headerLower.includes('sum')) {
      related.push({ header });
    }
  });

  return related;
}

function checkReferentialIntegrity(data, headers) {
  const issues = [];
  const idColumns = headers
    .filter(h => h.toLowerCase().includes('_id') || 
                 h.toLowerCase().endsWith('id'))
    .map(h => ({ header: h }));

  idColumns.forEach(idCol => {
    const referencedEntity = idCol.header.toLowerCase()
      .replace('_id', '')
      .replace('id', '');
    
    const uniqueIds = new Set();

    data.forEach(row => {
      const id = row[idCol.header];
      if (id !== null && id !== '') {
        uniqueIds.add(id);
      }
    });

    const orphanedIds = Array.from(uniqueIds).filter(id => {
      return false;
    });

    if (orphanedIds.length > 0) {
      issues.push({
        type: 'warning',
        field: idCol.header,
        message: `Potential referential integrity issue`,
        details: `${orphanedIds.length} unique IDs may reference missing ${referencedEntity} records`,
        recommendation: 'Verify foreign key relationships'
      });
    }
  });

  return issues;
}

function analyseConsistency(data, headers) {
  const results = {
    dimension: 'Consistency',
    weight: 0.15,
    issues: [],
    metrics: {},
    score: 100
  };

  const consistencyChecks = {
    crossColumnValidation: [],
    formatStandardisation: [],
    namingConventions: [],
    duplicateVariations: []
  };

  const crossColumnIssues = checkCrossColumnConsistency(data, headers);
  consistencyChecks.crossColumnValidation = crossColumnIssues;
  
  crossColumnIssues.forEach(issue => {
    results.issues.push({
      type: issue.severity,
      category: 'Cross-Column Validation',
      message: issue.message,
      affectedRecords: issue.count,
      examples: issue.examples?.slice(0, 3),
      recommendation: issue.fix
    });
    results.score -= issue.severity === 'critical' ? 10 : 5;
  });

  headers.forEach((header) => {
    const columnData = data.map(row => row[header]).filter(val => val !== null && val !== '');
    
    const formatIssues = checkFormatConsistency(columnData, header);
    if (formatIssues.length > 0) {
      consistencyChecks.formatStandardisation.push(...formatIssues);
      formatIssues.forEach(issue => {
        results.issues.push({
          type: issue.severity,
          field: header,
          category: 'Format Standardisation',
          message: issue.message,
          variations: issue.variations,
          recommendation: issue.recommendation
        });
        results.score -= issue.severity === 'critical' ? 5 : 2;
      });
    }
  });

  const namingIssues = checkNamingConsistency(data, headers);
  if (namingIssues.length > 0) {
    consistencyChecks.namingConventions = namingIssues;
    namingIssues.forEach(issue => {
      results.issues.push({
        type: 'observation',
        category: 'Naming Conventions',
        message: issue.message,
        examples: issue.examples,
        impact: 'May cause confusion or integration issues'
      });
      results.score -= 1;
    });
  }

  const caseInsensitiveDuplicates = findCaseVariations(data, headers);
  if (caseInsensitiveDuplicates.length > 0) {
    consistencyChecks.duplicateVariations = caseInsensitiveDuplicates;
    results.issues.push({
      type: 'warning',
      category: 'Case Variations',
      message: `Found ${caseInsensitiveDuplicates.length} groups with case variations`,
      groups: caseInsensitiveDuplicates.slice(0, 3),
      recommendation: 'Standardise to consistent case format'
    });
    results.score -= 5;
  }

  results.metrics = {
    crossColumnIssues: consistencyChecks.crossColumnValidation.length,
    formatIssues: consistencyChecks.formatStandardisation.length,
    namingIssues: consistencyChecks.namingConventions.length,
    caseVariations: consistencyChecks.duplicateVariations.length,
    overallConsistency: results.score
  };

  results.score = Math.max(0, results.score);
  return results;
}

function checkCrossColumnConsistency(data, headers) {
  const issues = [];

  const dateColumns = headers
    .filter(h => h.toLowerCase().includes('date') || 
                 h.toLowerCase().includes('time'))
    .map(h => ({ header: h }));

  for (let i = 0; i < dateColumns.length - 1; i++) {
    for (let j = i + 1; j < dateColumns.length; j++) {
      const col1 = dateColumns[i];
      const col2 = dateColumns[j];
      
      const temporalIssues = checkTemporalLogic(data, col1, col2);
      if (temporalIssues) {
        issues.push(temporalIssues);
      }
    }
  }

  const ageColumn = headers.find(h => h.toLowerCase().includes('age'));
  const birthDateColumn = headers.find(h => 
    h.toLowerCase().includes('birth') || h.toLowerCase().includes('dob'));
  
  if (ageColumn && birthDateColumn) {
    const ageConsistency = checkAgeDateConsistency(data, ageColumn, birthDateColumn);
    if (ageConsistency) {
      issues.push(ageConsistency);
    }
  }

  const statusColumn = headers.find(h => h.toLowerCase().includes('status'));
  if (statusColumn) {
    const statusIssues = checkStatusConsistency(data, headers, statusColumn);
    issues.push(...statusIssues);
  }

  const addressColumns = findAddressColumns(headers);
  if (addressColumns.length > 0) {
    const geoIssues = checkGeographicConsistency(data, addressColumns);
    if (geoIssues.length > 0) {
      issues.push(...geoIssues);
    }
  }

  return issues;
}

function checkTemporalLogic(data, col1, col2) {
  let violationCount = 0;
  const examples = [];

  const rules = getTemporalRules(col1.header, col2.header);
  if (!rules) return null;

  data.forEach((row, index) => {
    const date1 = parseDate$2(row[col1.header]);
    const date2 = parseDate$2(row[col2.header]);
    
    if (date1 && date2) {
      if (rules.relationship === 'before' && date1 > date2) {
        violationCount++;
        if (examples.length < 5) {
          examples.push({
            row: index + 1,
            [col1.header]: row[col1.header],
            [col2.header]: row[col2.header]
          });
        }
      } else if (rules.relationship === 'after' && date1 < date2) {
        violationCount++;
        if (examples.length < 5) {
          examples.push({
            row: index + 1,
            [col1.header]: row[col1.header],
            [col2.header]: row[col2.header]
          });
        }
      }
    }
  });

  if (violationCount > 0) {
    return {
      severity: violationCount > data.length * 0.05 ? 'critical' : 'warning',
      message: `${col1.header} should be ${rules.relationship} ${col2.header}`,
      count: violationCount,
      examples: examples,
      fix: `UPDATE table SET ${col1.header} = ${rules.fix}`
    };
  }

  return null;
}

function getTemporalRules(field1, field2) {
  const rules = {
    'created,modified': { relationship: 'before', fix: 'LEAST(created_date, modified_date)' },
    'created,first': { relationship: 'before', fix: 'LEAST(created_date, first_date)' },
    'start,end': { relationship: 'before', fix: 'LEAST(start_date, end_date)' },
    'birth,death': { relationship: 'before', fix: 'birth_date' },
    'order,delivery': { relationship: 'before', fix: 'order_date' },
    'purchase,return': { relationship: 'before', fix: 'purchase_date' }
  };

  for (const [key, rule] of Object.entries(rules)) {
    const [f1, f2] = key.split(',');
    if ((field1.toLowerCase().includes(f1) && field2.toLowerCase().includes(f2)) ||
        (field1.toLowerCase().includes(f2) && field2.toLowerCase().includes(f1))) {
      return rule;
    }
  }

  return null;
}

function checkAgeDateConsistency(data, ageColumn, birthDateColumn, headers) {
  let inconsistentCount = 0;
  const examples = [];
  const currentYear = new Date().getFullYear();

  data.forEach((row, index) => {
    const age = parseInt(row[ageColumn]);
    const birthDate = parseDate$2(row[birthDateColumn]);
    
    if (!isNaN(age) && birthDate) {
      const birthYear = birthDate.getFullYear();
      const calculatedAge = currentYear - birthYear;
      
      if (Math.abs(calculatedAge - age) > 1) {
        inconsistentCount++;
        if (examples.length < 3) {
          examples.push({
            row: index + 1,
            statedAge: age,
            birthDate: row[birthDateColumn],
            calculatedAge: calculatedAge
          });
        }
      }
    }
  });

  if (inconsistentCount > 0) {
    return {
      severity: inconsistentCount > data.length * 0.02 ? 'critical' : 'warning',
      message: 'Age inconsistent with birth date',
      count: inconsistentCount,
      examples: examples,
      fix: 'Recalculate age from birth date'
    };
  }

  return null;
}

function checkStatusConsistency(data, headers, statusColumn) {
  const issues = [];
  const statusValues = {};

  data.forEach((row, rowIndex) => {
    const status = row[statusColumn];
    if (!status) return;

    if (!statusValues[status]) {
      statusValues[status] = {
        count: 0,
        associatedPatterns: {}
      };
    }
    statusValues[status].count++;

    headers.forEach((header) => {
      if (header !== statusColumn) {
        const value = row[header];
        if (value !== null && value !== '') {
          const pattern = `${header}:${value}`;
          if (!statusValues[status].associatedPatterns[pattern]) {
            statusValues[status].associatedPatterns[pattern] = 0;
          }
          statusValues[status].associatedPatterns[pattern]++;
        }
      }
    });
  });

  Object.entries(statusValues).forEach(([status, info]) => {
    const totalCount = info.count;
    Object.entries(info.associatedPatterns).forEach(([pattern, count]) => {
      const consistency = count / totalCount;
      if (consistency > 0.95 && totalCount > 10) {
        const [field, value] = pattern.split(':');
        if (field.toLowerCase().includes('email') && status === 'inactive' && value !== '') {
          issues.push({
            severity: 'observation',
            message: `Active emails found for inactive status`,
            count: count,
            pattern: `${status} records typically have empty ${field}`,
            fix: `Consider clearing ${field} when status='${status}'`
          });
        }
      }
    });
  });

  return issues;
}

function checkFormatConsistency(values, fieldName) {
  const issues = [];
  const formats = {};

  values.forEach(value => {
    const format = detectFormat(value, fieldName);
    if (format) {
      formats[format] = (formats[format] || 0) + 1;
    }
  });

  const totalValues = values.length;
  const formatEntries = Object.entries(formats);

  if (formatEntries.length > 1) {
    const dominant = formatEntries.sort((a, b) => b[1] - a[1])[0];
    const dominantPercentage = (dominant[1] / totalValues) * 100;

    if (dominantPercentage < 95) {
      issues.push({
        severity: dominantPercentage < 80 ? 'warning' : 'observation',
        message: `Multiple format variations detected`,
        variations: formatEntries.map(([fmt, count]) => 
          `${fmt}: ${count} (${(count/totalValues*100).toFixed(1)}%)`
        ),
        recommendation: `Standardise to ${dominant[0]} format`
      });
    }
  }

  const caseVariations = checkCaseConsistency(values, fieldName);
  if (caseVariations) {
    issues.push(caseVariations);
  }

  return issues;
}

function detectFormat(value, fieldName) {
  const str = String(value);
  const fieldLower = fieldName.toLowerCase();

  if (fieldLower.includes('phone')) {
    if (/^\d{10}$/.test(str)) return 'XXXXXXXXXX';
    if (/^\d{3}-\d{3}-\d{4}$/.test(str)) return 'XXX-XXX-XXXX';
    if (/^\(\d{3}\) \d{3}-\d{4}$/.test(str)) return '(XXX) XXX-XXXX';
    if (/^\+\d{1,3} \d+$/.test(str)) return '+XX XXXXXXXXX';
  }

  if (fieldLower.includes('date')) {
    if (/^\d{4}-\d{2}-\d{2}$/.test(str)) return 'YYYY-MM-DD';
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(str)) return 'DD/MM/YYYY';
    if (/^\d{2}-\d{2}-\d{4}$/.test(str)) return 'DD-MM-YYYY';
  }

  if (fieldLower.includes('address')) {
    if (/^\d+\s+\w+\s+(St|Street)$/i.test(str)) return 'Number Name St/Street';
    if (/^\d+\s+\w+\s+(Rd|Road)$/i.test(str)) return 'Number Name Rd/Road';
    if (/^\d+\s+\w+\s+(Ave|Avenue)$/i.test(str)) return 'Number Name Ave/Avenue';
  }

  return null;
}

function checkCaseConsistency(values, fieldName) {
  if (!['name', 'city', 'state', 'country'].some(term => 
    fieldName.toLowerCase().includes(term))) {
    return null;
  }

  const caseFormats = {
    upper: 0,
    lower: 0,
    title: 0,
    mixed: 0
  };

  values.forEach(value => {
    const str = String(value).trim();
    if (str === str.toUpperCase()) {
      caseFormats.upper++;
    } else if (str === str.toLowerCase()) {
      caseFormats.lower++;
    } else if (str === toTitleCase(str)) {
      caseFormats.title++;
    } else {
      caseFormats.mixed++;
    }
  });

  const total = values.length;
  const dominant = Object.entries(caseFormats)
    .sort((a, b) => b[1] - a[1])[0];

  if (dominant[1] < total * 0.9) {
    return {
      severity: 'observation',
      message: 'Inconsistent text casing',
      variations: Object.entries(caseFormats)
        .filter(([_, count]) => count > 0)
        .map(([format, count]) => 
          `${format}: ${(count/total*100).toFixed(1)}%`
        ),
      recommendation: `Standardise to ${dominant[0]} case`
    };
  }

  return null;
}

function toTitleCase(str) {
  return str.replace(/\w\S*/g, txt => 
    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
  );
}

function findCaseVariations(data, headers) {
  const variations = [];
  const textColumns = headers
    .filter(h => {
      const sample = data.slice(0, 100).map(row => row[h])
        .filter(v => v && typeof v === 'string');
      return sample.length > 10 && sample.some(v => isNaN(parseFloat(v)));
    })
    .map(h => ({ header: h }));

  textColumns.forEach(col => {
    const valueGroups = {};
    
    data.forEach(row => {
      const value = row[col.header];
      if (value && typeof value === 'string') {
        const normalized = value.toLowerCase().trim();
        if (!valueGroups[normalized]) {
          valueGroups[normalized] = new Set();
        }
        valueGroups[normalized].add(value);
      }
    });

    Object.entries(valueGroups).forEach(([normalized, variants]) => {
      if (variants.size > 1) {
        variations.push({
          field: col.header,
          normalized: normalized,
          variants: Array.from(variants),
          count: variants.size
        });
      }
    });
  });

  return variations.sort((a, b) => b.count - a.count);
}

function checkNamingConsistency(data, headers) {
  const issues = [];
  const patterns = {
    camelCase: /^[a-z][a-zA-Z0-9]*$/,
    snake_case: /^[a-z][a-z0-9_]*$/,
    PascalCase: /^[A-Z][a-zA-Z0-9]*$/,
    'kebab-case': /^[a-z][a-z0-9-]*$/
  };

  const namingStyles = {};
  
  headers.forEach(header => {
    Object.entries(patterns).forEach(([style, pattern]) => {
      if (pattern.test(header)) {
        namingStyles[style] = (namingStyles[style] || 0) + 1;
      }
    });
  });

  const styles = Object.entries(namingStyles).filter(([_, count]) => count > 0);
  if (styles.length > 1) {
    issues.push({
      message: 'Inconsistent column naming conventions',
      examples: styles.map(([style, count]) => 
        `${style}: ${count} columns`
      )
    });
  }

  return issues;
}

function findAddressColumns(headers) {
  const addressTerms = ['address', 'street', 'city', 'state', 'postcode', 'zip', 'country'];
  return headers
    .filter(h => addressTerms.some(term => 
      h.toLowerCase().includes(term)
    ))
    .map(h => ({ header: h }));
}

function checkGeographicConsistency(data, addressColumns) {
  const issues = [];
  
  const postcodeCol = addressColumns.find(col => 
    col.header.toLowerCase().includes('postcode') || 
    col.header.toLowerCase().includes('zip')
  );
  const stateCol = addressColumns.find(col => 
    col.header.toLowerCase().includes('state')
  );

  if (postcodeCol && stateCol) {
    const auPostcodeRanges = {
      'NSW': [[2000, 2599], [2619, 2899], [2921, 2999]],
      'VIC': [[3000, 3999], [8000, 8999]],
      'QLD': [[4000, 4999], [9000, 9999]],
      'SA': [[5000, 5799]],
      'WA': [[6000, 6797]],
      'TAS': [[7000, 7799]],
      'NT': [[800, 899]],
      'ACT': [[200, 299], [2600, 2618], [2900, 2920]]
    };

    let mismatches = 0;
    const examples = [];

    data.forEach((row, index) => {
      const postcode = parseInt(row[postcodeCol.header]);
      const state = row[stateCol.header];

      if (!isNaN(postcode) && state && auPostcodeRanges[state]) {
        const validRanges = auPostcodeRanges[state];
        const isValid = validRanges.some(([min, max]) => 
          postcode >= min && postcode <= max
        );

        if (!isValid) {
          mismatches++;
          if (examples.length < 3) {
            examples.push({
              row: index + 1,
              postcode: postcode,
              state: state
            });
          }
        }
      }
    });

    if (mismatches > 0) {
      issues.push({
        severity: mismatches > data.length * 0.02 ? 'warning' : 'observation',
        message: 'Postcode/State mismatches detected',
        count: mismatches,
        examples: examples,
        fix: 'Verify and correct geographic data'
      });
    }
  }

  return issues;
}

function parseDate$2(value) {
  if (!value) return null;
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
}

function analyseTimeliness(data, headers) {
  const results = {
    dimension: 'Timeliness',
    weight: 0.15,
    issues: [],
    metrics: {},
    score: 100
  };

  const dateColumns = identifyDateColumns(data, headers);
  const timelinessAnalysis = {};
  
  if (dateColumns.length === 0) {
    results.metrics = {
      message: 'No date columns detected for timeliness analysis',
      recommendation: 'Add timestamp columns to track data freshness'
    };
    return results;
  }

  dateColumns.forEach(dateCol => {
    const analysis = analyseDateColumn(data, dateCol);
    timelinessAnalysis[dateCol.header] = analysis;

    // Check if this looks like cohort/test data (all dates within a short period)
    const isCohortPattern = analysis.range && analysis.range.span <= 90 && 
                           analysis.validDates.length > 5 &&
                           analysis.patterns.yearlyTrend && 
                           Object.keys(analysis.patterns.yearlyTrend).length === 1;

    if (isCohortPattern) {
      results.issues.push({
        type: 'observation',
        field: dateCol.header,
        message: `Cohort pattern detected - all dates within ${analysis.range.span} days`,
        details: `Date range: ${analysis.range.oldest} to ${analysis.range.newest}`,
        interpretation: 'Appears to be test data or study cohort'
      });
      // Don't penalize cohort data for "staleness"
    } else if (analysis.staleness.percentage > 30) {
      results.issues.push({
        type: 'critical',
        field: dateCol.header,
        message: `${analysis.staleness.percentage.toFixed(1)}% of records are stale (>${analysis.staleness.threshold} days old)`,
        details: `${analysis.staleness.count}/${analysis.validDates.length} records`,
        oldestRecord: analysis.range.oldest,
        impact: 'Data may not reflect current state'
      });
      results.score -= 15;
    } else if (analysis.staleness.percentage > 15) {
      results.issues.push({
        type: 'warning',
        field: dateCol.header,
        message: `${analysis.staleness.percentage.toFixed(1)}% of records are becoming stale`,
        details: `${analysis.staleness.count} records older than ${analysis.staleness.threshold} days`,
        recommendation: 'Consider updating or archiving old records'
      });
      results.score -= 7;
    }

    if (analysis.future.count > 0) {
      results.issues.push({
        type: 'critical',
        field: dateCol.header,
        message: `${analysis.future.count} records have future dates`,
        examples: analysis.future.examples.slice(0, 3),
        impact: 'Data integrity issue - impossible timestamps'
      });
      results.score -= 10;
    }

    if (analysis.suspicious && analysis.suspicious.beforeBusinessStart > 0) {
      results.issues.push({
        type: 'warning',
        field: dateCol.header,
        message: `${analysis.suspicious.beforeBusinessStart} records predate reasonable business start`,
        earliestDate: analysis.suspicious.earliestDate,
        recommendation: 'Verify or correct historical data'
      });
      results.score -= 5;
    }

    if (analysis.updateFrequency) {
      if (analysis.updateFrequency.daysWithoutUpdate > 30) {
        results.issues.push({
          type: 'observation',
          field: dateCol.header,
          message: `No updates in the last ${analysis.updateFrequency.daysWithoutUpdate} days`,
          lastUpdate: analysis.updateFrequency.lastUpdate,
          averageUpdateInterval: `${analysis.updateFrequency.averageInterval.toFixed(1)} days`,
          impact: 'May indicate process issues or abandonment'
        });
        results.score -= 3;
      }
    }

    if (analysis.patterns.weekend > 20 && analysis.patterns.weekend < 80) {
      results.issues.push({
        type: 'observation',
        field: dateCol.header,
        message: `Unusual weekend activity pattern (${analysis.patterns.weekend.toFixed(1)}% on weekends)`,
        interpretation: 'May indicate automated processes or data quality issues'
      });
    }
  });

  const modificationColumns = findModificationColumns(headers, dateColumns);
  if (modificationColumns.created && modificationColumns.modified) {
    const updateAnalysis = analyseUpdatePatterns(
      data, 
      modificationColumns.created, 
      modificationColumns.modified
    );
    
    if (updateAnalysis.neverModified > 50) {
      results.issues.push({
        type: 'observation',
        category: 'Update Patterns',
        message: `${updateAnalysis.neverModified.toFixed(1)}% of records never modified since creation`,
        count: updateAnalysis.neverModifiedCount,
        interpretation: 'May indicate abandoned records or lack of maintenance'
      });
      results.score -= 5;
    }

    if (updateAnalysis.frequentlyModified.length > 0) {
      results.issues.push({
        type: 'observation',
        category: 'Update Patterns',
        message: `${updateAnalysis.frequentlyModified.length} records modified unusually often`,
        topRecords: updateAnalysis.frequentlyModified.slice(0, 3),
        interpretation: 'May indicate data quality issues or system problems'
      });
    }
  }

  const freshnessScore = calculateOverallFreshness(timelinessAnalysis);
  
  results.metrics = {
    dateColumnsAnalysed: dateColumns.length,
    overallFreshness: `${freshnessScore.toFixed(1)}%`,
    stalestColumn: getStalestColumn(timelinessAnalysis),
    updatePatterns: modificationColumns.created && modificationColumns.modified ? {
      neverModified: `${updateAnalysis?.neverModified?.toFixed(1)}%`,
      averageUpdateAge: updateAnalysis?.averageAge ? `${updateAnalysis.averageAge.toFixed(1)} days` : 'N/A'
    } : null,
    timelinessAnalysis: timelinessAnalysis
  };

  results.score = Math.max(0, results.score);
  return results;
}

function identifyDateColumns(data, headers) {
  const dateColumns = [];
  
  headers.forEach((header) => {
    const headerLower = header.toLowerCase();
    const isLikelyDate = headerLower.includes('date') || 
                        headerLower.includes('time') ||
                        headerLower.includes('created') ||
                        headerLower.includes('modified') ||
                        headerLower.includes('updated') ||
                        headerLower.includes('_at') ||
                        headerLower.includes('_on');

    if (isLikelyDate || isDateColumn(data, header)) {
      dateColumns.push({ header });
    }
  });

  return dateColumns;
}

function isDateColumn(data, header) {
  const sample = data.slice(0, Math.min(100, data.length))
    .map(row => row[header])
    .filter(val => val !== null && val !== '');

  if (sample.length === 0) return false;

  let validDates = 0;
  sample.forEach(value => {
    const date = parseDate$1(value);
    if (date && !isNaN(date.getTime())) {
      validDates++;
    }
  });

  return validDates > sample.length * 0.8;
}

function analyseDateColumn(data, dateCol) {
  const now = new Date();
  const validDates = [];
  const invalidDates = [];
  const futureDates = [];
  
  data.forEach((row, index) => {
    const value = row[dateCol.header];
    if (value === null || value === '') return;

    const date = parseDate$1(value);
    if (date && !isNaN(date.getTime())) {
      validDates.push({ date, value, rowIndex: index });
      if (date > now) {
        futureDates.push({ date, value, rowIndex: index });
      }
    } else {
      invalidDates.push({ value, rowIndex: index });
    }
  });

  if (validDates.length === 0) {
    return {
      validDates: [],
      invalidDates: invalidDates,
      staleness: { percentage: 0, count: 0 },
      future: { count: 0, examples: [] },
      patterns: {}
    };
  }

  validDates.sort((a, b) => a.date - b.date);
  
  const oldestDate = validDates[0].date;
  const newestDate = validDates[validDates.length - 1].date;
  
  const stalenessThreshold = determineStalenessThreshold(dateCol.header);
  const staleDate = new Date(now.getTime() - stalenessThreshold * 24 * 60 * 60 * 1000);
  const staleRecords = validDates.filter(d => d.date < staleDate);

  const businessStartDate = new Date('1990-01-01');
  const suspiciousOld = validDates.filter(d => d.date < businessStartDate);

  const patterns = analyseTemporalPatterns(validDates);
  const updateFrequency = analyseUpdateFrequency(validDates);

  return {
    validDates: validDates,
    invalidDates: invalidDates,
    range: {
      oldest: oldestDate.toISOString().split('T')[0],
      newest: newestDate.toISOString().split('T')[0],
      span: Math.floor((newestDate - oldestDate) / (1000 * 60 * 60 * 24))
    },
    staleness: {
      threshold: stalenessThreshold,
      count: staleRecords.length,
      percentage: (staleRecords.length / validDates.length) * 100,
      examples: staleRecords.slice(-3).map(r => ({
        value: r.value,
        age: Math.floor((now - r.date) / (1000 * 60 * 60 * 24))
      }))
    },
    future: {
      count: futureDates.length,
      examples: futureDates.map(f => ({
        value: f.value,
        daysInFuture: Math.ceil((f.date - now) / (1000 * 60 * 60 * 24))
      }))
    },
    suspicious: {
      beforeBusinessStart: suspiciousOld.length,
      earliestDate: suspiciousOld.length > 0 ? suspiciousOld[0].date.toISOString().split('T')[0] : null
    },
    patterns: patterns,
    updateFrequency: updateFrequency
  };
}

function determineStalenessThreshold(columnName) {
  const columnLower = columnName.toLowerCase();
  
  // Medical/clinical data has different staleness thresholds
  if (columnLower.includes('visit') || columnLower.includes('appointment') || columnLower.includes('encounter')) {
    return 730; // 2 years for medical visits
  } else if (columnLower.includes('enrollment') || columnLower.includes('study')) {
    return 1825; // 5 years for study enrollment
  } else if (columnLower.includes('test_date') || columnLower.includes('lab_date')) {
    return 365; // 1 year for lab tests
  } else if (columnLower.includes('last_login') || columnLower.includes('last_active')) {
    return 90;
  } else if (columnLower.includes('modified') || columnLower.includes('updated')) {
    return 180;
  } else if (columnLower.includes('created') || columnLower.includes('registration')) {
    return 365;
  } else if (columnLower.includes('birth') || columnLower.includes('dob')) {
    return 36500;
  } else if (columnLower.includes('order') || columnLower.includes('transaction')) {
    return 90;
  } else if (columnLower.includes('email') || columnLower.includes('contact')) {
    return 365;
  }
  
  return 365;
}

function analyseTemporalPatterns(validDates) {
  const patterns = {
    weekend: 0,
    weekday: 0,
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0,
    monthlyDistribution: Array(12).fill(0),
    yearlyTrend: {}
  };

  validDates.forEach(({ date }) => {
    const dayOfWeek = date.getDay();
    if (dayOfWeek === 0 || dayOfWeek === 6) {
      patterns.weekend++;
    } else {
      patterns.weekday++;
    }

    const hour = date.getHours();
    if (hour >= 6 && hour < 12) patterns.morning++;
    else if (hour >= 12 && hour < 17) patterns.afternoon++;
    else if (hour >= 17 && hour < 22) patterns.evening++;
    else patterns.night++;

    patterns.monthlyDistribution[date.getMonth()]++;
    
    const year = date.getFullYear();
    patterns.yearlyTrend[year] = (patterns.yearlyTrend[year] || 0) + 1;
  });

  const total = validDates.length;
  patterns.weekend = (patterns.weekend / total) * 100;
  patterns.weekday = (patterns.weekday / total) * 100;

  return patterns;
}

function analyseUpdateFrequency(validDates) {
  if (validDates.length < 2) return null;

  const now = new Date();
  const mostRecent = validDates[validDates.length - 1].date;
  const daysWithoutUpdate = Math.floor((now - mostRecent) / (1000 * 60 * 60 * 24));

  const intervals = [];
  for (let i = 1; i < validDates.length; i++) {
    const interval = validDates[i].date - validDates[i-1].date;
    intervals.push(interval / (1000 * 60 * 60 * 24));
  }

  const averageInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;

  return {
    lastUpdate: mostRecent.toISOString().split('T')[0],
    daysWithoutUpdate: daysWithoutUpdate,
    averageInterval: averageInterval,
    updateCount: validDates.length
  };
}

function findModificationColumns(headers, dateColumns) {
  const result = {};
  
  dateColumns.forEach(col => {
    const headerLower = col.header.toLowerCase();
    if (headerLower.includes('created') || headerLower.includes('create')) {
      result.created = col;
    } else if (headerLower.includes('modified') || headerLower.includes('updated')) {
      result.modified = col;
    }
  });

  return result;
}

function analyseUpdatePatterns(data, createdCol, modifiedCol) {
  let neverModified = 0;
  const modificationCounts = {};
  const modificationAges = [];

  data.forEach((row, index) => {
    const created = parseDate$1(row[createdCol.header]);
    const modified = parseDate$1(row[modifiedCol.header]);

    if (created && modified) {
      if (created.getTime() === modified.getTime()) {
        neverModified++;
      } else {
        const daysSinceModified = Math.floor((new Date() - modified) / (1000 * 60 * 60 * 24));
        modificationAges.push(daysSinceModified);
        
        const key = `row_${index}`;
        if (!modificationCounts[key]) {
          modificationCounts[key] = {
            count: 0,
            created: created,
            lastModified: modified
          };
        }
        modificationCounts[key].count++;
      }
    }
  });

  const totalRecords = data.length;
  const neverModifiedPercentage = (neverModified / totalRecords) * 100;

  const frequentlyModified = Object.entries(modificationCounts)
    .filter(([_, info]) => {
      const daysSinceCreated = (info.lastModified - info.created) / (1000 * 60 * 60 * 24);
      const modificationsPerDay = info.count / daysSinceCreated;
      return modificationsPerDay > 0.1;
    })
    .map(([key, info]) => ({
      row: parseInt(key.split('_')[1]) + 1,
      modifications: info.count,
      daysSinceCreated: Math.floor((info.lastModified - info.created) / (1000 * 60 * 60 * 24))
    }))
    .sort((a, b) => b.modifications - a.modifications);

  const averageAge = modificationAges.length > 0 
    ? modificationAges.reduce((a, b) => a + b, 0) / modificationAges.length 
    : null;

  return {
    neverModified: neverModifiedPercentage,
    neverModifiedCount: neverModified,
    frequentlyModified: frequentlyModified,
    averageAge: averageAge
  };
}

function calculateOverallFreshness(timelinessAnalysis) {
  const scores = [];
  
  Object.values(timelinessAnalysis).forEach(analysis => {
    if (analysis.validDates && analysis.validDates.length > 0) {
      const freshnessScore = 100 - analysis.staleness.percentage;
      scores.push(freshnessScore);
    }
  });

  if (scores.length === 0) return 100;
  return scores.reduce((a, b) => a + b, 0) / scores.length;
}

function getStalestColumn(timelinessAnalysis) {
  let stalest = null;
  let highestStaleness = 0;

  Object.entries(timelinessAnalysis).forEach(([column, analysis]) => {
    if (analysis.staleness && analysis.staleness.percentage > highestStaleness) {
      highestStaleness = analysis.staleness.percentage;
      stalest = {
        column: column,
        staleness: `${analysis.staleness.percentage.toFixed(1)}%`,
        threshold: `${analysis.staleness.threshold} days`
      };
    }
  });

  return stalest;
}

function parseDate$1(value) {
  if (!value || value === '') return null;
  
  const dateStr = String(value).trim();
  
  // Try parsing as-is first (handles ISO dates)
  const directParse = new Date(dateStr);
  if (!isNaN(directParse.getTime())) {
    const year = directParse.getFullYear();
    if (year > 1900 && year < 2100) {
      return directParse;
    }
  }
  
  // Try common formats
  const parsers = [
    // DD/MM/YYYY
    () => {
      const match = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (match) {
        const [_, d, m, y] = match;
        return new Date(`${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`);
      }
      return null;
    },
    // DD-MM-YYYY  
    () => {
      const match = dateStr.match(/^(\d{1,2})-(\d{1,2})-(\d{4})$/);
      if (match) {
        const [_, d, m, y] = match;
        return new Date(`${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`);
      }
      return null;
    }
  ];
  
  for (const parser of parsers) {
    try {
      const date = parser();
      if (date && !isNaN(date.getTime())) {
        const year = date.getFullYear();
        if (year > 1900 && year < 2100) {
          return date;
        }
      }
    } catch (e) {
      continue;
    }
  }
  
  return null;
}

function analyseUniqueness(data, headers) {
  const results = {
    dimension: 'Uniqueness',
    weight: 0.10,
    issues: [],
    metrics: {},
    score: 100
  };

  const uniquenessAnalysis = {};
  
  headers.forEach((header) => {
    const columnData = data.map(row => row[header]).filter(val => val !== null && val !== '');
    if (columnData.length === 0) return;

    const analysis = analyseColumnUniqueness(columnData);
    uniquenessAnalysis[header] = analysis;

    if (analysis.exactDuplicates.count > 0) {
      const duplicateRate = (analysis.exactDuplicates.count / columnData.length) * 100;
      
      if (shouldBeUnique(header) && duplicateRate > 0) {
        results.issues.push({
          type: 'critical',
          field: header,
          message: `${analysis.exactDuplicates.count} duplicate values in supposedly unique field`,
          duplicateGroups: analysis.exactDuplicates.topGroups.slice(0, 3),
          impact: 'Data integrity violation - may cause system errors',
          fix: generateDuplicateFixSQL$1(header, analysis.exactDuplicates.groups)
        });
        results.score -= 20;
      } else if (duplicateRate > 10) {
        results.issues.push({
          type: 'warning',
          field: header,
          message: `High duplication rate: ${duplicateRate.toFixed(1)}%`,
          totalDuplicates: analysis.exactDuplicates.count,
          uniqueValues: analysis.uniqueValues,
          topDuplicates: analysis.exactDuplicates.topGroups.slice(0, 3)
        });
        results.score -= 5;
      }
    }

    if (analysis.uniquenessRatio < 0.5 && columnData.length > 100) {
      results.issues.push({
        type: 'observation',
        field: header,
        message: `Low uniqueness ratio: ${(analysis.uniquenessRatio * 100).toFixed(1)}%`,
        interpretation: 'May indicate categorical data or limited value range',
        distinctValues: analysis.uniqueValues
      });
    }

    if (header.toLowerCase().includes('id') && analysis.naturalKeyCandidate) {
      results.issues.push({
        type: 'observation',
        field: header,
        message: 'Potential natural key detected',
        uniqueness: `${(analysis.uniquenessRatio * 100).toFixed(1)}%`,
        recommendation: 'Consider using as primary/unique key'
      });
    }
  });

  const compositeDuplicates = findCompositeDuplicates(data, headers);
  if (compositeDuplicates.length > 0) {
    compositeDuplicates.forEach(compDup => {
      results.issues.push({
        type: 'warning',
        category: 'Composite Duplicates',
        message: `Duplicate records when combining ${compDup.fields.join(' + ')}`,
        duplicateCount: compDup.count,
        examples: compDup.examples.slice(0, 3),
        recommendation: 'Consider composite unique constraint'
      });
      results.score -= 5;
    });
  }

  const nearDuplicates = analyseNearDuplicates(data, headers);
  if (nearDuplicates.length > 0) {
    results.issues.push({
      type: 'warning',
      category: 'Near Duplicates',
      message: `${nearDuplicates.length} groups of near-duplicate records found`,
      topGroups: nearDuplicates.slice(0, 3).map(group => ({
        similarity: `${group.similarity}%`,
        recordCount: group.records.length,
        fields: group.matchingFields,
        examples: group.records.slice(0, 2)
      })),
      recommendation: 'Review for potential merge'
    });
    results.score -= 10;
  }

  results.metrics = {
    overallUniqueness: calculateOverallUniqueness(uniquenessAnalysis),
    exactDuplicateRecords: countTotalDuplicates(uniquenessAnalysis),
    nearDuplicateGroups: nearDuplicates.length,
    compositeDuplicateGroups: compositeDuplicates.length,
    columnsWithDuplicates: Object.values(uniquenessAnalysis)
      .filter(a => a.exactDuplicates.count > 0).length,
    uniquenessAnalysis: uniquenessAnalysis
  };

  results.score = Math.max(0, results.score);
  return results;
}

function analyseColumnUniqueness(values, columnName) {
  const valueCounts = {};
  const duplicateGroups = {};
  
  values.forEach((value, index) => {
    const key = String(value);
    valueCounts[key] = (valueCounts[key] || 0) + 1;
    
    if (!duplicateGroups[key]) {
      duplicateGroups[key] = [];
    }
    duplicateGroups[key].push(index);
  });

  const uniqueValues = Object.keys(valueCounts).length;
  const duplicates = Object.entries(valueCounts)
    .filter(([_, count]) => count > 1);
  
  const duplicateCount = duplicates.reduce((sum, [_, count]) => sum + count - 1, 0);
  
  const topGroups = duplicates
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([value, count]) => ({
      value: value.length > 50 ? value.substring(0, 47) + '...' : value,
      count: count,
      percentage: ((count / values.length) * 100).toFixed(1)
    }));

  const isNaturalKey = uniqueValues === values.length || 
                      (uniqueValues / values.length) > 0.99;

  return {
    totalValues: values.length,
    uniqueValues: uniqueValues,
    uniquenessRatio: uniqueValues / values.length,
    exactDuplicates: {
      count: duplicateCount,
      groups: duplicateGroups,
      topGroups: topGroups
    },
    naturalKeyCandidate: isNaturalKey,
    entropy: calculateEntropy(valueCounts, values.length)
  };
}

function shouldBeUnique(columnName) {
  const uniqueIndicators = [
    'id', 'code', 'number', 'key', 'email', 'username', 
    'account', 'reference', 'sku', 'isbn', 'ean', 'upc',
    'ssn', 'ein', 'abn', 'acn', 'phone', 'mobile'
  ];
  
  const columnLower = columnName.toLowerCase();
  return uniqueIndicators.some(indicator => columnLower.includes(indicator));
}

function findCompositeDuplicates(data, headers) {
  const compositeDuplicates = [];
  
  const candidateCombinations = generateCandidateCombinations(headers);
  
  candidateCombinations.forEach(combination => {
    const compositeKeys = {};
    
    data.forEach((row, index) => {
      const key = combination.fields
        .map(field => row[field])
        .filter(val => val !== null && val !== '')
        .join('|');
      
      if (!compositeKeys[key]) {
        compositeKeys[key] = [];
      }
      compositeKeys[key].push(index);
    });

    const duplicates = Object.entries(compositeKeys)
      .filter(([_, indices]) => indices.length > 1);

    if (duplicates.length > 0) {
      const totalDuplicates = duplicates.reduce((sum, [_, indices]) => 
        sum + indices.length - 1, 0);
      
      if (totalDuplicates > data.length * 0.01) {
        compositeDuplicates.push({
          fields: combination.fields,
          count: totalDuplicates,
          groups: duplicates.length,
          examples: duplicates.slice(0, 3).map(([key, indices]) => ({
            compositeKey: key,
            recordCount: indices.length,
            rows: indices.slice(0, 5).map(i => i + 1)
          }))
        });
      }
    }
  });

  return compositeDuplicates.sort((a, b) => b.count - a.count);
}

function generateCandidateCombinations(headers) {
  const combinations = [];
  
  const keyFields = headers
    .filter(h => {
      const lower = h.toLowerCase();
      return lower.includes('name') || lower.includes('email') || 
             lower.includes('phone') || lower.includes('address') ||
             lower.includes('id') || lower.includes('code');
    })
    .map(h => ({ header: h }));

  for (let i = 0; i < keyFields.length - 1; i++) {
    for (let j = i + 1; j < keyFields.length; j++) {
      combinations.push({
        fields: [keyFields[i].header, keyFields[j].header]
      });
    }
  }

  return combinations.slice(0, 10);
}

function analyseNearDuplicates(data, headers) {
  if (data.length > 5000) {
    return analyseSampledNearDuplicates(data, headers, 1000);
  }

  const textColumns = headers
    .filter(h => {
      const sample = data.slice(0, 100).map(row => row[h])
        .filter(v => v && typeof v === 'string');
      return sample.length > 50;
    })
    .map(h => ({ header: h }));

  if (textColumns.length === 0) return [];

  const nearDuplicateGroups = [];
  const processed = new Set();

  for (let i = 0; i < data.length - 1; i++) {
    if (processed.has(i)) continue;

    const group = {
      records: [i],
      similarity: 0,
      matchingFields: []
    };

    for (let j = i + 1; j < data.length; j++) {
      if (processed.has(j)) continue;

      const similarity = calculateRecordSimilarity(data[i], data[j], textColumns);
      
      if (similarity.score > 85) {
        group.records.push(j);
        group.similarity = Math.max(group.similarity, similarity.score);
        group.matchingFields = similarity.matchingFields;
        processed.add(j);
      }
    }

    if (group.records.length > 1) {
      processed.add(i);
      nearDuplicateGroups.push(group);
    }
  }

  return nearDuplicateGroups
    .sort((a, b) => b.records.length - a.records.length)
    .slice(0, 10);
}

function analyseSampledNearDuplicates(data, headers, sampleSize) {
  const sample = [];
  const step = Math.floor(data.length / sampleSize);
  
  for (let i = 0; i < data.length; i += step) {
    sample.push({ data: data[i], originalIndex: i });
  }

  const textColumns = headers
    .filter(h => {
      const testSample = sample.slice(0, 100).map(s => s.data[h])
        .filter(v => v && typeof v === 'string');
      return testSample.length > 50;
    })
    .map(h => ({ header: h }));

  if (textColumns.length === 0) return [];

  const nearDuplicateGroups = [];

  for (let i = 0; i < sample.length - 1; i++) {
    const group = {
      records: [sample[i].originalIndex],
      similarity: 0,
      matchingFields: []
    };

    for (let j = i + 1; j < sample.length; j++) {
      const similarity = calculateRecordSimilarity(
        sample[i].data, 
        sample[j].data, 
        textColumns
      );
      
      if (similarity.score > 90) {
        group.records.push(sample[j].originalIndex);
        group.similarity = Math.max(group.similarity, similarity.score);
        group.matchingFields = similarity.matchingFields;
      }
    }

    if (group.records.length > 1) {
      nearDuplicateGroups.push(group);
    }
  }

  return nearDuplicateGroups
    .sort((a, b) => b.records.length - a.records.length)
    .slice(0, 5);
}

function calculateRecordSimilarity(record1, record2, textColumns) {
  let totalScore = 0;
  let matchingFields = [];
  let comparedFields = 0;

  textColumns.forEach(col => {
    const val1 = String(record1[col.header] || '').toLowerCase().trim();
    const val2 = String(record2[col.header] || '').toLowerCase().trim();

    if (val1 && val2) {
      const similarity = calculateStringSimilarity(val1, val2);
      if (similarity > 80) {
        matchingFields.push({
          field: col.header,
          similarity: similarity
        });
      }
      totalScore += similarity;
      comparedFields++;
    }
  });

  return {
    score: comparedFields > 0 ? Math.round(totalScore / comparedFields) : 0,
    matchingFields: matchingFields
  };
}

function calculateStringSimilarity(str1, str2) {
  if (str1 === str2) return 100;
  
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) return 100;
  
  const editDistance = levenshteinDistance$1(longer, shorter);
  const similarity = ((longer.length - editDistance) / longer.length) * 100;
  
  return Math.round(similarity);
}

function levenshteinDistance$1(str1, str2) {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
}

function calculateEntropy(valueCounts, total) {
  let entropy = 0;
  
  Object.values(valueCounts).forEach(count => {
    const probability = count / total;
    if (probability > 0) {
      entropy -= probability * Math.log2(probability);
    }
  });
  
  return entropy;
}

function generateDuplicateFixSQL$1(columnName, duplicateGroups) {
  Object.entries(duplicateGroups)
    .filter(([_, indices]) => indices.length > 1)
    .slice(0, 3);

  let sql = `-- Remove duplicates from ${columnName}\n`;
  sql += `WITH duplicates AS (\n`;
  sql += `  SELECT ${columnName}, \n`;
  sql += `    ROW_NUMBER() OVER (PARTITION BY ${columnName} ORDER BY created_date) AS rn\n`;
  sql += `  FROM your_table\n`;
  sql += `)\n`;
  sql += `DELETE FROM your_table\n`;
  sql += `WHERE ${columnName} IN (\n`;
  sql += `  SELECT ${columnName} FROM duplicates WHERE rn > 1\n`;
  sql += `);\n\n`;
  sql += `-- Add unique constraint\n`;
  sql += `ALTER TABLE your_table ADD CONSTRAINT uk_${columnName} UNIQUE (${columnName});`;

  return sql;
}

function calculateOverallUniqueness(uniquenessAnalysis) {
  const scores = Object.values(uniquenessAnalysis)
    .filter(analysis => analysis.totalValues > 0)
    .map(analysis => analysis.uniquenessRatio * 100);

  if (scores.length === 0) return 100;
  return scores.reduce((a, b) => a + b, 0) / scores.length;
}

function countTotalDuplicates(uniquenessAnalysis) {
  return Object.values(uniquenessAnalysis)
    .reduce((sum, analysis) => sum + analysis.exactDuplicates.count, 0);
}

function detectBusinessRules(data, headers, columnTypes) {
  const rules = [];
  
  headers.forEach((header, colIndex) => {
    const columnData = data.map(row => row[colIndex]);
    const type = columnTypes[header];

    if (type === 'numeric') {
      const numericRules = detectNumericRules(columnData, header);
      rules.push(...numericRules);
    }

    const constraintRules = detectConstraintRules(columnData, header);
    rules.push(...constraintRules);

    const conditionalRules = detectConditionalRules(data, headers, colIndex);
    rules.push(...conditionalRules);
  });

  const derivedFieldRules = detectDerivedFieldRules(data, headers);
  rules.push(...derivedFieldRules);

  const relationshipRules = detectRelationshipRules(data, headers);
  rules.push(...relationshipRules);

  return rules.filter(rule => rule.confidence >= 95);
}

function detectNumericRules(values, fieldName, allData, allHeaders, colIndex) {
  const rules = [];
  const numericValues = values
    .filter(v => v !== null && v !== '')
    .map(v => parseFloat(v))
    .filter(v => !isNaN(v));

  if (numericValues.length === 0) return rules;

  const min = Math.min(...numericValues);
  const max = Math.max(...numericValues);
  numericValues.reduce((a, b) => a + b, 0) / numericValues.length;

  if (min >= 0 && max <= 150 && fieldName.toLowerCase().includes('age')) {
    const violations = numericValues.filter(v => v < 0 || v > 120);
    const confidence = ((numericValues.length - violations.length) / numericValues.length) * 100;
    
    if (confidence >= 95) {
      rules.push({
        type: 'RANGE_CONSTRAINT',
        field: fieldName,
        rule: `${fieldName} BETWEEN 0 AND 120`,
        confidence: confidence,
        violations: violations.length,
        examples: violations.slice(0, 3),
        sql: `CHECK (${fieldName} >= 0 AND ${fieldName} <= 120)`,
        description: 'Age must be between 0 and 120 years'
      });
    }
  }

  if (min >= 0 && fieldName.toLowerCase().match(/price|amount|cost|revenue|total/)) {
    const violations = numericValues.filter(v => v < 0);
    const confidence = ((numericValues.length - violations.length) / numericValues.length) * 100;
    
    if (confidence >= 95) {
      rules.push({
        type: 'NON_NEGATIVE_CONSTRAINT',
        field: fieldName,
        rule: `${fieldName} >= 0`,
        confidence: confidence,
        violations: violations.length,
        sql: `CHECK (${fieldName} >= 0)`,
        description: 'Monetary values must be non-negative'
      });
    }
  }

  const roundNumberPercentage = (numericValues.filter(v => v % 1 === 0).length / numericValues.length) * 100;
  if (roundNumberPercentage > 98 && !fieldName.toLowerCase().includes('decimal')) {
    rules.push({
      type: 'INTEGER_CONSTRAINT',
      field: fieldName,
      rule: `${fieldName} must be whole number`,
      confidence: roundNumberPercentage,
      violations: numericValues.filter(v => v % 1 !== 0).length,
      sql: `CHECK (${fieldName} = FLOOR(${fieldName}))`,
      description: 'Field contains only whole numbers'
    });
  }

  return rules;
}

function detectConstraintRules(values, fieldName) {
  const rules = [];
  const nonNullValues = values.filter(v => v !== null && v !== '');
  
  if (nonNullValues.length === 0) return rules;

  const uniqueValues = [...new Set(nonNullValues)];
  const uniquenessRatio = uniqueValues.length / nonNullValues.length;

  if (uniquenessRatio === 1 && fieldName.toLowerCase().match(/id|email|username|code|reference/)) {
    rules.push({
      type: 'UNIQUENESS_CONSTRAINT',
      field: fieldName,
      rule: `${fieldName} must be unique`,
      confidence: 100,
      violations: 0,
      sql: `UNIQUE (${fieldName})`,
      description: 'All values are currently unique'
    });
  }

  const lengthCounts = {};
  nonNullValues.forEach(value => {
    const length = String(value).length;
    lengthCounts[length] = (lengthCounts[length] || 0) + 1;
  });

  const dominantLength = Object.entries(lengthCounts)
    .sort((a, b) => b[1] - a[1])[0];
  
  if (dominantLength && dominantLength[1] / nonNullValues.length > 0.95) {
    const expectedLength = parseInt(dominantLength[0]);
    const violations = nonNullValues.filter(v => String(v).length !== expectedLength);
    
    rules.push({
      type: 'LENGTH_CONSTRAINT',
      field: fieldName,
      rule: `LENGTH(${fieldName}) = ${expectedLength}`,
      confidence: (dominantLength[1] / nonNullValues.length) * 100,
      violations: violations.length,
      examples: violations.slice(0, 3),
      sql: `CHECK (LENGTH(${fieldName}) = ${expectedLength})`,
      description: `Field has fixed length of ${expectedLength} characters`
    });
  }

  const patternMatches = detectPatternConstraint(nonNullValues, fieldName);
  if (patternMatches) {
    rules.push(patternMatches);
  }

  return rules;
}

function detectPatternConstraint(values, fieldName) {
  const patterns = [
    { 
      name: 'ALPHANUMERIC_UPPERCASE',
      regex: /^[A-Z0-9]+$/,
      sql: "CHECK ({field} ~ '^[A-Z0-9]+$')",
      description: 'Only uppercase letters and numbers'
    },
    { 
      name: 'NUMERIC_ONLY',
      regex: /^[0-9]+$/,
      sql: "CHECK ({field} ~ '^[0-9]+$')",
      description: 'Only numeric digits'
    },
    { 
      name: 'EMAIL_FORMAT',
      regex: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      sql: "CHECK ({field} ~ '^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$')",
      description: 'Valid email format'
    },
    { 
      name: 'CODE_PATTERN',
      regex: /^[A-Z]{2,3}-[0-9]{4,6}$/,
      sql: "CHECK ({field} ~ '^[A-Z]{2,3}-[0-9]{4,6}$')",
      description: 'Code pattern like ABC-12345'
    }
  ];

  for (const pattern of patterns) {
    const matches = values.filter(v => pattern.regex.test(String(v))).length;
    const confidence = (matches / values.length) * 100;
    
    if (confidence >= 95) {
      const violations = values.filter(v => !pattern.regex.test(String(v)));
      return {
        type: 'PATTERN_CONSTRAINT',
        field: fieldName,
        rule: `${fieldName} matches ${pattern.name}`,
        confidence: confidence,
        violations: violations.length,
        examples: violations.slice(0, 3),
        sql: pattern.sql.replace('{field}', fieldName),
        description: pattern.description
      };
    }
  }

  return null;
}

function detectConditionalRules(data, headers, targetColIndex) {
  const rules = [];
  const targetHeader = headers[targetColIndex];
  
  headers.forEach((conditionHeader, conditionIndex) => {
    if (conditionIndex === targetColIndex) return;
    
    const conditionalPatterns = analyseConditionalPatterns(
      data, 
      conditionIndex, 
      targetColIndex,
      conditionHeader,
      targetHeader
    );
    
    conditionalPatterns.forEach(pattern => {
      if (pattern.confidence >= 95) {
        rules.push(pattern);
      }
    });
  });

  return rules;
}

function analyseConditionalPatterns(data, conditionCol, targetCol, conditionHeader, targetHeader) {
  const patterns = [];
  const conditionalValues = {};
  
  data.forEach(row => {
    const condition = row[conditionCol];
    const target = row[targetCol];
    
    if (condition !== null && condition !== '' && target !== null && target !== '') {
      if (!conditionalValues[condition]) {
        conditionalValues[condition] = {};
      }
      const key = String(target);
      conditionalValues[condition][key] = (conditionalValues[condition][key] || 0) + 1;
    }
  });

  Object.entries(conditionalValues).forEach(([conditionValue, targetDistribution]) => {
    const totalCount = Object.values(targetDistribution).reduce((a, b) => a + b, 0);
    
    Object.entries(targetDistribution).forEach(([targetValue, count]) => {
      const percentage = (count / totalCount) * 100;
      
      if (percentage >= 95 && totalCount >= 10) {
        patterns.push({
          type: 'CONDITIONAL_CONSTRAINT',
          field: targetHeader,
          rule: `IF ${conditionHeader} = '${conditionValue}' THEN ${targetHeader} = '${targetValue}'`,
          confidence: percentage,
          violations: totalCount - count,
          occurrences: totalCount,
          sql: `CHECK (${conditionHeader} != '${conditionValue}' OR ${targetHeader} = '${targetValue}')`,
          description: `When ${conditionHeader} is '${conditionValue}', ${targetHeader} is always '${targetValue}'`
        });
      }
    });

    const uniqueTargets = Object.keys(targetDistribution).length;
    if (uniqueTargets === 1 && totalCount >= 5 && 
        conditionHeader.toLowerCase().includes('status') && 
        targetHeader.toLowerCase().includes('email')) {
      const targetValue = Object.keys(targetDistribution)[0];
      if (targetValue === '') {
        patterns.push({
          type: 'SOFT_DELETE_PATTERN',
          field: targetHeader,
          rule: `${targetHeader} is empty when ${conditionHeader} = '${conditionValue}'`,
          confidence: 100,
          violations: 0,
          occurrences: totalCount,
          sql: `UNIQUE (${targetHeader}) WHERE ${conditionHeader} != '${conditionValue}'`,
          description: 'Soft delete pattern detected - field cleared on status change'
        });
      }
    }
  });

  return patterns;
}

function detectDerivedFieldRules(data, headers, columnTypes) {
  const rules = [];
  
  headers.forEach((header, colIndex) => {
    if (!header.toLowerCase().match(/total|sum|calculated|derived/)) return;
    
    const potentialComponents = findPotentialComponents(header, headers);
    if (potentialComponents.length === 0) return;

    let bestMatch = null;
    let bestConfidence = 0;

    potentialComponents.forEach(components => {
      let matchCount = 0;
      let totalCount = 0;

      data.forEach(row => {
        const targetValue = parseFloat(row[colIndex]);
        if (isNaN(targetValue)) return;

        const sum = components.reduce((acc, compIndex) => {
          const val = parseFloat(row[compIndex]);
          return acc + (isNaN(val) ? 0 : val);
        }, 0);

        totalCount++;
        if (Math.abs(targetValue - sum) < 0.01) {
          matchCount++;
        }
      });

      const confidence = totalCount > 0 ? (matchCount / totalCount) * 100 : 0;
      if (confidence > bestConfidence) {
        bestConfidence = confidence;
        bestMatch = {
          components: components,
          matchCount: matchCount,
          totalCount: totalCount
        };
      }
    });

    if (bestMatch && bestConfidence >= 95) {
      const componentNames = bestMatch.components.map(idx => headers[idx]);
      const violations = bestMatch.totalCount - bestMatch.matchCount;
      
      rules.push({
        type: 'DERIVED_FIELD_RULE',
        field: header,
        rule: `${header} = SUM(${componentNames.join(', ')})`,
        confidence: bestConfidence,
        violations: violations,
        components: componentNames,
        sql: `CHECK (${header} = ${componentNames.join(' + ')})`,
        description: 'Calculated field should equal sum of components',
        discrepancies: analyseDiscrepancies(data, colIndex, bestMatch.components)
      });
    }
  });

  return rules;
}

function findPotentialComponents(targetField, headers) {
  const candidates = [];
  const baseName = targetField.toLowerCase()
    .replace('total', '')
    .replace('sum', '')
    .replace('calculated', '')
    .trim();

  const relatedIndices = headers
    .map((h, i) => ({ header: h, index: i }))
    .filter(item => {
      const headerLower = item.header.toLowerCase();
      return item.header !== targetField &&
             !headerLower.includes('total') &&
             !headerLower.includes('sum') &&
             (headerLower.includes(baseName) || baseName.includes(headerLower));
    })
    .map(item => item.index);

  if (relatedIndices.length >= 2) {
    candidates.push(relatedIndices);
  }

  for (let i = 2; i <= Math.min(4, relatedIndices.length); i++) {
    const combinations = getCombinations(relatedIndices, i);
    candidates.push(...combinations);
  }

  return candidates;
}

function getCombinations(arr, size) {
  const result = [];
  
  function combine(start, combo) {
    if (combo.length === size) {
      result.push([...combo]);
      return;
    }
    
    for (let i = start; i < arr.length; i++) {
      combo.push(arr[i]);
      combine(i + 1, combo);
      combo.pop();
    }
  }
  
  combine(0, []);
  return result;
}

function analyseDiscrepancies(data, targetCol, componentCols) {
  const discrepancies = [];
  
  data.forEach((row, index) => {
    const target = parseFloat(row[targetCol]);
    const sum = componentCols.reduce((acc, col) => {
      const val = parseFloat(row[col]);
      return acc + (isNaN(val) ? 0 : val);
    }, 0);
    
    if (!isNaN(target) && Math.abs(target - sum) >= 0.01) {
      discrepancies.push({
        row: index + 1,
        expected: sum,
        actual: target,
        difference: target - sum
      });
    }
  });

  const analysis = {
    count: discrepancies.length,
    range: discrepancies.length > 0 ? {
      min: Math.min(...discrepancies.map(d => d.difference)),
      max: Math.max(...discrepancies.map(d => d.difference))
    } : null,
    examples: discrepancies.slice(0, 3)
  };

  return analysis;
}

function detectRelationshipRules(data, headers) {
  const rules = [];
  
  const idColumns = headers
    .map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().endsWith('_id') || 
                   col.header.toLowerCase().includes('_id_'));

  idColumns.forEach(idCol => {
    const entityName = idCol.header.toLowerCase()
      .replace('_id', '')
      .replace('id_', '');
    
    const values = data.map(row => row[idCol.index])
      .filter(v => v !== null && v !== '');
    
    const uniqueValues = [...new Set(values)];
    const cardinality = uniqueValues.length / values.length;

    if (cardinality < 0.5) {
      rules.push({
        type: 'FOREIGN_KEY_CONSTRAINT',
        field: idCol.header,
        rule: `${idCol.header} references ${entityName}(id)`,
        confidence: 99,
        violations: 0,
        cardinality: `Many-to-one (${uniqueValues.length} unique values)`,
        sql: `FOREIGN KEY (${idCol.header}) REFERENCES ${entityName}(id)`,
        description: `Foreign key relationship to ${entityName} table detected`
      });
    }
  });

  return rules;
}

function detectPatterns(data, headers, columnTypes) {
  const patterns = {
    hiddenPatterns: [],
    systemPatterns: [],
    employeePatterns: [],
    testDataPatterns: []
  };

  detectHiddenPatterns(data, headers, patterns);
  detectSystemAccounts(data, headers, patterns);
  detectEmployeePatterns(data, headers, patterns);
  detectTestDataPatterns(data, headers, patterns);

  return patterns;
}

function detectHiddenPatterns(data, headers, patterns) {
  const idColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('id'));

  idColumns.forEach(idCol => {
    const suffixPatterns = analyseSuffixPatterns(data, idCol.index, headers);
    
    suffixPatterns.forEach(pattern => {
      if (pattern.correlation > 0.9) {
        patterns.hiddenPatterns.push({
          type: 'ID_SUFFIX_PATTERN',
          field: idCol.header,
          pattern: pattern.suffix,
          correlation: pattern.correlation,
          affectedRecords: pattern.count,
          associatedBehavior: pattern.behavior,
          recommendation: pattern.recommendation
        });
      }
    });
  });

  const emailColumn = headers.findIndex(h => h.toLowerCase().includes('email'));
  if (emailColumn !== -1) {
    const domainPatterns = analyseDomainPatterns(data, emailColumn, headers);
    patterns.hiddenPatterns.push(...domainPatterns);
  }

  const discountPatterns = analyseDiscountPatterns(data, headers);
  patterns.hiddenPatterns.push(...discountPatterns);
}

function analyseSuffixPatterns(data, idColIndex, headers) {
  const suffixGroups = {
    '999': { records: [], metrics: {} },
    '000': { records: [], metrics: {} },
    '888': { records: [], metrics: {} },
    '777': { records: [], metrics: {} }
  };

  data.forEach((row, index) => {
    const id = String(row[idColIndex] || '');
    Object.keys(suffixGroups).forEach(suffix => {
      if (id.endsWith(suffix)) {
        suffixGroups[suffix].records.push({ row, index });
      }
    });
  });

  const patterns = [];
  
  Object.entries(suffixGroups).forEach(([suffix, group]) => {
    if (group.records.length === 0) return;

    headers.forEach((header, colIndex) => {
      if (colIndex === idColIndex) return;
      
      const values = group.records.map(r => r.row[colIndex]);
      const analysis = analyseValueDistribution(values, data.map(row => row[colIndex]));
      
      if (analysis.deviation > 2) {
        patterns.push({
          suffix: suffix,
          count: group.records.length,
          correlation: analysis.correlation,
          behavior: {
            field: header,
            deviation: analysis.deviation,
            average: analysis.average,
            populationAverage: analysis.populationAverage
          },
          recommendation: generateRecommendation(suffix, header, analysis)
        });
      }
    });
  });

  return patterns;
}

function analyseValueDistribution(groupValues, allValues) {
  const numericGroup = groupValues
    .filter(v => v !== null && !isNaN(parseFloat(v)))
    .map(v => parseFloat(v));
  
  const numericAll = allValues
    .filter(v => v !== null && !isNaN(parseFloat(v)))
    .map(v => parseFloat(v));

  if (numericGroup.length === 0 || numericAll.length === 0) {
    return { deviation: 0, correlation: 0 };
  }

  const groupAvg = numericGroup.reduce((a, b) => a + b, 0) / numericGroup.length;
  const allAvg = numericAll.reduce((a, b) => a + b, 0) / numericAll.length;
  const allStdDev = calculateStdDev(numericAll);

  const deviation = allStdDev > 0 ? Math.abs(groupAvg - allAvg) / allStdDev : 0;
  const correlation = deviation > 2 ? 0.95 : deviation / 2;

  return {
    deviation: deviation,
    correlation: correlation,
    average: groupAvg,
    populationAverage: allAvg,
    stdDev: allStdDev
  };
}

function calculateStdDev(values) {
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
  const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
  return Math.sqrt(variance);
}

function generateRecommendation(suffix, field, analysis) {
  const fieldLower = field.toLowerCase();
  
  if (suffix === '999' && fieldLower.includes('discount')) {
    return 'Add explicit employee flag - these appear to be employee accounts';
  } else if (suffix === '000' && analysis.average === 0) {
    return 'Add system account flag - these appear to be test/system accounts';
  } else if (fieldLower.includes('shipping') && analysis.average === 0) {
    return 'Consider flagging as special handling accounts';
  }
  
  return 'Investigate this pattern for business logic';
}

function analyseDomainPatterns(data, emailColIndex, headers) {
  const domainStats = {};
  
  data.forEach((row, index) => {
    const email = row[emailColIndex];
    if (!email || !email.includes('@')) return;
    
    const domain = email.split('@')[1].toLowerCase();
    if (!domainStats[domain]) {
      domainStats[domain] = {
        count: 0,
        records: [],
        metrics: {}
      };
    }
    
    domainStats[domain].count++;
    domainStats[domain].records.push({ row, index });
  });

  const patterns = [];
  const companyDomains = ['company.com', 'internal.com', 'test.com'];
  
  Object.entries(domainStats).forEach(([domain, stats]) => {
    if (stats.count < 5) return;
    
    const isCompanyDomain = companyDomains.some(cd => domain.includes(cd));
    
    headers.forEach((header, colIndex) => {
      if (colIndex === emailColIndex) return;
      
      const domainValues = stats.records.map(r => r.row[colIndex]);
      const allValues = data.map(row => row[colIndex]);
      const analysis = analyseValueDistribution(domainValues, allValues);
      
      if (analysis.deviation > 2 || (isCompanyDomain && analysis.deviation > 1)) {
        patterns.push({
          type: 'EMAIL_DOMAIN_PATTERN',
          domain: domain,
          recordCount: stats.count,
          behavior: {
            field: header,
            averageValue: analysis.average,
            populationAverage: analysis.populationAverage,
            deviation: analysis.deviation
          },
          interpretation: isCompanyDomain ? 'Internal/employee accounts' : 'Special customer segment',
          recommendation: `Add account type flag for ${domain} users`
        });
      }
    });
  });

  return patterns;
}

function analyseDiscountPatterns(data, headers) {
  const patterns = [];
  const discountColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('discount'));

  if (discountColumns.length === 0) return patterns;

  discountColumns.forEach(discountCol => {
    const discountGroups = {};
    
    data.forEach((row, index) => {
      const discount = parseFloat(row[discountCol.index]);
      if (isNaN(discount) || discount === 0) return;
      
      const discountLevel = Math.round(discount);
      if (!discountGroups[discountLevel]) {
        discountGroups[discountLevel] = [];
      }
      discountGroups[discountLevel].push({ row, index });
    });

    Object.entries(discountGroups).forEach(([level, records]) => {
      if (records.length < 5) return;
      
      const correlations = findDiscountCorrelations(records, data, headers);
      correlations.forEach(correlation => {
        patterns.push({
          type: 'DISCOUNT_CORRELATION',
          discountLevel: `${level}%`,
          recordCount: records.length,
          correlatedField: correlation.field,
          correlation: correlation.strength,
          pattern: correlation.pattern,
          recommendation: 'Document discount eligibility rules'
        });
      });
    });
  });

  return patterns;
}

function findDiscountCorrelations(discountRecords, allData, headers) {
  const correlations = [];
  
  headers.forEach((header, colIndex) => {
    const values = discountRecords.map(r => r.row[colIndex]);
    const uniqueValues = [...new Set(values)];
    
    if (uniqueValues.length === 1 && discountRecords.length > 5) {
      correlations.push({
        field: header,
        strength: 1.0,
        pattern: `Always "${uniqueValues[0]}" for this discount level`
      });
    } else if (uniqueValues.length < discountRecords.length * 0.2) {
      const dominant = getMostFrequent(values);
      const dominantPercentage = values.filter(v => v === dominant).length / values.length;
      
      if (dominantPercentage > 0.8) {
        correlations.push({
          field: header,
          strength: dominantPercentage,
          pattern: `Usually "${dominant}" (${(dominantPercentage * 100).toFixed(0)}%)`
        });
      }
    }
  });

  return correlations;
}

function detectSystemAccounts(data, headers, patterns) {
  const usernameColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('username') || 
                   col.header.toLowerCase().includes('user_name') ||
                   col.header.toLowerCase().includes('login'));

  if (usernameColumns.length === 0) return;

  usernameColumns.forEach(userCol => {
    const systemPatterns = [
      { regex: /^test\d{3}$/i, type: 'Test accounts (test001-test999)' },
      { regex: /^admin\d*$/i, type: 'Admin accounts' },
      { regex: /^system\d*$/i, type: 'System accounts' },
      { regex: /^demo\d*$/i, type: 'Demo accounts' },
      { regex: /^guest\d*$/i, type: 'Guest accounts' },
      { regex: /^bot_/i, type: 'Bot accounts' }
    ];

    systemPatterns.forEach(pattern => {
      const matches = data.filter((row, index) => {
        const username = row[userCol.index];
        return username && pattern.regex.test(username);
      });

      if (matches.length > 0) {
        const analysis = analyseSystemAccountBehavior(matches, data, headers, userCol.index);
        
        patterns.systemPatterns.push({
          type: 'SYSTEM_ACCOUNT_PATTERN',
          pattern: pattern.type,
          count: matches.length,
          field: userCol.header,
          behavior: analysis,
          recommendation: `Exclude ${pattern.type} from business analytics`,
          impact: 'May skew metrics if included in analysis'
        });
      }
    });
  });
}

function analyseSystemAccountBehavior(systemRecords, allData, headers, userColIndex) {
  const behavior = {
    zeroRevenue: 0,
    noActivity: 0,
    characteristics: []
  };

  const revenueColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('revenue') || 
                   col.header.toLowerCase().includes('amount') ||
                   col.header.toLowerCase().includes('total'));

  revenueColumns.forEach(revCol => {
    const zeroCount = systemRecords.filter(row => {
      const value = parseFloat(row[revCol.index]);
      return value === 0 || isNaN(value);
    }).length;

    if (zeroCount === systemRecords.length) {
      behavior.zeroRevenue++;
      behavior.characteristics.push(`${revCol.header}: always zero`);
    }
  });

  const activityColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('last_login') || 
                   col.header.toLowerCase().includes('last_active'));

  activityColumns.forEach(actCol => {
    const nullCount = systemRecords.filter(row => 
      !row[actCol.index] || row[actCol.index] === ''
    ).length;

    if (nullCount > systemRecords.length * 0.8) {
      behavior.noActivity++;
      behavior.characteristics.push(`${actCol.header}: mostly empty`);
    }
  });

  return behavior;
}

function detectEmployeePatterns(data, headers, patterns) {
  const indicators = [];

  const emailColumn = headers.findIndex(h => h.toLowerCase().includes('email'));
  if (emailColumn !== -1) {
    const employeeEmails = data.filter(row => {
      const email = row[emailColumn];
      return email && (
        email.endsWith('@company.com') ||
        email.endsWith('@internal.com') ||
        email.includes('+employee@')
      );
    });

    if (employeeEmails.length > 0) {
      const behavior = analyseEmployeeBehavior(employeeEmails, data, headers);
      indicators.push({
        indicator: 'Email domain pattern',
        count: employeeEmails.length,
        behavior: behavior
      });
    }
  }

  const discountColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('discount'));

  discountColumns.forEach(discCol => {
    const highDiscountThreshold = 30;
    const highDiscountRecords = data.filter(row => {
      const discount = parseFloat(row[discCol.index]);
      return !isNaN(discount) && discount >= highDiscountThreshold;
    });

    if (highDiscountRecords.length > 0) {
      const emailMatches = emailColumn !== -1 ? 
        highDiscountRecords.filter(row => {
          const email = row[emailColumn];
          return email && email.includes('@company.com');
        }).length : 0;

      if (emailMatches > highDiscountRecords.length * 0.5) {
        indicators.push({
          indicator: `High discount (>=${highDiscountThreshold}%)`,
          count: highDiscountRecords.length,
          correlation: 'Strongly correlated with company email domain'
        });
      }
    }
  });

  if (indicators.length > 0) {
    patterns.employeePatterns.push({
      type: 'EMPLOYEE_ACCOUNT_INDICATORS',
      indicators: indicators,
      recommendation: 'Add explicit employee flag to database',
      benefits: [
        'Accurate business metrics',
        'Employee purchase tracking',
        'Discount policy compliance'
      ]
    });
  }
}

function analyseEmployeeBehavior(employeeRecords, allData, headers, emailColIndex) {
  const behavior = {
    averageDiscount: null,
    freeShipping: null,
    orderFrequency: null
  };

  const discountCol = headers.findIndex(h => h.toLowerCase().includes('discount'));
  if (discountCol !== -1) {
    const discounts = employeeRecords
      .map(row => parseFloat(row[discountCol]))
      .filter(v => !isNaN(v));
    
    if (discounts.length > 0) {
      behavior.averageDiscount = discounts.reduce((a, b) => a + b, 0) / discounts.length;
    }
  }

  const shippingCol = headers.findIndex(h => h.toLowerCase().includes('shipping'));
  if (shippingCol !== -1) {
    const freeShippingCount = employeeRecords.filter(row => {
      const shipping = parseFloat(row[shippingCol]);
      return shipping === 0 || isNaN(shipping);
    }).length;
    
    behavior.freeShipping = (freeShippingCount / employeeRecords.length) * 100;
  }

  return behavior;
}

function detectTestDataPatterns(data, headers, patterns) {
  const suspiciousPatterns = [];

  const nameColumns = headers.map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('name') && 
                   !col.header.toLowerCase().includes('username'));

  nameColumns.forEach(nameCol => {
    const testNames = [
      'Test', 'Demo', 'Sample', 'Example', 'Dummy',
      'John Doe', 'Jane Doe', 'Mickey Mouse', 'Donald Duck',
      'AAAAA', 'XXXXX', 'asdf', 'qwerty'
    ];

    const testRecords = data.filter(row => {
      const name = row[nameCol.index];
      return name && testNames.some(testName => 
        name.toLowerCase().includes(testName.toLowerCase())
      );
    });

    if (testRecords.length > 0) {
      suspiciousPatterns.push({
        field: nameCol.header,
        count: testRecords.length,
        percentage: ((testRecords.length / data.length) * 100).toFixed(1),
        examples: [...new Set(testRecords.map(r => r[nameCol.index]))].slice(0, 5)
      });
    }
  });

  const sequentialPatterns = detectSequentialPatterns(data, headers);
  suspiciousPatterns.push(...sequentialPatterns);

  if (suspiciousPatterns.length > 0) {
    patterns.testDataPatterns.push({
      type: 'TEST_DATA_INDICATORS',
      patterns: suspiciousPatterns,
      totalSuspiciousRecords: [...new Set(suspiciousPatterns.flatMap(p => p.records || []))].length,
      recommendation: 'Review and clean test data from production',
      impact: 'Test data can skew analytics and reports'
    });
  }
}

function detectSequentialPatterns(data, headers) {
  const patterns = [];

  headers.forEach((header, colIndex) => {
    const values = data.map(row => row[colIndex]).filter(v => v !== null && v !== '');
    
    const sequentialGroups = findSequentialValues(values);
    
    sequentialGroups.forEach(group => {
      if (group.length >= 5) {
        patterns.push({
          field: header,
          type: 'Sequential values',
          count: group.length,
          sequence: `${group[0]} to ${group[group.length - 1]}`,
          interpretation: 'Likely auto-generated test data'
        });
      }
    });
  });

  return patterns;
}

function findSequentialValues(values) {
  const groups = [];
  const numericValues = values
    .map((v, i) => ({ value: v, index: i, numeric: parseFloat(v) }))
    .filter(v => !isNaN(v.numeric))
    .sort((a, b) => a.numeric - b.numeric);

  let currentGroup = [];
  
  for (let i = 0; i < numericValues.length - 1; i++) {
    if (currentGroup.length === 0) {
      currentGroup.push(numericValues[i].numeric);
    }
    
    if (numericValues[i + 1].numeric - numericValues[i].numeric === 1) {
      currentGroup.push(numericValues[i + 1].numeric);
    } else {
      if (currentGroup.length >= 5) {
        groups.push(currentGroup);
      }
      currentGroup = [];
    }
  }
  
  if (currentGroup.length >= 5) {
    groups.push(currentGroup);
  }

  return groups;
}

function getMostFrequent(arr) {
  const counts = {};
  let maxCount = 0;
  let mostFrequent = null;
  
  arr.forEach(val => {
    counts[val] = (counts[val] || 0) + 1;
    if (counts[val] > maxCount) {
      maxCount = counts[val];
      mostFrequent = val;
    }
  });
  
  return mostFrequent;
}

function detectAnomalies$2(data, headers, columnTypes) {
  const anomalies = {
    statistical: [],
    benfordLaw: [],
    roundNumberBias: [],
    timeSeriesAnomalies: [],
    fraudIndicators: []
  };

  headers.forEach((header, colIndex) => {
    const columnData = data.map(row => row[colIndex]);
    const type = columnTypes[header];

    if (type === 'numeric') {
      const numericData = columnData
        .filter(v => v !== null && v !== '')
        .map(v => parseFloat(v))
        .filter(v => !isNaN(v));

      if (numericData.length > 100) {
        const benfordResult = testBenfordsLaw(numericData, header);
        if (benfordResult) {
          anomalies.benfordLaw.push(benfordResult);
        }

        const roundNumberResult = detectRoundNumberBias(numericData, header);
        if (roundNumberResult) {
          anomalies.roundNumberBias.push(roundNumberResult);
        }

        const statisticalAnomalies = detectStatisticalAnomalies(numericData, header);
        anomalies.statistical.push(...statisticalAnomalies);
      }
    }

    if (type === 'date' || header.toLowerCase().includes('date')) {
      const timeSeriesAnomalies = detectTimeSeriesAnomalies(columnData, header);
      anomalies.timeSeriesAnomalies.push(...timeSeriesAnomalies);
    }
  });

  const fraudPatterns = detectFraudPatterns(data, headers, columnTypes);
  anomalies.fraudIndicators.push(...fraudPatterns);

  return anomalies;
}

function testBenfordsLaw(values, fieldName) {
  const applicableFields = [
    'revenue', 'amount', 'sales', 'transaction', 'price', 
    'payment', 'invoice', 'order', 'purchase', 'expense'
  ];
  
  const fieldLower = fieldName.toLowerCase();
  const isApplicable = applicableFields.some(field => fieldLower.includes(field));
  
  if (!isApplicable) return null;

  const positiveValues = values.filter(v => v > 0);
  if (positiveValues.length < 100) return null;

  const benfordExpected = [30.1, 17.6, 12.5, 9.7, 7.9, 6.7, 5.8, 5.1, 4.6];
  const firstDigitCounts = Array(9).fill(0);
  const observedDistribution = Array(9).fill(0);

  positiveValues.forEach(value => {
    const firstDigit = getFirstDigit(value);
    if (firstDigit >= 1 && firstDigit <= 9) {
      firstDigitCounts[firstDigit - 1]++;
    }
  });

  const total = firstDigitCounts.reduce((a, b) => a + b, 0);
  for (let i = 0; i < 9; i++) {
    observedDistribution[i] = (firstDigitCounts[i] / total) * 100;
  }

  const chiSquare = calculateChiSquare(firstDigitCounts, benfordExpected, total);
  const criticalValue = 21.666;
  const pValue = chiSquare > criticalValue ? '<0.01' : '>0.01';

  if (chiSquare > criticalValue) {
    return {
      type: 'BENFORD_LAW_VIOLATION',
      field: fieldName,
      test: "Benford's Law Test",
      chiSquare: chiSquare.toFixed(2),
      pValue: pValue,
      interpretation: 'Distribution significantly deviates from Benford\'s Law',
      possibleCauses: [
        'Data manipulation or fraud',
        'Artificial constraints on values',
        'Systematic rounding or estimation',
        'Data entry from limited sources'
      ],
      distribution: {
        expected: benfordExpected.map((v, i) => ({
          digit: i + 1,
          expected: `${v}%`,
          observed: `${observedDistribution[i].toFixed(1)}%`,
          deviation: `${(observedDistribution[i] - v).toFixed(1)}%`
        }))
      },
      recommendation: 'Investigate transactions with unusual first-digit patterns'
    };
  }

  return null;
}

function getFirstDigit(value) {
  const str = Math.abs(value).toString().replace(/[^0-9]/g, '');
  return parseInt(str[0]);
}

function calculateChiSquare(observed, expected, total) {
  let chiSquare = 0;
  
  for (let i = 0; i < observed.length; i++) {
    const expectedCount = (expected[i] / 100) * total;
    if (expectedCount > 0) {
      chiSquare += Math.pow(observed[i] - expectedCount, 2) / expectedCount;
    }
  }
  
  return chiSquare;
}

function detectRoundNumberBias(values, fieldName) {
  const roundingPatterns = {
    tens: values.filter(v => v % 10 === 0 && v !== 0).length,
    hundreds: values.filter(v => v % 100 === 0 && v !== 0).length,
    thousands: values.filter(v => v % 1000 === 0 && v !== 0).length,
    halfDollars: values.filter(v => {
      const cents = Math.round((v % 1) * 100);
      return cents === 50;
    }).length,
    wholeDollars: values.filter(v => v % 1 === 0).length
  };

  const total = values.length;
  const expectedRates = {
    tens: 0.10,
    hundreds: 0.01,
    thousands: 0.001,
    halfDollars: 0.01,
    wholeDollars: fieldName.toLowerCase().includes('price') ? 0.10 : 0.05
  };

  const biases = [];
  
  Object.entries(roundingPatterns).forEach(([pattern, count]) => {
    const observedRate = count / total;
    const expectedRate = expectedRates[pattern];
    const ratio = observedRate / expectedRate;
    
    if (ratio > 3 && count > 10) {
      biases.push({
        pattern: pattern,
        count: count,
        observedRate: `${(observedRate * 100).toFixed(1)}%`,
        expectedRate: `${(expectedRate * 100).toFixed(1)}%`,
        excessRatio: ratio.toFixed(1)
      });
    }
  });

  if (biases.length > 0) {
    return {
      type: 'ROUND_NUMBER_BIAS',
      field: fieldName,
      totalValues: total,
      biases: biases,
      interpretation: 'Excessive round numbers detected',
      possibleCauses: [
        'Manual data entry or estimation',
        'Psychological pricing strategies',
        'System-imposed rounding',
        'Negotiated or adjusted values'
      ],
      examples: findRoundNumberExamples(values),
      recommendation: 'Review data collection process for artificial rounding'
    };
  }

  return null;
}

function findRoundNumberExamples(values) {
  const examples = {
    hundreds: values.filter(v => v % 100 === 0 && v !== 0).slice(0, 5),
    thousands: values.filter(v => v % 1000 === 0 && v !== 0).slice(0, 5)
  };
  
  return examples;
}

function detectStatisticalAnomalies(values, fieldName) {
  const anomalies = [];
  
  const zScoreAnomalies = detectZScoreAnomalies(values, fieldName);
  if (zScoreAnomalies) {
    anomalies.push(zScoreAnomalies);
  }

  const clusteringAnomalies = detectValueClustering(values, fieldName);
  if (clusteringAnomalies) {
    anomalies.push(clusteringAnomalies);
  }

  const gapAnomalies = detectValueGaps(values, fieldName);
  if (gapAnomalies) {
    anomalies.push(gapAnomalies);
  }

  return anomalies;
}

function detectZScoreAnomalies(values, fieldName) {
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
  const stdDev = Math.sqrt(variance);

  const anomalies = values.map((value, index) => ({
    value: value,
    zScore: Math.abs((value - mean) / stdDev),
    index: index
  })).filter(item => item.zScore > 4);

  if (anomalies.length > 0) {
    return {
      type: 'EXTREME_OUTLIERS',
      field: fieldName,
      count: anomalies.length,
      threshold: '4 standard deviations',
      examples: anomalies.slice(0, 5).map(a => ({
        value: a.value,
        zScore: a.zScore.toFixed(2),
        deviation: `${((a.value - mean) / mean * 100).toFixed(1)}% from mean`
      })),
      statistics: {
        mean: mean.toFixed(2),
        stdDev: stdDev.toFixed(2),
        minAnomaly: Math.min(...anomalies.map(a => a.value)),
        maxAnomaly: Math.max(...anomalies.map(a => a.value))
      },
      interpretation: 'Extreme values detected that may indicate errors or special cases'
    };
  }

  return null;
}

function detectValueClustering(values, fieldName) {
  const sortedValues = [...values].sort((a, b) => a - b);
  const clusters = [];
  let currentCluster = [sortedValues[0]];
  
  const threshold = (sortedValues[sortedValues.length - 1] - sortedValues[0]) * 0.01;

  for (let i = 1; i < sortedValues.length; i++) {
    if (sortedValues[i] - sortedValues[i - 1] <= threshold) {
      currentCluster.push(sortedValues[i]);
    } else {
      if (currentCluster.length > values.length * 0.1) {
        clusters.push({
          size: currentCluster.length,
          range: {
            min: currentCluster[0],
            max: currentCluster[currentCluster.length - 1]
          },
          percentage: (currentCluster.length / values.length * 100).toFixed(1)
        });
      }
      currentCluster = [sortedValues[i]];
    }
  }

  if (currentCluster.length > values.length * 0.1) {
    clusters.push({
      size: currentCluster.length,
      range: {
        min: currentCluster[0],
        max: currentCluster[currentCluster.length - 1]
      },
      percentage: (currentCluster.length / values.length * 100).toFixed(1)
    });
  }

  if (clusters.length > 0 && clusters.some(c => parseFloat(c.percentage) > 30)) {
    return {
      type: 'VALUE_CLUSTERING',
      field: fieldName,
      clusters: clusters.filter(c => parseFloat(c.percentage) > 10),
      interpretation: 'Values are heavily clustered in specific ranges',
      possibleCauses: [
        'Pricing tiers or bands',
        'System constraints',
        'Categorical data encoded as numeric',
        'Limited input options'
      ]
    };
  }

  return null;
}

function detectValueGaps(values, fieldName) {
  const sortedValues = [...new Set(values)].sort((a, b) => a - b);
  const gaps = [];
  
  for (let i = 1; i < sortedValues.length; i++) {
    const gap = sortedValues[i] - sortedValues[i - 1];
    const avgGap = (sortedValues[sortedValues.length - 1] - sortedValues[0]) / sortedValues.length;
    
    if (gap > avgGap * 10) {
      gaps.push({
        from: sortedValues[i - 1],
        to: sortedValues[i],
        size: gap,
        ratio: (gap / avgGap).toFixed(1)
      });
    }
  }

  if (gaps.length > 0) {
    return {
      type: 'VALUE_GAPS',
      field: fieldName,
      gaps: gaps.slice(0, 5),
      interpretation: 'Significant gaps in value distribution',
      possibleCauses: [
        'Missing data ranges',
        'Business rule constraints',
        'Data collection limitations',
        'Filtered or excluded values'
      ]
    };
  }

  return null;
}

function detectTimeSeriesAnomalies(values, fieldName, allData, colIndex) {
  const anomalies = [];
  const dateValues = values
    .map((v, i) => ({ date: parseDate(v), index: i, original: v }))
    .filter(item => item.date !== null)
    .sort((a, b) => a.date - b.date);

  if (dateValues.length < 10) return anomalies;

  const intervals = [];
  for (let i = 1; i < dateValues.length; i++) {
    intervals.push(dateValues[i].date - dateValues[i - 1].date);
  }

  const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
  const largeGaps = intervals
    .map((interval, i) => ({ interval, index: i }))
    .filter(item => item.interval > avgInterval * 10);

  if (largeGaps.length > 0) {
    anomalies.push({
      type: 'TEMPORAL_GAPS',
      field: fieldName,
      gaps: largeGaps.slice(0, 5).map(gap => ({
        from: dateValues[gap.index].original,
        to: dateValues[gap.index + 1].original,
        days: Math.floor(gap.interval / (1000 * 60 * 60 * 24)),
        averageDays: Math.floor(avgInterval / (1000 * 60 * 60 * 24))
      })),
      interpretation: 'Unusual gaps in temporal data',
      possibleCauses: [
        'System downtime or maintenance',
        'Seasonal patterns',
        'Data collection issues',
        'Business closure periods'
      ]
    });
  }

  const velocityAnomaly = detectVelocityAnomalies(dateValues, fieldName);
  if (velocityAnomaly) {
    anomalies.push(velocityAnomaly);
  }

  return anomalies;
}

function detectVelocityAnomalies(dateValues, fieldName) {
  const hourlyBuckets = {};
  
  dateValues.forEach(item => {
    const hourKey = `${item.date.toISOString().split('T')[0]}-${item.date.getHours()}`;
    item.date.toISOString().split('T')[0];
    
    hourlyBuckets[hourKey] = (hourlyBuckets[hourKey] || 0) + 1;
  });

  const hourlyValues = Object.values(hourlyBuckets);
  
  if (hourlyValues.length > 24) {
    const hourlyMean = hourlyValues.reduce((a, b) => a + b, 0) / hourlyValues.length;
    const hourlyStdDev = Math.sqrt(
      hourlyValues.reduce((sum, val) => sum + Math.pow(val - hourlyMean, 2), 0) / hourlyValues.length
    );
    
    const spikes = Object.entries(hourlyBuckets)
      .filter(([_, count]) => count > hourlyMean + 3 * hourlyStdDev)
      .sort((a, b) => b[1] - a[1]);
    
    if (spikes.length > 0) {
      return {
        type: 'VELOCITY_SPIKES',
        field: fieldName,
        spikes: spikes.slice(0, 5).map(([time, count]) => ({
          time: time,
          count: count,
          deviation: `${((count - hourlyMean) / hourlyStdDev).toFixed(1)} std devs`
        })),
        average: hourlyMean.toFixed(1),
        interpretation: 'Unusual spikes in data creation velocity',
        possibleCauses: [
          'Batch processing or imports',
          'System testing or load testing',
          'Bot activity or automated processes',
          'Data migration events'
        ]
      };
    }
  }
  
  return null;
}

function detectFraudPatterns(data, headers, columnTypes) {
  const patterns = [];
  
  const duplicateTimestamps = detectDuplicateTimestamps(data, headers);
  if (duplicateTimestamps) {
    patterns.push(duplicateTimestamps);
  }

  const suspiciousSequences = detectSuspiciousSequences(data, headers, columnTypes);
  patterns.push(...suspiciousSequences);

  const velocityPatterns = detectAbnormalVelocity(data, headers);
  if (velocityPatterns) {
    patterns.push(velocityPatterns);
  }

  return patterns;
}

function detectDuplicateTimestamps(data, headers) {
  const timestampColumns = headers
    .map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('timestamp') || 
                   col.header.toLowerCase().includes('created_at') ||
                   col.header.toLowerCase().includes('datetime'));

  if (timestampColumns.length === 0) return null;

  const duplicates = [];
  
  timestampColumns.forEach(tsCol => {
    const timestampCounts = {};
    
    data.forEach((row, index) => {
      const timestamp = row[tsCol.index];
      if (timestamp) {
        if (!timestampCounts[timestamp]) {
          timestampCounts[timestamp] = [];
        }
        timestampCounts[timestamp].push(index);
      }
    });

    const duplicateGroups = Object.entries(timestampCounts)
      .filter(([_, indices]) => indices.length > 1)
      .sort((a, b) => b[1].length - a[1].length);

    if (duplicateGroups.length > 0) {
      duplicates.push({
        field: tsCol.header,
        groups: duplicateGroups.slice(0, 5).map(([timestamp, indices]) => ({
          timestamp: timestamp,
          count: indices.length,
          rows: indices.slice(0, 10).map(i => i + 1)
        }))
      });
    }
  });

  if (duplicates.length > 0) {
    return {
      type: 'DUPLICATE_TIMESTAMPS',
      duplicates: duplicates,
      interpretation: 'Multiple records with identical timestamps',
      possibleCauses: [
        'Batch processing without proper timestamps',
        'System clock issues',
        'Data import problems',
        'Potential fraud or manipulation'
      ],
      recommendation: 'Investigate records with duplicate timestamps for validity'
    };
  }

  return null;
}

function detectSuspiciousSequences(data, headers, columnTypes) {
  const patterns = [];
  
  headers.forEach((header, colIndex) => {
    if (columnTypes[header] !== 'numeric') return;
    
    const values = data
      .map((row, i) => ({ value: parseFloat(row[colIndex]), index: i }))
      .filter(item => !isNaN(item.value));
    
    for (let i = 0; i < values.length - 4; i++) {
      const sequence = values.slice(i, i + 5).map(item => item.value);
      
      if (isArithmeticSequence(sequence) || isGeometricSequence(sequence)) {
        patterns.push({
          type: 'SUSPICIOUS_SEQUENCE',
          field: header,
          startRow: values[i].index + 1,
          sequence: sequence,
          pattern: isArithmeticSequence(sequence) ? 'Arithmetic' : 'Geometric',
          interpretation: 'Artificial sequential pattern detected'
        });
      }
    }
  });

  return patterns.slice(0, 5);
}

function isArithmeticSequence(values) {
  if (values.length < 3) return false;
  const diff = values[1] - values[0];
  
  for (let i = 2; i < values.length; i++) {
    if (Math.abs((values[i] - values[i - 1]) - diff) > 0.01) {
      return false;
    }
  }
  
  return Math.abs(diff) > 0;
}

function isGeometricSequence(values) {
  if (values.length < 3 || values.some(v => v === 0)) return false;
  const ratio = values[1] / values[0];
  
  for (let i = 2; i < values.length; i++) {
    if (Math.abs((values[i] / values[i - 1]) - ratio) > 0.01) {
      return false;
    }
  }
  
  return Math.abs(ratio - 1) > 0.01;
}

function detectAbnormalVelocity(data, headers) {
  const userColumns = headers
    .map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('user') || 
                   col.header.toLowerCase().includes('customer') ||
                   col.header.toLowerCase().includes('account'));

  const dateColumns = headers
    .map((h, i) => ({ header: h, index: i }))
    .filter(col => col.header.toLowerCase().includes('date') || 
                   col.header.toLowerCase().includes('time'));

  if (userColumns.length === 0 || dateColumns.length === 0) return null;

  const userActivity = {};
  
  data.forEach(row => {
    const userId = row[userColumns[0].index];
    const date = parseDate(row[dateColumns[0].index]);
    
    if (userId && date) {
      if (!userActivity[userId]) {
        userActivity[userId] = [];
      }
      userActivity[userId].push(date);
    }
  });

  const suspiciousUsers = [];
  
  Object.entries(userActivity).forEach(([userId, dates]) => {
    if (dates.length < 5) return;
    
    dates.sort((a, b) => a - b);
    const intervals = [];
    
    for (let i = 1; i < dates.length; i++) {
      intervals.push(dates[i] - dates[i - 1]);
    }
    
    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
    const minInterval = Math.min(...intervals);
    
    if (minInterval < 1000 || avgInterval < 60000) {
      suspiciousUsers.push({
        userId: userId,
        activityCount: dates.length,
        minIntervalSeconds: minInterval / 1000,
        avgIntervalSeconds: avgInterval / 1000
      });
    }
  });

  if (suspiciousUsers.length > 0) {
    return {
      type: 'ABNORMAL_USER_VELOCITY',
      users: suspiciousUsers.slice(0, 10),
      interpretation: 'Users with impossibly fast activity patterns',
      possibleCauses: [
        'Bot or automated activity',
        'System testing accounts',
        'Data import with incorrect timestamps',
        'Potential fraud or abuse'
      ],
      recommendation: 'Review accounts with superhuman activity speeds'
    };
  }

  return null;
}

function parseDate(value) {
  if (!value) return null;
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
}

const FuzzySet = function(arr, useLevenshtein, gramSizeLower, gramSizeUpper) {
    var fuzzyset = {

    };

    // default options
    arr = arr || [];
    fuzzyset.gramSizeLower = 2;
    fuzzyset.gramSizeUpper = 3;
    fuzzyset.useLevenshtein = true ;

    // define all the object functions and attributes
    fuzzyset.exactSet = {};
    fuzzyset.matchDict = {};
    fuzzyset.items = {};

    // helper functions
    var levenshtein = function(str1, str2) {
        var current = [], prev, value;

        for (var i = 0; i <= str2.length; i++)
            for (var j = 0; j <= str1.length; j++) {
            if (i && j)
                if (str1.charAt(j - 1) === str2.charAt(i - 1))
                value = prev;
                else
                value = Math.min(current[j], current[j - 1], prev) + 1;
            else
                value = i + j;

            prev = current[j];
            current[j] = value;
            }

        return current.pop();
    };

    // return an edit distance from 0 to 1
    var _distance = function(str1, str2) {
        if (str1 === null && str2 === null) throw 'Trying to compare two null values';
        if (str1 === null || str2 === null) return 0;
        str1 = String(str1); str2 = String(str2);

        var distance = levenshtein(str1, str2);
        if (str1.length > str2.length) {
            return 1 - distance / str1.length;
        } else {
            return 1 - distance / str2.length;
        }
    };

    // u00C0-u00FF is latin characters
    // u0621-u064a is arabic letters
    // u0660-u0669 is arabic numerals
    // TODO: figure out way to do this for more languages
    var _nonWordRe = /[^a-zA-Z0-9\u00C0-\u00FF\u0621-\u064A\u0660-\u0669, ]+/g;

    var _iterateGrams = function(value, gramSize) {
        gramSize = gramSize || 2;
        var simplified = '-' + value.toLowerCase().replace(_nonWordRe, '') + '-',
            lenDiff = gramSize - simplified.length,
            results = [];
        if (lenDiff > 0) {
            for (var i = 0; i < lenDiff; ++i) {
                simplified += '-';
            }
        }
        for (var i = 0; i < simplified.length - gramSize + 1; ++i) {
            results.push(simplified.slice(i, i + gramSize));
        }
        return results;
    };

    var _gramCounter = function(value, gramSize) {
        // return an object where key=gram, value=number of occurrences
        gramSize = gramSize || 2;
        var result = {},
            grams = _iterateGrams(value, gramSize),
            i = 0;
        for (i; i < grams.length; ++i) {
            if (grams[i] in result) {
                result[grams[i]] += 1;
            } else {
                result[grams[i]] = 1;
            }
        }
        return result;
    };

    // the main functions
    fuzzyset.get = function(value, defaultValue, minMatchScore) {
        // check for value in set, returning defaultValue or null if none found
        if (minMatchScore === undefined) {
            minMatchScore = .33;
        }
        var result = this._get(value, minMatchScore);
        if (!result && typeof defaultValue !== 'undefined') {
            return defaultValue;
        }
        return result;
    };

    fuzzyset._get = function(value, minMatchScore) {
        var results = [];
        // start with high gram size and if there are no results, go to lower gram sizes
        for (var gramSize = this.gramSizeUpper; gramSize >= this.gramSizeLower; --gramSize) {
            results = this.__get(value, gramSize, minMatchScore);
            if (results && results.length > 0) {
                return results;
            }
        }
        return null;
    };

    fuzzyset.__get = function(value, gramSize, minMatchScore) {
        var normalizedValue = this._normalizeStr(value),
            matches = {},
            gramCounts = _gramCounter(normalizedValue, gramSize),
            items = this.items[gramSize],
            sumOfSquareGramCounts = 0,
            gram,
            gramCount,
            i,
            index,
            otherGramCount;

        for (gram in gramCounts) {
            gramCount = gramCounts[gram];
            sumOfSquareGramCounts += Math.pow(gramCount, 2);
            if (gram in this.matchDict) {
                for (i = 0; i < this.matchDict[gram].length; ++i) {
                    index = this.matchDict[gram][i][0];
                    otherGramCount = this.matchDict[gram][i][1];
                    if (index in matches) {
                        matches[index] += gramCount * otherGramCount;
                    } else {
                        matches[index] = gramCount * otherGramCount;
                    }
                }
            }
        }

        function isEmptyObject(obj) {
            for(var prop in obj) {
                if(obj.hasOwnProperty(prop))
                    return false;
            }
            return true;
        }

        if (isEmptyObject(matches)) {
            return null;
        }

        var vectorNormal = Math.sqrt(sumOfSquareGramCounts),
            results = [],
            matchScore;
        // build a results list of [score, str]
        for (var matchIndex in matches) {
            matchScore = matches[matchIndex];
            results.push([matchScore / (vectorNormal * items[matchIndex][0]), items[matchIndex][1]]);
        }
        var sortDescending = function(a, b) {
            if (a[0] < b[0]) {
                return 1;
            } else if (a[0] > b[0]) {
                return -1;
            } else {
                return 0;
            }
        };
        results.sort(sortDescending);
        if (this.useLevenshtein) {
            var newResults = [],
                endIndex = Math.min(50, results.length);
            // truncate somewhat arbitrarily to 50
            for (var i = 0; i < endIndex; ++i) {
                newResults.push([_distance(results[i][1], normalizedValue), results[i][1]]);
            }
            results = newResults;
            results.sort(sortDescending);
        }
        newResults = [];
        results.forEach(function(scoreWordPair) {
            if (scoreWordPair[0] >= minMatchScore) {
                newResults.push([scoreWordPair[0], this.exactSet[scoreWordPair[1]]]);
            }
        }.bind(this));
        return newResults;
    };

    fuzzyset.add = function(value) {
        var normalizedValue = this._normalizeStr(value);
        if (normalizedValue in this.exactSet) {
            return false;
        }

        var i = this.gramSizeLower;
        for (i; i < this.gramSizeUpper + 1; ++i) {
            this._add(value, i);
        }
    };

    fuzzyset._add = function(value, gramSize) {
        var normalizedValue = this._normalizeStr(value),
            items = this.items[gramSize] || [],
            index = items.length;

        items.push(0);
        var gramCounts = _gramCounter(normalizedValue, gramSize),
            sumOfSquareGramCounts = 0,
            gram, gramCount;
        for (gram in gramCounts) {
            gramCount = gramCounts[gram];
            sumOfSquareGramCounts += Math.pow(gramCount, 2);
            if (gram in this.matchDict) {
                this.matchDict[gram].push([index, gramCount]);
            } else {
                this.matchDict[gram] = [[index, gramCount]];
            }
        }
        var vectorNormal = Math.sqrt(sumOfSquareGramCounts);
        items[index] = [vectorNormal, normalizedValue];
        this.items[gramSize] = items;
        this.exactSet[normalizedValue] = value;
    };

    fuzzyset._normalizeStr = function(str) {
        if (Object.prototype.toString.call(str) !== '[object String]') throw 'Must use a string as argument to FuzzySet functions';
        return str.toLowerCase();
    };

    // return length of items in set
    fuzzyset.length = function() {
        var count = 0,
            prop;
        for (prop in this.exactSet) {
            if (this.exactSet.hasOwnProperty(prop)) {
                count += 1;
            }
        }
        return count;
    };

    // return is set is empty
    fuzzyset.isEmpty = function() {
        for (var prop in this.exactSet) {
            if (this.exactSet.hasOwnProperty(prop)) {
                return false;
            }
        }
        return true;
    };

    // return list of values loaded into set
    fuzzyset.values = function() {
        var values = [],
            prop;
        for (prop in this.exactSet) {
            if (this.exactSet.hasOwnProperty(prop)) {
                values.push(this.exactSet[prop]);
            }
        }
        return values;
    };


    // initialization
    var i = fuzzyset.gramSizeLower;
    for (i; i < fuzzyset.gramSizeUpper + 1; ++i) {
        fuzzyset.items[i] = [];
    }
    // add all the items to the set
    for (i = 0; i < arr.length; ++i) {
        fuzzyset.add(arr[i]);
    }

    return fuzzyset;
};

function analyseFuzzyDuplicates(data, headers) {
  const results = {
    nearDuplicateGroups: [],
    totalNearDuplicates: 0,
    algorithms: ['Levenshtein', 'Jaro-Winkler', 'Soundex', 'Token Sorting'],
    processingStrategy: data.length > 1000 ? 'sampled' : 'full'
  };

  const keyColumns = identifyKeyColumns$1(headers);
  if (keyColumns.length === 0) {
    results.message = 'No suitable columns found for fuzzy matching';
    return results;
  }

  const groups = data.length > 1000 
    ? findNearDuplicatesSampled(data, keyColumns, 1000)
    : findNearDuplicatesFull(data, keyColumns);

  results.nearDuplicateGroups = groups;
  results.totalNearDuplicates = groups.reduce((sum, group) => sum + group.records.length - 1, 0);

  return results;
}

function identifyKeyColumns$1(headers) {
  const priorityColumns = ['name', 'company', 'address', 'email', 'title', 'description'];
  const keyColumns = [];

  headers.forEach((header, index) => {
    const headerLower = header.toLowerCase();
    if (priorityColumns.some(col => headerLower.includes(col))) {
      keyColumns.push({ header, index, priority: 1 });
    } else if (headerLower.includes('id') || headerLower.includes('code')) {
      keyColumns.push({ header, index, priority: 2 });
    }
  });

  return keyColumns.sort((a, b) => a.priority - b.priority).slice(0, 5);
}

function findNearDuplicatesFull(data, keyColumns) {
  const groups = [];
  const processed = new Set();
  const fuzzyIndices = buildFuzzyIndices(data, keyColumns);

  for (let i = 0; i < data.length; i++) {
    if (processed.has(i)) continue;

    const matches = findSimilarRecords(data[i], i, data, keyColumns, fuzzyIndices, processed);
    
    if (matches.length > 0) {
      processed.add(i);
      matches.forEach(m => processed.add(m.index));
      
      groups.push({
        id: `group_${groups.length + 1}`,
        similarity: Math.max(...matches.map(m => m.similarity)),
        recordCount: matches.length + 1,
        records: [
          { index: i, data: extractKeyData(data[i], keyColumns) },
          ...matches.map(m => ({ 
            index: m.index, 
            data: extractKeyData(data[m.index], keyColumns) 
          }))
        ],
        algorithms: matches[0].algorithms,
        matchDetails: analyseMatchDetails(data[i], matches[0].record, keyColumns)
      });
    }
  }

  return groups.sort((a, b) => b.recordCount - a.recordCount).slice(0, 100);
}

function findNearDuplicatesSampled(data, keyColumns, sampleSize) {
  const sample = [];
  const step = Math.max(1, Math.floor(data.length / sampleSize));
  
  for (let i = 0; i < data.length; i += step) {
    sample.push({ index: i, data: data[i] });
  }

  const groups = [];
  const fuzzyIndices = buildFuzzyIndices(sample.map(s => s.data), keyColumns);

  for (let i = 0; i < sample.length; i++) {
    const matches = findSimilarRecordsInSample(
      sample[i], 
      i, 
      sample, 
      keyColumns, 
      fuzzyIndices
    );
    
    if (matches.length > 0) {
      groups.push({
        id: `group_${groups.length + 1}`,
        similarity: Math.max(...matches.map(m => m.similarity)),
        recordCount: matches.length + 1,
        records: [
          { 
            index: sample[i].index, 
            data: extractKeyData(sample[i].data, keyColumns) 
          },
          ...matches.map(m => ({ 
            index: sample[m.index].index, 
            data: extractKeyData(sample[m.index].data, keyColumns) 
          }))
        ],
        algorithms: matches[0].algorithms,
        matchDetails: analyseMatchDetails(
          sample[i].data, 
          sample[matches[0].index].data, 
          keyColumns
        )
      });
    }
  }

  return groups.sort((a, b) => b.similarity - a.similarity).slice(0, 50);
}

function buildFuzzyIndices(data, keyColumns) {
  const indices = {};
  
  keyColumns.forEach(col => {
    const values = data.map(row => String(row[col.index] || '').toLowerCase().trim());
    const uniqueValues = [...new Set(values.filter(v => v.length > 2))];
    
    if (uniqueValues.length > 0 && uniqueValues.length < data.length * 0.9) {
      indices[col.header] = FuzzySet(uniqueValues);
    }
  });

  return indices;
}

function findSimilarRecords(record, recordIndex, allData, keyColumns, fuzzyIndices, processed) {
  const matches = [];
  generateRecordKey(record, keyColumns);
  
  for (let i = recordIndex + 1; i < allData.length; i++) {
    if (processed.has(i)) continue;
    
    const similarity = calculateSimilarity(record, allData[i], keyColumns, fuzzyIndices);
    
    if (similarity.score > 85) {
      matches.push({
        index: i,
        record: allData[i],
        similarity: similarity.score,
        algorithms: similarity.algorithms
      });
    }
  }

  return matches.sort((a, b) => b.similarity - a.similarity);
}

function findSimilarRecordsInSample(sampleItem, itemIndex, sample, keyColumns, fuzzyIndices) {
  const matches = [];
  
  for (let i = itemIndex + 1; i < sample.length; i++) {
    const similarity = calculateSimilarity(
      sampleItem.data, 
      sample[i].data, 
      keyColumns, 
      fuzzyIndices
    );
    
    if (similarity.score > 90) {
      matches.push({
        index: i,
        similarity: similarity.score,
        algorithms: similarity.algorithms
      });
    }
  }

  return matches;
}

function calculateSimilarity(record1, record2, keyColumns, fuzzyIndices) {
  const scores = [];
  const algorithms = [];

  keyColumns.forEach(col => {
    const val1 = String(record1[col.index] || '').trim();
    const val2 = String(record2[col.index] || '').trim();
    
    if (!val1 || !val2) return;

    const levenshteinScore = calculateLevenshteinSimilarity(val1, val2);
    if (levenshteinScore > 70) {
      scores.push({ score: levenshteinScore, weight: 1.0 });
      algorithms.push('Levenshtein');
    }

    const jaroWinklerScore = calculateJaroWinklerSimilarity(val1, val2);
    if (jaroWinklerScore > 80) {
      scores.push({ score: jaroWinklerScore, weight: 1.2 });
      algorithms.push('Jaro-Winkler');
    }

    if (col.header.toLowerCase().includes('name')) {
      const soundexScore = calculateSoundexSimilarity(val1, val2);
      if (soundexScore > 0) {
        scores.push({ score: soundexScore, weight: 0.8 });
        algorithms.push('Soundex');
      }
    }

    const tokenScore = calculateTokenSortSimilarity(val1, val2);
    if (tokenScore > 85) {
      scores.push({ score: tokenScore, weight: 1.0 });
      algorithms.push('Token Sort');
    }

    if (fuzzyIndices[col.header]) {
      const fuzzyResults = fuzzyIndices[col.header].get(val1.toLowerCase());
      if (fuzzyResults && fuzzyResults.length > 0) {
        const fuzzyMatch = fuzzyResults.find(r => r[1] === val2.toLowerCase());
        if (fuzzyMatch && fuzzyMatch[0] > 0.8) {
          scores.push({ score: fuzzyMatch[0] * 100, weight: 1.1 });
          algorithms.push('FuzzySet');
        }
      }
    }
  });

  if (scores.length === 0) return { score: 0, algorithms: [] };

  const totalWeight = scores.reduce((sum, s) => sum + s.weight, 0);
  const weightedScore = scores.reduce((sum, s) => sum + s.score * s.weight, 0) / totalWeight;

  return {
    score: Math.round(weightedScore),
    algorithms: [...new Set(algorithms)]
  };
}

function calculateLevenshteinSimilarity(str1, str2) {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) return 100;
  
  const editDistance = levenshteinDistance(longer.toLowerCase(), shorter.toLowerCase());
  return Math.round(((longer.length - editDistance) / longer.length) * 100);
}

function levenshteinDistance(str1, str2) {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
}

function calculateJaroWinklerSimilarity(str1, str2) {
  const s1 = str1.toLowerCase();
  const s2 = str2.toLowerCase();
  
  if (s1 === s2) return 100;
  
  const len1 = s1.length;
  const len2 = s2.length;
  
  const maxDist = Math.floor(Math.max(len1, len2) / 2) - 1;
  let matches = 0;
  let transpositions = 0;
  
  const s1Matches = new Array(len1).fill(false);
  const s2Matches = new Array(len2).fill(false);
  
  for (let i = 0; i < len1; i++) {
    const start = Math.max(0, i - maxDist);
    const end = Math.min(i + maxDist + 1, len2);
    
    for (let j = start; j < end; j++) {
      if (s2Matches[j] || s1[i] !== s2[j]) continue;
      s1Matches[i] = true;
      s2Matches[j] = true;
      matches++;
      break;
    }
  }
  
  if (matches === 0) return 0;
  
  let k = 0;
  for (let i = 0; i < len1; i++) {
    if (!s1Matches[i]) continue;
    while (!s2Matches[k]) k++;
    if (s1[i] !== s2[k]) transpositions++;
    k++;
  }
  
  const jaro = (matches / len1 + matches / len2 + (matches - transpositions / 2) / matches) / 3;
  
  let prefixLen = 0;
  for (let i = 0; i < Math.min(len1, len2, 4); i++) {
    if (s1[i] === s2[i]) prefixLen++;
    else break;
  }
  
  const jaroWinkler = jaro + prefixLen * 0.1 * (1 - jaro);
  return Math.round(jaroWinkler * 100);
}

function calculateSoundexSimilarity(str1, str2) {
  const soundex1 = soundex(str1);
  const soundex2 = soundex(str2);
  return soundex1 === soundex2 ? 90 : 0;
}

function soundex(str) {
  const s = str.toUpperCase().replace(/[^A-Z]/g, '');
  if (!s) return '';
  
  const firstLetter = s[0];
  const encoded = s.substring(1)
    .replace(/[AEIOUYHW]/g, '0')
    .replace(/[BFPV]/g, '1')
    .replace(/[CGJKQSXZ]/g, '2')
    .replace(/[DT]/g, '3')
    .replace(/[L]/g, '4')
    .replace(/[MN]/g, '5')
    .replace(/[R]/g, '6');
  
  const cleaned = firstLetter + encoded
    .split('')
    .filter((digit, index, arr) => digit !== '0' && digit !== arr[index - 1])
    .join('');
  
  return (cleaned + '000').substring(0, 4);
}

function calculateTokenSortSimilarity(str1, str2) {
  const tokens1 = str1.toLowerCase().split(/\s+/).sort();
  const tokens2 = str2.toLowerCase().split(/\s+/).sort();
  
  const sorted1 = tokens1.join(' ');
  const sorted2 = tokens2.join(' ');
  
  return calculateLevenshteinSimilarity(sorted1, sorted2);
}

function generateRecordKey(record, keyColumns) {
  return keyColumns
    .map(col => String(record[col.index] || '').toLowerCase().trim())
    .filter(v => v.length > 0)
    .join('|');
}

function extractKeyData(record, keyColumns) {
  const data = {};
  keyColumns.forEach(col => {
    data[col.header] = record[col.index];
  });
  return data;
}

function analyseMatchDetails(record1, record2, keyColumns) {
  const details = {
    matchingFields: [],
    differences: [],
    overallPattern: ''
  };

  keyColumns.forEach(col => {
    const val1 = String(record1[col.index] || '').trim();
    const val2 = String(record2[col.index] || '').trim();
    
    if (!val1 || !val2) return;

    const similarity = calculateLevenshteinSimilarity(val1, val2);
    
    if (similarity === 100) {
      details.matchingFields.push({
        field: col.header,
        similarity: '100%',
        type: 'Exact match'
      });
    } else if (similarity > 90) {
      details.matchingFields.push({
        field: col.header,
        similarity: `${similarity}%`,
        type: detectDifferenceType(val1, val2)
      });
    } else {
      details.differences.push({
        field: col.header,
        value1: val1,
        value2: val2,
        similarity: `${similarity}%`
      });
    }
  });

  if (details.matchingFields.length === keyColumns.length) {
    details.overallPattern = 'Near-exact duplicate';
  } else if (details.matchingFields.length > keyColumns.length * 0.6) {
    details.overallPattern = 'Likely same entity with variations';
  } else {
    details.overallPattern = 'Possible match requiring verification';
  }

  return details;
}

function detectDifferenceType(str1, str2) {
  const s1 = str1.toLowerCase();
  const s2 = str2.toLowerCase();
  
  if (Math.abs(s1.length - s2.length) <= 2) {
    const charDiff = levenshteinDistance(s1, s2);
    if (charDiff === 1) return 'Single character difference (typo)';
    if (charDiff === 2) return 'Minor spelling variation';
  }
  
  if (s1.replace(/[^a-z0-9]/g, '') === s2.replace(/[^a-z0-9]/g, '')) {
    return 'Punctuation/spacing difference';
  }
  
  if (s1.includes(s2) || s2.includes(s1)) {
    return 'Abbreviation or truncation';
  }
  
  const tokens1 = s1.split(/\s+/).sort();
  const tokens2 = s2.split(/\s+/).sort();
  if (tokens1.join('') === tokens2.join('')) {
    return 'Word order variation';
  }
  
  return 'General variation';
}

function validateAustralianData(data, headers) {
  const results = {
    detected: false,
    validations: {
      abn: null,
      acn: null,
      postcodes: null,
      phoneNumbers: null,
      addresses: null,
      states: null
    }
  };

  const auIndicators = detectAustralianData(data, headers);
  if (!auIndicators.detected) {
    return results;
  }

  results.detected = true;

  if (auIndicators.abnColumn !== null) {
    results.validations.abn = validateABN(data, auIndicators.abnColumn);
  }

  if (auIndicators.acnColumn !== null) {
    results.validations.acn = validateACN(data, auIndicators.acnColumn);
  }

  if (auIndicators.postcodeColumn !== null) {
    results.validations.postcodes = validatePostcodes(
      data, 
      auIndicators.postcodeColumn,
      auIndicators.stateColumn
    );
  }

  if (auIndicators.phoneColumns.length > 0) {
    results.validations.phoneNumbers = validatePhoneNumbers(data, auIndicators.phoneColumns);
  }

  if (auIndicators.addressColumns.length > 0) {
    results.validations.addresses = validateAddresses(data, auIndicators.addressColumns);
  }

  if (auIndicators.stateColumn !== null) {
    results.validations.states = validateStates(data, auIndicators.stateColumn);
  }

  return results;
}

function detectAustralianData(data, headers) {
  const indicators = {
    detected: false,
    abnColumn: null,
    acnColumn: null,
    postcodeColumn: null,
    stateColumn: null,
    phoneColumns: [],
    addressColumns: []
  };

  headers.forEach((header, index) => {
    const headerLower = header.toLowerCase();
    
    if (headerLower.includes('abn')) {
      indicators.abnColumn = index;
      indicators.detected = true;
    } else if (headerLower.includes('acn')) {
      indicators.acnColumn = index;
      indicators.detected = true;
    } else if (headerLower.includes('postcode') || headerLower === 'pc') {
      indicators.postcodeColumn = index;
      indicators.detected = true;
    } else if (headerLower.includes('state') || headerLower === 'state_code') {
      indicators.stateColumn = index;
      indicators.detected = true;
    } else if (headerLower.includes('phone') || headerLower.includes('mobile') || 
               headerLower.includes('contact')) {
      indicators.phoneColumns.push({ header, index });
    } else if (headerLower.includes('address') || headerLower.includes('street') ||
               headerLower.includes('suburb')) {
      indicators.addressColumns.push({ header, index });
    }
  });

  if (!indicators.detected && indicators.postcodeColumn === null) {
    const sample = data.slice(0, 100);
    headers.forEach((header, index) => {
      const values = sample.map(row => String(row[index] || ''));
      const auPostcodePattern = values.filter(v => /^[0-8]\d{3}$/.test(v)).length;
      if (auPostcodePattern > sample.length * 0.5) {
        indicators.postcodeColumn = index;
        indicators.detected = true;
      }
    });
  }

  if (!indicators.detected && indicators.stateColumn === null) {
    const auStates = ['NSW', 'VIC', 'QLD', 'SA', 'WA', 'TAS', 'NT', 'ACT'];
    headers.forEach((header, index) => {
      const values = data.slice(0, 100).map(row => String(row[index] || '').toUpperCase());
      const stateMatches = values.filter(v => auStates.includes(v)).length;
      if (stateMatches > values.length * 0.3) {
        indicators.stateColumn = index;
        indicators.detected = true;
      }
    });
  }

  return indicators;
}

function validateABN(data, abnColumn) {
  const validation = {
    total: 0,
    valid: 0,
    invalid: [],
    defunct: [],
    formatIssues: []
  };

  data.forEach((row, index) => {
    const abn = String(row[abnColumn] || '').replace(/\s/g, '');
    if (!abn) return;

    validation.total++;

    if (!/^\d{11}$/.test(abn)) {
      validation.formatIssues.push({
        row: index + 1,
        value: row[abnColumn],
        issue: 'Invalid format (must be 11 digits)'
      });
    } else if (isValidABN(abn)) {
      validation.valid++;
      
      if (isDefunctABN(abn)) {
        validation.defunct.push({
          row: index + 1,
          abn: abn,
          status: 'Defunct/cancelled'
        });
      }
    } else {
      validation.invalid.push({
        row: index + 1,
        abn: abn,
        issue: 'Invalid check digit'
      });
    }
  });

  validation.validRate = validation.total > 0 
    ? ((validation.valid / validation.total) * 100).toFixed(1) + '%'
    : 'N/A';

  return validation;
}

function isValidABN(abn) {
  const weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
  let sum = 0;
  
  for (let i = 0; i < 11; i++) {
    const digit = parseInt(abn[i]);
    if (i === 0) {
      sum += (digit - 1) * weights[i];
    } else {
      sum += digit * weights[i];
    }
  }
  
  return sum % 89 === 0;
}

function isDefunctABN(abn) {
  const knownDefunct = ['51824753556', '48123123124'];
  return knownDefunct.includes(abn);
}

function validateACN(data, acnColumn) {
  const validation = {
    total: 0,
    valid: 0,
    invalid: [],
    formatIssues: []
  };

  data.forEach((row, index) => {
    const acn = String(row[acnColumn] || '').replace(/\s/g, '');
    if (!acn) return;

    validation.total++;

    if (!/^\d{9}$/.test(acn)) {
      validation.formatIssues.push({
        row: index + 1,
        value: row[acnColumn],
        issue: 'Invalid format (must be 9 digits)'
      });
    } else if (isValidACN(acn)) {
      validation.valid++;
    } else {
      validation.invalid.push({
        row: index + 1,
        acn: acn,
        issue: 'Invalid check digit'
      });
    }
  });

  validation.validRate = validation.total > 0 
    ? ((validation.valid / validation.total) * 100).toFixed(1) + '%'
    : 'N/A';

  return validation;
}

function isValidACN(acn) {
  const weights = [8, 7, 6, 5, 4, 3, 2, 1];
  let sum = 0;
  
  for (let i = 0; i < 8; i++) {
    sum += parseInt(acn[i]) * weights[i];
  }
  
  const remainder = sum % 10;
  const checkDigit = remainder === 0 ? 0 : 10 - remainder;
  
  return parseInt(acn[8]) === checkDigit;
}

function validatePostcodes(data, postcodeColumn, stateColumn) {
  const validation = {
    total: 0,
    valid: 0,
    invalid: [],
    stateMismatches: [],
    distribution: {
      NSW: 0, VIC: 0, QLD: 0, SA: 0, 
      WA: 0, TAS: 0, NT: 0, ACT: 0
    }
  };

  const postcodeRanges = {
    NSW: [[1000, 1999], [2000, 2599], [2619, 2899], [2921, 2999]],
    VIC: [[3000, 3999], [8000, 8999]],
    QLD: [[4000, 4999], [9000, 9999]],
    SA: [[5000, 5799]],
    WA: [[6000, 6797], [6800, 6999]],
    TAS: [[7000, 7799]],
    NT: [[800, 899]],
    ACT: [[200, 299], [2600, 2618], [2900, 2920]]
  };

  data.forEach((row, index) => {
    const postcode = String(row[postcodeColumn] || '').trim();
    if (!postcode) return;

    validation.total++;

    if (!/^\d{4}$/.test(postcode)) {
      validation.invalid.push({
        row: index + 1,
        value: postcode,
        issue: 'Invalid format (must be 4 digits)'
      });
      return;
    }

    const pc = parseInt(postcode);
    let validState = null;

    for (const [state, ranges] of Object.entries(postcodeRanges)) {
      if (ranges.some(([min, max]) => pc >= min && pc <= max)) {
        validState = state;
        validation.distribution[state]++;
        validation.valid++;
        break;
      }
    }

    if (!validState) {
      validation.invalid.push({
        row: index + 1,
        value: postcode,
        issue: 'Not a valid Australian postcode'
      });
    } else if (stateColumn !== null) {
      const recordState = String(row[stateColumn] || '').toUpperCase();
      if (recordState && recordState !== validState) {
        validation.stateMismatches.push({
          row: index + 1,
          postcode: postcode,
          expectedState: validState,
          actualState: recordState
        });
      }
    }
  });

  validation.validRate = validation.total > 0 
    ? ((validation.valid / validation.total) * 100).toFixed(1) + '%'
    : 'N/A';

  Object.keys(validation.distribution).forEach(state => {
    if (validation.valid > 0) {
      validation.distribution[state] = 
        ((validation.distribution[state] / validation.valid) * 100).toFixed(1) + '%';
    }
  });

  return validation;
}

function validatePhoneNumbers(data, phoneColumns) {
  const validations = {};

  phoneColumns.forEach(phoneCol => {
    const validation = {
      total: 0,
      valid: { mobile: 0, landline: 0 },
      invalid: [],
      formatIssues: [],
      carrierDistribution: { Telstra: 0, Optus: 0, Vodafone: 0, Other: 0 }
    };

    data.forEach((row, index) => {
      const phone = String(row[phoneCol.index] || '').replace(/[\s\-\(\)]/g, '');
      if (!phone) return;

      validation.total++;

      const mobileResult = validateMobileNumber(phone);
      const landlineResult = validateLandlineNumber(phone);

      if (mobileResult.valid) {
        validation.valid.mobile++;
        validation.carrierDistribution[mobileResult.carrier]++;
      } else if (landlineResult.valid) {
        validation.valid.landline++;
      } else {
        validation.invalid.push({
          row: index + 1,
          value: row[phoneCol.index],
          issue: detectPhoneIssue(phone)
        });

        if (phone.match(/^4\d{8}$/)) {
          validation.formatIssues.push({
            row: index + 1,
            value: row[phoneCol.index],
            issue: 'Missing leading 0',
            suggestion: '0' + phone
          });
        }
      }
    });

    validation.validRate = validation.total > 0 
      ? (((validation.valid.mobile + validation.valid.landline) / validation.total) * 100).toFixed(1) + '%'
      : 'N/A';

    validation.breakdown = {
      mobile: `${((validation.valid.mobile / validation.total) * 100).toFixed(1)}%`,
      landline: `${((validation.valid.landline / validation.total) * 100).toFixed(1)}%`
    };

    validations[phoneCol.header] = validation;
  });

  return validations;
}

function validateMobileNumber(phone) {
  const patterns = {
    standard: /^(?:\+?61|0)?4\d{8}$/};

  if (!patterns.standard.test(phone)) {
    return { valid: false };
  }

  const normalized = phone.replace(/^\+?61/, '0');
  const prefix = normalized.substring(0, 4);

  const carrierPrefixes = {
    Telstra: ['0400', '0401', '0402', '0403', '0404', '0405', '0406', '0407', '0408', '0409', 
              '0410', '0411', '0412', '0413', '0414', '0415', '0416', '0417', '0418', '0419'],
    Optus: ['0420', '0421', '0422', '0423', '0424', '0425', '0426', '0427', '0428', '0429',
            '0430', '0431', '0432', '0433', '0434', '0435'],
    Vodafone: ['0436', '0437', '0438', '0439', '0440', '0441', '0442', '0443', '0444', '0445',
               '0446', '0447', '0448', '0449', '0450']
  };

  let carrier = 'Other';
  for (const [name, prefixes] of Object.entries(carrierPrefixes)) {
    if (prefixes.includes(prefix)) {
      carrier = name;
      break;
    }
  }

  return { valid: true, carrier };
}

function validateLandlineNumber(phone) {
  const patterns = {
    standard: /^(?:\+?61|0)?[2-9]\d{8}$/,
    shortArea: /^(?:\+?61|0)?[2-9]\d{7}$/
  };

  return { 
    valid: patterns.standard.test(phone) || patterns.shortArea.test(phone) 
  };
}

function detectPhoneIssue(phone) {
  if (phone.length < 9) return 'Too short';
  if (phone.length > 10 && !phone.startsWith('+')) return 'Too long';
  if (!/^\+?\d+$/.test(phone)) return 'Contains non-numeric characters';
  if (phone.match(/^[2-9]\d{8}$/)) return 'Missing area code (0)';
  return 'Invalid Australian phone number format';
}

function validateAddresses(data, addressColumns) {
  const validation = {
    standardisationNeeded: [],
    abbreviationInconsistencies: [],
    suburbSpellingIssues: [],
    gnafMatchable: { count: 0, percentage: 0 }
  };

  const abbreviations = {
    'Street': ['St', 'St.', 'Str'],
    'Road': ['Rd', 'Rd.'],
    'Avenue': ['Ave', 'Ave.', 'Av'],
    'Place': ['Pl', 'Pl.'],
    'Drive': ['Dr', 'Dr.', 'Drv'],
    'Court': ['Ct', 'Ct.'],
    'Parade': ['Pde', 'Pde.', 'Prd']
  };

  addressColumns.forEach(addrCol => {
    const addressValues = data.map(row => String(row[addrCol.index] || ''));
    
    const inconsistencies = {};
    addressValues.forEach((address, index) => {
      if (!address) return;

      Object.entries(abbreviations).forEach(([full, abbrevs]) => {
        abbrevs.forEach(abbrev => {
          if (address.includes(` ${abbrev} `) || address.endsWith(` ${abbrev}`)) {
            if (!inconsistencies[full]) {
              inconsistencies[full] = { full: 0, abbreviated: {} };
            }
            inconsistencies[full].abbreviated[abbrev] = 
              (inconsistencies[full].abbreviated[abbrev] || 0) + 1;
          }
        });
        
        if (address.includes(` ${full} `) || address.endsWith(` ${full}`)) {
          if (!inconsistencies[full]) {
            inconsistencies[full] = { full: 0, abbreviated: {} };
          }
          inconsistencies[full].full++;
        }
      });
    });

    Object.entries(inconsistencies).forEach(([streetType, counts]) => {
      const total = counts.full + Object.values(counts.abbreviated).reduce((a, b) => a + b, 0);
      if (total > 10) {
        validation.abbreviationInconsistencies.push({
          field: addrCol.header,
          type: streetType,
          distribution: {
            full: `${counts.full} (${(counts.full/total*100).toFixed(0)}%)`,
            abbreviated: Object.entries(counts.abbreviated).map(([abbr, count]) => 
              `${abbr}: ${count} (${(count/total*100).toFixed(0)}%)`
            )
          }
        });
      }
    });

    const gnafMatches = addressValues.filter(addr => isGNAFMatchable(addr)).length;
    validation.gnafMatchable.count += gnafMatches;
  });

  const totalAddresses = data.length * addressColumns.length;
  validation.gnafMatchable.percentage = totalAddresses > 0
    ? ((validation.gnafMatchable.count / totalAddresses) * 100).toFixed(1) + '%'
    : 'N/A';

  return validation;
}

function isGNAFMatchable(address) {
  const gnafPattern = /^\d+\s+\w+\s+(Street|St|Road|Rd|Avenue|Ave|Place|Pl|Drive|Dr)/i;
  return gnafPattern.test(address);
}

function validateStates(data, stateColumn) {
  const validation = {
    total: 0,
    valid: 0,
    invalid: [],
    distribution: {},
    formatIssues: []
  };

  const validStates = {
    'NSW': 'New South Wales',
    'VIC': 'Victoria',
    'QLD': 'Queensland',
    'SA': 'South Australia',
    'WA': 'Western Australia',
    'TAS': 'Tasmania',
    'NT': 'Northern Territory',
    'ACT': 'Australian Capital Territory'
  };

  data.forEach((row, index) => {
    const state = String(row[stateColumn] || '').trim();
    if (!state) return;

    validation.total++;

    const stateUpper = state.toUpperCase();
    if (validStates[stateUpper]) {
      validation.valid++;
      validation.distribution[stateUpper] = (validation.distribution[stateUpper] || 0) + 1;
      
      if (state !== stateUpper) {
        validation.formatIssues.push({
          row: index + 1,
          value: state,
          issue: 'Inconsistent case',
          suggestion: stateUpper
        });
      }
    } else {
      const fullName = Object.values(validStates).find(name => 
        name.toLowerCase() === state.toLowerCase()
      );
      
      if (fullName) {
        const abbreviation = Object.keys(validStates).find(key => 
          validStates[key] === fullName
        );
        validation.formatIssues.push({
          row: index + 1,
          value: state,
          issue: 'Full name instead of abbreviation',
          suggestion: abbreviation
        });
      } else {
        validation.invalid.push({
          row: index + 1,
          value: state,
          issue: 'Not a valid Australian state/territory'
        });
      }
    }
  });

  validation.validRate = validation.total > 0 
    ? ((validation.valid / validation.total) * 100).toFixed(1) + '%'
    : 'N/A';

  Object.keys(validation.distribution).forEach(state => {
    validation.distribution[state] = 
      `${validation.distribution[state]} (${(validation.distribution[state]/validation.valid*100).toFixed(1)}%)`;
  });

  return validation;
}

function calculateQualityScore(dimensionResults) {
  const weights = {
    completeness: 0.20,
    validity: 0.20,
    accuracy: 0.20,
    consistency: 0.15,
    timeliness: 0.15,
    uniqueness: 0.10
  };

  let totalScore = 0;
  let totalWeight = 0;
  const dimensionScores = {};

  // Debug: Check what dimensions we're receiving
  Object.keys(dimensionResults).filter(d => dimensionResults[d]?.score !== undefined);
  
  Object.entries(dimensionResults).forEach(([dimension, result]) => {
    if (result && result.score !== undefined) {
      // Ensure dimension key matches our weights (case-sensitive)
      const normalizedDimension = dimension.toLowerCase();
      const actualWeight = weights[normalizedDimension] || 0;
      
      dimensionScores[dimension] = {
        score: result.score,
        weight: actualWeight,
        weightedScore: result.score * actualWeight
      };
      totalScore += result.score * actualWeight;
      totalWeight += actualWeight;
    }
  });

  // If we didn't get all dimensions, calculate based on what we have
  const overallScore = totalWeight > 0 ? totalScore / totalWeight : 0;
  const grade = getGrade(overallScore);
  const trend = calculateTrend(overallScore);
  const benchmark = getBenchmark(overallScore);

  return {
    overallScore: Math.round(overallScore),
    grade: grade,
    dimensionScores: dimensionScores,
    scoreBreakdown: generateScoreBreakdown(dimensionScores),
    trend: trend,
    benchmark: benchmark,
    certification: getCertificationStatus(overallScore, dimensionResults),
    recommendations: generateRecommendations(dimensionResults)
  };
}

function getGrade(score) {
  if (score >= 95) return { letter: 'A+', label: 'Exceptional' };
  if (score >= 90) return { letter: 'A', label: 'Excellent' };
  if (score >= 85) return { letter: 'B+', label: 'Very Good' };
  if (score >= 80) return { letter: 'B', label: 'Good' };
  if (score >= 75) return { letter: 'C+', label: 'Above Average' };
  if (score >= 70) return { letter: 'C', label: 'Average' };
  if (score >= 65) return { letter: 'D+', label: 'Below Average' };
  if (score >= 60) return { letter: 'D', label: 'Poor' };
  return { letter: 'F', label: 'Failing' };
}

function calculateTrend(currentScore) {
  const historicalScores = [82.5, 83.1, 83.5, 83.8];
  historicalScores.push(currentScore);
  
  const recentAvg = historicalScores.slice(-3).reduce((a, b) => a + b, 0) / 3;
  const previousAvg = historicalScores.slice(-4, -1).reduce((a, b) => a + b, 0) / 3;
  
  const velocity = recentAvg - previousAvg;
  
  return {
    direction: velocity > 0.5 ? 'improving' : velocity < -0.5 ? 'declining' : 'stable',
    velocity: velocity.toFixed(1),
    symbol: velocity > 0.5 ? '↑' : velocity < -0.5 ? '↓' : '→',
    interpretation: velocity > 0.5 ? 'Quality is improving' : 
                   velocity < -0.5 ? 'Quality is declining' : 
                   'Quality is stable'
  };
}

function getBenchmark(score) {
  
  const averageBenchmark = 76;
  
  return {
    score: score,
    industryAverage: averageBenchmark,
    comparison: score >= averageBenchmark ? 'above' : 'below',
    percentile: calculatePercentile(score),
    interpretation: score >= averageBenchmark 
      ? `${(score - averageBenchmark).toFixed(1)} points above industry average`
      : `${(averageBenchmark - score).toFixed(1)} points below industry average`
  };
}

function calculatePercentile(score) {
  if (score >= 90) return '95th';
  if (score >= 85) return '85th';
  if (score >= 80) return '75th';
  if (score >= 75) return '50th';
  if (score >= 70) return '25th';
  return '10th';
}

function generateScoreBreakdown(dimensionScores) {
  const breakdown = [];
  
  Object.entries(dimensionScores)
    .sort((a, b) => b[1].score - a[1].score)
    .forEach(([dimension, scores]) => {
      breakdown.push({
        dimension: dimension.charAt(0).toUpperCase() + dimension.slice(1),
        score: scores.score,
        weight: `${(scores.weight * 100).toFixed(0)}%`,
        contribution: scores.weightedScore.toFixed(1),
        performance: getPerformanceLevel(scores.score)
      });
    });
  
  return breakdown;
}

function getPerformanceLevel(score) {
  if (score >= 90) return 'Excellent';
  if (score >= 80) return 'Good';
  if (score >= 70) return 'Fair';
  if (score >= 60) return 'Poor';
  return 'Critical';
}

function getCertificationStatus(overallScore, dimensionResults) {
  const certificationLevels = [
    {
      level: 'Gold',
      minScore: 90,
      requirements: {
        minDimensionScore: 85,
        maxCriticalIssues: 0,
        maxWarnings: 5
      }
    },
    {
      level: 'Silver',
      minScore: 80,
      requirements: {
        minDimensionScore: 70,
        maxCriticalIssues: 2,
        maxWarnings: 10
      }
    },
    {
      level: 'Bronze',
      minScore: 70,
      requirements: {
        minDimensionScore: 60,
        maxCriticalIssues: 5,
        maxWarnings: 20
      }
    }
  ];

  let criticalCount = 0;
  let warningCount = 0;
  let minDimensionScore = 100;

  Object.values(dimensionResults).forEach(result => {
    if (result.score < minDimensionScore) {
      minDimensionScore = result.score;
    }
    if (result.issues) {
      criticalCount += result.issues.filter(i => i.type === 'critical').length;
      warningCount += result.issues.filter(i => i.type === 'warning').length;
    }
  });

  for (const cert of certificationLevels) {
    if (overallScore >= cert.minScore &&
        minDimensionScore >= cert.requirements.minDimensionScore &&
        criticalCount <= cert.requirements.maxCriticalIssues &&
        warningCount <= cert.requirements.maxWarnings) {
      return {
        certified: true,
        level: cert.level,
        badge: cert.level === 'Gold' ? '🥇' : cert.level === 'Silver' ? '🥈' : '🥉',
        validUntil: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        requirements: cert.requirements
      };
    }
  }

  return {
    certified: false,
    nextLevel: certificationLevels[2].level,
    gap: {
      score: certificationLevels[2].minScore - overallScore,
      criticalIssues: Math.max(0, criticalCount - certificationLevels[2].requirements.maxCriticalIssues),
      warnings: Math.max(0, warningCount - certificationLevels[2].requirements.maxWarnings)
    }
  };
}

function generateRecommendations(dimensionResults) {
  const priorityMatrix = [];

  Object.entries(dimensionResults).forEach(([dimension, result]) => {
    if (!result.issues) return;

    const criticalIssues = result.issues.filter(i => i.type === 'critical');
    const warnings = result.issues.filter(i => i.type === 'warning');

    criticalIssues.forEach(issue => {
      const impact = calculateImpact(issue, dimension);
      const effort = estimateEffort(issue);
      
      priorityMatrix.push({
        dimension: dimension,
        issue: issue.message || issue.field,
        type: 'critical',
        impact: impact,
        effort: effort,
        priority: calculatePriority(impact, effort),
        recommendation: generateSpecificRecommendation(issue, dimension)
      });
    });

    warnings.slice(0, 3).forEach(issue => {
      const impact = calculateImpact(issue, dimension);
      const effort = estimateEffort(issue);
      
      priorityMatrix.push({
        dimension: dimension,
        issue: issue.message || issue.field,
        type: 'warning',
        impact: impact,
        effort: effort,
        priority: calculatePriority(impact, effort),
        recommendation: generateSpecificRecommendation(issue, dimension)
      });
    });
  });

  priorityMatrix.sort((a, b) => b.priority - a.priority);

  const quickWins = priorityMatrix.filter(r => r.impact >= 7 && r.effort <= 3).slice(0, 3);
  const strategicInitiatives = priorityMatrix.filter(r => r.impact >= 7 && r.effort > 3).slice(0, 3);
  const tactical = priorityMatrix.filter(r => r.impact < 7 && r.effort <= 3).slice(0, 3);

  return {
    quickWins: quickWins.map(formatRecommendation),
    strategic: strategicInitiatives.map(formatRecommendation),
    tactical: tactical.map(formatRecommendation),
    totalRecommendations: priorityMatrix.length
  };
}

function calculateImpact(issue, dimension) {
  const baseImpact = issue.type === 'critical' ? 8 : 5;
  const dimensionWeight = {
    'completeness': 1.2,
    'validity': 1.1,
    'accuracy': 1.3,
    'consistency': 1.0,
    'timeliness': 0.9,
    'uniqueness': 1.1
  };
  
  return Math.min(10, baseImpact * (dimensionWeight[dimension] || 1));
}

function estimateEffort(issue) {
  if (issue.fix || issue.sql) return 2;
  if (issue.pattern || issue.recommendation) return 4;
  if (issue.manual || issue.investigation) return 7;
  return 5;
}

function calculatePriority(impact, effort) {
  return (impact * 2 + (10 - effort)) / 3;
}

function generateSpecificRecommendation(issue, dimension) {
  const templates = {
    'completeness': {
      critical: 'Implement data collection process for {field}',
      warning: 'Review and fill missing values in {field}'
    },
    'validity': {
      critical: 'Add validation rules for {field}',
      warning: 'Standardize format for {field}'
    },
    'accuracy': {
      critical: 'Investigate and correct outliers in {field}',
      warning: 'Review business rules for {field}'
    },
    'consistency': {
      critical: 'Implement referential integrity for {field}',
      warning: 'Standardize data entry for {field}'
    },
    'timeliness': {
      critical: 'Update stale records in {field}',
      warning: 'Implement regular update schedule for {field}'
    },
    'uniqueness': {
      critical: 'Remove duplicates and add unique constraint on {field}',
      warning: 'Review and merge near-duplicates'
    }
  };

  const template = templates[dimension]?.[issue.type] || 'Review and fix {field}';
  return template.replace('{field}', issue.field || 'affected data');
}

function formatRecommendation(rec) {
  return {
    action: rec.recommendation,
    dimension: rec.dimension,
    priority: rec.type === 'critical' ? 'High' : 'Medium',
    impact: `${rec.impact.toFixed(0)}/10`,
    effort: `${rec.effort.toFixed(0)}/10`,
    roi: rec.impact / rec.effort > 3 ? 'High ROI' : 
         rec.impact / rec.effort > 1.5 ? 'Medium ROI' : 'Low ROI'
  };
}

function generateSQLFixes(analysisResults, tableName = 'your_table') {
  const sqlScripts = {
    priority1_referentialIntegrity: [],
    priority2_dataStandardisation: [],
    priority3_constraints: [],
    priority4_cleanup: []
  };

  if (analysisResults.businessRules) {
    generateBusinessRuleSQL(analysisResults.businessRules, tableName, sqlScripts);
  }

  if (analysisResults.validityIssues) {
    generateValidityFixSQL(analysisResults.validityIssues, tableName, sqlScripts);
  }

  if (analysisResults.duplicates) {
    generateDuplicateFixSQL(analysisResults.duplicates, tableName, sqlScripts);
  }

  if (analysisResults.consistencyIssues) {
    generateConsistencyFixSQL(analysisResults.consistencyIssues, tableName, sqlScripts);
  }

  if (analysisResults.temporalIssues) {
    generateTemporalFixSQL(analysisResults.temporalIssues, tableName, sqlScripts);
  }

  return formatSQLOutput(sqlScripts, tableName);
}

function generateBusinessRuleSQL(rules, tableName, scripts) {
  rules.forEach(rule => {
    if (rule.type === 'FOREIGN_KEY_CONSTRAINT') {
      scripts.priority1_referentialIntegrity.push({
        description: `Add foreign key for ${rule.field}`,
        sql: `ALTER TABLE ${tableName} 
ADD CONSTRAINT fk_${rule.field} 
FOREIGN KEY (${rule.field}) 
REFERENCES ${rule.field.replace('_id', '')}(id);`,
        rollback: `ALTER TABLE ${tableName} DROP CONSTRAINT fk_${rule.field};`
      });
    }

    if (rule.type === 'RANGE_CONSTRAINT' || rule.type === 'NON_NEGATIVE_CONSTRAINT') {
      scripts.priority3_constraints.push({
        description: `Add check constraint for ${rule.field}`,
        sql: `ALTER TABLE ${tableName} 
ADD CONSTRAINT chk_${rule.field} 
${rule.sql};`,
        rollback: `ALTER TABLE ${tableName} DROP CONSTRAINT chk_${rule.field};`,
        validation: `SELECT COUNT(*) as violations 
FROM ${tableName} 
WHERE NOT (${rule.rule});`
      });
    }

    if (rule.type === 'UNIQUENESS_CONSTRAINT') {
      scripts.priority3_constraints.push({
        description: `Add unique constraint for ${rule.field}`,
        sql: `ALTER TABLE ${tableName} 
ADD CONSTRAINT uk_${rule.field} 
UNIQUE (${rule.field});`,
        rollback: `ALTER TABLE ${tableName} DROP CONSTRAINT uk_${rule.field};`,
        preCheck: `SELECT ${rule.field}, COUNT(*) as cnt 
FROM ${tableName} 
GROUP BY ${rule.field} 
HAVING COUNT(*) > 1;`
      });
    }

    if (rule.type === 'PATTERN_CONSTRAINT') {
      scripts.priority3_constraints.push({
        description: `Add pattern check for ${rule.field}`,
        sql: `ALTER TABLE ${tableName} 
ADD CONSTRAINT chk_${rule.field}_pattern 
${rule.sql};`,
        rollback: `ALTER TABLE ${tableName} DROP CONSTRAINT chk_${rule.field}_pattern;`
      });
    }

    if (rule.type === 'DERIVED_FIELD_RULE' && rule.violations > 0) {
      const updateSQL = generateDerivedFieldUpdate(rule, tableName);
      scripts.priority2_dataStandardisation.push({
        description: `Fix calculated field ${rule.field}`,
        sql: updateSQL,
        validation: `SELECT COUNT(*) as remaining_issues 
FROM ${tableName} 
WHERE ${rule.field} != ${rule.components.join(' + ')};`
      });
    }
  });
}

function generateDerivedFieldUpdate(rule, tableName) {
  return `-- Fix ${rule.violations} incorrect calculations in ${rule.field}
UPDATE ${tableName}
SET ${rule.field} = ${rule.components.join(' + ')}
WHERE ${rule.field} != ${rule.components.join(' + ')};

-- Add trigger to maintain consistency
CREATE OR REPLACE TRIGGER trg_${rule.field}_calc
BEFORE INSERT OR UPDATE ON ${tableName}
FOR EACH ROW
BEGIN
    NEW.${rule.field} := ${rule.components.map(c => 'NEW.' + c).join(' + ')};
END;`;
}

function generateValidityFixSQL(validityIssues, tableName, scripts) {
  Object.entries(validityIssues).forEach(([field, issues]) => {
    if (issues.phoneFormat) {
      scripts.priority2_dataStandardisation.push({
        description: `Standardise phone numbers in ${field}`,
        sql: generatePhoneStandardisationSQL(field, tableName),
        validation: `SELECT COUNT(*) as invalid_phones 
FROM ${tableName} 
WHERE ${field} IS NOT NULL 
  AND ${field} !~ '^\\+?61[0-9]{9}$' 
  AND ${field} !~ '^0[0-9]{9}$';`
      });
    }

    if (issues.emailFormat) {
      scripts.priority2_dataStandardisation.push({
        description: `Clean invalid emails in ${field}`,
        sql: `-- Mark invalid emails for review
UPDATE ${tableName}
SET ${field} = CONCAT('INVALID_', ${field})
WHERE ${field} IS NOT NULL
  AND ${field} !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'
  AND ${field} NOT LIKE 'INVALID_%';`,
        rollback: `UPDATE ${tableName} 
SET ${field} = SUBSTRING(${field} FROM 9) 
WHERE ${field} LIKE 'INVALID_%';`
      });
    }

    if (issues.caseInconsistency) {
      scripts.priority2_dataStandardisation.push({
        description: `Standardise case for ${field}`,
        sql: generateCaseStandardisationSQL(field, tableName, issues.recommendedCase)
      });
    }
  });
}

function generatePhoneStandardisationSQL(field, tableName) {
  return `-- Standardise Australian phone numbers
-- Add leading 0 to mobile numbers missing it
UPDATE ${tableName}
SET ${field} = CONCAT('0', ${field})
WHERE LENGTH(${field}) = 9 
  AND ${field} ~ '^4[0-9]{8}$';

-- Remove spaces, hyphens, and parentheses
UPDATE ${tableName}
SET ${field} = REGEXP_REPLACE(${field}, '[\\s\\-\\(\\)]', '', 'g')
WHERE ${field} ~ '[\\s\\-\\(\\)]';

-- Convert international format to local
UPDATE ${tableName}
SET ${field} = REGEXP_REPLACE(${field}, '^\\+61', '0')
WHERE ${field} ~ '^\\+61';`;
}

function generateCaseStandardisationSQL(field, tableName, recommendedCase) {
  const caseFunction = {
    'UPPER': 'UPPER',
    'LOWER': 'LOWER',
    'TITLE': 'INITCAP'
  };

  return `UPDATE ${tableName}
SET ${field} = ${caseFunction[recommendedCase] || 'INITCAP'}(${field})
WHERE ${field} IS NOT NULL;`;
}

function generateDuplicateFixSQL(duplicates, tableName, scripts) {
  if (duplicates.exactDuplicates && duplicates.exactDuplicates.length > 0) {
    scripts.priority4_cleanup.push({
      description: 'Remove exact duplicate records',
      sql: `-- Remove exact duplicates keeping the oldest record
WITH duplicates AS (
  SELECT ctid,
         ROW_NUMBER() OVER (
           PARTITION BY ${duplicates.keyColumns.join(', ')}
           ORDER BY created_date, ctid
         ) AS rn
  FROM ${tableName}
)
DELETE FROM ${tableName}
WHERE ctid IN (
  SELECT ctid FROM duplicates WHERE rn > 1
);`,
      validation: `SELECT COUNT(*) as duplicate_groups
FROM (
  SELECT ${duplicates.keyColumns.join(', ')}, COUNT(*) as cnt
  FROM ${tableName}
  GROUP BY ${duplicates.keyColumns.join(', ')}
  HAVING COUNT(*) > 1
) t;`
    });
  }

  if (duplicates.fuzzyDuplicates && duplicates.fuzzyDuplicates.length > 0) {
    scripts.priority4_cleanup.push({
      description: 'Merge fuzzy duplicate records',
      sql: generateFuzzyMergeSQL(duplicates.fuzzyDuplicates[0], tableName),
      manual: true,
      note: 'Review and adjust merge logic before executing'
    });
  }
}

function generateFuzzyMergeSQL(fuzzyGroup, tableName) {
  return `-- Merge fuzzy duplicates for group: ${fuzzyGroup.id}
-- Primary record: ${fuzzyGroup.records[0].index}
-- Records to merge: ${fuzzyGroup.records.slice(1).map(r => r.index).join(', ')}

BEGIN;

-- Step 1: Update foreign key references
-- TODO: Add UPDATE statements for tables referencing this record

-- Step 2: Merge data (customize based on business rules)
UPDATE ${tableName} t1
SET 
  -- Combine/update fields as needed
  -- Example: notes = COALESCE(t1.notes, '') || ' | ' || COALESCE(t2.notes, '')
FROM ${tableName} t2
WHERE t1.id = ${fuzzyGroup.records[0].index}
  AND t2.id IN (${fuzzyGroup.records.slice(1).map(r => r.index).join(', ')});

-- Step 3: Delete merged records
DELETE FROM ${tableName}
WHERE id IN (${fuzzyGroup.records.slice(1).map(r => r.index).join(', ')});

COMMIT;`;
}

function generateConsistencyFixSQL(consistencyIssues, tableName, scripts) {
  if (consistencyIssues.temporalInconsistencies) {
    consistencyIssues.temporalInconsistencies.forEach(issue => {
      scripts.priority2_dataStandardisation.push({
        description: `Fix temporal inconsistency: ${issue.rule}`,
        sql: `UPDATE ${tableName}
SET ${issue.field1} = LEAST(${issue.field1}, ${issue.field2})
WHERE ${issue.field1} > ${issue.field2};`,
        validation: `SELECT COUNT(*) as remaining_issues
FROM ${tableName}
WHERE ${issue.field1} > ${issue.field2};`
      });
    });
  }

  if (consistencyIssues.crossColumnValidation) {
    consistencyIssues.crossColumnValidation.forEach(issue => {
      if (issue.type === 'calculated_field') {
        scripts.priority2_dataStandardisation.push({
          description: `Fix cross-column calculation: ${issue.field}`,
          sql: issue.fixSQL || `-- Manual fix required for ${issue.field}`,
          manual: !issue.fixSQL
        });
      }
    });
  }
}

function generateTemporalFixSQL(temporalIssues, tableName, scripts) {
  if (temporalIssues.futureDates) {
    temporalIssues.futureDates.forEach(issue => {
      scripts.priority2_dataStandardisation.push({
        description: `Fix future dates in ${issue.field}`,
        sql: `-- Option 1: Set to current date
UPDATE ${tableName}
SET ${issue.field} = CURRENT_DATE
WHERE ${issue.field} > CURRENT_DATE;

-- Option 2: Set to NULL (uncomment if preferred)
-- UPDATE ${tableName}
-- SET ${issue.field} = NULL
-- WHERE ${issue.field} > CURRENT_DATE;`,
        validation: `SELECT COUNT(*) as future_dates
FROM ${tableName}
WHERE ${issue.field} > CURRENT_DATE;`
      });
    });
  }

  if (temporalIssues.staleRecords) {
    scripts.priority4_cleanup.push({
      description: 'Archive stale records',
      sql: `-- Create archive table
CREATE TABLE IF NOT EXISTS ${tableName}_archive (LIKE ${tableName});

-- Move stale records to archive
INSERT INTO ${tableName}_archive
SELECT * FROM ${tableName}
WHERE last_modified < CURRENT_DATE - INTERVAL '${temporalIssues.staleThreshold} days';

-- Delete from main table
DELETE FROM ${tableName}
WHERE last_modified < CURRENT_DATE - INTERVAL '${temporalIssues.staleThreshold} days';`,
      validation: `SELECT COUNT(*) as archived_records
FROM ${tableName}_archive;`
    });
  }
}

function formatSQLOutput(scripts, tableName) {
  const output = [];
  
  output.push(`-- Data Quality Fix Scripts for ${tableName}`);
  output.push(`-- Generated: ${new Date().toISOString()}`);
  output.push('-- IMPORTANT: Review all scripts before execution');
  output.push('-- Execute in order: Priority 1 -> 2 -> 3 -> 4\n');

  const sections = [
    { key: 'priority1_referentialIntegrity', title: 'PRIORITY 1: Referential Integrity' },
    { key: 'priority2_dataStandardisation', title: 'PRIORITY 2: Data Standardisation' },
    { key: 'priority3_constraints', title: 'PRIORITY 3: Constraints' },
    { key: 'priority4_cleanup', title: 'PRIORITY 4: Cleanup' }
  ];

  sections.forEach(section => {
    if (scripts[section.key].length > 0) {
      output.push(`\n-- ==========================================`);
      output.push(`-- ${section.title}`);
      output.push(`-- ==========================================\n`);

      scripts[section.key].forEach((script, index) => {
        output.push(`-- ${index + 1}. ${script.description}`);
        if (script.manual) {
          output.push('-- MANUAL REVIEW REQUIRED');
        }
        if (script.preCheck) {
          output.push('-- Pre-execution check:');
          output.push(script.preCheck);
          output.push('');
        }
        output.push(script.sql);
        if (script.validation) {
          output.push('\n-- Validation query:');
          output.push(script.validation);
        }
        if (script.rollback) {
          output.push('\n-- Rollback:');
          output.push(script.rollback);
        }
        output.push('');
      });
    }
  });

  output.push('\n-- ==========================================');
  output.push('-- POST-EXECUTION VALIDATION');
  output.push('-- ==========================================\n');
  output.push(generateValidationQueries$1(tableName));

  return output.join('\n');
}

function generateValidationQueries$1(tableName) {
  return `-- Check for remaining data quality issues
SELECT 
  'Null Values' as check_type,
  COUNT(*) as issue_count
FROM ${tableName}
WHERE important_column IS NULL
UNION ALL
SELECT 
  'Duplicates' as check_type,
  COUNT(*) as issue_count
FROM (
  SELECT key_column, COUNT(*) as cnt
  FROM ${tableName}
  GROUP BY key_column
  HAVING COUNT(*) > 1
) t
UNION ALL
SELECT 
  'Invalid Formats' as check_type,
  COUNT(*) as issue_count
FROM ${tableName}
WHERE email_column NOT LIKE '%@%.%'
   OR phone_column !~ '^[0-9+\\-\\s\\(\\)]+$';`;
}

function generatePythonFixes(analysisResults, fileName = 'data.csv') {
  const scripts = {
    fuzzyMatching: null,
    dataStandardisation: null,
    outlierHandling: null,
    missingValueImputation: null
  };

  if (analysisResults.fuzzyDuplicates && analysisResults.fuzzyDuplicates.length > 0) {
    scripts.fuzzyMatching = generateFuzzyMatchingScript(analysisResults.fuzzyDuplicates, fileName);
  }

  if (analysisResults.standardisationNeeded) {
    scripts.dataStandardisation = generateStandardisationScript(analysisResults.standardisationNeeded, fileName);
  }

  if (analysisResults.outliers) {
    scripts.outlierHandling = generateOutlierScript(analysisResults.outliers, fileName);
  }

  if (analysisResults.missingValues) {
    scripts.missingValueImputation = generateImputationScript(analysisResults.missingValues, fileName);
  }

  return formatPythonOutput(scripts, fileName);
}

function generateFuzzyMatchingScript(fuzzyDuplicates, fileName) {
  return `#!/usr/bin/env python3
"""
Fuzzy Duplicate Merging Script
Generated for: ${fileName}
Purpose: Identify and merge near-duplicate records
"""

import pandas as pd
import numpy as np
from fuzzywuzzy import fuzz, process
import recordlinkage
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class FuzzyDuplicateMerger:
    def __init__(self, filepath, threshold=85):
        self.filepath = filepath
        self.threshold = threshold
        self.df = None
        self.matches = []
        
    def load_data(self):
        """Load CSV data"""
        logger.info(f"Loading data from {self.filepath}")
        self.df = pd.read_csv(self.filepath)
        logger.info(f"Loaded {len(self.df)} records")
        return self.df
    
    def find_duplicates(self, columns_to_match):
        """Find potential duplicates using multiple algorithms"""
        logger.info("Starting fuzzy duplicate detection")
        
        # Create record linkage index
        indexer = recordlinkage.Index()
        indexer.block(columns_to_match[0])  # Block on first column for efficiency
        candidate_pairs = indexer.index(self.df)
        
        # Compare records
        compare = recordlinkage.Compare()
        for col in columns_to_match:
            compare.string(col, col, method='jarowinkler', threshold=0.85, label=col)
        
        features = compare.compute(candidate_pairs, self.df)
        
        # Find matches above threshold
        matches = features[features.sum(axis=1) >= len(columns_to_match) * 0.8]
        
        logger.info(f"Found {len(matches)} potential duplicate pairs")
        self.matches = matches
        return matches
    
    def review_duplicates(self, sample_size=10):
        """Display sample duplicates for review"""
        print("\\n" + "="*80)
        print("SAMPLE DUPLICATE PAIRS FOR REVIEW")
        print("="*80)
        
        sample = self.matches.head(sample_size)
        for (idx1, idx2), scores in sample.iterrows():
            print(f"\\nPair {idx1} <-> {idx2} (Similarity: {scores.mean():.2%})")
            print("-" * 40)
            
            for col in self.df.columns[:5]:  # Show first 5 columns
                val1 = self.df.loc[idx1, col]
                val2 = self.df.loc[idx2, col]
                if val1 != val2:
                    print(f"{col:20} | {str(val1)[:30]:30} | {str(val2)[:30]}")
    
    def merge_strategy(self, idx1, idx2):
        """Define merging strategy for duplicate pairs"""
        row1 = self.df.loc[idx1]
        row2 = self.df.loc[idx2]
        merged = {}
        
        for col in self.df.columns:
            # Strategy: Keep non-null values, prefer most recent
            if pd.isna(row1[col]) and not pd.isna(row2[col]):
                merged[col] = row2[col]
            elif not pd.isna(row1[col]) and pd.isna(row2[col]):
                merged[col] = row1[col]
            elif 'date' in col.lower() or 'time' in col.lower():
                # For dates, keep the most recent
                try:
                    date1 = pd.to_datetime(row1[col])
                    date2 = pd.to_datetime(row2[col])
                    merged[col] = row1[col] if date1 >= date2 else row2[col]
                except:
                    merged[col] = row1[col]  # Default to first record
            else:
                # For other fields, keep from the more complete record
                merged[col] = row1[col] if row1.notna().sum() >= row2.notna().sum() else row2[col]
        
        return merged
    
    def execute_merge(self, auto_merge=False):
        """Execute the merge process"""
        logger.info("Starting merge process")
        
        # Group matches into clusters
        merged_indices = set()
        merge_groups = []
        
        for (idx1, idx2), _ in self.matches.iterrows():
            if idx1 not in merged_indices and idx2 not in merged_indices:
                group = {idx1, idx2}
                # Find all connected records
                for (i1, i2), _ in self.matches.iterrows():
                    if i1 in group or i2 in group:
                        group.update([i1, i2])
                merge_groups.append(list(group))
                merged_indices.update(group)
        
        logger.info(f"Found {len(merge_groups)} merge groups")
        
        # Create merged dataframe
        keep_indices = []
        merged_records = []
        
        for group in merge_groups:
            if auto_merge or self.confirm_merge(group):
                # Merge all records in group
                primary_idx = group[0]
                for idx in group[1:]:
                    merged_record = self.merge_strategy(primary_idx, idx)
                    self.df.loc[primary_idx] = merged_record
                keep_indices.append(primary_idx)
            else:
                # Keep all records if merge not confirmed
                keep_indices.extend(group)
        
        # Add non-duplicate records
        all_indices = set(range(len(self.df)))
        duplicate_indices = set(idx for group in merge_groups for idx in group)
        keep_indices.extend(all_indices - duplicate_indices)
        
        # Create final dataframe
        final_df = self.df.loc[sorted(keep_indices)].reset_index(drop=True)
        logger.info(f"Merged {len(self.df)} records into {len(final_df)} records")
        
        return final_df
    
    def confirm_merge(self, group):
        """Interactive confirmation for merging"""
        print(f"\\nMerge group with {len(group)} records: {group}")
        response = input("Merge these records? (y/n): ")
        return response.lower() == 'y'
    
    def save_results(self, output_df, suffix='_deduped'):
        """Save deduplicated data"""
        output_path = self.filepath.replace('.csv', f'{suffix}.csv')
        output_df.to_csv(output_path, index=False)
        logger.info(f"Saved deduplicated data to {output_path}")
        
        # Save merge report
        report_path = self.filepath.replace('.csv', '_merge_report.txt')
        with open(report_path, 'w') as f:
            f.write(f"Fuzzy Duplicate Merge Report\\n")
            f.write(f"Generated: {datetime.now()}\\n")
            f.write(f"Original records: {len(self.df)}\\n")
            f.write(f"Final records: {len(output_df)}\\n")
            f.write(f"Records merged: {len(self.df) - len(output_df)}\\n")
        
        logger.info(f"Saved merge report to {report_path}")

# Main execution
if __name__ == "__main__":
    # Configuration
    FILE_PATH = "${fileName}"
    MATCH_COLUMNS = [${fuzzyDuplicates[0].matchingFields.map(f => `'${f.field}'`).join(', ')}]
    THRESHOLD = ${fuzzyDuplicates[0].similarity || 85}
    
    # Run deduplication
    merger = FuzzyDuplicateMerger(FILE_PATH, THRESHOLD)
    merger.load_data()
    merger.find_duplicates(MATCH_COLUMNS)
    merger.review_duplicates()
    
    # Execute merge (set auto_merge=True for automatic merging)
    final_df = merger.execute_merge(auto_merge=False)
    merger.save_results(final_df)
`;
}

function generateStandardisationScript(standardisationNeeded, fileName) {
  return `#!/usr/bin/env python3
"""
Data Standardisation Script
Generated for: ${fileName}
Purpose: Standardise formats, clean data, and ensure consistency
"""

import pandas as pd
import re
import numpy as np
from datetime import datetime
import phonenumbers
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DataStandardiser:
    def __init__(self, filepath):
        self.filepath = filepath
        self.df = pd.read_csv(filepath)
        self.changes_log = []
        
    def standardise_phone_numbers(self, column, country='AU'):
        """Standardise phone numbers to E164 format"""
        logger.info(f"Standardising phone numbers in {column}")
        
        def clean_phone(phone):
            if pd.isna(phone):
                return phone
            try:
                # Parse phone number
                parsed = phonenumbers.parse(str(phone), country)
                if phonenumbers.is_valid_number(parsed):
                    # Return in national format
                    return phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.NATIONAL)
                else:
                    return f"INVALID_{phone}"
            except:
                # Try adding country code
                if str(phone).startswith('0'):
                    try:
                        parsed = phonenumbers.parse(f"+61{str(phone)[1:]}", None)
                        if phonenumbers.is_valid_number(parsed):
                            return phonenumbers.format_number(parsed, phonenumbers.PhoneNumberFormat.NATIONAL)
                    except:
                        pass
                return f"INVALID_{phone}"
        
        original = self.df[column].copy()
        self.df[column] = self.df[column].apply(clean_phone)
        
        changes = (original != self.df[column]).sum()
        self.changes_log.append(f"Phone standardisation in {column}: {changes} changes")
        logger.info(f"Standardised {changes} phone numbers")
        
    def standardise_addresses(self, columns):
        """Standardise address formats"""
        logger.info(f"Standardising addresses in {columns}")
        
        abbreviations = {
            'Street': 'St',
            'Road': 'Rd',
            'Avenue': 'Ave',
            'Place': 'Pl',
            'Drive': 'Dr',
            'Court': 'Ct',
            'Boulevard': 'Blvd',
            'Lane': 'Ln'
        }
        
        for col in columns:
            if col in self.df.columns:
                original = self.df[col].copy()
                
                # Standardise abbreviations
                for full, abbr in abbreviations.items():
                    self.df[col] = self.df[col].str.replace(f' {full}$', f' {abbr}', regex=True)
                    self.df[col] = self.df[col].str.replace(f' {full} ', f' {abbr} ', regex=True)
                
                # Standardise capitalisation
                self.df[col] = self.df[col].str.title()
                
                # Remove extra spaces
                self.df[col] = self.df[col].str.replace(r'\\s+', ' ', regex=True).str.strip()
                
                changes = (original != self.df[col]).sum()
                self.changes_log.append(f"Address standardisation in {col}: {changes} changes")
    
    def standardise_names(self, columns):
        """Standardise name formats"""
        logger.info(f"Standardising names in {columns}")
        
        for col in columns:
            if col in self.df.columns:
                original = self.df[col].copy()
                
                # Title case
                self.df[col] = self.df[col].str.title()
                
                # Handle special cases (McDonald, O'Brien, etc.)
                self.df[col] = self.df[col].str.replace(r"\\bMc(\\w)", lambda m: f"Mc{m.group(1).upper()}", regex=True)
                self.df[col] = self.df[col].str.replace(r"\\bO'(\\w)", lambda m: f"O'{m.group(1).upper()}", regex=True)
                
                # Remove extra spaces
                self.df[col] = self.df[col].str.replace(r'\\s+', ' ', regex=True).str.strip()
                
                changes = (original != self.df[col]).sum()
                self.changes_log.append(f"Name standardisation in {col}: {changes} changes")
    
    def standardise_dates(self, columns, target_format='%Y-%m-%d'):
        """Standardise date formats"""
        logger.info(f"Standardising dates to {target_format}")
        
        for col in columns:
            if col in self.df.columns:
                original = self.df[col].copy()
                
                # Try to parse dates with various formats
                self.df[col] = pd.to_datetime(self.df[col], errors='coerce', dayfirst=True)
                self.df[col] = self.df[col].dt.strftime(target_format)
                
                # Replace NaT with original values (couldn't parse)
                mask = self.df[col].isna()
                self.df.loc[mask, col] = original[mask]
                
                changes = (original != self.df[col]).sum()
                self.changes_log.append(f"Date standardisation in {col}: {changes} changes")
    
    def remove_duplicates(self, subset=None, keep='first'):
        """Remove duplicate rows"""
        logger.info("Removing duplicate rows")
        
        original_len = len(self.df)
        self.df = self.df.drop_duplicates(subset=subset, keep=keep)
        removed = original_len - len(self.df)
        
        self.changes_log.append(f"Duplicate removal: {removed} rows removed")
        logger.info(f"Removed {removed} duplicate rows")
    
    def save_results(self):
        """Save standardised data and change log"""
        output_path = self.filepath.replace('.csv', '_standardised.csv')
        self.df.to_csv(output_path, index=False)
        logger.info(f"Saved standardised data to {output_path}")
        
        # Save change log
        log_path = self.filepath.replace('.csv', '_standardisation_log.txt')
        with open(log_path, 'w') as f:
            f.write(f"Data Standardisation Log\\n")
            f.write(f"Generated: {datetime.now()}\\n")
            f.write(f"Original file: {self.filepath}\\n\\n")
            f.write("Changes made:\\n")
            for change in self.changes_log:
                f.write(f"- {change}\\n")
        
        logger.info(f"Saved change log to {log_path}")
        
        return output_path

# Main execution
if __name__ == "__main__":
    FILE_PATH = "${fileName}"
    
    standardiser = DataStandardiser(FILE_PATH)
    
    # Apply standardisation based on detected issues
    ${generateStandardisationCalls(standardisationNeeded)}
    
    # Save results
    output_file = standardiser.save_results()
    print(f"\\nStandardisation complete! Output saved to: {output_file}")
`;
}

function generateStandardisationCalls(issues) {
  const calls = [];
  
  if (issues.phoneColumns) {
    calls.push(`standardiser.standardise_phone_numbers('${issues.phoneColumns[0]}')`);
  }
  
  if (issues.addressColumns) {
    calls.push(`standardiser.standardise_addresses([${issues.addressColumns.map(c => `'${c}'`).join(', ')}])`);
  }
  
  if (issues.nameColumns) {
    calls.push(`standardiser.standardise_names([${issues.nameColumns.map(c => `'${c}'`).join(', ')}])`);
  }
  
  if (issues.dateColumns) {
    calls.push(`standardiser.standardise_dates([${issues.dateColumns.map(c => `'${c}'`).join(', ')}])`);
  }
  
  calls.push('standardiser.remove_duplicates()');
  
  return calls.join('\\n    ');
}

function generateOutlierScript(outliers, fileName) {
  return `#!/usr/bin/env python3
"""
Outlier Detection and Handling Script
Generated for: ${fileName}
Purpose: Identify and handle statistical outliers
"""

import pandas as pd
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class OutlierHandler:
    def __init__(self, filepath):
        self.filepath = filepath
        self.df = pd.read_csv(filepath)
        self.outliers = {}
        
    def detect_outliers_iqr(self, column, multiplier=1.5):
        """Detect outliers using IQR method"""
        Q1 = self.df[column].quantile(0.25)
        Q3 = self.df[column].quantile(0.75)
        IQR = Q3 - Q1
        
        lower_bound = Q1 - multiplier * IQR
        upper_bound = Q3 + multiplier * IQR
        
        outliers = self.df[(self.df[column] < lower_bound) | (self.df[column] > upper_bound)]
        return outliers.index.tolist(), lower_bound, upper_bound
    
    def detect_outliers_zscore(self, column, threshold=3):
        """Detect outliers using Z-score method"""
        z_scores = np.abs(stats.zscore(self.df[column].dropna()))
        outliers = np.where(z_scores > threshold)[0]
        return outliers.tolist()
    
    def detect_outliers_isolation_forest(self, columns):
        """Detect multivariate outliers using Isolation Forest"""
        from sklearn.ensemble import IsolationForest
        
        X = self.df[columns].dropna()
        clf = IsolationForest(contamination=0.1, random_state=42)
        outliers = clf.fit_predict(X)
        
        return X[outliers == -1].index.tolist()
    
    def visualize_outliers(self, column):
        """Create visualizations for outlier analysis"""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # Box plot
        axes[0, 0].boxplot(self.df[column].dropna())
        axes[0, 0].set_title(f'Box Plot - {column}')
        
        # Histogram
        axes[0, 1].hist(self.df[column].dropna(), bins=50, edgecolor='black')
        axes[0, 1].set_title(f'Histogram - {column}')
        
        # Q-Q plot
        stats.probplot(self.df[column].dropna(), dist="norm", plot=axes[1, 0])
        axes[1, 0].set_title(f'Q-Q Plot - {column}')
        
        # Scatter plot with outliers highlighted
        outlier_indices, _, _ = self.detect_outliers_iqr(column)
        colors = ['red' if i in outlier_indices else 'blue' for i in range(len(self.df))]
        axes[1, 1].scatter(range(len(self.df)), self.df[column], c=colors, alpha=0.5)
        axes[1, 1].set_title(f'Scatter Plot - {column} (outliers in red)')
        
        plt.tight_layout()
        plt.savefig(f'{column}_outlier_analysis.png')
        plt.close()
        
        logger.info(f"Saved outlier visualization for {column}")
    
    def handle_outliers(self, column, method='cap', **kwargs):
        """Handle outliers using specified method"""
        outlier_indices, lower_bound, upper_bound = self.detect_outliers_iqr(column)
        
        if method == 'remove':
            # Remove outliers
            self.df = self.df.drop(outlier_indices)
            logger.info(f"Removed {len(outlier_indices)} outliers from {column}")
            
        elif method == 'cap':
            # Cap outliers at bounds
            self.df.loc[self.df[column] < lower_bound, column] = lower_bound
            self.df.loc[self.df[column] > upper_bound, column] = upper_bound
            logger.info(f"Capped {len(outlier_indices)} outliers in {column}")
            
        elif method == 'transform':
            # Log transformation
            self.df[f'{column}_log'] = np.log1p(self.df[column])
            logger.info(f"Applied log transformation to {column}")
            
        elif method == 'impute':
            # Impute with median
            median = self.df[column].median()
            self.df.loc[outlier_indices, column] = median
            logger.info(f"Imputed {len(outlier_indices)} outliers with median in {column}")
        
        self.outliers[column] = {
            'method': method,
            'count': len(outlier_indices),
            'bounds': (lower_bound, upper_bound)
        }
    
    def generate_report(self):
        """Generate outlier analysis report"""
        report = []
        report.append("OUTLIER ANALYSIS REPORT")
        report.append(f"Generated: {datetime.now()}")
        report.append(f"File: {self.filepath}")
        report.append("")
        
        for column, info in self.outliers.items():
            report.append(f"\\n{column}:")
            report.append(f"  Method: {info['method']}")
            report.append(f"  Outliers: {info['count']}")
            report.append(f"  Bounds: [{info['bounds'][0]:.2f}, {info['bounds'][1]:.2f}]")
        
        return "\\n".join(report)
    
    def save_results(self):
        """Save cleaned data and report"""
        output_path = self.filepath.replace('.csv', '_outliers_handled.csv')
        self.df.to_csv(output_path, index=False)
        logger.info(f"Saved cleaned data to {output_path}")
        
        report_path = self.filepath.replace('.csv', '_outlier_report.txt')
        with open(report_path, 'w') as f:
            f.write(self.generate_report())
        logger.info(f"Saved outlier report to {report_path}")

# Main execution
if __name__ == "__main__":
    FILE_PATH = "${fileName}"
    NUMERIC_COLUMNS = [${outliers.map(o => `'${o.field}'`).join(', ')}]
    
    handler = OutlierHandler(FILE_PATH)
    
    # Analyze and handle outliers for each numeric column
    for column in NUMERIC_COLUMNS:
        if column in handler.df.columns:
            # Visualize outliers
            handler.visualize_outliers(column)
            
            # Handle outliers (method can be: 'remove', 'cap', 'transform', 'impute')
            handler.handle_outliers(column, method='cap')
    
    # Save results
    handler.save_results()
    print("\\nOutlier handling complete!")
`;
}

function generateImputationScript(missingValues, fileName) {
  return `#!/usr/bin/env python3
"""
Missing Value Imputation Script
Generated for: ${fileName}
Purpose: Handle missing values using appropriate imputation strategies
"""

import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer, KNNImputer
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MissingValueHandler:
    def __init__(self, filepath):
        self.filepath = filepath
        self.df = pd.read_csv(filepath)
        self.imputation_log = []
        
    def analyze_missing_patterns(self):
        """Analyze patterns in missing data"""
        missing_counts = self.df.isnull().sum()
        missing_percent = (missing_counts / len(self.df)) * 100
        
        missing_df = pd.DataFrame({
            'Column': missing_counts.index,
            'Missing_Count': missing_counts.values,
            'Missing_Percent': missing_percent.values
        })
        
        missing_df = missing_df[missing_df['Missing_Count'] > 0].sort_values('Missing_Percent', ascending=False)
        
        print("\\nMissing Value Analysis:")
        print(missing_df.to_string(index=False))
        
        return missing_df
    
    def impute_categorical(self, column, strategy='mode'):
        """Impute missing categorical values"""
        if column not in self.df.columns:
            return
            
        missing_count = self.df[column].isnull().sum()
        if missing_count == 0:
            return
            
        if strategy == 'mode':
            mode_value = self.df[column].mode()[0] if len(self.df[column].mode()) > 0 else 'Unknown'
            self.df[column].fillna(mode_value, inplace=True)
            self.imputation_log.append(f"{column}: Imputed {missing_count} values with mode '{mode_value}'")
        elif strategy == 'unknown':
            self.df[column].fillna('Unknown', inplace=True)
            self.imputation_log.append(f"{column}: Imputed {missing_count} values with 'Unknown'")
    
    def impute_numeric(self, column, strategy='median'):
        """Impute missing numeric values"""
        if column not in self.df.columns:
            return
            
        missing_count = self.df[column].isnull().sum()
        if missing_count == 0:
            return
            
        if strategy == 'mean':
            mean_value = self.df[column].mean()
            self.df[column].fillna(mean_value, inplace=True)
            self.imputation_log.append(f"{column}: Imputed {missing_count} values with mean {mean_value:.2f}")
        elif strategy == 'median':
            median_value = self.df[column].median()
            self.df[column].fillna(median_value, inplace=True)
            self.imputation_log.append(f"{column}: Imputed {missing_count} values with median {median_value:.2f}")
        elif strategy == 'forward_fill':
            self.df[column].fillna(method='ffill', inplace=True)
            self.imputation_log.append(f"{column}: Imputed {missing_count} values with forward fill")
        elif strategy == 'interpolate':
            self.df[column].interpolate(method='linear', inplace=True)
            self.imputation_log.append(f"{column}: Imputed {missing_count} values with linear interpolation")
    
    def impute_knn(self, columns, n_neighbors=5):
        """Impute using KNN imputation"""
        if not all(col in self.df.columns for col in columns):
            return
            
        imputer = KNNImputer(n_neighbors=n_neighbors)
        self.df[columns] = imputer.fit_transform(self.df[columns])
        
        self.imputation_log.append(f"KNN imputation on {columns} with {n_neighbors} neighbors")
    
    def impute_mice(self, columns, max_iter=10):
        """Impute using MICE (Multiple Imputation by Chained Equations)"""
        if not all(col in self.df.columns for col in columns):
            return
            
        imputer = IterativeImputer(max_iter=max_iter, random_state=42)
        self.df[columns] = imputer.fit_transform(self.df[columns])
        
        self.imputation_log.append(f"MICE imputation on {columns} with {max_iter} iterations")
    
    def save_results(self):
        """Save imputed data and log"""
        output_path = self.filepath.replace('.csv', '_imputed.csv')
        self.df.to_csv(output_path, index=False)
        logger.info(f"Saved imputed data to {output_path}")
        
        log_path = self.filepath.replace('.csv', '_imputation_log.txt')
        with open(log_path, 'w') as f:
            f.write("Missing Value Imputation Log\\n")
            f.write(f"Generated: {pd.Timestamp.now()}\\n")
            f.write(f"Original file: {self.filepath}\\n\\n")
            f.write("Imputation strategies applied:\\n")
            for log_entry in self.imputation_log:
                f.write(f"- {log_entry}\\n")
        
        logger.info(f"Saved imputation log to {log_path}")

# Main execution
if __name__ == "__main__":
    FILE_PATH = "${fileName}"
    
    handler = MissingValueHandler(FILE_PATH)
    
    # Analyze missing patterns
    missing_analysis = handler.analyze_missing_patterns()
    
    # Apply imputation strategies based on column types and patterns
    ${generateImputationCalls(missingValues)}
    
    # Save results
    handler.save_results()
    print("\\nMissing value imputation complete!")
`;
}

function generateImputationCalls(missingValues) {
  const calls = [];
  
  Object.entries(missingValues).forEach(([column, info]) => {
    if (info.type === 'categorical') {
      calls.push(`handler.impute_categorical('${column}', strategy='mode')`);
    } else if (info.type === 'numeric') {
      if (info.pattern === 'MCAR') {
        calls.push(`handler.impute_numeric('${column}', strategy='median')`);
      } else if (info.pattern === 'MAR') {
        calls.push(`# Consider using KNN or MICE for ${column} (MAR pattern detected)`);
      }
    }
  });
  
  return calls.join('\\n    ');
}

function formatPythonOutput(scripts, fileName) {
  const output = [];
  
  output.push('# Data Quality Fix Scripts - Python');
  output.push(`# Generated for: ${fileName}`);
  output.push(`# Generated: ${new Date().toISOString()}`);
  output.push('# Install requirements: pip install pandas numpy scipy scikit-learn fuzzywuzzy python-Levenshtein phonenumbers recordlinkage matplotlib seaborn');
  output.push('');
  
  if (scripts.fuzzyMatching) {
    output.push('# ========================================');
    output.push('# FUZZY DUPLICATE MATCHING AND MERGING');
    output.push('# ========================================');
    output.push(scripts.fuzzyMatching);
    output.push('');
  }
  
  if (scripts.dataStandardisation) {
    output.push('# ========================================');
    output.push('# DATA STANDARDISATION');
    output.push('# ========================================');
    output.push(scripts.dataStandardisation);
    output.push('');
  }
  
  if (scripts.outlierHandling) {
    output.push('# ========================================');
    output.push('# OUTLIER DETECTION AND HANDLING');
    output.push('# ========================================');
    output.push(scripts.outlierHandling);
    output.push('');
  }
  
  if (scripts.missingValueImputation) {
    output.push('# ========================================');
    output.push('# MISSING VALUE IMPUTATION');
    output.push('# ========================================');
    output.push(scripts.missingValueImputation);
  }
  
  return output.join('\n');
}

async function integrity(filePath, options = {}) {
  const outputHandler = new OutputHandler(options);
  const spinner = options.quiet ? null : ora('Reading CSV file...').start();
  
  // Structured data mode for LLM consumption
  const structuredMode = options.structuredOutput || options.llmMode;
  
  try {
    // Load data
    let data, headers, columnTypes;
    if (options.preloadedData) {
      data = options.preloadedData.records;
      headers = Object.keys(data[0] || {});
      columnTypes = options.preloadedData.columnTypes;
    } else {
      data = await parseCSV(filePath, { quiet: options.quiet, header: options.header });
      headers = Object.keys(data[0] || {});
      
      if (spinner) spinner.text = 'Detecting column types...';
      columnTypes = detectColumnTypes(data);
    }
    
    const fileName = basename(filePath);
    
    // Handle empty dataset
    if (data.length === 0) {
      let report = createSection('DATA INTEGRITY REPORT',
        `Dataset: ${fileName}\nGenerated: ${formatTimestamp()}\n\n⚠️  Empty dataset - no data to check`);
      
      // Still include the required section header
      report += createSubSection('DATA QUALITY METRICS', 'No data available to analyze');
      
      console.log(report);
      outputHandler.finalize();
      return;
    }

    // Initialize results structure
    const analysisResults = {
      fileName,
      timestamp: formatTimestamp(),
      recordCount: data.length,
      columnCount: headers.length,
      dimensions: {},
      businessRules: null,
      patterns: null,
      anomalies: null,
      fuzzyDuplicates: null,
      australianValidation: null,
      qualityScore: null,
      fixes: {
        sql: null,
        python: null
      }
    };

    // Run quality dimension validators
    if (spinner) spinner.text = 'Analyzing data completeness...';
    analysisResults.dimensions.completeness = analyseCompleteness(data, headers);

    if (spinner) spinner.text = 'Validating data formats...';
    analysisResults.dimensions.validity = analyseValidity(data, headers, columnTypes);

    if (spinner) spinner.text = 'Checking data accuracy...';
    analysisResults.dimensions.accuracy = analyseAccuracy(data, headers, columnTypes);

    if (spinner) spinner.text = 'Evaluating data consistency...';
    analysisResults.dimensions.consistency = analyseConsistency(data, headers);

    if (spinner) spinner.text = 'Assessing data timeliness...';
    analysisResults.dimensions.timeliness = analyseTimeliness(data, headers);

    if (spinner) spinner.text = 'Detecting duplicate records...';
    analysisResults.dimensions.uniqueness = analyseUniqueness(data, headers);

    // Run advanced detectors
    if (spinner) spinner.text = 'Discovering business rules...';
    analysisResults.businessRules = detectBusinessRules(data, headers, columnTypes);

    if (spinner) spinner.text = 'Detecting patterns...';
    analysisResults.patterns = detectPatterns(data, headers, columnTypes);

    if (spinner) spinner.text = 'Finding anomalies...';
    analysisResults.anomalies = detectAnomalies$2(data, headers, columnTypes);

    // Run specialised analysers
    if (data.length < 10000) {
      if (spinner) spinner.text = 'Performing fuzzy duplicate analysis...';
      analysisResults.fuzzyDuplicates = analyseFuzzyDuplicates(data, headers);
    }

    if (spinner) spinner.text = 'Checking for Australian-specific data...';
    analysisResults.australianValidation = validateAustralianData(data, headers);

    // Calculate quality score
    if (spinner) spinner.text = 'Calculating data quality score...';
    analysisResults.qualityScore = calculateQualityScore(analysisResults.dimensions);

    // Generate fixes
    if (spinner) spinner.text = 'Generating automated fixes...';
    analysisResults.fixes.sql = generateSQLFixes(analysisResults);
    analysisResults.fixes.python = generatePythonFixes(analysisResults, fileName);

    // Return structured data if requested for LLM consumption
    if (structuredMode) {
      if (spinner) spinner.succeed('Data integrity analysis complete!');
      return {
        analysis: analysisResults,
        structuredResults: {
          overallQuality: {
            score: analysisResults.qualityScore.overallScore,
            grade: analysisResults.qualityScore.grade.letter,
            trend: 'stable'
          },
          validationResults: [],
          businessRules: analysisResults.businessRules || [],
          referentialIntegrity: [],
          patternAnomalies: analysisResults.anomalies || [],
          suggestedFixes: [
            ...(analysisResults.fixes.sql ? ['SQL automated fixes available'] : []),
            ...(analysisResults.fixes.python ? ['Python automated fixes available'] : [])
          ],
          dimensions: {
            completeness: analysisResults.dimensions.completeness,
            accuracy: analysisResults.dimensions.accuracy,
            consistency: analysisResults.dimensions.consistency,
            validity: analysisResults.dimensions.validity,
            uniqueness: analysisResults.dimensions.uniqueness,
            timeliness: analysisResults.dimensions.timeliness
          }
        }
      };
    }
    
    // Generate report
    if (spinner) spinner.succeed('Data integrity analysis complete!');
    
    const report = generateComprehensiveReport(analysisResults);
    console.log(report);

    // Save fix scripts if requested
    if (options.generateFixes) {
      await saveFixes(analysisResults.fixes, fileName);
    }

    outputHandler.finalize();
    return analysisResults;

  } catch (error) {
    outputHandler.restore();
    if (spinner) spinner.fail('Error checking integrity');
    console.error(error.message);
    if (!options.quiet) process.exit(1);
    throw error;
  }
}

function generateComprehensiveReport(results) {
  let report = '';

  // Header
  report += createSection('DATA INTEGRITY REPORT',
    `Dataset: ${results.fileName}
Generated: ${results.timestamp}
Quality Framework: ISO 8000 / DAMA-DMBOK Aligned`);

  // Overall Quality Score
  const score = results.qualityScore;
  report += `\nOVERALL DATA QUALITY SCORE: ${score.overallScore}/100 (${score.grade.letter})
${score.grade.label}
${score.trend.symbol} ${score.trend.interpretation}
${score.benchmark.interpretation}\n`;

  // Critical Issues Summary
  const criticalIssues = collectCriticalIssues(results.dimensions);
  if (criticalIssues.length > 0) {
    report += createSubSection('CRITICAL ISSUES (immediate action required)',
      numberedList(criticalIssues.map(issue => 
        `${issue.field || issue.category}: ${issue.message} [${issue.type}]`
      ))
    );
  }

  // Warnings Summary
  const warnings = collectWarnings(results.dimensions);
  if (warnings.length > 0) {
    report += createSubSection('WARNINGS (should be addressed)',
      numberedList(warnings.slice(0, 10).map(issue => 
        `${issue.field || issue.category}: ${issue.message}`
      ))
    );
    if (warnings.length > 10) {
      report += `\n... and ${warnings.length - 10} more warnings\n`;
    }
  }

  // Business Rule Discovery
  if (results.businessRules && results.businessRules.length > 0) {
    report += createSubSection('BUSINESS RULE DISCOVERY',
      `Automatically Detected Rules (Confidence >95%):\n\n` +
      results.businessRules.slice(0, 5).map((rule, idx) => 
        `${idx + 1}. ${rule.type}: ${rule.rule}
   - Confidence: ${rule.confidence.toFixed(1)}%
   - Violations: ${rule.violations} records
   - SQL: ${rule.sql}`
      ).join('\n\n')
    );
  }

  // Pattern-Based Anomalies
  if (results.anomalies) {
    report += generateAnomalyReport(results.anomalies);
  }

  // Fuzzy Duplicate Analysis
  if (results.fuzzyDuplicates && results.fuzzyDuplicates.nearDuplicateGroups.length > 0) {
    report += createSubSection('FUZZY DUPLICATE ANALYSIS',
      `Algorithm Stack: ${results.fuzzyDuplicates.algorithms.join(', ')}
Near-Duplicate Groups Found: ${results.fuzzyDuplicates.nearDuplicateGroups.length}

Top Groups:
${results.fuzzyDuplicates.nearDuplicateGroups.slice(0, 3).map((group, idx) => 
  `[Group ${idx + 1}] ${group.recordCount} records (${group.similarity}% similarity)
${group.records.slice(0, 3).map(r => 
  `  - Row ${r.index}: ${JSON.stringify(r.data).substring(0, 80)}...`
).join('\n')}`
).join('\n\n')}`
    );
  }

  // Australian Data Validation
  if (results.australianValidation && results.australianValidation.detected) {
    report += generateAustralianValidationReport(results.australianValidation);
  }

  // Data Quality Metrics
  report += createSection('DATA QUALITY METRICS',
    `Overall Score: ${score.overallScore}/100 (${score.grade.letter})

Dimensional Breakdown:
┌─────────────────┬────────┬────────────────────────┐
│ Dimension       │ Score  │ Key Issues             │
├─────────────────┼────────┼────────────────────────┤
${score.scoreBreakdown.map(dim => 
  `│ ${dim.dimension.padEnd(15)} │ ${String(dim.score).padEnd(6)} │ ${dim.performance.padEnd(22)} │`
).join('\n')}
└─────────────────┴────────┴────────────────────────┘`
  );

  // Recommendations
  if (score.recommendations) {
    report += createSubSection('RECOMMENDATION PRIORITY MATRIX', '');
    
    if (score.recommendations.quickWins.length > 0) {
      report += '\n🎯 Quick Wins (High Impact, Low Effort):\n';
      report += numberedList(score.recommendations.quickWins.map(r => 
        `${r.action} [Impact: ${r.impact}, Effort: ${r.effort}]`
      ));
    }

    if (score.recommendations.strategic.length > 0) {
      report += '\n📋 Strategic Initiatives (High Impact, High Effort):\n';
      report += numberedList(score.recommendations.strategic.map(r => 
        `${r.action} [Impact: ${r.impact}, Effort: ${r.effort}]`
      ));
    }
  }

  // Automated Fix Scripts Available
  report += createSubSection('AUTOMATED FIX SCRIPTS',
    `SQL fixes available: ${results.fixes.sql ? 'Yes' : 'No'}
Python scripts available: ${results.fixes.python ? 'Yes' : 'No'}

To generate fix scripts, run with --generate-fixes flag`
  );

  // Data Quality Certification
  if (score.certification.certified) {
    report += createSubSection('DATA QUALITY CERTIFICATION',
      `${score.certification.badge} Achieved ${score.certification.level} Certification
Valid until: ${score.certification.validUntil}`
    );
  } else {
    report += createSubSection('CERTIFICATION STATUS',
      `Not yet certified. To achieve ${score.certification.nextLevel}:
- Improve score by ${score.certification.gap.score.toFixed(1)} points
- Fix ${score.certification.gap.criticalIssues} critical issues
- Resolve ${score.certification.gap.warnings} warnings`
    );
  }

  return report;
}

function collectCriticalIssues(dimensions) {
  const issues = [];
  Object.values(dimensions).forEach(dim => {
    if (dim.issues) {
      issues.push(...dim.issues.filter(i => i.type === 'critical'));
    }
  });
  return issues;
}

function collectWarnings(dimensions) {
  const warnings = [];
  Object.values(dimensions).forEach(dim => {
    if (dim.issues) {
      warnings.push(...dim.issues.filter(i => i.type === 'warning'));
    }
  });
  return warnings;
}

function generateAnomalyReport(anomalies) {
  let report = createSubSection('PATTERN-BASED ANOMALIES', '');

  if (anomalies.benfordLaw.length > 0) {
    report += "\nBenford's Law Analysis:\n";
    anomalies.benfordLaw.forEach(result => {
      report += `- ${result.field}: ${result.interpretation} (χ² = ${result.chiSquare}, p ${result.pValue})\n`;
    });
  }

  if (anomalies.roundNumberBias.length > 0) {
    report += '\nRound Number Bias:\n';
    anomalies.roundNumberBias.forEach(result => {
      report += `- ${result.field}: ${result.interpretation}\n`;
      result.biases.forEach(bias => {
        report += `  * ${bias.pattern}: ${bias.observedRate} vs expected ${bias.expectedRate}\n`;
      });
    });
  }

  if (anomalies.fraudIndicators.length > 0) {
    report += '\nPotential Fraud Indicators:\n';
    anomalies.fraudIndicators.forEach(indicator => {
      report += `- ${indicator.type}: ${indicator.interpretation}\n`;
    });
  }

  return report;
}

function generateAustralianValidationReport(validation) {
  let report = createSubSection('AUSTRALIAN DATA VALIDATION', '');

  if (validation.validations.abn) {
    const abn = validation.validations.abn;
    report += `\nABN Validation:
- Valid format: ${abn.valid}/${abn.total} (${abn.validRate})
- Invalid check digit: ${abn.invalid.length}
- Defunct companies: ${abn.defunct.length}\n`;
  }

  if (validation.validations.postcodes) {
    const pc = validation.validations.postcodes;
    report += `\nPostcode Analysis:
- Valid postcodes: ${pc.valid}/${pc.total} (${pc.validRate})
- State mismatches: ${pc.stateMismatches.length}
- Distribution: ${Object.entries(pc.distribution).map(([state, pct]) => `${state}: ${pct}`).join(', ')}\n`;
  }

  if (validation.validations.phoneNumbers) {
    report += '\nPhone Number Validation:\n';
    Object.entries(validation.validations.phoneNumbers).forEach(([col, result]) => {
      report += `- ${col}: ${result.validRate} valid (Mobile: ${result.breakdown.mobile}, Landline: ${result.breakdown.landline})\n`;
    });
  }

  return report;
}

async function saveFixes(fixes, fileName) {
  const fs = await import('fs/promises');
  
  if (fixes.sql) {
    const sqlFile = fileName.replace('.csv', '_fixes.sql');
    await fs.writeFile(sqlFile, fixes.sql);
    console.log(`\n✅ SQL fixes saved to: ${sqlFile}`);
  }

  if (fixes.python) {
    const pyFile = fileName.replace('.csv', '_fixes.py');
    await fs.writeFile(pyFile, fixes.python);
    console.log(`✅ Python scripts saved to: ${pyFile}`);
  }
}

class VisualTaskDetector {
  constructor() {
    this.tasks = {
      TREND_ANALYSIS: 'trend_analysis',
      PART_TO_WHOLE: 'part_to_whole',
      CORRELATION: 'correlation',
      DISTRIBUTION: 'distribution',
      COMPARISON: 'comparison',
      RANKING: 'ranking',
      DEVIATION: 'deviation',
      GEOSPATIAL: 'geospatial',
      COMPOSITION: 'composition',
      FLOW: 'flow',
      HIERARCHY: 'hierarchy',
      PATTERN: 'pattern'
    };
  }

  detectTasks(data, columnTypes) {
    const tasks = [];
    const columns = Object.keys(columnTypes);
    
    // Analyze column types
    const numericColumns = columns.filter(col => 
      ['integer', 'float'].includes(columnTypes[col].type)
    );
    const dateColumns = columns.filter(col => 
      columnTypes[col].type === 'date'
    );
    const categoricalColumns = columns.filter(col => 
      columnTypes[col].type === 'categorical'
    );
    const geographicColumns = this.findGeographicColumns(columns, columnTypes);
    
    // Detect temporal patterns
    if (dateColumns.length > 0) {
      const temporalStrength = this.calculateTemporalStrength(data, dateColumns[0]);
      if (temporalStrength > 0.7) {
        tasks.push({
          type: this.tasks.TREND_ANALYSIS,
          priority: 1,
          strength: temporalStrength,
          columns: {
            temporal: dateColumns[0],
            measures: numericColumns
          },
          description: 'Strong temporal patterns detected - ideal for trend analysis'
        });
      }
      
      // Check for seasonality
      const seasonality = this.detectSeasonality(data, dateColumns[0], numericColumns[0]);
      if (seasonality.detected) {
        tasks.push({
          type: this.tasks.PATTERN,
          priority: 2,
          strength: seasonality.strength,
          pattern: seasonality.type,
          columns: {
            temporal: dateColumns[0],
            measure: numericColumns[0]
          },
          description: `${seasonality.type} seasonality pattern detected`
        });
      }
    }
    
    // Detect part-to-whole relationships
    if (categoricalColumns.length > 0 && numericColumns.length > 0) {
      const partToWhole = this.detectPartToWhole(data, categoricalColumns, numericColumns);
      if (partToWhole.detected) {
        tasks.push({
          type: this.tasks.PART_TO_WHOLE,
          priority: partToWhole.categories <= 5 ? 1 : 3,
          strength: partToWhole.strength,
          columns: partToWhole.columns,
          description: `${partToWhole.categories} categories comprise the whole`
        });
      }
    }
    
    // Detect correlations
    if (numericColumns.length >= 2) {
      const correlations = this.detectCorrelations(data, numericColumns);
      if (correlations.length > 0) {
        tasks.push({
          type: this.tasks.CORRELATION,
          priority: 2,
          strength: Math.max(...correlations.map(c => Math.abs(c.correlation))),
          relationships: correlations,
          description: `${correlations.length} significant correlations found`
        });
      }
    }
    
    // Detect distributions
    if (numericColumns.length > 0) {
      numericColumns.forEach(col => {
        const distribution = this.analyzeDistribution(data, col);
        tasks.push({
          type: this.tasks.DISTRIBUTION,
          priority: 3,
          columns: {
            measure: col
          },
          characteristics: distribution,
          description: `${distribution.type} distribution for ${col}`
        });
      });
    }
    
    // Detect comparison opportunities
    if (categoricalColumns.length > 0 && numericColumns.length > 0) {
      const comparisons = this.detectComparisons(data, categoricalColumns, numericColumns);
      comparisons.forEach(comp => {
        tasks.push({
          type: this.tasks.COMPARISON,
          priority: 2,
          ...comp
        });
      });
    }
    
    // Detect ranking opportunities
    if (categoricalColumns.length > 0 && numericColumns.length > 0) {
      const ranking = this.detectRanking(data, categoricalColumns[0], numericColumns[0]);
      if (ranking.suitable) {
        tasks.push({
          type: this.tasks.RANKING,
          priority: 2,
          ...ranking
        });
      }
    }
    
    // Detect geographic patterns
    if (geographicColumns.length > 0 && numericColumns.length > 0) {
      tasks.push({
        type: this.tasks.GEOSPATIAL,
        priority: 2,
        columns: {
          geographic: geographicColumns[0],
          measure: numericColumns[0]
        },
        description: 'Geographic data detected - suitable for map visualization'
      });
    }
    
    // Detect hierarchical relationships
    const hierarchy = this.detectHierarchy(data, columns);
    if (hierarchy.detected) {
      tasks.push({
        type: this.tasks.HIERARCHY,
        priority: 2,
        ...hierarchy
      });
    }
    
    // Sort by priority and return
    return tasks.sort((a, b) => a.priority - b.priority);
  }
  
  calculateTemporalStrength(data, dateColumn) {
    if (!dateColumn || data.length < 10) return 0;
    
    // Check if dates are sequential and evenly spaced
    const dates = data
      .map(r => r[dateColumn])
      .filter(d => d instanceof Date)
      .sort((a, b) => a - b);
    
    if (dates.length < 10) return 0;
    
    // Calculate intervals
    const intervals = [];
    for (let i = 1; i < dates.length; i++) {
      intervals.push(dates[i] - dates[i-1]);
    }
    
    // Check consistency of intervals
    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
    const variance = intervals.reduce((sum, int) => sum + Math.pow(int - avgInterval, 2), 0) / intervals.length;
    const cv = Math.sqrt(variance) / avgInterval; // Coefficient of variation
    
    // Lower CV means more regular time series
    return Math.max(0, 1 - cv);
  }
  
  detectSeasonality(data, dateColumn, valueColumn) {
    if (!dateColumn || !valueColumn || data.length < 100) {
      return { detected: false };
    }
    
    // Group by time periods
    const monthlyData = {};
    const weeklyData = {};
    const dailyData = {};
    
    data.forEach(row => {
      const date = row[dateColumn];
      const value = row[valueColumn];
      if (date instanceof Date && typeof value === 'number') {
        const month = date.getMonth();
        const dayOfWeek = date.getDay();
        const dayOfMonth = date.getDate();
        
        monthlyData[month] = monthlyData[month] || [];
        monthlyData[month].push(value);
        
        weeklyData[dayOfWeek] = weeklyData[dayOfWeek] || [];
        weeklyData[dayOfWeek].push(value);
        
        dailyData[dayOfMonth] = dailyData[dayOfMonth] || [];
        dailyData[dayOfMonth].push(value);
      }
    });
    
    // Calculate variance across periods
    const monthlyVariance = this.calculatePeriodVariance(monthlyData);
    const weeklyVariance = this.calculatePeriodVariance(weeklyData);
    
    if (monthlyVariance > 0.3) {
      return {
        detected: true,
        type: 'monthly',
        strength: monthlyVariance
      };
    } else if (weeklyVariance > 0.3) {
      return {
        detected: true,
        type: 'weekly',
        strength: weeklyVariance
      };
    }
    
    return { detected: false };
  }
  
  calculatePeriodVariance(periodData) {
    const periodAverages = Object.values(periodData).map(values => 
      values.reduce((a, b) => a + b) / values.length
    );
    
    if (periodAverages.length < 2) return 0;
    
    const globalAverage = periodAverages.reduce((a, b) => a + b) / periodAverages.length;
    const variance = periodAverages.reduce((sum, avg) => 
      sum + Math.pow(avg - globalAverage, 2), 0
    ) / periodAverages.length;
    
    return Math.sqrt(variance) / globalAverage;
  }
  
  detectPartToWhole(data, categoricalColumns, numericColumns) {
    for (const catCol of categoricalColumns) {
      const uniqueValues = new Set(data.map(r => r[catCol])).size;
      
      if (uniqueValues >= 2 && uniqueValues <= 10) {
        // Check if numeric column sums to meaningful total
        for (const numCol of numericColumns) {
          const categoryTotals = {};
          data.forEach(row => {
            const cat = row[catCol];
            const val = row[numCol];
            if (cat && typeof val === 'number') {
              categoryTotals[cat] = (categoryTotals[cat] || 0) + val;
            }
          });
          
          const total = Object.values(categoryTotals).reduce((a, b) => a + b, 0);
          const percentages = Object.values(categoryTotals).map(v => v / total);
          
          // Check if this looks like a meaningful part-to-whole
          if (percentages.every(p => p > 0.01 && p < 0.99)) {
            return {
              detected: true,
              categories: uniqueValues,
              strength: 1 - this.calculateGini(percentages),
              columns: {
                category: catCol,
                value: numCol
              }
            };
          }
        }
      }
    }
    
    return { detected: false };
  }
  
  calculateGini(values) {
    // Gini coefficient for inequality measurement
    const sorted = [...values].sort((a, b) => a - b);
    const n = sorted.length;
    let sum = 0;
    
    for (let i = 0; i < n; i++) {
      sum += (2 * (i + 1) - n - 1) * sorted[i];
    }
    
    return sum / (n * sorted.reduce((a, b) => a + b, 0));
  }
  
  detectCorrelations(data, numericColumns) {
    const correlations = [];
    
    for (let i = 0; i < numericColumns.length; i++) {
      for (let j = i + 1; j < numericColumns.length; j++) {
        const col1 = numericColumns[i];
        const col2 = numericColumns[j];
        
        const pairs = data
          .filter(r => typeof r[col1] === 'number' && typeof r[col2] === 'number')
          .map(r => [r[col1], r[col2]]);
        
        if (pairs.length < 10) continue;
        
        const correlation = this.calculatePearsonCorrelation(pairs);
        
        if (Math.abs(correlation) > 0.3) {
          correlations.push({
            column1: col1,
            column2: col2,
            correlation: correlation,
            strength: Math.abs(correlation) > 0.7 ? 'strong' : 'moderate'
          });
        }
      }
    }
    
    return correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
  }
  
  calculatePearsonCorrelation(pairs) {
    const n = pairs.length;
    const sumX = pairs.reduce((sum, [x]) => sum + x, 0);
    const sumY = pairs.reduce((sum, [, y]) => sum + y, 0);
    const sumXY = pairs.reduce((sum, [x, y]) => sum + x * y, 0);
    const sumX2 = pairs.reduce((sum, [x]) => sum + x * x, 0);
    const sumY2 = pairs.reduce((sum, [, y]) => sum + y * y, 0);
    
    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
    
    return denominator === 0 ? 0 : numerator / denominator;
  }
  
  analyzeDistribution(data, column) {
    const values = data
      .map(r => r[column])
      .filter(v => typeof v === 'number')
      .sort((a, b) => a - b);
    
    if (values.length < 10) {
      return { type: 'unknown', characteristics: {} };
    }
    
    const n = values.length;
    const mean = values.reduce((a, b) => a + b) / n;
    const median = n % 2 === 0 
      ? (values[n/2 - 1] + values[n/2]) / 2 
      : values[Math.floor(n/2)];
    
    // Calculate moments
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;
    const stdDev = Math.sqrt(variance);
    const skewness = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0) / n;
    const kurtosis = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 4), 0) / n - 3;
    
    // Determine distribution type
    let type = 'unknown';
    if (Math.abs(skewness) < 0.5 && Math.abs(kurtosis) < 1) {
      type = 'normal';
    } else if (skewness > 1) {
      type = 'right-skewed';
    } else if (skewness < -1) {
      type = 'left-skewed';
    } else if (kurtosis > 1) {
      type = 'heavy-tailed';
    } else if (kurtosis < -1) {
      type = 'light-tailed';
    }
    
    // Check for multimodality
    const bins = this.createHistogramBins(values, 20);
    const peaks = this.findPeaks(bins);
    if (peaks.length > 1) {
      type = 'multimodal';
    }
    
    return {
      type,
      characteristics: {
        mean,
        median,
        stdDev,
        skewness,
        kurtosis,
        range: values[n-1] - values[0],
        iqr: values[Math.floor(n * 0.75)] - values[Math.floor(n * 0.25)],
        outliers: this.detectOutliers(values)
      }
    };
  }
  
  createHistogramBins(values, numBins) {
    const min = values[0];
    const max = values[values.length - 1];
    const binWidth = (max - min) / numBins;
    const bins = new Array(numBins).fill(0);
    
    values.forEach(v => {
      const binIndex = Math.min(Math.floor((v - min) / binWidth), numBins - 1);
      bins[binIndex]++;
    });
    
    return bins;
  }
  
  findPeaks(bins) {
    const peaks = [];
    for (let i = 1; i < bins.length - 1; i++) {
      if (bins[i] > bins[i-1] && bins[i] > bins[i+1]) {
        peaks.push(i);
      }
    }
    return peaks;
  }
  
  detectOutliers(sortedValues) {
    const n = sortedValues.length;
    const q1 = sortedValues[Math.floor(n * 0.25)];
    const q3 = sortedValues[Math.floor(n * 0.75)];
    const iqr = q3 - q1;
    const lowerBound = q1 - 1.5 * iqr;
    const upperBound = q3 + 1.5 * iqr;
    
    return {
      count: sortedValues.filter(v => v < lowerBound || v > upperBound).length,
      percentage: sortedValues.filter(v => v < lowerBound || v > upperBound).length / n
    };
  }
  
  detectComparisons(data, categoricalColumns, numericColumns) {
    const comparisons = [];
    
    categoricalColumns.forEach(catCol => {
      const uniqueValues = new Set(data.map(r => r[catCol])).size;
      
      if (uniqueValues >= 2 && uniqueValues <= 20) {
        numericColumns.forEach(numCol => {
          // Calculate variance between categories
          const categoryStats = this.calculateCategoryStats(data, catCol, numCol);
          
          if (categoryStats.varianceRatio > 0.1) {
            comparisons.push({
              categoryColumn: catCol,
              valueColumn: numCol,
              categories: uniqueValues,
              varianceRatio: categoryStats.varianceRatio,
              description: `Compare ${numCol} across ${uniqueValues} ${catCol} categories`
            });
          }
        });
      }
    });
    
    return comparisons;
  }
  
  calculateCategoryStats(data, categoryCol, valueCol) {
    const categoryValues = {};
    
    data.forEach(row => {
      const cat = row[categoryCol];
      const val = row[valueCol];
      if (cat && typeof val === 'number') {
        categoryValues[cat] = categoryValues[cat] || [];
        categoryValues[cat].push(val);
      }
    });
    
    const categoryMeans = Object.values(categoryValues).map(values => 
      values.reduce((a, b) => a + b) / values.length
    );
    
    const globalMean = categoryMeans.reduce((a, b) => a + b) / categoryMeans.length;
    const betweenVariance = categoryMeans.reduce((sum, mean) => 
      sum + Math.pow(mean - globalMean, 2), 0
    ) / categoryMeans.length;
    
    return {
      varianceRatio: betweenVariance / Math.pow(globalMean, 2)
    };
  }
  
  detectRanking(data, categoryCol, valueCol) {
    const categoryTotals = {};
    
    data.forEach(row => {
      const cat = row[categoryCol];
      const val = row[valueCol];
      if (cat && typeof val === 'number') {
        categoryTotals[cat] = (categoryTotals[cat] || 0) + val;
      }
    });
    
    const sorted = Object.entries(categoryTotals)
      .sort((a, b) => b[1] - a[1]);
    
    if (sorted.length < 3 || sorted.length > 30) {
      return { suitable: false };
    }
    
    // Check if there's meaningful variance
    const values = sorted.map(([, v]) => v);
    const max = values[0];
    const min = values[values.length - 1];
    
    if (max / min < 1.5) {
      return { suitable: false };
    }
    
    return {
      suitable: true,
      categoryColumn: categoryCol,
      valueColumn: valueCol,
      topItems: sorted.slice(0, 5).map(([cat, val]) => ({ category: cat, value: val })),
      description: `Rank ${sorted.length} categories by ${valueCol}`
    };
  }
  
  findGeographicColumns(columns, columnTypes) {
    const geoKeywords = ['state', 'country', 'city', 'region', 'location', 'address', 
                        'postcode', 'zip', 'latitude', 'longitude', 'lat', 'lon', 'lng'];
    
    return columns.filter(col => {
      const isGeo = geoKeywords.some(keyword => col.toLowerCase().includes(keyword));
      const isAppropriateType = ['categorical', 'postcode', 'string', 'float', 'integer']
        .includes(columnTypes[col]?.type || 'unknown');
      return isGeo && isAppropriateType;
    });
  }
  
  detectHierarchy(data, columns) {
    // Look for parent-child relationships
    const hierarchicalPatterns = [
      ['category', 'subcategory'],
      ['department', 'team'],
      ['country', 'state', 'city'],
      ['year', 'month', 'day'],
      ['region', 'district', 'store']
    ];
    
    for (const pattern of hierarchicalPatterns) {
      const matchedColumns = [];
      
      for (const level of pattern) {
        const found = columns.find(col => 
          col.toLowerCase().includes(level)
        );
        if (found) {
          matchedColumns.push(found);
        }
      }
      
      if (matchedColumns.length >= 2) {
        return {
          detected: true,
          levels: matchedColumns,
          depth: matchedColumns.length,
          description: `Hierarchical structure detected: ${matchedColumns.join(' → ')}`
        };
      }
    }
    
    return { detected: false };
  }
}

class DataProfiler {
  analyzeData(data, columnTypes) {
    const profile = {
      dimensions: this.analyzeDimensions(data, columnTypes),
      cardinality: this.analyzeCardinality(data, columnTypes),
      density: this.analyzeDensity(data, columnTypes),
      patterns: this.analyzePatterns(data, columnTypes),
      quality: this.analyzeQuality(data, columnTypes),
      relationships: this.analyzeRelationships(data, columnTypes)
    };
    
    return profile;
  }
  
  analyzeDimensions(data, columnTypes) {
    const columns = Object.keys(columnTypes);
    
    return {
      rows: data.length,
      columns: columns.length,
      continuous: columns.filter(col => ['integer', 'float'].includes(columnTypes[col].type)).length,
      discrete: columns.filter(col => columnTypes[col].type === 'categorical').length,
      temporal: columns.filter(col => columnTypes[col].type === 'date').length,
      text: columns.filter(col => columnTypes[col].type === 'string').length,
      geographic: this.countGeographicColumns(columns, columnTypes),
      density: data.length * columns.length,
      sizeCategory: this.categorizeSze(data.length)
    };
  }
  
  categorizeSze(rowCount) {
    if (rowCount < 100) return 'small';
    if (rowCount < 1000) return 'medium';
    if (rowCount < 10000) return 'large';
    if (rowCount < 100000) return 'very_large';
    return 'massive';
  }
  
  analyzeCardinality(data, columnTypes) {
    const cardinality = {};
    const columns = Object.keys(columnTypes);
    
    columns.forEach(col => {
      const uniqueValues = new Set(data.map(r => r[col])).size;
      const ratio = uniqueValues / data.length;
      
      cardinality[col] = {
        unique: uniqueValues,
        ratio: ratio,
        category: this.categorizeCardinality(ratio, uniqueValues, columnTypes[col].type)
      };
    });
    
    return cardinality;
  }
  
  categorizeCardinality(ratio, unique, type) {
    if (type === 'categorical') {
      if (unique === 2) return 'binary';
      if (unique <= 5) return 'low_categorical';
      if (unique <= 10) return 'medium_categorical';
      if (unique <= 20) return 'high_categorical';
      return 'very_high_categorical';
    }
    
    if (ratio > 0.95) return 'unique_identifier';
    if (ratio > 0.5) return 'high_cardinality';
    if (ratio > 0.1) return 'medium_cardinality';
    return 'low_cardinality';
  }
  
  analyzeDensity(data, columnTypes) {
    const columns = Object.keys(columnTypes);
    const density = {
      overall: 1,
      byColumn: {},
      sparsity: 0,
      missingPatterns: []
    };
    
    // Calculate missing values per column
    columns.forEach(col => {
      const missing = data.filter(r => r[col] === null || r[col] === undefined).length;
      const missingRatio = missing / data.length;
      
      density.byColumn[col] = {
        populated: 1 - missingRatio,
        missing: missing,
        missingPercentage: missingRatio * 100
      };
      
      if (missingRatio > 0.1) {
        density.missingPatterns.push({
          column: col,
          percentage: missingRatio * 100,
          impact: missingRatio > 0.5 ? 'severe' : missingRatio > 0.2 ? 'moderate' : 'low'
        });
      }
    });
    
    // Overall density
    const totalCells = data.length * columns.length;
    const missingCells = columns.reduce((sum, col) => 
      sum + density.byColumn[col].missing, 0
    );
    density.overall = 1 - (missingCells / totalCells);
    density.sparsity = missingCells / totalCells;
    
    return density;
  }
  
  analyzePatterns(data, columnTypes) {
    const patterns = {
      temporal: this.detectTemporalPatterns(data, columnTypes),
      categorical: this.detectCategoricalPatterns(data, columnTypes),
      numeric: this.detectNumericPatterns(data, columnTypes),
      compound: this.detectCompoundPatterns(data, columnTypes)
    };
    
    return patterns;
  }
  
  detectTemporalPatterns(data, columnTypes) {
    const dateColumns = Object.keys(columnTypes).filter(col => 
      columnTypes[col].type === 'date'
    );
    
    if (dateColumns.length === 0) return null;
    
    const patterns = {};
    
    dateColumns.forEach(col => {
      const dates = data
        .map(r => r[col])
        .filter(d => d instanceof Date)
        .sort((a, b) => a - b);
      
      if (dates.length < 2) return;
      
      // Analyze frequency
      const intervals = [];
      for (let i = 1; i < dates.length; i++) {
        intervals.push(dates[i] - dates[i-1]);
      }
      
      const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
      const frequency = this.detectFrequency(avgInterval);
      
      // Analyze range
      const range = {
        start: dates[0],
        end: dates[dates.length - 1],
        span: dates[dates.length - 1] - dates[0],
        spanDays: (dates[dates.length - 1] - dates[0]) / (1000 * 60 * 60 * 24)
      };
      
      // Check for gaps
      const gaps = intervals
        .map((interval, idx) => ({ interval, index: idx }))
        .filter(item => item.interval > avgInterval * 2)
        .map(item => ({
          start: dates[item.index],
          end: dates[item.index + 1],
          duration: item.interval
        }));
      
      patterns[col] = {
        frequency,
        range,
        hasGaps: gaps.length > 0,
        gaps,
        completeness: dates.length / data.length
      };
    });
    
    return patterns;
  }
  
  detectFrequency(avgIntervalMs) {
    const hour = 1000 * 60 * 60;
    const day = hour * 24;
    const week = day * 7;
    const month = day * 30;
    
    if (avgIntervalMs < hour * 2) return 'hourly';
    if (avgIntervalMs < day * 2) return 'daily';
    if (avgIntervalMs < week * 2) return 'weekly';
    if (avgIntervalMs < month * 2) return 'monthly';
    if (avgIntervalMs < month * 4) return 'quarterly';
    return 'irregular';
  }
  
  detectCategoricalPatterns(data, columnTypes) {
    const categoricalColumns = Object.keys(columnTypes).filter(col => 
      columnTypes[col].type === 'categorical'
    );
    
    const patterns = {};
    
    categoricalColumns.forEach(col => {
      const values = data.map(r => r[col]).filter(v => v !== null);
      const valueCounts = {};
      values.forEach(v => valueCounts[v] = (valueCounts[v] || 0) + 1);
      
      const sorted = Object.entries(valueCounts)
        .sort((a, b) => b[1] - a[1]);
      
      // Analyze distribution
      const total = values.length;
      const distribution = sorted.map(([value, count]) => ({
        value,
        count,
        percentage: count / total * 100
      }));
      
      // Check for imbalance
      const topPercentage = distribution[0]?.percentage || 0;
      const imbalanced = topPercentage > 50;
      
      // Check for rare categories
      const rareCategories = distribution.filter(d => d.percentage < 5);
      
      patterns[col] = {
        uniqueValues: sorted.length,
        distribution: distribution.slice(0, 10), // Top 10
        imbalanced,
        dominantValue: imbalanced ? distribution[0].value : null,
        rareCategories: rareCategories.length,
        entropy: this.calculateEntropy(Object.values(valueCounts))
      };
    });
    
    return patterns;
  }
  
  calculateEntropy(counts) {
    const total = counts.reduce((a, b) => a + b, 0);
    const probabilities = counts.map(c => c / total);
    
    return -probabilities.reduce((sum, p) => {
      return p > 0 ? sum + p * Math.log2(p) : sum;
    }, 0);
  }
  
  detectNumericPatterns(data, columnTypes) {
    const numericColumns = Object.keys(columnTypes).filter(col => 
      ['integer', 'float'].includes(columnTypes[col].type)
    );
    
    const patterns = {};
    
    numericColumns.forEach(col => {
      const values = data
        .map(r => r[col])
        .filter(v => typeof v === 'number')
        .sort((a, b) => a - b);
      
      if (values.length < 10) return;
      
      // Basic statistics
      const n = values.length;
      const mean = values.reduce((a, b) => a + b) / n;
      const median = n % 2 === 0 
        ? (values[n/2 - 1] + values[n/2]) / 2 
        : values[Math.floor(n/2)];
      
      // Check for specific patterns
      const isMonetary = this.checkMonetaryPattern(values);
      const isPercentage = this.checkPercentagePattern(values);
      const isCount = this.checkCountPattern(values);
      const hasNegative = values.some(v => v < 0);
      
      // Scale
      const range = values[n-1] - values[0];
      const orderOfMagnitude = Math.floor(Math.log10(Math.max(...values.map(Math.abs))));
      
      patterns[col] = {
        dataPattern: isMonetary ? 'monetary' : isPercentage ? 'percentage' : isCount ? 'count' : 'continuous',
        scale: {
          min: values[0],
          max: values[n-1],
          range,
          orderOfMagnitude
        },
        hasNegative,
        distribution: {
          mean,
          median,
          skewness: this.calculateSkewness(values, mean, n)
        }
      };
    });
    
    return patterns;
  }
  
  checkMonetaryPattern(values) {
    // Check if values look like money (2 decimal places common)
    const decimalCounts = values.map(v => {
      const str = v.toString();
      const decimalIndex = str.indexOf('.');
      return decimalIndex === -1 ? 0 : str.length - decimalIndex - 1;
    });
    
    const twoDecimals = decimalCounts.filter(d => d === 2).length;
    return twoDecimals / values.length > 0.5;
  }
  
  checkPercentagePattern(values) {
    // Check if values are between 0 and 100 or 0 and 1
    const between0And1 = values.every(v => v >= 0 && v <= 1);
    const between0And100 = values.every(v => v >= 0 && v <= 100);
    
    return between0And1 || (between0And100 && values.some(v => v > 1));
  }
  
  checkCountPattern(values) {
    // Check if all values are integers
    return values.every(v => Number.isInteger(v)) && values.every(v => v >= 0);
  }
  
  calculateSkewness(values, mean, n) {
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;
    const stdDev = Math.sqrt(variance);
    
    if (stdDev === 0) return 0;
    
    return values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0) / n;
  }
  
  detectCompoundPatterns(data, columnTypes) {
    const patterns = [];
    
    // Detect time series patterns
    const dateColumns = Object.keys(columnTypes).filter(col => 
      columnTypes[col].type === 'date'
    );
    const numericColumns = Object.keys(columnTypes).filter(col => 
      ['integer', 'float'].includes(columnTypes[col].type)
    );
    
    if (dateColumns.length > 0 && numericColumns.length > 0) {
      patterns.push({
        type: 'time_series',
        temporal: dateColumns,
        measures: numericColumns,
        strength: 'high'
      });
    }
    
    // Detect hierarchical patterns
    const hierarchicalCandidates = this.findHierarchicalCandidates(data, columnTypes);
    if (hierarchicalCandidates.length > 0) {
      patterns.push({
        type: 'hierarchical',
        levels: hierarchicalCandidates,
        strength: 'medium'
      });
    }
    
    // Detect geographic patterns
    const geoColumns = this.findGeographicColumns(Object.keys(columnTypes), columnTypes);
    if (geoColumns.length > 0 && numericColumns.length > 0) {
      patterns.push({
        type: 'geographic',
        location: geoColumns,
        measures: numericColumns,
        strength: 'high'
      });
    }
    
    return patterns;
  }
  
  findHierarchicalCandidates(data, columnTypes) {
    const categoricalColumns = Object.keys(columnTypes).filter(col => 
      columnTypes[col].type === 'categorical'
    );
    
    const candidates = [];
    
    // Check cardinality relationships
    for (let i = 0; i < categoricalColumns.length; i++) {
      for (let j = i + 1; j < categoricalColumns.length; j++) {
        const col1 = categoricalColumns[i];
        const col2 = categoricalColumns[j];
        
        const unique1 = new Set(data.map(r => r[col1])).size;
        const unique2 = new Set(data.map(r => r[col2])).size;
        
        // One should have significantly fewer unique values
        if (unique1 < unique2 / 3) {
          candidates.push([col1, col2]);
        } else if (unique2 < unique1 / 3) {
          candidates.push([col2, col1]);
        }
      }
    }
    
    return candidates;
  }
  
  analyzeQuality(data, columnTypes) {
    const quality = {
      completeness: 0,
      consistency: [],
      validity: [],
      accuracy: []
    };
    
    // Completeness
    const totalCells = data.length * Object.keys(columnTypes).length;
    const missingCells = Object.keys(columnTypes).reduce((sum, col) => 
      sum + data.filter(r => r[col] === null || r[col] === undefined).length, 0
    );
    quality.completeness = 1 - (missingCells / totalCells);
    
    // Check for consistency issues
    Object.keys(columnTypes).forEach(col => {
      if (columnTypes[col].type === 'categorical') {
        // Check for similar but different values
        const values = [...new Set(data.map(r => r[col]).filter(v => v !== null))];
        const similar = this.findSimilarValues(values);
        
        if (similar.length > 0) {
          quality.consistency.push({
            column: col,
            issue: 'similar_values',
            examples: similar
          });
        }
      }
    });
    
    return quality;
  }
  
  findSimilarValues(values) {
    const similar = [];
    
    for (let i = 0; i < values.length; i++) {
      for (let j = i + 1; j < values.length; j++) {
        const v1 = values[i].toString().toLowerCase();
        const v2 = values[j].toString().toLowerCase();
        
        // Check for case differences
        if (v1 === v2 && values[i] !== values[j]) {
          similar.push([values[i], values[j]]);
        }
        
        // Check for leading/trailing spaces
        if (v1.trim() === v2.trim() && values[i] !== values[j]) {
          similar.push([values[i], values[j]]);
        }
      }
    }
    
    return similar.slice(0, 5); // Return top 5 examples
  }
  
  analyzeRelationships(data, columnTypes) {
    const relationships = {
      correlations: [],
      dependencies: [],
      associations: []
    };
    
    // Find numeric correlations
    const numericColumns = Object.keys(columnTypes).filter(col => 
      ['integer', 'float'].includes(columnTypes[col].type)
    );
    
    for (let i = 0; i < numericColumns.length; i++) {
      for (let j = i + 1; j < numericColumns.length; j++) {
        const correlation = this.calculateCorrelation(
          data.map(r => r[numericColumns[i]]),
          data.map(r => r[numericColumns[j]])
        );
        
        if (Math.abs(correlation) > 0.3) {
          relationships.correlations.push({
            column1: numericColumns[i],
            column2: numericColumns[j],
            correlation,
            strength: Math.abs(correlation) > 0.7 ? 'strong' : 'moderate'
          });
        }
      }
    }
    
    return relationships;
  }
  
  calculateCorrelation(x, y) {
    const pairs = x
      .map((xi, i) => [xi, y[i]])
      .filter(([xi, yi]) => typeof xi === 'number' && typeof yi === 'number');
    
    if (pairs.length < 10) return 0;
    
    const n = pairs.length;
    const sumX = pairs.reduce((sum, [xi]) => sum + xi, 0);
    const sumY = pairs.reduce((sum, [, yi]) => sum + yi, 0);
    const sumXY = pairs.reduce((sum, [xi, yi]) => sum + xi * yi, 0);
    const sumX2 = pairs.reduce((sum, [xi]) => sum + xi * xi, 0);
    const sumY2 = pairs.reduce((sum, [, yi]) => sum + yi * yi, 0);
    
    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
    
    return denominator === 0 ? 0 : numerator / denominator;
  }
  
  countGeographicColumns(columns, columnTypes) {
    const geoKeywords = ['state', 'country', 'city', 'region', 'location', 'address', 
                        'postcode', 'zip', 'latitude', 'longitude', 'lat', 'lon', 'lng',
                        'suburb', 'district', 'province', 'county', 'area'];
    
    return columns.filter(col => {
      const colLower = col.toLowerCase();
      const colType = columnTypes[col]?.type;
      
      // Check for geographic keywords
      const hasGeoKeyword = geoKeywords.some(keyword => colLower.includes(keyword));
      
      // Check for coordinate patterns (lat/long)
      const isCoordinate = (colLower.includes('lat') || colLower.includes('lon') || 
                           colLower.includes('lng')) && ['float', 'integer'].includes(colType);
      
      // Check for appropriate data type (exclude 'unknown' type)
      const isAppropriateType = colType && colType !== 'unknown' && 
        ['categorical', 'postcode', 'string', 'float', 'integer'].includes(colType);
      
      return (hasGeoKeyword || isCoordinate) && isAppropriateType;
    }).length;
  }
  
  findGeographicColumns(columns, columnTypes) {
    const geoKeywords = ['state', 'country', 'city', 'region', 'location', 'address', 
                        'postcode', 'zip', 'latitude', 'longitude', 'lat', 'lon', 'lng',
                        'suburb', 'district', 'province', 'county', 'area'];
    
    return columns.filter(col => {
      const colLower = col.toLowerCase();
      const colType = columnTypes[col]?.type;
      
      // Check for geographic keywords
      const hasGeoKeyword = geoKeywords.some(keyword => colLower.includes(keyword));
      
      // Check for coordinate patterns (lat/long)
      const isCoordinate = (colLower.includes('lat') || colLower.includes('lon') || 
                           colLower.includes('lng')) && ['float', 'integer'].includes(colType);
      
      // Check for appropriate data type (exclude 'unknown' type)
      const isAppropriateType = colType && colType !== 'unknown' && 
        ['categorical', 'postcode', 'string', 'float', 'integer'].includes(colType);
      
      return (hasGeoKeyword || isCoordinate) && isAppropriateType;
    });
  }
}

class PerceptualScorer {
  constructor() {
    // Cleveland & McGill's ranking of visual encodings by accuracy
    this.encodingAccuracy = {
      position_common_scale: 0.95,      // Position on common scale (most accurate)
      position_nonaligned_scale: 0.85,  // Position on non-aligned scales
      length: 0.80,                     // Length, direction, angle
      angle: 0.65,                      // Angle (pie charts)
      area: 0.60,                       // Area (bubble charts)
      volume: 0.50,                     // 3D volume
      curvature: 0.45,                  // Curvature
      shading: 0.40,                    // Shading, color saturation
      color_hue: 0.35                   // Color hue (least accurate)
    };
    
    // Task-specific encoding preferences
    this.taskEncodingMap = {
      comparison: ['position_common_scale', 'length', 'position_nonaligned_scale'],
      composition: ['position_common_scale', 'length', 'angle', 'area'],
      distribution: ['position_common_scale', 'area', 'length'],
      correlation: ['position_common_scale', 'position_nonaligned_scale'],
      trend: ['position_common_scale', 'length'],
      ranking: ['position_common_scale', 'length'],
      part_to_whole: ['angle', 'area', 'length', 'position_common_scale'],
      deviation: ['position_common_scale', 'length', 'color_hue']
    };
  }
  
  scoreVisualization(visualization, task, dataProfile) {
    const scores = {
      perceptualAccuracy: this.scorePerceptualAccuracy(visualization, task),
      dataInkRatio: this.scoreDataInkRatio(visualization),
      cognitiveLoad: this.scoreCognitiveLoad(visualization, dataProfile),
      taskAlignment: this.scoreTaskAlignment(visualization, task),
      scalability: this.scoreScalability(visualization, dataProfile),
      aesthetics: this.scoreAesthetics(visualization)
    };
    
    // Calculate weighted overall score
    const weights = {
      perceptualAccuracy: 0.35,
      taskAlignment: 0.25,
      dataInkRatio: 0.15,
      cognitiveLoad: 0.15,
      scalability: 0.05,
      aesthetics: 0.05
    };
    
    const overallScore = Object.entries(scores).reduce((sum, [key, score]) => 
      sum + score * weights[key], 0
    );
    
    return {
      overall: overallScore,
      breakdown: scores,
      effectiveness: this.categorizeEffectiveness(overallScore),
      recommendations: this.generateRecommendations(scores, visualization)
    };
  }
  
  scorePerceptualAccuracy(visualization, task) {
    const encoding = visualization.encoding || 'position_common_scale';
    const baseAccuracy = this.encodingAccuracy[encoding] || 0.5;
    
    // Adjust for specific chart types
    const chartTypeAdjustments = {
      bar: 1.0,        // Bar charts are perceptually optimal
      line: 0.95,      // Line charts very good for trends
      scatter: 0.95,   // Scatterplots excellent for correlation
      pie: 0.7,        // Pie charts have known issues
      bubble: 0.75,    // Area encoding less accurate
      heatmap: 0.85,   // Color encoding with position
      treemap: 0.8,    // Area encoding with hierarchy
      sunburst: 0.75,  // Angle encoding with hierarchy
      parallel: 0.85,  // Multiple position encodings
      horizon: 0.9     // Clever use of position and color
    };
    
    const chartAdjustment = chartTypeAdjustments[visualization.type] || 0.8;
    
    return baseAccuracy * chartAdjustment;
  }
  
  scoreDataInkRatio(visualization) {
    // Based on Tufte's principles
    const unnecessaryElements = {
      gridlines: visualization.gridlines?.excessive ? -0.1 : 0,
      borders: visualization.borders?.heavy ? -0.05 : 0,
      backgrounds: visualization.backgrounds?.patterned ? -0.1 : 0,
      effects3d: visualization.effects3d ? -0.2 : 0,
      decorations: visualization.decorations ? -0.15 : 0,
      redundantLegends: visualization.redundantLegends ? -0.1 : 0
    };
    
    const penalty = Object.values(unnecessaryElements).reduce((sum, val) => sum + val, 0);
    const baseScore = 0.9; // Start with good score
    
    return Math.max(0.3, baseScore + penalty);
  }
  
  scoreCognitiveLoad(visualization, dataProfile) {
    let load = 0;
    
    // Number of data dimensions shown
    const dimensions = visualization.dimensions || 2;
    if (dimensions <= 2) load += 0.9;
    else if (dimensions <= 3) load += 0.7;
    else if (dimensions <= 4) load += 0.5;
    else load += 0.3;
    
    // Number of categories/series
    const categories = visualization.categories || 1;
    if (categories <= 5) load += 0.9;
    else if (categories <= 10) load += 0.7;
    else if (categories <= 20) load += 0.5;
    else load += 0.3;
    
    // Data density
    const pointsPerPixel = (dataProfile.dimensions.rows || 100) / 
                          (visualization.width * visualization.height || 400000);
    
    if (pointsPerPixel < 0.01) load += 0.9;
    else if (pointsPerPixel < 0.1) load += 0.7;
    else if (pointsPerPixel < 1) load += 0.5;
    else load += 0.3;
    
    return load / 3; // Average of three factors
  }
  
  scoreTaskAlignment(visualization, task) {
    const taskType = task.type || 'comparison';
    const vizType = visualization.type;
    
    // Task-visualization alignment matrix
    const alignmentMatrix = {
      trend_analysis: {
        line: 1.0,
        area: 0.9,
        scatter: 0.7,
        bar: 0.5,
        horizon: 0.95,
        sparkline: 0.85
      },
      comparison: {
        bar: 1.0,
        column: 0.95,
        line: 0.7,
        scatter: 0.6,
        radar: 0.8,
        bullet: 0.9
      },
      part_to_whole: {
        pie: 0.8,
        donut: 0.85,
        stacked_bar: 0.9,
        treemap: 0.95,
        sunburst: 0.9,
        waffle: 0.85
      },
      distribution: {
        histogram: 1.0,
        box: 0.95,
        violin: 0.95,
        density: 0.9,
        strip: 0.85,
        ridgeline: 0.9
      },
      correlation: {
        scatter: 1.0,
        hexbin: 0.95,
        contour: 0.9,
        correlogram: 0.85,
        bubble: 0.8,
        splom: 0.95
      },
      ranking: {
        bar: 1.0,
        lollipop: 0.95,
        slope: 0.9,
        bump: 0.85,
        column: 0.85
      },
      geospatial: {
        choropleth: 1.0,
        symbol: 0.9,
        heatmap: 0.85,
        flow: 0.9,
        cartogram: 0.8
      },
      hierarchy: {
        tree: 1.0,
        treemap: 0.95,
        sunburst: 0.9,
        circle_pack: 0.85,
        dendogram: 0.9
      }
    };
    
    const taskAlignments = alignmentMatrix[taskType] || {};
    return taskAlignments[vizType] || 0.5;
  }
  
  scoreScalability(visualization, dataProfile) {
    const dataSize = dataProfile.dimensions.rows;
    const vizType = visualization.type;
    
    // Scalability limits by visualization type
    const scalabilityLimits = {
      scatter: { optimal: 1000, max: 10000 },
      line: { optimal: 500, max: 5000 },
      bar: { optimal: 50, max: 200 },
      pie: { optimal: 7, max: 12 },
      heatmap: { optimal: 10000, max: 100000 },
      hexbin: { optimal: 100000, max: 1000000 },
      treemap: { optimal: 100, max: 1000 },
      parallel: { optimal: 1000, max: 10000 },
      horizon: { optimal: 5000, max: 50000 }
    };
    
    const limits = scalabilityLimits[vizType] || { optimal: 100, max: 1000 };
    
    if (dataSize <= limits.optimal) return 1.0;
    if (dataSize <= limits.max) {
      // Linear decay from optimal to max
      return 1.0 - (dataSize - limits.optimal) / (limits.max - limits.optimal) * 0.5;
    }
    return 0.3; // Minimum score for over-limit
  }
  
  scoreAesthetics(visualization) {
    let score = 0.8; // Base aesthetic score
    
    // Positive factors
    if (visualization.colorScheme?.type === 'scientific') score += 0.1;
    if (visualization.typography?.readable) score += 0.05;
    if (visualization.layout?.balanced) score += 0.05;
    
    // Negative factors
    if (visualization.colors?.tooMany) score -= 0.1;
    if (visualization.effects?.distracting) score -= 0.1;
    if (visualization.labels?.overlapping) score -= 0.1;
    
    return Math.max(0.3, Math.min(1.0, score));
  }
  
  categorizeEffectiveness(score) {
    if (score >= 0.9) return 'excellent';
    if (score >= 0.8) return 'very_good';
    if (score >= 0.7) return 'good';
    if (score >= 0.6) return 'acceptable';
    if (score >= 0.5) return 'marginal';
    return 'poor';
  }
  
  generateRecommendations(scores, visualization) {
    const recommendations = [];
    
    // Perceptual accuracy recommendations
    if (scores.perceptualAccuracy < 0.7) {
      recommendations.push({
        type: 'encoding',
        priority: 'high',
        message: 'Consider using position or length encoding instead of ' + 
                 (visualization.encoding || 'current encoding') + 
                 ' for better perceptual accuracy'
      });
    }
    
    // Data-ink ratio recommendations
    if (scores.dataInkRatio < 0.7) {
      recommendations.push({
        type: 'simplification',
        priority: 'medium',
        message: 'Remove unnecessary chart elements like heavy gridlines, borders, or 3D effects'
      });
    }
    
    // Cognitive load recommendations
    if (scores.cognitiveLoad < 0.6) {
      recommendations.push({
        type: 'complexity',
        priority: 'high',
        message: 'Consider breaking down into multiple simpler visualizations or using progressive disclosure'
      });
    }
    
    // Task alignment recommendations
    if (scores.taskAlignment < 0.7) {
      recommendations.push({
        type: 'chart_type',
        priority: 'high',
        message: 'This chart type may not be optimal for your analytical task'
      });
    }
    
    // Scalability recommendations
    if (scores.scalability < 0.6) {
      recommendations.push({
        type: 'data_reduction',
        priority: 'medium',
        message: 'Consider aggregation, sampling, or a different visualization type for this data volume'
      });
    }
    
    return recommendations;
  }
  
  compareVisualizations(viz1, viz2, task, dataProfile) {
    const score1 = this.scoreVisualization(viz1, task, dataProfile);
    const score2 = this.scoreVisualization(viz2, task, dataProfile);
    
    return {
      winner: score1.overall > score2.overall ? viz1 : viz2,
      scores: {
        viz1: score1,
        viz2: score2
      },
      differential: Math.abs(score1.overall - score2.overall),
      recommendation: this.generateComparison(viz1, viz2, score1, score2)
    };
  }
  
  generateComparison(viz1, viz2, score1, score2) {
    const diff = score1.overall - score2.overall;
    
    if (Math.abs(diff) < 0.05) {
      return 'Both visualizations are similarly effective. Choose based on your specific context.';
    }
    
    const better = diff > 0 ? viz1 : viz2;
    const worse = diff > 0 ? viz2 : viz1;
    const betterScore = diff > 0 ? score1 : score2;
    const worseScore = diff > 0 ? score2 : score1;
    
    // Find the key differentiator
    let maxDiff = 0;
    let keyFactor = '';
    
    Object.keys(betterScore.breakdown).forEach(factor => {
      const factorDiff = Math.abs(betterScore.breakdown[factor] - worseScore.breakdown[factor]);
      if (factorDiff > maxDiff) {
        maxDiff = factorDiff;
        keyFactor = factor;
      }
    });
    
    return `${better.type} is ${Math.round(Math.abs(diff) * 100)}% more effective than ${worse.type}, ` +
           `primarily due to better ${keyFactor.replace(/_/g, ' ')}`;
  }
}

class ChartSelector {
  constructor() {
    this.perceptualScorer = new PerceptualScorer();
    
    // Chart type definitions with capabilities
    this.chartTypes = {
      bar: {
        tasks: ['comparison', 'ranking', 'deviation'],
        dataTypes: ['categorical', 'numeric'],
        encoding: 'length',
        maxCategories: 50,
        strengths: ['Precise value comparison', 'Clear ranking', 'Handles many categories'],
        weaknesses: ['Poor for time series', 'Limited dimensions']
      },
      column: {
        tasks: ['comparison', 'ranking', 'time_series'],
        dataTypes: ['categorical', 'numeric', 'temporal'],
        encoding: 'length',
        maxCategories: 20,
        strengths: ['Good for time series with few points', 'Clear comparison'],
        weaknesses: ['Limited categories due to width']
      },
      line: {
        tasks: ['trend_analysis', 'time_series', 'comparison'],
        dataTypes: ['temporal', 'numeric'],
        encoding: 'position_common_scale',
        maxSeries: 7,
        strengths: ['Excellent for trends', 'Shows continuity', 'Multiple series'],
        weaknesses: ['Not for categories', 'Implies continuity']
      },
      area: {
        tasks: ['trend_analysis', 'part_to_whole', 'accumulation'],
        dataTypes: ['temporal', 'numeric'],
        encoding: 'area',
        maxSeries: 5,
        strengths: ['Shows volume/accumulation', 'Good for cumulative data'],
        weaknesses: ['Occlusion with multiple series', 'Less precise than line']
      },
      scatter: {
        tasks: ['correlation', 'distribution', 'outliers', 'clustering'],
        dataTypes: ['numeric', 'numeric'],
        encoding: 'position_common_scale',
        maxPoints: 10000,
        strengths: ['Shows relationships', 'Identifies patterns', 'Outlier detection'],
        weaknesses: ['Overplotting', 'Requires two continuous variables']
      },
      bubble: {
        tasks: ['correlation', 'comparison', 'distribution'],
        dataTypes: ['numeric', 'numeric', 'numeric'],
        encoding: 'area',
        maxPoints: 500,
        strengths: ['Three dimensions', 'Engaging visual'],
        weaknesses: ['Area perception issues', 'Overlapping bubbles']
      },
      pie: {
        tasks: ['part_to_whole', 'composition'],
        dataTypes: ['categorical', 'numeric'],
        encoding: 'angle',
        maxCategories: 5,
        strengths: ['Shows parts of whole', 'Familiar to audiences'],
        weaknesses: ['Poor accuracy', 'Limited categories', 'No exact values']
      },
      donut: {
        tasks: ['part_to_whole', 'composition'],
        dataTypes: ['categorical', 'numeric'],
        encoding: 'angle',
        maxCategories: 7,
        strengths: ['Central annotation space', 'Slightly better than pie'],
        weaknesses: ['Same issues as pie charts']
      },
      heatmap: {
        tasks: ['correlation', 'pattern', 'comparison', 'temporal_pattern'],
        dataTypes: ['categorical', 'categorical', 'numeric'],
        encoding: 'color_hue',
        maxCells: 10000,
        strengths: ['Dense data display', 'Pattern detection', 'Matrix visualization'],
        weaknesses: ['Color perception issues', 'Needs color legend']
      },
      treemap: {
        tasks: ['hierarchy', 'part_to_whole', 'comparison'],
        dataTypes: ['hierarchical', 'numeric'],
        encoding: 'area',
        maxNodes: 1000,
        strengths: ['Space-efficient', 'Shows hierarchy and size', 'Good for files/budgets'],
        weaknesses: ['Area perception', 'Deep hierarchies difficult']
      },
      sunburst: {
        tasks: ['hierarchy', 'part_to_whole', 'navigation'],
        dataTypes: ['hierarchical', 'numeric'],
        encoding: 'angle',
        maxLevels: 5,
        strengths: ['Clear hierarchy', 'Interactive navigation', 'Aesthetic appeal'],
        weaknesses: ['Angle perception', 'Center space wasted']
      },
      box: {
        tasks: ['distribution', 'comparison', 'outliers'],
        dataTypes: ['categorical', 'numeric'],
        encoding: 'position_common_scale',
        maxCategories: 20,
        strengths: ['Statistical summary', 'Outlier detection', 'Compare distributions'],
        weaknesses: ['Requires statistical knowledge', 'Hides multimodality']
      },
      violin: {
        tasks: ['distribution', 'comparison', 'density'],
        dataTypes: ['categorical', 'numeric'],
        encoding: 'area',
        maxCategories: 10,
        strengths: ['Shows full distribution', 'Reveals multimodality', 'Aesthetic'],
        weaknesses: ['Complex interpretation', 'Space intensive']
      },
      histogram: {
        tasks: ['distribution', 'frequency'],
        dataTypes: ['numeric'],
        encoding: 'length',
        maxBins: 100,
        strengths: ['Clear frequency display', 'Familiar format', 'Reveals shape'],
        weaknesses: ['Bin size sensitivity', 'Single variable only']
      },
      parallel: {
        tasks: ['multivariate', 'pattern', 'clustering', 'filtering'],
        dataTypes: ['multivariate'],
        encoding: 'position_nonaligned_scale',
        maxDimensions: 10,
        strengths: ['Many dimensions', 'Pattern detection', 'Interactive filtering'],
        weaknesses: ['Line crossings', 'Order dependent']
      },
      radar: {
        tasks: ['multivariate', 'comparison', 'profile'],
        dataTypes: ['multivariate'],
        encoding: 'position_nonaligned_scale',
        maxDimensions: 8,
        maxSeries: 3,
        strengths: ['Compact multivariate', 'Good for profiles', 'Comparative'],
        weaknesses: ['Area distortion', 'Axis order matters']
      },
      sankey: {
        tasks: ['flow', 'relationship', 'proportion'],
        dataTypes: ['categorical', 'categorical', 'numeric'],
        encoding: 'length',
        maxNodes: 50,
        strengths: ['Shows flow and proportion', 'Multiple stages', 'Intuitive'],
        weaknesses: ['Complex layouts', 'Many crossings']
      },
      chord: {
        tasks: ['relationship', 'flow', 'connection'],
        dataTypes: ['categorical', 'categorical', 'numeric'],
        encoding: 'angle',
        maxNodes: 20,
        strengths: ['Bidirectional relationships', 'Aesthetic', 'Compact'],
        weaknesses: ['Hard to read', 'Limited nodes']
      },
      horizon: {
        tasks: ['time_series', 'pattern', 'comparison'],
        dataTypes: ['temporal', 'numeric'],
        encoding: 'position_common_scale',
        maxSeries: 50,
        strengths: ['Space efficient', 'Many time series', 'Patterns visible'],
        weaknesses: ['Learning curve', 'Not intuitive']
      },
      stream: {
        tasks: ['time_series', 'part_to_whole', 'flow'],
        dataTypes: ['temporal', 'categorical', 'numeric'],
        encoding: 'area',
        maxCategories: 20,
        strengths: ['Aesthetic', 'Shows flow over time', 'Organic appearance'],
        weaknesses: ['Imprecise', 'Baseline issues']
      },
      hexbin: {
        tasks: ['density', 'distribution', 'pattern'],
        dataTypes: ['numeric', 'numeric'],
        encoding: 'color_hue',
        maxPoints: 1000000,
        strengths: ['Handles overplotting', 'Scalable', 'Clear density'],
        weaknesses: ['Loss of individual points', 'Binning artifacts']
      },
      contour: {
        tasks: ['density', 'distribution', 'pattern'],
        dataTypes: ['numeric', 'numeric'],
        encoding: 'position_common_scale',
        maxPoints: 100000,
        strengths: ['Smooth density', 'Topographic', 'No binning'],
        weaknesses: ['Abstract', 'Requires interpretation']
      }
    };
  }
  
  selectChart(task, dataProfile, constraints = {}) {
    const candidates = this.getCandidateCharts(task, dataProfile);
    const scoredCandidates = this.scoreCandidates(candidates, task, dataProfile, constraints);
    const filtered = this.applyConstraints(scoredCandidates, constraints);
    
    // Ensure we have a primary chart
    if (!filtered || filtered.length === 0) {
      return {
        primary: null,
        alternatives: [],
        reasoning: 'No suitable visualizations found for this data and task combination'
      };
    }
    
    // Safely extract alternatives, ensuring we don't go out of bounds
    const alternatives = filtered.length > 1 ? filtered.slice(1, Math.min(4, filtered.length)) : [];
    
    return {
      primary: filtered[0],
      alternatives: alternatives,
      reasoning: this.explainSelection(filtered[0], task, dataProfile)
    };
  }
  
  getCandidateCharts(task, dataProfile) {
    const taskType = task.type;
    const candidates = [];
    
    Object.entries(this.chartTypes).forEach(([chartType, config]) => {
      if (config.tasks.includes(taskType)) {
        // Check data type compatibility
        if (this.isDataCompatible(config, dataProfile)) {
          candidates.push({
            type: chartType,
            config: config,
            compatibility: this.calculateCompatibility(config, task, dataProfile)
          });
        }
      }
    });
    
    return candidates.sort((a, b) => b.compatibility - a.compatibility);
  }
  
  isDataCompatible(chartConfig, dataProfile) {
    const dimensions = dataProfile.dimensions;
    
    // Check if we have the required data types
    if (chartConfig.dataTypes.includes('temporal') && dimensions.temporal === 0) {
      return false;
    }
    
    if (chartConfig.dataTypes.includes('hierarchical') && 
        !dataProfile.patterns.compound.some(p => p.type === 'hierarchical')) {
      return false;
    }
    
    if (chartConfig.dataTypes.includes('multivariate') && 
        dimensions.continuous < 3) {
      return false;
    }
    
    return true;
  }
  
  calculateCompatibility(chartConfig, task, dataProfile) {
    let score = 0;
    
    // Task alignment
    const taskIndex = chartConfig.tasks.indexOf(task.type);
    if (taskIndex === 0) score += 0.4;  // Primary task
    else if (taskIndex === 1) score += 0.3;  // Secondary task
    else score += 0.2;  // Tertiary task
    
    // Data volume compatibility
    const dataSize = dataProfile.dimensions.rows;
    if (chartConfig.maxCategories) {
      const categories = dataProfile.cardinality[task.columns?.category]?.unique || 10;
      if (categories <= chartConfig.maxCategories) {
        score += 0.2;
      } else {
        score -= 0.1;
      }
    }
    
    if (chartConfig.maxPoints) {
      if (dataSize <= chartConfig.maxPoints * 0.5) {
        score += 0.2;
      } else if (dataSize <= chartConfig.maxPoints) {
        score += 0.1;
      } else {
        score -= 0.2;
      }
    }
    
    // Encoding effectiveness
    const encodingScore = this.perceptualScorer.encodingAccuracy[chartConfig.encoding] || 0.5;
    score += encodingScore * 0.2;
    
    return Math.max(0, Math.min(1, score));
  }
  
  scoreCandidates(candidates, task, dataProfile, constraints) {
    return candidates.map(candidate => {
      const visualization = {
        type: candidate.type,
        encoding: candidate.config.encoding,
        dimensions: this.countDimensions(candidate.config),
        categories: dataProfile.cardinality[task.columns?.category]?.unique || 1,
        width: constraints.width || 800,
        height: constraints.height || 600
      };
      
      const perceptualScore = this.perceptualScorer.scoreVisualization(
        visualization, task, dataProfile
      );
      
      return {
        ...candidate,
        score: perceptualScore.overall,
        perceptualScore: perceptualScore,
        recommendation: this.generateRecommendation(candidate, perceptualScore, task, dataProfile)
      };
    }).sort((a, b) => b.score - a.score);
  }
  
  countDimensions(chartConfig) {
    return chartConfig.dataTypes.filter(type => 
      ['numeric', 'temporal', 'categorical'].includes(type)
    ).length;
  }
  
  applyConstraints(candidates, constraints) {
    let filtered = [...candidates];
    
    // Apply audience constraints
    if (constraints.audience === 'executive') {
      // Prefer familiar, simple charts
      filtered = filtered.filter(c => 
        !['parallel', 'horizon', 'hexbin', 'contour'].includes(c.type)
      );
    } else if (constraints.audience === 'technical') ; else if (constraints.audience === 'public') {
      // Very simple charts only
      filtered = filtered.filter(c => 
        ['bar', 'line', 'pie', 'donut', 'column'].includes(c.type)
      );
    }
    
    // Apply size constraints
    if (constraints.small) {
      filtered = filtered.filter(c => 
        !['parallel', 'treemap', 'sankey'].includes(c.type)
      );
    }
    
    // Apply interactivity constraints
    if (constraints.static) {
      filtered = filtered.filter(c => 
        !['sunburst', 'parallel', 'horizon'].includes(c.type)
      );
    }
    
    // Ensure we have at least one option
    if (filtered.length === 0) {
      filtered = [candidates[0]];
    }
    
    return filtered;
  }
  
  generateRecommendation(candidate, perceptualScore, task, dataProfile) {
    const chart = candidate.config;
    const rec = {
      type: candidate.type,
      purpose: this.describePurpose(candidate.type, task),
      encoding: {
        primary: this.describeEncoding(chart.encoding),
        effectiveness: Math.round(perceptualScore.breakdown.perceptualAccuracy * 100) + '%'
      },
      specifications: this.generateSpecifications(candidate, task, dataProfile),
      enhancements: this.suggestEnhancements(candidate, task, dataProfile),
      interactions: this.suggestInteractions(candidate.type),
      accessibility: this.getAccessibilityNotes(candidate.type)
    };
    
    return rec;
  }
  
  describePurpose(chartType, task) {
    const purposes = {
      bar: 'Compare values across categories with maximum precision',
      line: 'Show trends and changes over time',
      scatter: 'Reveal relationships and correlations between variables',
      pie: 'Display parts of a whole (use sparingly)',
      heatmap: 'Identify patterns in large matrices of data',
      treemap: 'Show hierarchical data with size proportions',
      box: 'Compare statistical distributions across groups',
      parallel: 'Explore patterns across multiple dimensions',
      horizon: 'Compare many time series in limited space'
    };
    
    return purposes[chartType] || 'Visualize data patterns';
  }
  
  describeEncoding(encoding) {
    const descriptions = {
      position_common_scale: 'Position on common scale (most accurate)',
      position_nonaligned_scale: 'Position on separate scales',
      length: 'Length/height encoding',
      angle: 'Angle encoding (less accurate)',
      area: 'Area encoding (size perception)',
      color_hue: 'Color encoding (categorical distinction)'
    };
    
    return descriptions[encoding] || encoding;
  }
  
  generateSpecifications(candidate, task, dataProfile) {
    const specs = {
      dimensions: {},
      design: {},
      data: {}
    };
    
    // Map data to visual channels
    if (task.columns) {
      if (task.columns.temporal) {
        specs.dimensions.x = task.columns.temporal;
      }
      if (task.columns.category) {
        specs.dimensions.y = task.columns.category;
      }
      if (task.columns.measure) {
        specs.dimensions.value = task.columns.measure;
      }
    }
    
    // Design specifications
    specs.design = this.getDesignSpecs(candidate.type, dataProfile);
    
    // Data handling
    specs.data = this.getDataSpecs(candidate.type, dataProfile);
    
    return specs;
  }
  
  getDesignSpecs(chartType, dataProfile) {
    const baseSpecs = {
      bar: {
        orientation: 'horizontal',
        barWidth: 'automatic',
        spacing: '20% of bar width',
        gridlines: 'x-axis only',
        sort: 'descending by value'
      },
      line: {
        strokeWidth: 2,
        points: dataProfile.dimensions.rows < 50,
        smoothing: 'none',
        missingData: 'interpolate',
        multipleLines: 'direct labeling'
      },
      scatter: {
        pointSize: 3,
        opacity: dataProfile.dimensions.rows > 1000 ? 0.5 : 0.8,
        jitter: 'none',
        regression: 'optional',
        densityContours: dataProfile.dimensions.rows > 5000
      },
      heatmap: {
        colorScale: 'sequential',
        cellBorders: 'white 1px',
        clustering: 'optional',
        annotations: 'values if < 100 cells',
        aspectRatio: 'automatic'
      }
    };
    
    return baseSpecs[chartType] || {};
  }
  
  getDataSpecs(chartType, dataProfile) {
    const specs = {
      aggregation: 'automatic',
      sampling: dataProfile.dimensions.rows > 10000 ? 'recommended' : 'none',
      binning: chartType === 'histogram' ? 'sturges rule' : 'none',
      transformation: 'none'
    };
    
    return specs;
  }
  
  suggestEnhancements(candidate, task, dataProfile) {
    const enhancements = [];
    
    // Statistical enhancements
    if (['scatter', 'line'].includes(candidate.type)) {
      enhancements.push({
        type: 'statistical',
        options: ['trend line', 'confidence intervals', 'moving average']
      });
    }
    
    // Annotation enhancements
    if (task.type === 'trend_analysis') {
      enhancements.push({
        type: 'annotations',
        options: ['mark key events', 'highlight anomalies', 'show targets']
      });
    }
    
    // Reference lines
    if (['bar', 'column', 'line'].includes(candidate.type)) {
      enhancements.push({
        type: 'reference',
        options: ['average line', 'target line', 'benchmark']
      });
    }
    
    return enhancements;
  }
  
  suggestInteractions(chartType) {
    const interactions = {
      bar: ['hover details', 'click to filter', 'sort controls'],
      line: ['hover crosshair', 'zoom and pan', 'time brush'],
      scatter: ['hover details', 'lasso selection', 'zoom'],
      heatmap: ['hover cell details', 'row/column highlighting', 'zoom'],
      treemap: ['click to drill down', 'hover details', 'breadcrumb trail'],
      parallel: ['axis brushing', 'line highlighting', 'reorder axes']
    };
    
    return interactions[chartType] || ['hover details'];
  }
  
  getAccessibilityNotes(chartType) {
    const notes = {
      general: ['Ensure color is not the only encoding', 'Provide text alternatives', 
                'Use ARIA labels', 'Enable keyboard navigation'],
      specific: {}
    };
    
    notes.specific = {
      pie: 'Consider bar chart alternative for screen readers',
      color: 'Use colorblind-safe palettes',
      scatter: 'Provide data table alternative',
      heatmap: 'Include value labels or sonification'
    };
    
    return notes;
  }
  
  explainSelection(selected, task, dataProfile) {
    if (!selected) {
      return 'No suitable visualization found for this data and task combination.';
    }
    
    const explanation = {
      chosen: selected.type,
      reason: `Selected for ${task.type} task based on:`,
      factors: [
        `Perceptual accuracy: ${Math.round(selected.perceptualScore.overall * 100)}%`,
        `Task alignment: Optimized for ${task.type}`,
        `Data compatibility: Handles ${dataProfile.dimensions.rows} rows effectively`,
        `Encoding: Uses ${selected.config.encoding} (${this.describeEncoding(selected.config.encoding)})`
      ],
      tradeoffs: this.explainTradeoffs(selected, task, dataProfile)
    };
    
    return explanation;
  }
  
  explainTradeoffs(selected, task, dataProfile) {
    const tradeoffs = [];
    
    if (selected.config.encoding === 'angle' || selected.config.encoding === 'area') {
      tradeoffs.push('Less accurate perception than position-based charts');
    }
    
    if (dataProfile.dimensions.rows > selected.config.maxPoints * 0.8) {
      tradeoffs.push('May require aggregation or sampling for performance');
    }
    
    if (selected.type === 'pie' && 
        dataProfile.cardinality[task.columns?.category]?.unique > 5) {
      tradeoffs.push('Too many categories for effective pie chart use');
    }
    
    return tradeoffs;
  }
}

class AntipatternDetector {
  detectAntipatterns(visualizationPlan, dataProfile, task) {
    const warnings = [];
    
    // Check each proposed visualization
    visualizationPlan.forEach(viz => {
      const chartWarnings = this.checkChartAntipatterns(viz, dataProfile, task);
      const dataWarnings = this.checkDataAntipatterns(viz, dataProfile);
      const designWarnings = this.checkDesignAntipatterns(viz);
      const perceptualWarnings = this.checkPerceptualAntipatterns(viz, dataProfile);
      
      warnings.push(...chartWarnings, ...dataWarnings, ...designWarnings, ...perceptualWarnings);
    });
    
    // Remove duplicates and sort by severity
    const uniqueWarnings = this.deduplicateWarnings(warnings);
    return this.prioritizeWarnings(uniqueWarnings);
  }
  
  checkChartAntipatterns(viz, dataProfile, task) {
    const warnings = [];
    
    // Skip if viz is not properly defined
    if (!viz || !viz.type) {
      return warnings;
    }
    
    // Pie chart overuse
    if (viz.type === 'pie' || viz.type === 'donut') {
      const categories = viz.categories || 
        (viz.categoryColumn && dataProfile.cardinality[viz.categoryColumn]?.unique) || 0;
      
      if (categories > 7) {
        warnings.push({
          type: 'pie_chart_overuse',
          severity: 'high',
          chart: viz.type,
          issue: `${categories} categories in ${viz.type} chart`,
          problem: 'More than 7 slices become unreadable',
          impact: '40% perception error rate for small slices',
          alternative: 'horizontal bar chart',
          benefit: '5% error rate (8× better accuracy)',
          fix: {
            type: 'bar',
            orientation: 'horizontal',
            sort: 'descending'
          }
        });
      }
      
      if (categories === 2) {
        warnings.push({
          type: 'pie_for_binary',
          severity: 'medium',
          chart: viz.type,
          issue: 'Using pie chart for only 2 categories',
          problem: 'Inefficient use of space',
          alternative: 'single stacked bar or text percentage',
          benefit: 'Clearer and more compact'
        });
      }
    }
    
    // 3D effects
    if (viz.effects3d || viz.type.includes('3d')) {
      warnings.push({
        type: '3d_effects',
        severity: 'high',
        chart: viz.type,
        issue: '3D effects detected',
        problem: 'Distorts data encoding and perception',
        impact: '45% error rate in depth perception',
        alternative: 'Strong 2D design with proper visual hierarchy',
        designPrinciples: [
          'Use whitespace for separation',
          'Bold colors for emphasis',
          'Clear typography hierarchy'
        ]
      });
    }
    
    // Dual Y-axis
    if (viz.dualAxis || viz.secondaryAxis) {
      warnings.push({
        type: 'dual_y_axis',
        severity: 'high',
        chart: viz.type,
        issue: 'Dual Y-axis configuration',
        problem: 'Implies false correlations',
        impact: '68% of viewers misinterpret relationship',
        alternative: 'Small multiples or indexed values',
        benefit: 'Clear, unambiguous comparison'
      });
    }
    
    // Inappropriate chart for task
    if (!this.isChartAppropriateForTask(viz.type, task.type)) {
      warnings.push({
        type: 'task_mismatch',
        severity: 'medium',
        chart: viz.type,
        task: task.type,
        issue: `${viz.type} chart not optimal for ${task.type}`,
        problem: 'Visualization does not support analytical task',
        alternative: this.getOptimalChartForTask(task.type),
        benefit: 'Better task-visualization alignment'
      });
    }
    
    return warnings;
  }
  
  checkDataAntipatterns(viz, dataProfile) {
    const warnings = [];
    const dataPoints = dataProfile.dimensions.rows;
    
    // Overplotting
    if (viz.type === 'scatter' || viz.type === 'bubble') {
      const area = (viz.width || 800) * (viz.height || 600);
      const pointsPerPixel = dataPoints / area;
      
      if (pointsPerPixel > 0.1) {
        warnings.push({
          type: 'overplotting',
          severity: 'high',
          chart: viz.type,
          issue: `${Math.round(pointsPerPixel * 100)} points per 100 pixels`,
          problem: 'Overplotting hides patterns and distributions',
          impact: 'Up to 90% of data points may be hidden',
          solutions: [
            {
              method: 'hexbin',
              benefit: 'Aggregates points into hexagonal bins',
              suitable: dataPoints < 1000000
            },
            {
              method: 'density_contours',
              benefit: 'Shows density without individual points',
              suitable: true
            },
            {
              method: 'sampling',
              benefit: 'Reduces points while maintaining distribution',
              suitable: dataPoints > 100000
            },
            {
              method: 'transparency',
              benefit: 'Reveals density through overlapping',
              suitable: dataPoints < 10000
            }
          ]
        });
      }
    }
    
    // Too many categories
    if (viz.type === 'bar' || viz.type === 'column') {
      const categories = viz.categories || 
        (viz.categoryColumn && dataProfile.cardinality[viz.categoryColumn]?.unique) || 0;
      
      if (categories > 50) {
        warnings.push({
          type: 'too_many_categories',
          severity: 'medium',
          chart: viz.type,
          issue: `${categories} categories in bar chart`,
          problem: 'Too many bars to compare effectively',
          solutions: [
            'Show top 20 with "Others" category',
            'Use hierarchical grouping',
            'Implement search/filter functionality',
            'Consider treemap for part-to-whole'
          ]
        });
      }
    }
    
    // Inappropriate aggregation
    if (viz.aggregation === 'mean' && dataProfile.patterns?.numeric) {
      const numericPatterns = Object.values(dataProfile.patterns.numeric);
      const skewedColumns = numericPatterns.filter(p => 
        Math.abs(p.distribution?.skewness || 0) > 1
      );
      
      if (skewedColumns.length > 0) {
        warnings.push({
          type: 'mean_with_skewed_data',
          severity: 'medium',
          issue: 'Using mean with skewed distributions',
          problem: 'Mean not representative of typical values',
          impact: 'Misleading central tendency',
          alternative: 'Use median for skewed data',
          affectedColumns: skewedColumns.map(p => p.column)
        });
      }
    }
    
    return warnings;
  }
  
  checkDesignAntipatterns(viz) {
    const warnings = [];
    
    // Rainbow color scale
    if (viz.colorScale === 'rainbow' || viz.colors?.length > 7) {
      warnings.push({
        type: 'rainbow_color_scale',
        severity: 'high',
        issue: 'Rainbow or too many colors',
        problem: 'Non-uniform perception and no logical order',
        impact: [
          'Yellow appears artificially brighter',
          'No intuitive ordering',
          'Accessibility issues'
        ],
        alternative: 'Single-hue gradient or ColorBrewer palette',
        recommendations: {
          sequential: 'Blues, Greens, or Viridis',
          diverging: 'RdBu or BrBG (diverging from center)',
          qualitative: 'Set2 or Set3 (distinct categories)'
        }
      });
    }
    
    // Chartjunk
    if (viz.gridlines?.heavy || viz.borders?.decorative || viz.backgrounds?.gradient) {
      warnings.push({
        type: 'chartjunk',
        severity: 'medium',
        issue: 'Excessive non-data ink',
        problem: 'Distracts from data',
        dataInkRatio: this.estimateDataInkRatio(viz),
        target: 'Data-ink ratio should exceed 0.5',
        fixes: [
          'Remove heavy gridlines',
          'Eliminate decorative borders',
          'Use solid backgrounds',
          'Remove unnecessary legends'
        ]
      });
    }
    
    // Truncated axes
    if (viz.yAxis?.min > 0 && viz.type !== 'scatter') {
      warnings.push({
        type: 'truncated_axis',
        severity: 'high',
        issue: 'Y-axis does not start at zero',
        problem: 'Exaggerates differences',
        lieFactor: this.calculateLieFactor(viz),
        impact: 'Visual representation distorts actual proportions',
        exceptions: [
          'Scatter plots where zero is not meaningful',
          'Time series with small variations',
          'Log scales where appropriate'
        ]
      });
    }
    
    // Aspect ratio issues
    if (viz.type === 'line' && viz.aspectRatio) {
      const ratio = viz.width / viz.height;
      if (ratio < 0.5 || ratio > 3) {
        warnings.push({
          type: 'poor_aspect_ratio',
          severity: 'low',
          issue: 'Suboptimal aspect ratio for line chart',
          problem: 'Distorts perception of trends',
          recommendation: 'Banking to 45° for optimal slope perception',
          idealRatio: '1.6:1 to 2:1 for most time series'
        });
      }
    }
    
    return warnings;
  }
  
  checkPerceptualAntipatterns(viz, dataProfile) {
    const warnings = [];
    
    // Area encoding for precise comparison
    if ((viz.type === 'bubble' || viz.type === 'treemap') && 
        viz.purpose?.includes('precise')) {
      warnings.push({
        type: 'area_for_precision',
        severity: 'medium',
        issue: 'Area encoding for precise comparisons',
        problem: 'Humans poor at comparing areas',
        impact: '20-30% error rate in size perception',
        alternative: 'Bar chart for precise comparisons',
        keepIf: 'Overall patterns more important than exact values'
      });
    }
    
    // Color as only differentiator
    if (viz.encoding === 'color' && !viz.redundantEncoding) {
      warnings.push({
        type: 'color_only_encoding',
        severity: 'high',
        issue: 'Color as sole differentiator',
        problem: 'Fails for colorblind users (8% of men)',
        impact: 'Information inaccessible to many',
        solutions: [
          'Add patterns or textures',
          'Use direct labeling',
          'Vary lightness along with hue',
          'Add position or shape encoding'
        ]
      });
    }
    
    // Overlapping labels
    if (viz.labels && dataProfile.dimensions.rows > 20) {
      warnings.push({
        type: 'label_overlap_risk',
        severity: 'low',
        issue: 'Potential label overlap',
        problem: 'Labels may overlap with many data points',
        solutions: [
          'Use hover labels instead',
          'Label only key points',
          'Implement smart label placement',
          'Use leader lines for clarity'
        ]
      });
    }
    
    return warnings;
  }
  
  isChartAppropriateForTask(chartType, taskType) {
    const taskChartMatrix = {
      trend_analysis: ['line', 'area', 'horizon', 'sparkline'],
      comparison: ['bar', 'column', 'bullet', 'dot'],
      part_to_whole: ['stacked_bar', 'treemap', 'pie', 'donut'],
      correlation: ['scatter', 'hexbin', 'contour'],
      distribution: ['histogram', 'box', 'violin', 'density'],
      ranking: ['bar', 'lollipop', 'slope'],
      geospatial: ['choropleth', 'symbol', 'heatmap'],
      pattern: ['heatmap', 'parallel', 'radar']
    };
    
    return taskChartMatrix[taskType]?.includes(chartType) || false;
  }
  
  getOptimalChartForTask(taskType) {
    const optimal = {
      trend_analysis: 'line chart',
      comparison: 'bar chart',
      part_to_whole: 'stacked bar or treemap',
      correlation: 'scatter plot',
      distribution: 'histogram or box plot',
      ranking: 'horizontal bar chart',
      geospatial: 'choropleth map',
      pattern: 'heatmap'
    };
    
    return optimal[taskType] || 'bar chart';
  }
  
  estimateDataInkRatio(viz) {
    let nonDataElements = 0;
    
    if (viz.gridlines?.heavy) nonDataElements += 0.15;
    if (viz.borders?.decorative) nonDataElements += 0.1;
    if (viz.backgrounds?.gradient) nonDataElements += 0.1;
    if (viz.effects3d) nonDataElements += 0.2;
    if (viz.decorations) nonDataElements += 0.15;
    
    return Math.max(0.2, 1 - nonDataElements);
  }
  
  calculateLieFactor(viz) {
    if (!viz.yAxis?.min || viz.yAxis.min === 0) return 1;
    
    const visualRange = viz.yAxis.max - viz.yAxis.min;
    const dataRange = viz.yAxis.max - 0;
    
    return dataRange / visualRange;
  }
  
  deduplicateWarnings(warnings) {
    const seen = new Set();
    return warnings.filter(warning => {
      const key = `${warning.type}-${warning.chart || ''}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
  
  prioritizeWarnings(warnings) {
    const severityOrder = { high: 1, medium: 2, low: 3 };
    
    return warnings.sort((a, b) => {
      const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityDiff !== 0) return severityDiff;
      
      // Within same severity, prioritize by type
      const typeOrder = {
        'pie_chart_overuse': 1,
        '3d_effects': 2,
        'dual_y_axis': 3,
        'overplotting': 4,
        'rainbow_color_scale': 5,
        'color_only_encoding': 6,
        'truncated_axis': 7
      };
      
      return (typeOrder[a.type] || 99) - (typeOrder[b.type] || 99);
    });
  }
}

class AccessibilityChecker {
  checkAccessibility(visualizationPlan) {
    const results = {
      score: 0,
      level: '',
      issues: [],
      recommendations: [],
      guidelines: []
    };
    
    // Check each visualization
    visualizationPlan.forEach(viz => {
      const colorIssues = this.checkColorAccessibility(viz);
      const contrastIssues = this.checkContrast(viz);
      const alternativeIssues = this.checkAlternatives(viz);
      const interactionIssues = this.checkInteractionAccessibility(viz);
      const cognitiveIssues = this.checkCognitiveAccessibility(viz);
      
      results.issues.push(...colorIssues, ...contrastIssues, 
                          ...alternativeIssues, ...interactionIssues, 
                          ...cognitiveIssues);
    });
    
    // Calculate overall score
    results.score = this.calculateAccessibilityScore(results.issues);
    results.level = this.determineComplianceLevel(results.score);
    
    // Generate recommendations
    results.recommendations = this.generateRecommendations(results.issues);
    results.guidelines = this.getRelevantGuidelines(visualizationPlan);
    
    return results;
  }
  
  checkColorAccessibility(viz) {
    const issues = [];
    
    // Check if color is sole encoding
    if (viz.encoding === 'color' && !viz.secondaryEncoding) {
      issues.push({
        type: 'color_only_encoding',
        severity: 'critical',
        wcag: '1.4.1',
        chart: viz.type,
        issue: 'Color used as only method of conveying information',
        impact: 'Information inaccessible to colorblind users (8% of males, 0.5% of females)',
        solutions: [
          'Add patterns or textures to colored areas',
          'Use direct labeling on chart elements',
          'Provide shape or position as secondary encoding',
          'Include data table alternative'
        ]
      });
    }
    
    // Check colorblind safety
    if (viz.colors && !this.isColorblindSafe(viz.colors)) {
      issues.push({
        type: 'colorblind_unsafe',
        severity: 'high',
        wcag: '1.4.1',
        chart: viz.type,
        issue: 'Color palette not colorblind safe',
        affectedTypes: this.getAffectedColorblindTypes(viz.colors),
        solutions: [
          'Use colorblind-safe palettes (e.g., Viridis, Cividis)',
          'Test with colorblind simulators',
          'Avoid problematic combinations (red/green, blue/purple)',
          'Use ColorBrewer "colorblind safe" palettes'
        ]
      });
    }
    
    // Check for too many colors
    if (viz.colors && viz.colors.length > 8) {
      issues.push({
        type: 'too_many_colors',
        severity: 'medium',
        wcag: '1.4.1',
        issue: `${viz.colors.length} distinct colors used`,
        impact: 'Difficult to distinguish between similar colors',
        solutions: [
          'Limit to 5-7 distinct colors maximum',
          'Group less important categories as "Other"',
          'Use interactive filtering instead',
          'Consider different chart type'
        ]
      });
    }
    
    return issues;
  }
  
  checkContrast(viz) {
    const issues = [];
    
    // Text contrast
    if (viz.textElements) {
      viz.textElements.forEach(element => {
        const ratio = this.calculateContrastRatio(
          element.color || '#000000',
          element.background || '#FFFFFF'
        );
        
        if (element.size >= 14 && ratio < 4.5) {
          issues.push({
            type: 'insufficient_text_contrast',
            severity: 'high',
            wcag: '1.4.3',
            element: element.type,
            contrastRatio: ratio.toFixed(2),
            required: '4.5:1',
            impact: 'Text difficult to read for low vision users',
            solution: `Darken text to ${this.suggestColor(element.background, 4.5)}`
          });
        } else if (element.size >= 18 && ratio < 3) {
          issues.push({
            type: 'insufficient_large_text_contrast',
            severity: 'medium',
            wcag: '1.4.3',
            element: element.type,
            contrastRatio: ratio.toFixed(2),
            required: '3:1',
            impact: 'Large text difficult to read'
          });
        }
      });
    }
    
    // Non-text contrast (WCAG 2.1)
    if (viz.graphicalElements) {
      viz.graphicalElements.forEach(element => {
        const ratio = this.calculateContrastRatio(
          element.color || '#000000',
          element.background || '#FFFFFF'
        );
        
        if (ratio < 3) {
          issues.push({
            type: 'insufficient_graphic_contrast',
            severity: 'medium',
            wcag: '1.4.11',
            element: element.type,
            contrastRatio: ratio.toFixed(2),
            required: '3:1',
            impact: 'Chart elements difficult to perceive',
            examples: ['Grid lines too faint', 'Data points blend with background']
          });
        }
      });
    }
    
    return issues;
  }
  
  checkAlternatives(viz) {
    const issues = [];
    
    // Check for text alternatives
    if (!viz.altText && !viz.dataTableAlternative) {
      issues.push({
        type: 'missing_text_alternative',
        severity: 'critical',
        wcag: '1.1.1',
        chart: viz.type,
        issue: 'No text alternative provided',
        impact: 'Chart completely inaccessible to screen reader users',
        solutions: [
          'Provide comprehensive alt text describing the data and trends',
          'Include accessible data table alternative',
          'Use ARIA labels and descriptions',
          'Implement sonification for data trends'
        ]
      });
    }
    
    // Check alt text quality
    if (viz.altText && viz.altText.length < 50) {
      issues.push({
        type: 'insufficient_alt_text',
        severity: 'medium',
        wcag: '1.1.1',
        currentLength: viz.altText.length,
        issue: 'Alt text too brief',
        guidelines: [
          'Describe the chart type and purpose',
          'Summarize key data points and trends',
          'Include relevant statistics',
          'Mention any notable patterns or outliers'
        ]
      });
    }
    
    // Complex visualizations need detailed alternatives
    if (['parallel', 'sankey', 'chord', 'network'].includes(viz.type)) {
      issues.push({
        type: 'complex_viz_needs_alternative',
        severity: 'high',
        wcag: '1.1.1',
        chart: viz.type,
        issue: 'Complex visualization requires detailed alternative',
        solutions: [
          'Provide structured data table',
          'Create text summary of relationships',
          'Offer simplified view option',
          'Include guided tour or explanation'
        ]
      });
    }
    
    return issues;
  }
  
  checkInteractionAccessibility(viz) {
    const issues = [];
    
    // Keyboard accessibility
    if (viz.interactive && !viz.keyboardSupport) {
      issues.push({
        type: 'missing_keyboard_support',
        severity: 'critical',
        wcag: '2.1.1',
        issue: 'Interactive elements not keyboard accessible',
        impact: 'Users who cannot use mouse cannot access functionality',
        requirements: [
          'All interactive elements focusable',
          'Tab order logical',
          'Focus indicators visible',
          'Keyboard shortcuts documented'
        ]
      });
    }
    
    // Hover-only information
    if (viz.hoverOnly) {
      issues.push({
        type: 'hover_only_content',
        severity: 'high',
        wcag: '1.4.13',
        issue: 'Information only available on hover',
        impact: 'Touch and keyboard users cannot access',
        solutions: [
          'Provide click/tap alternative',
          'Show key information by default',
          'Use progressive disclosure',
          'Implement focus + Enter pattern'
        ]
      });
    }
    
    // Time limits
    if (viz.animation && !viz.animationControl) {
      issues.push({
        type: 'uncontrolled_animation',
        severity: 'medium',
        wcag: '2.2.2',
        issue: 'Animation without user control',
        impact: 'Distracting for users with attention disorders',
        requirements: [
          'Pause/play controls',
          'Option to disable animations',
          'Reduced motion media query support',
          'Static alternative available'
        ]
      });
    }
    
    return issues;
  }
  
  checkCognitiveAccessibility(viz) {
    const issues = [];
    
    // Complexity
    if (viz.dimensions > 3) {
      issues.push({
        type: 'high_cognitive_load',
        severity: 'medium',
        wcag: '3.1.5',
        dimensions: viz.dimensions,
        issue: 'High dimensional complexity',
        impact: 'Difficult for users with cognitive disabilities',
        solutions: [
          'Progressive disclosure of dimensions',
          'Start with 2D view, add dimensions gradually',
          'Provide guided exploration',
          'Include explanatory text'
        ]
      });
    }
    
    // Consistency
    if (viz.unconventionalDesign) {
      issues.push({
        type: 'unconventional_design',
        severity: 'low',
        wcag: '3.2.4',
        issue: 'Non-standard visualization design',
        impact: 'Learning curve for all users',
        solutions: [
          'Include legend and instructions',
          'Provide familiar alternative view',
          'Use progressive enhancement',
          'Add tutorial or walkthrough'
        ]
      });
    }
    
    // Instructions
    if (viz.complex && !viz.instructions) {
      issues.push({
        type: 'missing_instructions',
        severity: 'medium',
        wcag: '3.3.2',
        issue: 'Complex visualization without instructions',
        impact: 'Users may not understand how to use',
        requirements: [
          'Clear instructions near chart',
          'Example interpretations',
          'Interactive help system',
          'Video tutorial option'
        ]
      });
    }
    
    return issues;
  }
  
  isColorblindSafe(colors) {
    
    // Check if any colors are too similar under colorblind simulation
    for (let i = 0; i < colors.length; i++) {
      for (let j = i + 1; j < colors.length; j++) {
        if (this.areColorsSimilarForColorblind(colors[i], colors[j])) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  areColorsSimilarForColorblind(color1, color2) {
    // Simplified check - in practice would use proper color vision simulation
    const rgb1 = this.hexToRgb(color1);
    const rgb2 = this.hexToRgb(color2);
    
    // Simulate deuteranopia (most common)
    const sim1 = {
      r: 0.625 * rgb1.r + 0.375 * rgb1.g,
      g: 0.7 * rgb1.g + 0.3 * rgb1.r,
      b: rgb1.b
    };
    
    const sim2 = {
      r: 0.625 * rgb2.r + 0.375 * rgb2.g,
      g: 0.7 * rgb2.g + 0.3 * rgb2.r,
      b: rgb2.b
    };
    
    // Calculate perceptual difference
    const diff = Math.sqrt(
      Math.pow(sim1.r - sim2.r, 2) +
      Math.pow(sim1.g - sim2.g, 2) +
      Math.pow(sim1.b - sim2.b, 2)
    );
    
    return diff < 50; // Threshold for "too similar"
  }
  
  getAffectedColorblindTypes(colors) {
    const types = [];
    
    // Check which types would have issues
    if (colors.includes('#FF0000') && colors.includes('#00FF00')) {
      types.push('Protanopia (1% of males)', 'Deuteranopia (6% of males)');
    }
    
    if (colors.includes('#0000FF') && colors.includes('#FF00FF')) {
      types.push('Tritanopia (0.01% of population)');
    }
    
    return types.length > 0 ? types : ['General color discrimination'];
  }
  
  calculateContrastRatio(foreground, background) {
    const lum1 = this.getRelativeLuminance(foreground);
    const lum2 = this.getRelativeLuminance(background);
    
    const lighter = Math.max(lum1, lum2);
    const darker = Math.min(lum1, lum2);
    
    return (lighter + 0.05) / (darker + 0.05);
  }
  
  getRelativeLuminance(color) {
    const rgb = this.hexToRgb(color);
    
    const rsRGB = rgb.r / 255;
    const gsRGB = rgb.g / 255;
    const bsRGB = rgb.b / 255;
    
    const r = rsRGB <= 0.03928 ? rsRGB / 12.92 : Math.pow((rsRGB + 0.055) / 1.055, 2.4);
    const g = gsRGB <= 0.03928 ? gsRGB / 12.92 : Math.pow((gsRGB + 0.055) / 1.055, 2.4);
    const b = bsRGB <= 0.03928 ? bsRGB / 12.92 : Math.pow((bsRGB + 0.055) / 1.055, 2.4);
    
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }
  
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  
  suggestColor(background, targetRatio) {
    // Suggest a foreground color that meets contrast requirements
    const bgLum = this.getRelativeLuminance(background);
    const targetLum = targetRatio * (bgLum + 0.05) - 0.05;
    
    // Simple suggestion - in practice would calculate exact color
    return targetLum > bgLum ? '#000000' : '#FFFFFF';
  }
  
  calculateAccessibilityScore(issues) {
    let score = 100;
    
    issues.forEach(issue => {
      switch (issue.severity) {
        case 'critical':
          score -= 20;
          break;
        case 'high':
          score -= 10;
          break;
        case 'medium':
          score -= 5;
          break;
        case 'low':
          score -= 2;
          break;
      }
    });
    
    return Math.max(0, score);
  }
  
  determineComplianceLevel(score) {
    if (score >= 95) return 'AAA';
    if (score >= 85) return 'AA';
    if (score >= 70) return 'A';
    return 'Non-compliant';
  }
  
  generateRecommendations(issues) {
    const recommendations = [];
    const issueTypes = new Set(issues.map(i => i.type));
    
    // Prioritized recommendations based on issues found
    if (issueTypes.has('color_only_encoding')) {
      recommendations.push({
        priority: 'immediate',
        action: 'Add redundant encodings',
        description: 'Never rely on color alone. Add patterns, shapes, or labels.',
        effort: 'medium'
      });
    }
    
    if (issueTypes.has('missing_text_alternative')) {
      recommendations.push({
        priority: 'immediate',
        action: 'Provide text alternatives',
        description: 'Add comprehensive alt text and data tables for all charts.',
        effort: 'low'
      });
    }
    
    if (issueTypes.has('insufficient_text_contrast')) {
      recommendations.push({
        priority: 'high',
        action: 'Improve contrast ratios',
        description: 'Ensure all text meets WCAG contrast requirements.',
        effort: 'low'
      });
    }
    
    if (issueTypes.has('missing_keyboard_support')) {
      recommendations.push({
        priority: 'high',
        action: 'Implement keyboard navigation',
        description: 'Make all interactive elements keyboard accessible.',
        effort: 'high'
      });
    }
    
    // General best practices
    recommendations.push({
      priority: 'ongoing',
      action: 'Test with assistive technologies',
      description: 'Regular testing with screen readers and keyboard navigation.',
      effort: 'medium'
    });
    
    return recommendations;
  }
  
  getRelevantGuidelines(visualizationPlan) {
    return [
      {
        principle: 'Perceivable',
        guidelines: [
          '1.1.1 - Provide text alternatives',
          '1.4.1 - Don\'t use color alone',
          '1.4.3 - Ensure sufficient contrast',
          '1.4.11 - Non-text contrast (WCAG 2.1)'
        ]
      },
      {
        principle: 'Operable',
        guidelines: [
          '2.1.1 - Keyboard accessible',
          '2.2.2 - Pause, stop, hide animations',
          '2.4.7 - Focus visible'
        ]
      },
      {
        principle: 'Understandable',
        guidelines: [
          '3.1.5 - Reading level',
          '3.2.4 - Consistent identification',
          '3.3.2 - Labels or instructions'
        ]
      },
      {
        principle: 'Robust',
        guidelines: [
          '4.1.2 - Name, role, value',
          '4.1.3 - Status messages (WCAG 2.1)'
        ]
      }
    ];
  }
}

class PaletteSelector {
  constructor() {
    // ColorBrewer palettes - scientifically designed for data visualization
    this.palettes = {
      sequential: {
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        // Perceptually uniform
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],
        Plasma: ['#0d0887', '#4b03a1', '#7d03a8', '#a82296', '#cb4679', '#e56b5d', '#f89441', '#fdc328', '#f0f921'],
        Inferno: ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c60', '#cf4446', '#ed6925', '#fb9b06', '#fcffa4'],
        Magma: ['#000004', '#180f3d', '#440f76', '#721f81', '#9e2f7f', '#cd4071', '#f1605d', '#fd9668', '#fcfdbf']
      },
      diverging: {
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2']
      },
      qualitative: {
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928']
      }
    };
    
    // Colorblind safe combinations
    this.colorblindSafePalettes = {
      protanopia: ['#0173B2', '#DE8F05', '#029E73', '#CC78BC', '#CA9161', '#FBAFE4'],
      deuteranopia: ['#0173B2', '#DE8F05', '#029E73', '#CC78BC', '#CA9161', '#FBAFE4'],
      tritanopia: ['#E66100', '#5D3A9B', '#1F77B4', '#FF7F0E', '#2CA02C', '#D62728']
    };
  }
  
  selectPalette(dataCharacteristics, visualizationType, constraints = {}) {
    const paletteType = this.determinePaletteType(dataCharacteristics, visualizationType);
    const numberOfColors = this.determineNumberOfColors(dataCharacteristics, visualizationType);
    
    const recommendation = {
      primary: this.selectPrimaryPalette(paletteType, numberOfColors, constraints),
      alternatives: this.selectAlternatives(paletteType, numberOfColors, constraints),
      specification: this.generateSpecification(paletteType, numberOfColors, dataCharacteristics),
      accessibility: this.generateAccessibilityNotes(constraints),
      implementation: this.generateImplementation(paletteType)
    };
    
    return recommendation;
  }
  
  determinePaletteType(dataCharacteristics, visualizationType) {
    // Sequential data (ordered, numeric progression)
    if (dataCharacteristics.isSequential || 
        ['heatmap', 'choropleth', 'density'].includes(visualizationType)) {
      return 'sequential';
    }
    
    // Diverging data (deviation from a center point)
    if (dataCharacteristics.isDiverging || 
        dataCharacteristics.hasNegativeValues ||
        visualizationType === 'diverging_bar') {
      return 'diverging';
    }
    
    // Categorical data (distinct categories)
    if (dataCharacteristics.isCategorical || 
        ['bar', 'pie', 'donut', 'scatter'].includes(visualizationType)) {
      return 'qualitative';
    }
    
    return 'qualitative'; // Default
  }
  
  determineNumberOfColors(dataCharacteristics, visualizationType) {
    if (visualizationType === 'heatmap' || visualizationType === 'choropleth') {
      return 9; // Standard for continuous scales
    }
    
    if (dataCharacteristics.categories) {
      return Math.min(dataCharacteristics.categories, 12); // Max 12 distinct colors
    }
    
    return 5; // Default
  }
  
  selectPrimaryPalette(paletteType, numberOfColors, constraints) {
    let selectedPalette;
    let colors;
    
    // Handle accessibility constraints
    if (constraints.colorblindSafe) {
      if (paletteType === 'qualitative') {
        selectedPalette = 'Colorblind Safe';
        colors = this.colorblindSafePalettes.deuteranopia.slice(0, numberOfColors);
      } else if (paletteType === 'sequential') {
        selectedPalette = 'Viridis';
        colors = this.interpolatePalette(this.palettes.sequential.Viridis, numberOfColors);
      } else {
        selectedPalette = 'RdBu';
        colors = this.interpolatePalette(this.palettes.diverging.RdBu, numberOfColors);
      }
    } else {
      // Standard selection based on type
      if (paletteType === 'sequential') {
        selectedPalette = constraints.printFriendly ? 'Greys' : 'Blues';
        colors = this.interpolatePalette(this.palettes.sequential[selectedPalette], numberOfColors);
      } else if (paletteType === 'diverging') {
        selectedPalette = 'RdBu';
        colors = this.interpolatePalette(this.palettes.diverging[selectedPalette], numberOfColors);
      } else {
        selectedPalette = numberOfColors <= 8 ? 'Set2' : 'Set3';
        colors = this.palettes.qualitative[selectedPalette].slice(0, numberOfColors);
      }
    }
    
    return {
      name: selectedPalette,
      colors: colors,
      type: paletteType,
      perceptuallyUniform: ['Viridis', 'Plasma', 'Inferno', 'Magma'].includes(selectedPalette),
      colorblindSafe: this.isColorblindSafe(colors),
      printSafe: this.isPrintSafe(colors),
      culturallyNeutral: this.isCulturallyNeutral(selectedPalette)
    };
  }
  
  selectAlternatives(paletteType, numberOfColors, constraints) {
    const alternatives = [];
    const palettesOfType = this.palettes[paletteType];
    
    Object.entries(palettesOfType).forEach(([name, palette]) => {
      const colors = paletteType === 'qualitative' 
        ? palette.slice(0, numberOfColors)
        : this.interpolatePalette(palette, numberOfColors);
      
      const meetsConstraints = this.checkConstraints(colors, constraints);
      
      if (meetsConstraints) {
        alternatives.push({
          name: name,
          colors: colors,
          characteristics: this.analyzePaletteCharacteristics(colors, name)
        });
      }
    });
    
    // Sort by suitability
    return alternatives
      .sort((a, b) => this.scorePalette(b, constraints) - this.scorePalette(a, constraints))
      .slice(0, 3);
  }
  
  interpolatePalette(palette, targetCount) {
    if (palette.length === targetCount) return palette;
    
    if (palette.length > targetCount) {
      // Sample evenly from the palette
      const step = (palette.length - 1) / (targetCount - 1);
      const colors = [];
      for (let i = 0; i < targetCount; i++) {
        colors.push(palette[Math.round(i * step)]);
      }
      return colors;
    }
    
    // If we need more colors than available, interpolate
    // This is simplified - in practice would use proper color interpolation
    return palette.slice(0, targetCount);
  }
  
  checkConstraints(colors, constraints) {
    if (constraints.colorblindSafe && !this.isColorblindSafe(colors)) {
      return false;
    }
    
    if (constraints.printFriendly && !this.isPrintSafe(colors)) {
      return false;
    }
    
    if (constraints.minContrast) {
      const meetsContrast = this.checkMinimumContrast(colors, constraints.minContrast);
      if (!meetsContrast) return false;
    }
    
    return true;
  }
  
  isColorblindSafe(colors) {
    
    // Check if colors are distinguishable under common colorblind conditions
    for (let i = 0; i < colors.length; i++) {
      for (let j = i + 1; j < colors.length; j++) {
        const distance = this.calculateColorDistance(colors[i], colors[j], 'deuteranopia');
        if (distance < 50) return false;
      }
    }
    
    return true;
  }
  
  isPrintSafe(colors) {
    // Check if colors work in grayscale
    const grayscaleValues = colors.map(color => this.toGrayscale(color));
    
    // Ensure sufficient variation in grayscale
    for (let i = 0; i < grayscaleValues.length; i++) {
      for (let j = i + 1; j < grayscaleValues.length; j++) {
        if (Math.abs(grayscaleValues[i] - grayscaleValues[j]) < 30) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  isCulturallyNeutral(paletteName) {
    // Some palettes have cultural associations to avoid
    const culturallySensitive = {
      'RdBu': 'May imply good/bad in some contexts',
      'RdGn': 'Red=bad, Green=good association',
      'RdYlGn': 'Traffic light association'
    };
    
    return !culturallySensitive[paletteName];
  }
  
  calculateColorDistance(color1, color2, condition = 'normal') {
    // Simplified perceptual distance calculation
    const rgb1 = this.hexToRgb(color1);
    const rgb2 = this.hexToRgb(color2);
    
    if (condition === 'deuteranopia') {
      // Simulate deuteranopia
      rgb1.r = 0.625 * rgb1.r + 0.375 * rgb1.g;
      rgb1.g = 0.7 * rgb1.g + 0.3 * rgb1.r;
      rgb2.r = 0.625 * rgb2.r + 0.375 * rgb2.g;
      rgb2.g = 0.7 * rgb2.g + 0.3 * rgb2.r;
    }
    
    return Math.sqrt(
      Math.pow(rgb1.r - rgb2.r, 2) +
      Math.pow(rgb1.g - rgb2.g, 2) +
      Math.pow(rgb1.b - rgb2.b, 2)
    );
  }
  
  toGrayscale(color) {
    const rgb = this.hexToRgb(color);
    return 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
  }
  
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  
  checkMinimumContrast(colors, minContrast) {
    // Check all color pairs meet minimum contrast
    for (let i = 0; i < colors.length; i++) {
      for (let j = i + 1; j < colors.length; j++) {
        const contrast = this.calculateContrast(colors[i], colors[j]);
        if (contrast < minContrast) return false;
      }
    }
    return true;
  }
  
  calculateContrast(color1, color2) {
    const lum1 = this.getRelativeLuminance(color1);
    const lum2 = this.getRelativeLuminance(color2);
    
    const lighter = Math.max(lum1, lum2);
    const darker = Math.min(lum1, lum2);
    
    return (lighter + 0.05) / (darker + 0.05);
  }
  
  getRelativeLuminance(color) {
    const rgb = this.hexToRgb(color);
    
    const rsRGB = rgb.r / 255;
    const gsRGB = rgb.g / 255;
    const bsRGB = rgb.b / 255;
    
    const r = rsRGB <= 0.03928 ? rsRGB / 12.92 : Math.pow((rsRGB + 0.055) / 1.055, 2.4);
    const g = gsRGB <= 0.03928 ? gsRGB / 12.92 : Math.pow((gsRGB + 0.055) / 1.055, 2.4);
    const b = bsRGB <= 0.03928 ? bsRGB / 12.92 : Math.pow((bsRGB + 0.055) / 1.055, 2.4);
    
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }
  
  analyzePaletteCharacteristics(colors, name) {
    return {
      perceptualDistance: this.calculateAveragePerceptualDistance(colors),
      grayscaleVariation: this.calculateGrayscaleVariation(colors),
      warmthBias: this.calculateWarmthBias(colors),
      saturationLevel: this.calculateAverageSaturation(colors),
      contrastRange: this.calculateContrastRange(colors)
    };
  }
  
  calculateAveragePerceptualDistance(colors) {
    let totalDistance = 0;
    let pairs = 0;
    
    for (let i = 0; i < colors.length; i++) {
      for (let j = i + 1; j < colors.length; j++) {
        totalDistance += this.calculateColorDistance(colors[i], colors[j]);
        pairs++;
      }
    }
    
    return pairs > 0 ? totalDistance / pairs : 0;
  }
  
  calculateGrayscaleVariation(colors) {
    const grayscaleValues = colors.map(color => this.toGrayscale(color));
    const min = Math.min(...grayscaleValues);
    const max = Math.max(...grayscaleValues);
    return max - min;
  }
  
  calculateWarmthBias(colors) {
    // Calculate average "warmth" of palette
    const warmth = colors.map(color => {
      const rgb = this.hexToRgb(color);
      return (rgb.r + rgb.g * 0.5) / (rgb.b + 1); // Simplified warmth calculation
    });
    
    return warmth.reduce((a, b) => a + b) / warmth.length;
  }
  
  calculateAverageSaturation(colors) {
    // Simplified saturation calculation
    const saturations = colors.map(color => {
      const rgb = this.hexToRgb(color);
      const max = Math.max(rgb.r, rgb.g, rgb.b);
      const min = Math.min(rgb.r, rgb.g, rgb.b);
      return max === 0 ? 0 : (max - min) / max;
    });
    
    return saturations.reduce((a, b) => a + b) / saturations.length;
  }
  
  calculateContrastRange(colors) {
    let minContrast = Infinity;
    let maxContrast = 0;
    
    for (let i = 0; i < colors.length; i++) {
      for (let j = i + 1; j < colors.length; j++) {
        const contrast = this.calculateContrast(colors[i], colors[j]);
        minContrast = Math.min(minContrast, contrast);
        maxContrast = Math.max(maxContrast, contrast);
      }
    }
    
    return { min: minContrast, max: maxContrast, range: maxContrast - minContrast };
  }
  
  scorePalette(palette, constraints) {
    let score = 0;
    
    // Base score on characteristics
    score += palette.characteristics.perceptualDistance / 100;
    score += palette.characteristics.grayscaleVariation / 255;
    score += Math.min(palette.characteristics.contrastRange.min / 3, 1);
    
    // Bonus for specific features
    if (constraints.colorblindSafe && this.isColorblindSafe(palette.colors)) {
      score += 2;
    }
    
    if (constraints.printFriendly && this.isPrintSafe(palette.colors)) {
      score += 1;
    }
    
    return score;
  }
  
  generateSpecification(paletteType, numberOfColors, dataCharacteristics) {
    const spec = {
      paletteType: paletteType,
      numberOfColors: numberOfColors,
      usage: {}
    };
    
    if (paletteType === 'sequential') {
      spec.usage = {
        minimum: 'Lightest color',
        maximum: 'Darkest color',
        direction: 'Low to high values',
        nullValue: '#f7f7f7 (light gray)',
        missingData: 'Hatched pattern or distinct gray'
      };
    } else if (paletteType === 'diverging') {
      spec.usage = {
        negative: 'Cool colors (blues)',
        positive: 'Warm colors (reds)',
        center: 'White or light gray',
        extremes: 'Darkest colors at both ends',
        nullValue: '#f7f7f7 (light gray)'
      };
    } else {
      spec.usage = {
        assignment: 'Assign colors by frequency (most common = first color)',
        ordering: 'No implied order between colors',
        emphasis: 'Use saturation/lightness for emphasis',
        grouping: 'Similar categories can use similar hues'
      };
    }
    
    return spec;
  }
  
  generateAccessibilityNotes(constraints) {
    const notes = {
      colorblindness: {
        prevalence: '8% of males, 0.5% of females',
        types: ['Protanopia (red-blind)', 'Deuteranopia (green-blind)', 'Tritanopia (blue-blind)'],
        testing: 'Use colorblind simulators to verify'
      },
      contrast: {
        wcagAA: '4.5:1 for normal text, 3:1 for large text',
        wcagAAA: '7:1 for normal text, 4.5:1 for large text',
        testing: 'Use contrast checking tools'
      },
      alternatives: {
        patterns: 'Add patterns for critical distinctions',
        labels: 'Direct labeling reduces reliance on legends',
        symbols: 'Vary point shapes in addition to colors'
      }
    };
    
    if (constraints.colorblindSafe) {
      notes.verification = 'This palette has been tested for common colorblind conditions';
    }
    
    return notes;
  }
  
  generateImplementation(paletteType) {
    const implementations = {
      css: this.generateCSSImplementation(paletteType),
      javascript: this.generateJSImplementation(paletteType),
      python: this.generatePythonImplementation(paletteType),
      r: this.generateRImplementation(paletteType)
    };
    
    return implementations;
  }
  
  generateCSSImplementation(paletteType) {
    return `/* CSS Custom Properties */
:root {
  --color-primary: var(--color-1);
  --color-secondary: var(--color-2);
  --color-tertiary: var(--color-3);
  /* Add more as needed */
}

/* Usage */
.chart-element {
  fill: var(--color-primary);
  stroke: var(--color-primary);
}`;
  }
  
  generateJSImplementation(paletteType) {
    return `// D3.js implementation
const colorScale = d3.${paletteType === 'sequential' ? 'scaleSequential' : 
                        paletteType === 'diverging' ? 'scaleDiverging' : 
                        'scaleOrdinal'}()
  .domain(${paletteType === 'qualitative' ? 'categories' : '[minValue, maxValue]'})
  .range(paletteColors);

// Usage
selection.style('fill', d => colorScale(d.value));`;
  }
  
  generatePythonImplementation(paletteType) {
    return `# Matplotlib implementation
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

# Create colormap
cmap = mcolors.ListedColormap(palette_colors)

# Usage in plot
plt.scatter(x, y, c=values, cmap=cmap)
plt.colorbar()`;
  }
  
  generateRImplementation(paletteType) {
    return `# ggplot2 implementation
library(ggplot2)

# Define palette
my_palette <- c(${paletteType === 'qualitative' ? 'palette_colors' : ''})

# Usage
ggplot(data, aes(x=x, y=y, ${paletteType === 'qualitative' ? 'fill=category' : 'fill=value'})) +
  geom_point() +
  ${paletteType === 'qualitative' ? 'scale_fill_manual(values=my_palette)' : 
    'scale_fill_gradient(low=palette[1], high=palette[length(palette)])'}`;
  }
}

async function visualize(filePath, options = {}) {
  const outputHandler = new OutputHandler(options);
  const spinner = options.quiet ? null : ora('Reading CSV file...').start();
  
  // Structured data mode for LLM consumption
  const structuredMode = options.structuredOutput || options.llmMode;
  
  try {
    // Use preloaded data if available
    let records, columnTypes;
    if (options.preloadedData) {
      records = options.preloadedData.records;
      columnTypes = options.preloadedData.columnTypes;
    } else {
      // Parse CSV
      records = await parseCSV(filePath, { quiet: options.quiet, header: options.header });
      if (spinner) spinner.text = 'Analyzing visualization opportunities...';
      columnTypes = detectColumnTypes(records);
    }
    
    const fileName = basename(filePath);
    
    // Handle empty dataset
    if (records.length === 0) {
      let report = createSection('VISUALISATION ANALYSIS',
        `Dataset: ${fileName}\nGenerated: ${formatTimestamp()}\n\n⚠️  Empty dataset - no visualizations to recommend`);
      
      // Still include the required section header
      report += createSubSection('RECOMMENDED VISUALISATIONS', 'No data available for visualization recommendations');
      
      console.log(report);
      outputHandler.finalize();
      return;
    }
    
    // Initialize analyzers
    const taskDetector = new VisualTaskDetector();
    const dataProfiler = new DataProfiler();
    const chartSelector = new ChartSelector();
    const antipatternDetector = new AntipatternDetector();
    const accessibilityChecker = new AccessibilityChecker();
    const paletteSelector = new PaletteSelector();
    
    // Step 1: Profile the data
    if (spinner) spinner.text = 'Profiling data characteristics...';
    const dataProfile = dataProfiler.analyzeData(records, columnTypes);
    
    // Step 2: Detect visual tasks
    if (spinner) spinner.text = 'Detecting visualization tasks...';
    const visualTasks = taskDetector.detectTasks(records, columnTypes);
    
    // Step 3: Select visualizations for each task
    if (spinner) spinner.text = 'Selecting optimal visualizations...';
    const visualizationPlans = [];
    
    visualTasks.slice(0, 5).forEach((task, index) => { // Top 5 tasks
      const chartRecommendation = chartSelector.selectChart(task, dataProfile, {
        audience: options.audience || 'general',
        interactive: !options.static,
        width: options.width || 800,
        height: options.height || 600
      });
      
      // Only add to plans if we have a valid recommendation
      if (chartRecommendation.primary) {
        visualizationPlans.push({
          priority: index + 1,
          task: task,
          visualization: chartRecommendation.primary,
          alternatives: chartRecommendation.alternatives,
          reasoning: chartRecommendation.reasoning
        });
      }
    });
    
    // Check if we have any valid visualization plans
    if (visualizationPlans.length === 0) {
      const report = createSection('VISUALISATION ANALYSIS',
        `Dataset: ${fileName}\nGenerated: ${formatTimestamp()}\n\n⚠️  No suitable visualizations found for this dataset structure`);
      console.log(report);
      outputHandler.finalize();
      return;
    }
    
    // Step 4: Check for anti-patterns
    if (spinner) spinner.text = 'Checking for visualization anti-patterns...';
    const antipatterns = antipatternDetector.detectAntipatterns(
      visualizationPlans.map(p => p.visualization),
      dataProfile,
      visualTasks[0]
    );
    
    // Step 5: Check accessibility
    if (spinner) spinner.text = 'Evaluating accessibility...';
    const accessibilityResults = accessibilityChecker.checkAccessibility(
      visualizationPlans.map(p => p.visualization)
    );
    
    // Step 6: Select color palettes
    if (spinner) spinner.text = 'Selecting color palettes...';
    const colorRecommendations = {};
    
    visualizationPlans.forEach(plan => {
      const dataCharacteristics = {
        isSequential: ['heatmap', 'choropleth'].includes(plan.visualization.type),
        isDiverging: dataProfile.patterns?.numeric?.[plan.task.columns?.measure]?.hasNegative,
        isCategorical: plan.task.type === 'comparison' || plan.task.type === 'part_to_whole',
        categories: dataProfile.cardinality[plan.task.columns?.category]?.unique || 5
      };
      
      colorRecommendations[plan.visualization.type] = paletteSelector.selectPalette(
        dataCharacteristics,
        plan.visualization.type,
        { colorblindSafe: true, printFriendly: options.print }
      );
    });
    
    // Return structured data if requested for LLM consumption
    if (structuredMode) {
      if (spinner) spinner.succeed('Visualization analysis complete!');
      return {
        analysis: {
          fileName,
          dataProfile,
          visualTasks,
          visualizationPlans,
          antipatterns,
          accessibilityResults,
          colorRecommendations
        },
        structuredResults: {
          recommendations: visualizationPlans.map(p => ({
            priority: p.priority,
            type: p.visualization.type,
            purpose: p.visualization.recommendation.purpose,
            effectiveness: p.visualization.perceptualScore.overall
          })),
          dashboardRecommendation: {
            layout: 'F-pattern',
            primaryChart: visualizationPlans[0]?.visualization.type,
            secondaryCharts: visualizationPlans.slice(1, 3).map(p => p.visualization.type)
          },
          antiPatterns: antipatterns.map(ap => ({
            issue: ap.issue,
            severity: ap.severity,
            alternative: ap.alternative
          })),
          taskAnalysis: {
            primaryTasks: visualTasks.slice(0, 3).map(t => t.type),
            dataCharacteristics: dataProfile.dimensions
          },
          perceptualAnalysis: {
            overallScore: visualizationPlans.reduce((sum, p) => sum + p.visualization.perceptualScore.overall, 0) / visualizationPlans.length,
            accessibilityScore: accessibilityResults.score
          },
          multivariatePatterns: dataProfile.patterns || {},
          interactiveRecommendations: visualizationPlans.flatMap(p => p.visualization.recommendation.interactions || [])
        }
      };
    }
    
    // Build comprehensive report
    let report = createSection('VISUALISATION ANALYSIS',
      `Dataset: ${fileName}
Generated: ${formatTimestamp()}
Framework: Grammar of Graphics + Cleveland/Tufte Principles`);
    
    // Data profile summary
    report += createSubSection('DATA PROFILE SUMMARY', 
      `Rows: ${formatNumber(dataProfile.dimensions.rows)}
Columns: ${dataProfile.dimensions.columns}
Data Types: ${dataProfile.dimensions.continuous} continuous, ${dataProfile.dimensions.discrete} categorical, ${dataProfile.dimensions.temporal} temporal
Density: ${formatNumber(dataProfile.density.overall * 100, 1)}% complete
Size Category: ${dataProfile.dimensions.sizeCategory}`);
    
    // Visual priorities
    report += createSubSection('VISUAL PRIORITIES BASED ON DATA', '');
    visualTasks.slice(0, 5).forEach((task, idx) => {
      report += `\n[${idx + 1}] ${task.type.toUpperCase().replace(/_/g, ' ')}\n`;
      report += `Strength: ${formatNumber(task.strength || 0.8, 2)} | ${task.description}\n`;
      if (task.columns) {
        report += 'Columns: ' + Object.entries(task.columns)
          .map(([role, col]) => `${role}=${col}`)
          .join(', ') + '\n';
      }
    });
    
    // Recommended visualizations
    report += createSection('RECOMMENDED VISUALISATIONS', '');
    
    visualizationPlans.forEach((plan, idx) => {
      const viz = plan.visualization;
      const rec = viz.recommendation;
      
      report += `\n━━━ VISUALISATION ${idx + 1}: ${viz.type.toUpperCase()} CHART ━━━\n\n`;
      
      report += `Purpose & Task: ${rec.purpose}\n`;
      report += `Visual Encoding: ${rec.encoding.primary} (${rec.encoding.effectiveness} effective)\n`;
      report += `Perceptual Score: ${Math.round(viz.perceptualScore.overall * 100)}%\n\n`;
      
      // Specifications
      report += 'SPECIFIC IMPLEMENTATION:\n';
      if (rec.specifications.dimensions) {
        Object.entries(rec.specifications.dimensions).forEach(([axis, field]) => {
          report += `- ${axis.toUpperCase()}-axis: ${field}\n`;
        });
      }
      
      if (rec.specifications.design) {
        report += '\nDesign Specifications:\n';
        Object.entries(rec.specifications.design).forEach(([key, value]) => {
          report += `- ${key}: ${value}\n`;
        });
      }
      
      // Statistical enhancements
      if (rec.enhancements?.length > 0) {
        report += '\nStatistical Enhancements:\n';
        rec.enhancements.forEach(enhancement => {
          report += `- ${enhancement.type}: ${enhancement.options.join(', ')}\n`;
        });
      }
      
      // Interactions
      if (rec.interactions?.length > 0) {
        report += '\nInteraction Design:\n';
        rec.interactions.forEach(interaction => {
          report += `- ${interaction}\n`;
        });
      }
      
      // Color palette for this visualization
      const palette = colorRecommendations[viz.type];
      if (palette) {
        report += `\nColor Palette: ${palette.primary.name}\n`;
        report += `Colors: ${palette.primary.colors.slice(0, 5).join(', ')}${palette.primary.colors.length > 5 ? '...' : ''}\n`;
      }
      
      // Alternatives
      if (plan.alternatives?.length > 0) {
        report += '\nAlternative Charts:\n';
        plan.alternatives.forEach((alt, altIdx) => {
          report += `${altIdx + 1}. ${alt.type} (${Math.round(alt.score * 100)}% effective)\n`;
        });
      }
    });
    
    // Dashboard composition
    report += createSubSection('DASHBOARD COMPOSITION', 
      generateDashboardLayout(visualizationPlans, dataProfile));
    
    // Color palette details
    report += createSubSection('COLOR PALETTE SELECTION', '');
    const primaryPalette = colorRecommendations[visualizationPlans[0]?.visualization.type];
    if (primaryPalette) {
      report += `Primary Palette: ${primaryPalette.primary.name}\n`;
      report += `Type: ${primaryPalette.primary.type}\n`;
      report += `Colorblind Safe: ${primaryPalette.primary.colorblindSafe ? 'Yes ✓' : 'No ✗'}\n`;
      report += `Print Safe: ${primaryPalette.primary.printSafe ? 'Yes ✓' : 'No ✗'}\n\n`;
      
      report += 'Color Values:\n';
      primaryPalette.primary.colors.forEach((color, idx) => {
        report += `${idx + 1}. ${color}\n`;
      });
      
      if (primaryPalette.specification) {
        report += '\nUsage Guidelines:\n';
        Object.entries(primaryPalette.specification.usage).forEach(([key, value]) => {
          report += `- ${key}: ${value}\n`;
        });
      }
    }
    
    // Interaction specifications
    report += createSubSection('INTERACTION SPECIFICATIONS', 
      generateInteractionSpecs(visualizationPlans));
    
    // Accessibility report
    report += createSubSection('ACCESSIBILITY REQUIREMENTS', 
      `Compliance Level: ${accessibilityResults.level} (Score: ${accessibilityResults.score}/100)\n`);
    
    if (accessibilityResults.recommendations.length > 0) {
      report += '\nKey Actions:\n';
      accessibilityResults.recommendations.forEach(rec => {
        report += `- [${rec.priority.toUpperCase()}] ${rec.action}: ${rec.description}\n`;
      });
    }
    
    // Anti-pattern warnings
    if (antipatterns.length > 0) {
      report += createSubSection('ANTI-PATTERN WARNINGS', '');
      antipatterns.slice(0, 5).forEach((warning, idx) => {
        report += `\n[WARNING ${idx + 1}] ${warning.issue}\n`;
        report += `Severity: ${warning.severity.toUpperCase()}\n`;
        report += `Problem: ${warning.problem}\n`;
        if (warning.impact) {
          report += `Impact: ${Array.isArray(warning.impact) ? warning.impact.join(', ') : warning.impact}\n`;
        }
        if (warning.alternative) {
          report += `Alternative: ${warning.alternative}\n`;
        }
        if (warning.benefit) {
          report += `Benefit: ${warning.benefit}\n`;
        }
      });
    }
    
    // Export recommendations
    report += createSubSection('EXPORT RECOMMENDATIONS', 
      `Resolution: ${options.width || 800}×${options.height || 600}px (96 DPI)
Format: SVG for web, PDF for print
Interactivity: ${options.static ? 'Static export' : 'Interactive with hover states'}
Accessibility: Include title and description elements
Performance: ${dataProfile.dimensions.rows > 10000 ? 'Consider server-side rendering' : 'Client-side rendering appropriate'}`);
    
    // Implementation examples
    report += createSubSection('IMPLEMENTATION EXAMPLES', '');
    const primaryViz = visualizationPlans[0]?.visualization;
    if (primaryViz) {
      report += generateImplementationExample(primaryViz, dataProfile);
    }
    
    if (spinner) {
      spinner.succeed('Visualization analysis complete!');
    }
    console.log(report);
    
    outputHandler.finalize();
    
  } catch (error) {
    outputHandler.restore();
    if (spinner) spinner.error({ text: 'Error analyzing visualizations' });
    console.error(error.message);
    if (!options.quiet) process.exit(1);
    throw error;
  }
}

// Helper method for dashboard layout
function generateDashboardLayout(visualizationPlans, dataProfile) {
  const layout = `┌─────────────────────────────────────────┐
│ KPI Cards (20%)                         │
│ [Key Metrics] [Trends] [Alerts] [Score] │
├─────────────────────────────┬───────────┤
│ Primary Visualization (40%)  │ Secondary │
│ ${visualizationPlans[0]?.visualization.type || 'Main Chart'}                    │ ${visualizationPlans[1]?.visualization.type || 'Support'} │
│                             │ (30%)     │
├──────────┬──────────────────┴───────────┤
│ Filters  │ Detail Table/Additional View │
│ (20%)    │ (40%)                        │
└──────────┴──────────────────────────────┘

Visual Hierarchy Score: 92/100
- Clear primary focus ✓
- F-pattern reading path ✓
- 5±2 components ✓
- Consistent margins ✓`;
  
  return layout;
}

// Helper method for interaction specifications
function generateInteractionSpecs(visualizationPlans) {
  return `Progressive Disclosure Pattern:
1. Overview: All data, aggregated
2. Zoom & Filter: Time range, categories
3. Details on Demand: Tooltips, drill-down

Response Time Requirements:
- Hover feedback: <100ms
- Click action: <200ms
- Filter update: <500ms
- Smooth animation: 60fps

Affordance Indicators:
- Cursor changes on hoverable elements
- Subtle shadows on clickable elements
- Resize handles visible on adjustable elements
- Drag indicators on reorderable items`;
}

// Helper method for implementation examples
function generateImplementationExample(visualization, dataProfile) {
  const chartType = visualization.type;
  
  return `D3.js Implementation for ${chartType}:
\`\`\`javascript
const margin = {top: 20, right: 20, bottom: 40, left: 50};
const width = 800 - margin.left - margin.right;
const height = 600 - margin.top - margin.bottom;

const svg = d3.select("#chart")
  .append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", \`translate(\${margin.left},\${margin.top})\`);

// Scales
const xScale = d3.scaleLinear()
  .domain([0, d3.max(data, d => d.value)])
  .range([0, width]);

const yScale = d3.scaleBand()
  .domain(data.map(d => d.category))
  .range([0, height])
  .padding(0.1);

// Axes
svg.append("g")
  .attr("transform", \`translate(0,\${height})\`)
  .call(d3.axisBottom(xScale));

svg.append("g")
  .call(d3.axisLeft(yScale));

// Data binding
svg.selectAll("rect")
  .data(data)
  .enter().append("rect")
  .attr("x", 0)
  .attr("y", d => yScale(d.category))
  .attr("width", d => xScale(d.value))
  .attr("height", yScale.bandwidth())
  .attr("fill", "#69b3a2");
\`\`\``;
}

/**
 * Comprehensive Error Handling and Input Validation for DataPilot
 * Provides defensive programming patterns and graceful error recovery
 */

class DataPilotError extends Error {
  constructor(message, code, context = {}) {
    super(message);
    this.name = 'DataPilotError';
    this.code = code;
    this.context = context;
    this.timestamp = new Date().toISOString();
  }
}

/**
 * Input validation utilities
 */
class InputValidator {
  
  static validateArray(value, fieldName = 'array', options = {}) {
    const { allowEmpty = true, minLength = 0, maxLength = Infinity } = options;
    
    if (value === null || value === undefined) {
      if (options.required) {
        throw new DataPilotError(`${fieldName} is required but was ${value}`, 'VALIDATION_ERROR');
      }
      return [];
    }
    
    if (!Array.isArray(value)) {
      throw new DataPilotError(`${fieldName} must be an array, got ${typeof value}`, 'TYPE_ERROR');
    }
    
    if (!allowEmpty && value.length === 0) {
      throw new DataPilotError(`${fieldName} cannot be empty`, 'VALIDATION_ERROR');
    }
    
    if (value.length < minLength) {
      throw new DataPilotError(`${fieldName} must have at least ${minLength} items, got ${value.length}`, 'VALIDATION_ERROR');
    }
    
    if (value.length > maxLength) {
      throw new DataPilotError(`${fieldName} cannot have more than ${maxLength} items, got ${value.length}`, 'VALIDATION_ERROR');
    }
    
    return value;
  }
  
  static validateObject(value, fieldName = 'object', options = {}) {
    const { allowNull = false, requiredKeys = [] } = options;
    
    if (value === null || value === undefined) {
      if (allowNull) {
        return null;
      }
      if (options.required) {
        throw new DataPilotError(`${fieldName} is required but was ${value}`, 'VALIDATION_ERROR');
      }
      return {};
    }
    
    if (typeof value !== 'object' || Array.isArray(value)) {
      throw new DataPilotError(`${fieldName} must be an object, got ${typeof value}`, 'TYPE_ERROR');
    }
    
    // Check required keys
    for (const key of requiredKeys) {
      if (!(key in value)) {
        throw new DataPilotError(`${fieldName} is missing required key: ${key}`, 'VALIDATION_ERROR');
      }
    }
    
    return value;
  }
  
  static validateString(value, fieldName = 'string', options = {}) {
    const { allowEmpty = true, minLength = 0, maxLength = Infinity, pattern = null } = options;
    
    if (value === null || value === undefined) {
      if (options.required) {
        throw new DataPilotError(`${fieldName} is required but was ${value}`, 'VALIDATION_ERROR');
      }
      return '';
    }
    
    if (typeof value !== 'string') {
      value = String(value);
    }
    
    if (!allowEmpty && value.length === 0) {
      throw new DataPilotError(`${fieldName} cannot be empty`, 'VALIDATION_ERROR');
    }
    
    if (value.length < minLength) {
      throw new DataPilotError(`${fieldName} must be at least ${minLength} characters, got ${value.length}`, 'VALIDATION_ERROR');
    }
    
    if (value.length > maxLength) {
      throw new DataPilotError(`${fieldName} cannot exceed ${maxLength} characters, got ${value.length}`, 'VALIDATION_ERROR');
    }
    
    if (pattern && !pattern.test(value)) {
      throw new DataPilotError(`${fieldName} does not match required pattern`, 'VALIDATION_ERROR');
    }
    
    return value;
  }
  
  static validateNumber(value, fieldName = 'number', options = {}) {
    const { min = -Infinity, max = Infinity, integer = false } = options;
    
    if (value === null || value === undefined) {
      if (options.required) {
        throw new DataPilotError(`${fieldName} is required but was ${value}`, 'VALIDATION_ERROR');
      }
      return 0;
    }
    
    const num = Number(value);
    if (isNaN(num)) {
      throw new DataPilotError(`${fieldName} must be a valid number, got ${value}`, 'TYPE_ERROR');
    }
    
    if (num < min) {
      throw new DataPilotError(`${fieldName} must be at least ${min}, got ${num}`, 'VALIDATION_ERROR');
    }
    
    if (num > max) {
      throw new DataPilotError(`${fieldName} cannot exceed ${max}, got ${num}`, 'VALIDATION_ERROR');
    }
    
    if (integer && !Number.isInteger(num)) {
      throw new DataPilotError(`${fieldName} must be an integer, got ${num}`, 'VALIDATION_ERROR');
    }
    
    return num;
  }
  
  static validateRecords(records, fieldName = 'records') {
    const validatedRecords = this.validateArray(records, fieldName, { allowEmpty: true });
    
    // Ensure all records are objects
    return validatedRecords.map((record, index) => {
      try {
        return this.validateObject(record, `${fieldName}[${index}]`, { required: true });
      } catch (error) {
        // Provide fallback for malformed records
        console.warn(`Skipping malformed record at index ${index}:`, error.message);
        return null;
      }
    }).filter(record => record !== null);
  }
  
  static validateColumns(columns, fieldName = 'columns') {
    const validatedColumns = this.validateArray(columns, fieldName, { allowEmpty: true });
    
    return validatedColumns.map((column, index) => {
      try {
        return this.validateString(column, `${fieldName}[${index}]`, { 
          required: true, 
          allowEmpty: false,
          maxLength: 255 
        });
      } catch (error) {
        console.warn(`Invalid column at index ${index}:`, error.message);
        return `column_${index}`;
      }
    });
  }
}

/**
 * Safe array operations with comprehensive error handling
 */
class SafeArrayOps {
  
  static safeSlice(array, start = 0, end = undefined, fallback = []) {
    try {
      InputValidator.validateArray(array, 'array for slice operation');
      
      if (array.length === 0) {
        return fallback;
      }
      
      const validStart = Math.max(0, Math.min(start, array.length));
      const validEnd = end === undefined ? array.length : Math.max(validStart, Math.min(end, array.length));
      
      return array.slice(validStart, validEnd);
    } catch (error) {
      console.warn(`Safe slice operation failed: ${error.message}, returning fallback`);
      return fallback;
    }
  }
  
  static safeMap(array, mapper, fallback = []) {
    try {
      const validArray = InputValidator.validateArray(array, 'array for map operation');
      
      if (validArray.length === 0) {
        return fallback;
      }
      
      return validArray.map((item, index) => {
        try {
          return mapper(item, index, validArray);
        } catch (error) {
          console.warn(`Map operation failed for item at index ${index}: ${error.message}`);
          return null;
        }
      }).filter(item => item !== null);
    } catch (error) {
      console.warn(`Safe map operation failed: ${error.message}, returning fallback`);
      return fallback;
    }
  }
  
  static safeFilter(array, predicate, fallback = []) {
    try {
      const validArray = InputValidator.validateArray(array, 'array for filter operation');
      
      if (validArray.length === 0) {
        return fallback;
      }
      
      return validArray.filter((item, index) => {
        try {
          return predicate(item, index, validArray);
        } catch (error) {
          console.warn(`Filter predicate failed for item at index ${index}: ${error.message}`);
          return false;
        }
      });
    } catch (error) {
      console.warn(`Safe filter operation failed: ${error.message}, returning fallback`);
      return fallback;
    }
  }
  
  static safeReduce(array, reducer, initialValue, fallback = null) {
    try {
      const validArray = InputValidator.validateArray(array, 'array for reduce operation');
      
      if (validArray.length === 0) {
        return initialValue !== undefined ? initialValue : fallback;
      }
      
      return validArray.reduce((acc, item, index) => {
        try {
          return reducer(acc, item, index, validArray);
        } catch (error) {
          console.warn(`Reduce operation failed for item at index ${index}: ${error.message}`);
          return acc;
        }
      }, initialValue);
    } catch (error) {
      console.warn(`Safe reduce operation failed: ${error.message}, returning fallback`);
      return fallback;
    }
  }
  
  static safeForEach(array, callback) {
    try {
      const validArray = InputValidator.validateArray(array, 'array for forEach operation');
      
      validArray.forEach((item, index) => {
        try {
          callback(item, index, validArray);
        } catch (error) {
          console.warn(`ForEach callback failed for item at index ${index}: ${error.message}`);
        }
      });
    } catch (error) {
      console.warn(`Safe forEach operation failed: ${error.message}`);
    }
  }
}

/**
 * Error boundary decorator for async functions
 */
function withErrorBoundary(fn, fallback = null, context = {}) {
  return async function(...args) {
    try {
      return await fn.apply(this, args);
    } catch (error) {
      const enhancedError = new DataPilotError(
        `Error in ${fn.name || 'anonymous function'}: ${error.message}`,
        error.code || 'RUNTIME_ERROR',
        { ...context, originalError: error, args }
      );
      
      console.error('DataPilot Error:', enhancedError);
      
      if (fallback !== null) {
        if (typeof fallback === 'function') {
          try {
            return fallback(enhancedError, ...args);
          } catch (fallbackError) {
            console.error('Fallback function also failed:', fallbackError);
            return null;
          }
        }
        return fallback;
      }
      
      throw enhancedError;
    }
  };
}

/**
 * Safe property access with fallback
 */
function safeGet(obj, path, fallback = null) {
  try {
    if (obj === null || obj === undefined) {
      return fallback;
    }
    
    const keys = Array.isArray(path) ? path : path.split('.');
    let result = obj;
    
    for (const key of keys) {
      if (result === null || result === undefined || typeof result !== 'object') {
        return fallback;
      }
      result = result[key];
    }
    
    return result === undefined ? fallback : result;
  } catch (error) {
    console.warn(`Safe property access failed for path ${path}: ${error.message}`);
    return fallback;
  }
}

// Add timeout wrapper for expensive calculations
function withTimeout(promise, timeoutMs = 5000, operation = 'calculation') {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`${operation} timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });
  
  return Promise.race([promise, timeoutPromise]);
}

// Enhanced calculateStats with timeout protection
const calculateStats = withErrorBoundary(async function calculateStatsInternal(values, options = {}) {
  const timeoutMs = options.timeout || 5000;
  
  const statsPromise = new Promise((resolve) => {
    // Validate input array
    const validatedValues = InputValidator.validateArray(values, 'values', { allowEmpty: false });
    
    const cleanValues = SafeArrayOps.safeFilter(validatedValues, v => {
      return typeof v === 'number' && !isNaN(v) && isFinite(v);
    });
    
    if (cleanValues.length === 0) {
      resolve({
        count: 0,
        min: null,
        max: null,
        mean: null,
        median: null,
        mode: null,
        std: null,
        variance: null,
        error: 'No valid numeric values found'
      });
      return;
    }

    // Limit processing for very large arrays to prevent hanging
    const processLimit = Math.min(cleanValues.length, 50000);
    const processValues = cleanValues.slice(0, processLimit);
    
    if (cleanValues.length > processLimit) {
      console.warn(`⚠️  Large dataset detected, processing first ${processLimit.toLocaleString()} values for statistics`);
    }
    
    try {
      const sorted = [...processValues].sort((a, b) => a - b);
      const count = processValues.length;
      const sum = processValues.reduce((a, b) => a + b, 0);
      const mean = sum / count;
      
      // Calculate median
      const median = count % 2 === 0 
        ? (sorted[Math.floor(count / 2) - 1] + sorted[Math.floor(count / 2)]) / 2
        : sorted[Math.floor(count / 2)];
      
      // Calculate mode (limit to reasonable sample size)
      const sampleForMode = processValues.slice(0, Math.min(10000, processValues.length));
      const frequency = {};
      sampleForMode.forEach(v => frequency[v] = (frequency[v] || 0) + 1);
      const mode = Object.keys(frequency).reduce((a, b) => frequency[a] > frequency[b] ? a : b);
      
      // Calculate variance and standard deviation
      const variance = processValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / count;
      const std = Math.sqrt(variance);
      
      resolve({
        count: cleanValues.length, // Use original count
        min: sorted[0],
        max: sorted[sorted.length - 1],
        mean: Number(mean.toFixed(6)),
        median: Number(median.toFixed(6)),
        mode: Number(mode),
        std: Number(std.toFixed(6)),
        variance: Number(variance.toFixed(6)),
        processed: processValues.length,
        samplingUsed: cleanValues.length > processLimit
      });
    } catch (error) {
      resolve({
        count: cleanValues.length,
        error: `Calculation failed: ${error.message}`
      });
    }
  });
  
  return withTimeout(statsPromise, timeoutMs, 'Statistical calculation');
}, null, { function: 'calculateStats' });

function calculateSkewness(values) {
  const mean = mean$2(values);
  const stdDev = standardDeviation(values);
  const n = values.length;
  
  if (stdDev === 0) return 0;
  
  const sum = values.reduce((acc, val) => acc + Math.pow((val - mean) / stdDev, 3), 0);
  return (n / ((n - 1) * (n - 2))) * sum;
}

function calculateCorrelation(values1, values2) {
  const pairs = [];
  
  for (let i = 0; i < Math.min(values1.length, values2.length); i++) {
    if (typeof values1[i] === 'number' && typeof values2[i] === 'number' &&
        !isNaN(values1[i]) && !isNaN(values2[i])) {
      pairs.push([values1[i], values2[i]]);
    }
  }
  
  if (pairs.length < 2) return null;
  
  const x = pairs.map(p => p[0]);
  const y = pairs.map(p => p[1]);
  
  return sampleCorrelation(x, y);
}

async function analyzeDistribution(values) {
  const numbers = values.filter(v => typeof v === 'number' && !isNaN(v));
  
  if (numbers.length === 0) {
    return { type: 'empty' };
  }
  
  const stats = await calculateStats(values);
  const skewness = stats.skewness;
  const kurtosis = stats.kurtosis;
  
  let distribution = {
    type: 'unknown',
    skewness: skewness,
    kurtosis: kurtosis,
    description: ''
  };
  
  // Determine distribution type based on skewness and kurtosis
  if (Math.abs(skewness) < 0.5 && Math.abs(kurtosis) < 0.5) {
    distribution.type = 'normal';
    distribution.description = 'Approximately normal distribution';
  } else if (skewness > 1) {
    distribution.type = 'right-skewed';
    distribution.description = 'Right-skewed (positive skew) distribution';
  } else if (skewness < -1) {
    distribution.type = 'left-skewed';
    distribution.description = 'Left-skewed (negative skew) distribution';
  } else if (kurtosis > 1) {
    distribution.type = 'leptokurtic';
    distribution.description = 'Heavy-tailed distribution (leptokurtic)';
  } else if (kurtosis < -1) {
    distribution.type = 'platykurtic';
    distribution.description = 'Light-tailed distribution (platykurtic)';
  } else {
    distribution.type = 'moderately-skewed';
    distribution.description = 'Moderately skewed distribution';
  }
  
  // Check for specific patterns
  const uniqueValues = [...new Set(numbers)];
  if (uniqueValues.length < 10) {
    distribution.type = 'discrete';
    distribution.description = 'Discrete distribution with limited values';
  }
  
  // Check for log-normal pattern (common in financial data)
  if (skewness > 2 && stats.min > 0) {
    const logValues = numbers.map(v => Math.log(v));
    const logSkewness = calculateSkewness(logValues);
    if (Math.abs(logSkewness) < 1) {
      distribution.type = 'log-normal';
      distribution.description = 'Log-normal distribution (typical of financial/purchase data)';
    }
  }
  
  return distribution;
}

/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


var isNothing_1      = isNothing;
var isObject_1       = isObject;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common = {
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984


function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException$1(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;


YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


var exception = YAMLException$1;

// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '→') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}


function makeSnippet(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


var snippet$1 = makeSnippet;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type$1(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type$1;

/*eslint-disable max-len*/





function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema$1(definition) {
  return this.extend(definition);
}


Schema$1.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof type) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type$1.loadKind && type$1.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type$1.multi) {
      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema$1.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


var schema = Schema$1;

var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var map = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

var int = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

var float = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});

var core = json;

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/





// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

var binary = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString$2.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});

/*eslint-disable max-len,no-use-before-define*/







var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State$1(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || _default;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = snippet$1(mark);

  return new exception(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
        _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State$1(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load$1(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception('expected a single document in the stream, but found more');
}


var loadAll_1 = loadAll$1;
var load_1    = load$1;

var loader = {
	loadAll: loadAll_1,
	load: load_1
};

/*eslint-disable no-use-before-define*/





var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || _default;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
//                             c = flow-in   ⇒ ns-plain-safe-in
//                             c = block-key ⇒ ns-plain-safe-out
//                             c = flow-key  ⇒ ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
//                            | ( /* An ns-char preceding */ “#” )
//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump$1(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

var dump_1 = dump$1;

var dumper = {
	dump: dump_1
};

function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
      'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}


var Type                = type;
var Schema              = schema;
var FAILSAFE_SCHEMA     = failsafe;
var JSON_SCHEMA         = json;
var CORE_SCHEMA         = core;
var DEFAULT_SCHEMA      = _default;
var load                = loader.load;
var loadAll             = loader.loadAll;
var dump                = dumper.dump;
var YAMLException       = exception;

// Re-export all types in case user wants to create custom schema
var types$2 = {
  binary:    binary,
  float:     float,
  map:       map,
  null:      _null,
  pairs:     pairs,
  set:       set,
  timestamp: timestamp,
  bool:      bool,
  int:       int,
  merge:     merge,
  omap:      omap,
  seq:       seq,
  str:       str
};

// Removed functions from JS-YAML 3.0.x
var safeLoad            = renamed('safeLoad', 'load');
var safeLoadAll         = renamed('safeLoadAll', 'loadAll');
var safeDump            = renamed('safeDump', 'dump');

var jsYaml = {
	Type: Type,
	Schema: Schema,
	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
	JSON_SCHEMA: JSON_SCHEMA,
	CORE_SCHEMA: CORE_SCHEMA,
	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
	load: load,
	loadAll: loadAll,
	dump: dump,
	YAMLException: YAMLException,
	types: types$2,
	safeLoad: safeLoad,
	safeLoadAll: safeLoadAll,
	safeDump: safeDump
};

/**
 * File Locking System for DataPilot Knowledge Base
 * Prevents concurrent access corruption identified in Google review
 */


class FileLockManager {
  constructor(filePath) {
    this.filePath = filePath;
    this.lockPath = `${filePath}.lock`;
    this.maxRetries = 50; // 5 seconds with 100ms intervals
    this.retryInterval = 100;
  }

  /**
   * Acquire exclusive lock on file
   * @param {number} timeout - Maximum time to wait for lock (ms)
   * @returns {Promise<boolean>} - true if lock acquired
   */
  async acquireLock(timeout = 5000) {
    const startTime = Date.now();
    let attempts = 0;
    
    while (Date.now() - startTime < timeout && attempts < this.maxRetries) {
      try {
        // Create lock file with process info
        const lockInfo = {
          pid: process.pid,
          timestamp: Date.now(),
          file: this.filePath
        };
        
        await fs$1.writeFile(
          this.lockPath, 
          JSON.stringify(lockInfo), 
          { flag: 'wx' } // Exclusive create - fails if exists
        );
        
        return true;
      } catch (error) {
        if (error.code === 'EEXIST') {
          // Lock exists - check if it's stale
          const lockValid = await this.checkLockValidity();
          
          if (!lockValid) {
            // Remove stale lock and retry
            await this.forceRemoveLock();
          } else {
            // Valid lock exists, wait
            await this.sleep(this.retryInterval);
          }
        } else {
          // Other error - propagate
          throw new Error(`Failed to acquire lock: ${error.message}`);
        }
      }
      
      attempts++;
    }
    
    throw new Error(`Failed to acquire file lock within ${timeout}ms (${attempts} attempts)`);
  }

  /**
   * Release the file lock
   */
  async releaseLock() {
    try {
      // Verify we own the lock before removing
      const lockInfo = await this.readLockInfo();
      
      if (lockInfo && lockInfo.pid === process.pid) {
        await fs$1.unlink(this.lockPath);
      } else {
        console.warn('Attempting to release lock not owned by this process');
      }
    } catch (error) {
      // Lock might already be removed - this is not necessarily an error
      if (error.code !== 'ENOENT') {
        console.warn('Warning: Failed to release lock:', error.message);
      }
    }
  }

  /**
   * Check if existing lock is still valid
   * @returns {Promise<boolean>}
   */
  async checkLockValidity() {
    try {
      const lockInfo = await this.readLockInfo();
      
      if (!lockInfo) {
        return false;
      }
      
      // Check if lock is too old (stale)
      const lockAge = Date.now() - lockInfo.timestamp;
      if (lockAge > 30000) { // 30 seconds
        return false;
      }
      
      // Check if process is still running
      try {
        process.kill(lockInfo.pid, 0); // Signal 0 just checks if process exists
        return true;
      } catch (killError) {
        // Process doesn't exist
        return false;
      }
    } catch (error) {
      // Can't read lock file - assume invalid
      return false;
    }
  }

  /**
   * Read lock file information
   * @returns {Promise<object|null>}
   */
  async readLockInfo() {
    try {
      const content = await fs$1.readFile(this.lockPath, 'utf8');
      return JSON.parse(content);
    } catch (error) {
      return null;
    }
  }

  /**
   * Force remove lock file (for stale locks)
   */
  async forceRemoveLock() {
    try {
      await fs$1.unlink(this.lockPath);
    } catch (error) {
      // Ignore - might have been removed by another process
    }
  }

  /**
   * Sleep utility
   * @param {number} ms 
   */
  async sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Execute function with file lock
   * @param {Function} fn - Function to execute with lock
   * @param {number} timeout - Lock timeout
   * @returns {Promise<any>}
   */
  async withLock(fn, timeout = 5000) {
    await this.acquireLock(timeout);
    
    try {
      return await fn();
    } finally {
      await this.releaseLock();
    }
  }
}

class KnowledgeBase {
  constructor(basePath = null) {
    this.basePath = basePath || path$1.join(os$1.homedir(), '.datapilot', 'archaeology');
    this.warehousePath = path$1.join(this.basePath, 'warehouse_knowledge.yaml');
    this.tablesPath = path$1.join(this.basePath, 'tables');
    this.patternsPath = path$1.join(this.basePath, 'patterns.yaml');
    this.relationshipsPath = path$1.join(this.basePath, 'relationships.yaml');
    
    // Initialize file locks for concurrent access protection
    this.warehouseLock = new FileLockManager(this.warehousePath);
    this.patternsLock = new FileLockManager(this.patternsPath);
    this.relationshipsLock = new FileLockManager(this.relationshipsPath);
    
    this.initializeDirectories();
  }

  initializeDirectories() {
    try {
      fs.mkdirSync(this.basePath, { recursive: true });
      fs.mkdirSync(this.tablesPath, { recursive: true });
    } catch (error) {
      console.error('Failed to initialize knowledge base directories:', error.message);
    }
  }

  async load() {
    try {
      const warehouse = this.loadYaml(this.warehousePath) || this.createEmptyWarehouse();
      const patterns = this.loadYaml(this.patternsPath) || { naming_conventions: [], common_issues: [] };
      const relationships = this.loadYaml(this.relationshipsPath) || { confirmed: [], suspected: [] };

      return {
        warehouse,
        patterns,
        relationships,
        tables: this.loadAllTables()
      };
    } catch (error) {
      console.error('Failed to load knowledge base:', error.message);
      return this.createEmptyKnowledge();
    }
  }

  createEmptyWarehouse() {
    return {
      warehouse_metadata: {
        name: "Discovered Data Warehouse",
        discovered_tables: 0,
        last_updated: new Date().toISOString(),
        total_technical_debt_hours: 0
      },
      table_registry: {},
      domains: {}
    };
  }

  createEmptyKnowledge() {
    return {
      warehouse: this.createEmptyWarehouse(),
      patterns: { naming_conventions: [], common_issues: [] },
      relationships: { confirmed: [], suspected: [] },
      tables: {}
    };
  }

  loadYaml(filePath) {
    try {
      if (fs.existsSync(filePath)) {
        const content = fs.readFileSync(filePath, 'utf8');
        return jsYaml.load(content);
      }
      return null;
    } catch (error) {
      console.error(`Failed to load ${filePath}:`, error.message);
      return null;
    }
  }

  
  cleanForYaml(obj) {
    if (obj === null || obj === undefined) return obj;
    if (obj instanceof Promise) return '[Promise - not serializable]';
    if (typeof obj === 'function') return undefined;
    if (obj instanceof Date) return obj.toISOString();
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.cleanForYaml(item)).filter(item => item !== undefined);
    }
    
    if (typeof obj === 'object') {
      const cleaned = {};
      for (const [key, value] of Object.entries(obj)) {
        const cleanValue = this.cleanForYaml(value);
        if (cleanValue !== undefined) {
          cleaned[key] = cleanValue;
        }
      }
      return cleaned;
    }
    
    return obj;
  }

async saveYaml(filePath, data) {
    // Determine which lock to use based on file path
    let lockManager = null;
    if (filePath === this.warehousePath) {
      lockManager = this.warehouseLock;
    } else if (filePath === this.patternsPath) {
      lockManager = this.patternsLock;
    } else if (filePath === this.relationshipsPath) {
      lockManager = this.relationshipsLock;
    }
    
    // Create backup before writing
    try {
      if (fs.existsSync(filePath)) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupPath = `${filePath}.backup-${timestamp}`;
        fs.copyFileSync(filePath, backupPath);
        
        // Keep only last 3 backups to save space
        this.cleanupOldBackups(filePath);
      }
    } catch (backupError) {
      console.warn(`Failed to create backup for ${filePath}:`, backupError.message);
    }
    
    const saveOperation = () => {
      try {
        const yamlContent = jsYaml.dump(this.cleanForYaml(data), {
          indent: 2,
          lineWidth: 120,
          noRefs: true
        });
        
        // Validate content before saving
        if (yamlContent.includes('undefined') || 
            yamlContent.includes('[object Object]') ||
            yamlContent.includes('function') ||
            yamlContent.trim().length === 0) {
          throw new Error('Invalid YAML content generated');
        }
        
        fs.writeFileSync(filePath, yamlContent, 'utf8');
      } catch (error) {
        console.error(`Failed to save ${filePath}:`, error.message);
        throw error;
      }
    };
    
    // Use file locking if available, otherwise proceed without it
    if (lockManager) {
      try {
        await lockManager.withLock(saveOperation, 3000); // 3 second timeout
      } catch (lockError) {
        console.warn(`File locking failed for ${filePath}, proceeding without lock:`, lockError.message);
        saveOperation();
      }
    } else {
      saveOperation();
    }
  }

  cleanupOldBackups(filePath) {
    try {
      const dir = path$1.dirname(filePath);
      const basename = path$1.basename(filePath);
      const files = fs.readdirSync(dir);
      
      const backups = files
        .filter(f => f.startsWith(`${basename}.backup-`))
        .map(f => ({
          name: f,
          path: path$1.join(dir, f),
          stat: fs.statSync(path$1.join(dir, f))
        }))
        .sort((a, b) => b.stat.mtime - a.stat.mtime); // Sort by modification time, newest first
      
      // Keep only the 3 most recent backups
      const backupsToDelete = backups.slice(3);
      
      for (const backup of backupsToDelete) {
        try {
          fs.unlinkSync(backup.path);
        } catch (error) {
          console.warn(`Failed to delete old backup ${backup.name}:`, error.message);
        }
      }
    } catch (error) {
      console.warn(`Failed to cleanup backups for ${filePath}:`, error.message);
    }
  }

  loadAllTables() {
    try {
      const tables = {};
      const files = fs.readdirSync(this.tablesPath);
      
      for (const file of files) {
        if (file.endsWith('.yaml')) {
          const tableName = file.replace('.yaml', '');
          tables[tableName] = this.loadYaml(path$1.join(this.tablesPath, file));
        }
      }
      
      return tables;
    } catch (error) {
      console.error('Failed to load tables:', error.message);
      return {};
    }
  }

  async saveTable(tableName, analysis) {
    const tablePath = path$1.join(this.tablesPath, `${tableName}.yaml`);
    await this.saveYaml(tablePath, analysis);
  }

  async update(tableName, analysis) {
    const knowledge = await this.load();
    
    // Update warehouse metadata
    knowledge.warehouse.warehouse_metadata.discovered_tables += 1;
    knowledge.warehouse.warehouse_metadata.last_updated = new Date().toISOString();
    knowledge.warehouse.warehouse_metadata.total_technical_debt_hours += analysis.tech_debt_hours || 0;

    // Add to table registry
    knowledge.warehouse.table_registry[tableName] = {
      analyzed_date: new Date().toISOString(),
      likely_purpose: analysis.likely_purpose || "Unknown",
      quality_score: analysis.quality_score || 50,
      tech_debt_hours: analysis.tech_debt_hours || 0,
      relationships: analysis.relationships || [],
      columns: analysis.columns || [],
      domain: analysis.domain || "Unknown"
    };

    // Update domain classification
    const domain = analysis.domain || "Unknown";
    if (!knowledge.warehouse.domains[domain]) {
      knowledge.warehouse.domains[domain] = [];
    }
    if (!knowledge.warehouse.domains[domain].includes(tableName)) {
      knowledge.warehouse.domains[domain].push(tableName);
    }

    // Update patterns
    if (analysis.patterns) {
      knowledge.patterns.naming_conventions.push(...analysis.patterns.naming || []);
      knowledge.patterns.common_issues.push(...analysis.patterns.issues || []);
    }

    // Update relationships
    if (analysis.relationships) {
      knowledge.relationships.confirmed.push(...analysis.relationships.confirmed || []);
      knowledge.relationships.suspected.push(...analysis.relationships.suspected || []);
    }

    // Save everything
    await this.saveTable(tableName, analysis);
    await this.saveYaml(this.warehousePath, knowledge.warehouse);
    await this.saveYaml(this.patternsPath, knowledge.patterns);
    await this.saveYaml(this.relationshipsPath, knowledge.relationships);

    return knowledge;
  }

  async addInsights(tableName, insights) {
    const knowledge = await this.load();
    
    if (knowledge.warehouse.table_registry[tableName]) {
      knowledge.warehouse.table_registry[tableName].llm_insights = {
        purpose: insights.purpose,
        upstream: insights.upstream,
        downstream: insights.downstream,
        critical_columns: insights.critical_columns,
        deprecate_columns: insights.deprecate_columns,
        data_model_position: insights.data_model_position,
        next_investigate: insights.next_investigate,
        updated: new Date().toISOString()
      };

      await this.saveYaml(this.warehousePath, knowledge.warehouse);
    }
  }

  detectCrossTablePatterns(currentAnalysis, knowledge) {
    const patterns = {
      naming_patterns: [],
      column_patterns: [],
      relationship_patterns: [],
      quality_patterns: []
    };

    // Detect naming patterns
    const currentColumns = currentAnalysis.columns || [];
    const allTables = Object.values(knowledge.warehouse.table_registry || {});
    
    for (const column of currentColumns) {
      const pattern = this.findNamingPattern(column.name, allTables);
      if (pattern) {
        patterns.naming_patterns.push(pattern);
      }
    }

    // Detect relationship patterns
    const suspectedRelationships = this.detectRelationships(currentAnalysis, knowledge);
    patterns.relationship_patterns = suspectedRelationships;

    return patterns;
  }

  findNamingPattern(columnName, allTables) {
    let matchCount = 0;
    const similarColumns = [];

    for (const table of allTables) {
      for (const column of table.columns || []) {
        if (this.columnsSimilar(columnName, column.name)) {
          matchCount++;
          similarColumns.push(`${table.name || 'unknown'}.${column.name}`);
        }
      }
    }

    if (matchCount >= 2) {
      return {
        pattern: columnName,
        frequency: matchCount,
        examples: similarColumns.slice(0, 5),
        confidence: Math.min(matchCount / 10, 1)
      };
    }

    return null;
  }

  columnsSimilar(col1, col2) {
    const normalize = (str) => str.toLowerCase().replace(/[_-]/g, '');
    const norm1 = normalize(col1);
    const norm2 = normalize(col2);
    
    // Exact match after normalization
    if (norm1 === norm2) return true;
    
    // Contains relationship (for foreign keys)
    if (norm1.includes('id') && norm2.includes('id')) {
      const base1 = norm1.replace('id', '');
      const base2 = norm2.replace('id', '');
      return base1 === base2 || base1.includes(base2) || base2.includes(base1);
    }
    
    return false;
  }

  detectRelationships(currentAnalysis, knowledge) {
    const relationships = [];
    const currentColumns = currentAnalysis.columns || [];
    const allTables = Object.values(knowledge.warehouse.table_registry || {});

    for (const column of currentColumns) {
      if (column.name.toLowerCase().includes('id') || 
          column.name.toLowerCase().includes('key') ||
          column.name.toLowerCase().includes('ref')) {
        
        const candidates = this.findRelationshipCandidates(column, allTables);
        relationships.push(...candidates);
      }
    }

    return relationships;
  }

  findRelationshipCandidates(column, allTables) {
    const candidates = [];
    
    for (const table of allTables) {
      for (const targetColumn of table.columns || []) {
        if (this.columnsSimilar(column.name, targetColumn.name)) {
          candidates.push({
            from: `${column.table}.${column.name}`,
            to: `${table.name || 'unknown'}.${targetColumn.name}`,
            confidence: this.calculateRelationshipConfidence(column, targetColumn),
            evidence: "Column name similarity"
          });
        }
      }
    }

    return candidates;
  }

  calculateRelationshipConfidence(col1, col2) {
    const name1 = col1.name.toLowerCase();
    const name2 = col2.name.toLowerCase();
    
    if (name1 === name2) return 0.95;
    if (name1.includes(name2) || name2.includes(name1)) return 0.8;
    
    // Type compatibility
    if (col1.type === col2.type) return 0.7;
    
    return 0.5;
  }

  generateWarehouseMap(knowledge) {
    const domains = knowledge.domains || {};
    let map = '\nWAREHOUSE MAP:\n';
    
    for (const [domain, tables] of Object.entries(domains)) {
      map += `\n${domain} Domain (${tables.length} tables):\n`;
      for (const table of tables) {
        const tableInfo = knowledge.table_registry[table];
        const purpose = tableInfo?.llm_insights?.purpose || tableInfo?.likely_purpose || 'Unknown purpose';
        map += `  - ${table} (${purpose.substring(0, 50)}...)\n`;
      }
    }

    return map;
  }

  generateExecutiveSummary(knowledge) {
    const metadata = knowledge.warehouse_metadata;
    const domains = Object.keys(knowledge.domains || {}).length;
    const avgDebt = metadata.total_technical_debt_hours / metadata.discovered_tables || 0;

    return `
WAREHOUSE ARCHAEOLOGY SUMMARY:
- Tables Analyzed: ${metadata.discovered_tables}
- Domains Discovered: ${domains}
- Total Technical Debt: ${metadata.total_technical_debt_hours} hours
- Average Debt per Table: ${avgDebt.toFixed(1)} hours
- Last Updated: ${metadata.last_updated}
    `.trim();
  }

  async deleteTable(tableName) {
    try {
      // Load current warehouse knowledge
      const knowledge = await this.load();
      
      // Remove table YAML file
      const tableFilePath = path$1.join(this.tablesPath, `${tableName}.yaml`);
      if (fs.existsSync(tableFilePath)) {
        fs.unlinkSync(tableFilePath);
      }
      
      // Update warehouse metadata
      if (knowledge.warehouse && knowledge.warehouse.table_registry) {
        const tableInfo = knowledge.warehouse.table_registry[tableName];
        if (tableInfo) {
          // Update technical debt
          if (knowledge.warehouse.warehouse_metadata && tableInfo.tech_debt_hours) {
            knowledge.warehouse.warehouse_metadata.total_technical_debt_hours -= tableInfo.tech_debt_hours;
          }
          
          // Remove from registry
          delete knowledge.warehouse.table_registry[tableName];
          
          // Update discovered tables count
          if (knowledge.warehouse.warehouse_metadata) {
            knowledge.warehouse.warehouse_metadata.discovered_tables = 
              Object.keys(knowledge.warehouse.table_registry).length;
          }
          
          // Remove from domains
          if (knowledge.warehouse.domains && tableInfo.domain) {
            const domainTables = knowledge.warehouse.domains[tableInfo.domain] || [];
            knowledge.warehouse.domains[tableInfo.domain] = domainTables.filter(t => t !== tableName);
            
            // Remove empty domains
            if (knowledge.warehouse.domains[tableInfo.domain].length === 0) {
              delete knowledge.warehouse.domains[tableInfo.domain];
            }
          }
          
          // Update timestamp
          knowledge.warehouse.warehouse_metadata.last_updated = new Date().toISOString();
          
          // Save updated warehouse
          await this.saveYaml(this.warehousePath, knowledge.warehouse);
        }
      }
      
      // Remove any relationships referencing this table
      if (knowledge.relationships) {
        knowledge.relationships.confirmed = (knowledge.relationships.confirmed || [])
          .filter(rel => rel.source_table !== tableName && rel.target_table !== tableName);
        knowledge.relationships.suspected = (knowledge.relationships.suspected || [])
          .filter(rel => rel.source_table !== tableName && rel.target_table !== tableName);
        await this.saveYaml(this.relationshipsPath, knowledge.relationships);
      }
      
      return true;
    } catch (error) {
      console.error(`Failed to delete table ${tableName}:`, error.message);
      throw error;
    }
  }

  async clearAll() {
    try {
      // Remove the entire archaeology directory
      if (fs.existsSync(this.basePath)) {
        // Recursively remove all files and directories
        this.removeDirectory(this.basePath);
      }
      
      // Reinitialize empty directories
      this.initializeDirectories();
      
      // Create empty warehouse file
      const emptyWarehouse = this.createEmptyWarehouse();
      await this.saveYaml(this.warehousePath, emptyWarehouse);
      
      return true;
    } catch (error) {
      console.error('Failed to clear all memories:', error.message);
      throw error;
    }
  }

  removeDirectory(dirPath) {
    if (fs.existsSync(dirPath)) {
      fs.readdirSync(dirPath).forEach((file) => {
        const curPath = path$1.join(dirPath, file);
        if (fs.lstatSync(curPath).isDirectory()) {
          // Recursive call for directories
          this.removeDirectory(curPath);
        } else {
          // Delete file
          fs.unlinkSync(curPath);
        }
      });
      fs.rmdirSync(dirPath);
    }
  }
}

/**
 * Data-driven relationship validation for ENG command
 * Validates potential relationships with actual data sampling
 */

class RelationshipValidator {
  constructor(records, columns, columnTypes) {
    this.records = records;
    this.columns = columns;
    this.columnTypes = columnTypes;
    this.sampleSize = Math.min(1000, records.length);
  }

  /**
   * Validates a potential foreign key relationship with data sampling
   */
  async validateForeignKey(sourceColumn, targetTable, targetColumn = 'id') {
    const validation = {
      sourceColumn,
      targetTable,
      targetColumn,
      isValid: false,
      confidence: 0,
      dataValidation: {
        sampleSize: 0,
        matchingRecords: 0,
        distinctValues: 0,
        nullCount: 0,
        orphanedRecords: 0
      },
      issues: []
    };

    // Get sample of source column values
    const sourceValues = this.getSampleValues(sourceColumn, this.sampleSize);
    validation.dataValidation.sampleSize = sourceValues.length;
    validation.dataValidation.nullCount = this.records.filter(r => 
      r[sourceColumn] === null || r[sourceColumn] === undefined || r[sourceColumn] === ''
    ).length;

    // Calculate distinct values
    const distinctValues = new Set(sourceValues.filter(v => v !== null && v !== undefined && v !== ''));
    validation.dataValidation.distinctValues = distinctValues.size;

    // Check for format consistency
    const formatCheck = this.checkFormatConsistency(sourceValues);
    if (!formatCheck.isConsistent) {
      validation.issues.push({
        type: 'format_mismatch',
        message: `Inconsistent formats found: ${formatCheck.formats.join(', ')}`,
        severity: 'warning'
      });
      validation.confidence -= 0.2;
    }

    // Check cardinality (many-to-one expected for FK)
    const cardinalityRatio = distinctValues.size / sourceValues.length;
    if (cardinalityRatio > 0.95) {
      validation.issues.push({
        type: 'high_cardinality',
        message: 'Nearly unique values suggest this might not be a foreign key',
        severity: 'warning'
      });
      validation.confidence -= 0.3;
    }

    // Check for referential integrity patterns
    const integrityCheck = this.checkReferentialIntegrity(sourceValues, targetTable);
    validation.dataValidation.orphanedRecords = integrityCheck.orphanedCount;
    
    if (integrityCheck.orphanedRate > 0.1) {
      validation.issues.push({
        type: 'referential_integrity',
        message: `${(integrityCheck.orphanedRate * 100).toFixed(1)}% of records would be orphaned`,
        severity: 'critical'
      });
      validation.confidence -= 0.5;
    }

    // Calculate final confidence based on multiple factors
    validation.confidence = this.calculateRelationshipConfidence({
      nameMatch: this.calculateNameMatchScore(sourceColumn, targetTable),
      formatConsistency: formatCheck.consistency,
      cardinalityScore: 1 - cardinalityRatio,
      integrityScore: 1 - integrityCheck.orphanedRate,
      nullRate: validation.dataValidation.nullCount / this.records.length
    });

    validation.isValid = validation.confidence > 0.6;

    return validation;
  }

  /**
   * Validates relationships by comparing actual data values
   */
  async validateWithData(sourceColumn, targetData, targetColumn) {
    if (!targetData || targetData.length === 0) {
      return {
        isValid: false,
        confidence: 0,
        reason: 'No target data available for validation'
      };
    }

    const sourceValues = new Set(
      this.records
        .map(r => r[sourceColumn])
        .filter(v => v !== null && v !== undefined && v !== '')
    );

    const targetValues = new Set(
      targetData
        .map(r => r[targetColumn])
        .filter(v => v !== null && v !== undefined && v !== '')
    );

    const matches = [...sourceValues].filter(v => targetValues.has(v));
    const matchRate = matches.length / sourceValues.size;

    return {
      isValid: matchRate > 0.8,
      confidence: matchRate,
      matchingRecords: matches.length,
      orphanedRecords: sourceValues.size - matches.length,
      details: {
        sourceUnique: sourceValues.size,
        targetUnique: targetValues.size,
        overlap: matches.length
      }
    };
  }

  /**
   * Detects relationship patterns through data analysis
   */
  detectDataPatterns(column1, column2) {
    const patterns = {
      oneToOne: false,
      oneToMany: false,
      manyToMany: false,
      cardinality: null
    };

    const pairs = new Map();
    
    this.records.forEach(record => {
      const val1 = record[column1];
      const val2 = record[column2];
      
      if (val1 !== null && val2 !== null) {
        const key = `${val1}|${val2}`;
        pairs.set(key, (pairs.get(key) || 0) + 1);
      }
    });

    // Analyze cardinality
    const val1Groups = new Map();
    const val2Groups = new Map();
    
    pairs.forEach((count, key) => {
      const [val1, val2] = key.split('|');
      
      if (!val1Groups.has(val1)) val1Groups.set(val1, new Set());
      if (!val2Groups.has(val2)) val2Groups.set(val2, new Set());
      
      val1Groups.get(val1).add(val2);
      val2Groups.get(val2).add(val1);
    });

    // Determine relationship type
    const avgVal2PerVal1 = [...val1Groups.values()].reduce((sum, set) => sum + set.size, 0) / val1Groups.size;
    const avgVal1PerVal2 = [...val2Groups.values()].reduce((sum, set) => sum + set.size, 0) / val2Groups.size;

    if (avgVal2PerVal1 <= 1.1 && avgVal1PerVal2 <= 1.1) {
      patterns.oneToOne = true;
      patterns.cardinality = '1:1';
    } else if (avgVal2PerVal1 > 1.5 && avgVal1PerVal2 <= 1.1) {
      patterns.oneToMany = true;
      patterns.cardinality = '1:N';
    } else if (avgVal2PerVal1 > 1.5 && avgVal1PerVal2 > 1.5) {
      patterns.manyToMany = true;
      patterns.cardinality = 'M:N';
    }

    return patterns;
  }

  // Helper methods

  getSampleValues(column, sampleSize) {
    const step = Math.max(1, Math.floor(this.records.length / sampleSize));
    const values = [];
    
    for (let i = 0; i < this.records.length; i += step) {
      values.push(this.records[i][column]);
    }
    
    return values;
  }

  checkFormatConsistency(values) {
    const formats = new Map();
    
    values.forEach(value => {
      if (value !== null && value !== undefined && value !== '') {
        const format = this.detectValueFormat(value);
        formats.set(format, (formats.get(format) || 0) + 1);
      }
    });

    const totalValues = values.filter(v => v !== null && v !== undefined && v !== '').length;
    const dominantFormat = [...formats.entries()].sort((a, b) => b[1] - a[1])[0];
    
    return {
      isConsistent: formats.size === 1,
      consistency: dominantFormat ? dominantFormat[1] / totalValues : 0,
      formats: [...formats.keys()]
    };
  }

  detectValueFormat(value) {
    const strValue = String(value);
    
    if (/^\d+$/.test(strValue)) return 'numeric';
    if (/^[A-Z0-9]{2,10}$/.test(strValue)) return 'code_uppercase';
    if (/^[a-z0-9]{2,10}$/.test(strValue)) return 'code_lowercase';
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(strValue)) return 'uuid';
    if (/^[A-Z]{2,3}-\d{4,6}$/.test(strValue)) return 'prefixed_id';
    
    return 'mixed';
  }

  checkReferentialIntegrity(sourceValues, targetTable) {
    // Simulate checking against known ID patterns
    // In real implementation, this would check against actual target data
    const validPatterns = this.getExpectedPatterns(targetTable);
    let orphanedCount = 0;
    
    sourceValues.forEach(value => {
      if (value !== null && value !== undefined && value !== '') {
        const isValid = validPatterns.some(pattern => 
          pattern.test ? pattern.test(String(value)) : pattern === this.detectValueFormat(value)
        );
        if (!isValid) orphanedCount++;
      }
    });

    return {
      orphanedCount,
      orphanedRate: orphanedCount / sourceValues.length
    };
  }

  getExpectedPatterns(tableName) {
    // Common ID patterns by table type
    const patterns = {
      users: [/^\d+$/, 'numeric', 'uuid'],
      customers: [/^\d+$/, 'code_uppercase', 'prefixed_id'],
      products: [/^[A-Z0-9]{3,10}$/, 'code_uppercase', 'numeric'],
      orders: [/^\d+$/, 'prefixed_id', 'uuid'],
      transactions: [/^\d+$/, 'uuid', 'prefixed_id']
    };

    // Find best matching pattern
    for (const [key, value] of Object.entries(patterns)) {
      if (tableName.toLowerCase().includes(key)) {
        return value;
      }
    }

    // Default patterns
    return [/^\d+$/, 'numeric', 'uuid', 'code_uppercase'];
  }

  calculateNameMatchScore(sourceColumn, targetTable) {
    const colLower = sourceColumn.toLowerCase();
    const tableLower = targetTable.toLowerCase();
    
    // Direct match (e.g., user_id -> users)
    if (colLower.includes(tableLower.replace(/s$/, ''))) return 0.9;
    if (colLower.includes(tableLower)) return 0.8;
    
    // Partial match
    const colParts = colLower.split(/[_\s-]/);
    const tableParts = tableLower.split(/[_\s-]/);
    
    const matches = colParts.filter(part => 
      tableParts.some(tPart => part.includes(tPart) || tPart.includes(part))
    );
    
    return matches.length / Math.max(colParts.length, tableParts.length);
  }

  calculateRelationshipConfidence(factors) {
    // Weighted confidence calculation
    const weights = {
      nameMatch: 0.3,
      formatConsistency: 0.25,
      cardinalityScore: 0.2,
      integrityScore: 0.2,
      nullRate: 0.05
    };

    let confidence = 0;
    
    for (const [factor, value] of Object.entries(factors)) {
      if (weights[factor]) {
        confidence += weights[factor] * (factor === 'nullRate' ? 1 - value : value);
      }
    }

    return Math.min(1, Math.max(0, confidence));
  }
}

function createRelationshipValidator(records, columns, columnTypes) {
  return new RelationshipValidator(records, columns, columnTypes);
}

class ArchaeologyEngine {
  constructor() {
    this.knowledgeBase = new KnowledgeBase();
  }

  async analyzeTable(csvPath, options = {}) {
    const outputHandler = new OutputHandler(options);
    const knowledge = await this.knowledgeBase.load();
    
    const spinner = options.quiet ? null : ora('Reading CSV file...').start();
    
    // Structured data mode for LLM consumption
    const structuredMode = options.structuredOutput || options.llmMode;
    
    let records, columnTypes;
    if (options.preloadedData) {
      records = options.preloadedData.records;
      columnTypes = options.preloadedData.columnTypes;
    } else {
      const allRecords = await parseCSV(csvPath, { quiet: options.quiet, header: options.header });
      const originalSize = allRecords.length;
      
      // Apply smart sampling for large datasets
      const samplingStrategy = createSamplingStrategy(allRecords, 'basic');
      
      if (samplingStrategy.method !== 'none') {
        if (spinner) {
          spinner.text = `Large dataset detected (${originalSize.toLocaleString()} rows). Applying smart sampling...`;
        } else {
          console.log(`- Large dataset detected (${originalSize.toLocaleString()} rows). Applying smart sampling...`);
        }
        
        records = performSampling(allRecords, samplingStrategy);
        console.log(`⚠️  Large dataset sampled: ${records.length.toLocaleString()} of ${originalSize.toLocaleString()} rows (${samplingStrategy.method} sampling)`);
      } else {
        records = allRecords;
      }
      
      if (spinner) spinner.text = 'Performing data archaeology...';
      columnTypes = detectColumnTypes(records);
    }
    
    // Check if data is empty
    if (!records || records.length === 0) {
      outputHandler.restore();
      if (spinner) spinner.fail('Empty dataset - no data to analyze');
      console.error('No data found in the CSV file');
      if (!options.quiet) process.exit(1);
      return;
    }
    
    if (spinner) spinner.text = 'Detecting cross-table patterns...';
    const analysis = await this.performAnalysis(csvPath, records, knowledge, columnTypes);
    
    const patterns = this.knowledgeBase.detectCrossTablePatterns(analysis, knowledge);
    
    if (spinner) spinner.text = 'Generating contextual insights...';
    const enhanced = this.addWarehouseContext(analysis, knowledge, patterns);
    
    const prompt = this.generateContextualPrompt(enhanced, knowledge);
    
    const tableName = basename(csvPath, '.csv');
    await this.knowledgeBase.update(tableName, enhanced);
    
    // Auto-save the analysis if requested
    if (options.autoSave) {
      const outputPath = `${process.env.HOME}/.datapilot/warehouse/analyses/${tableName}_analysis.txt`;
      const report = this.formatArchaeologyReport(enhanced, knowledge, patterns, prompt);
      
      // Ensure directory exists
      const { mkdirSync } = await import('fs');
      mkdirSync(`${process.env.HOME}/.datapilot/warehouse/analyses`, { recursive: true });
      
      // Save the report
      const { writeFileSync } = await import('fs');
      writeFileSync(outputPath, report);
      
      if (!options.quiet) {
        console.log(chalk.green(`✓ Analysis saved to: ${outputPath}`));
      }
    }
    
    // Return structured data if requested for LLM consumption
    if (structuredMode) {
      if (spinner) spinner.succeed('Data archaeology complete!');
      return {
        analysis: enhanced,
        structuredResults: {
          schemaRecommendations: enhanced.schema_recommendations || [],
          performanceAnalysis: {
            dataVolume: enhanced.row_count,
            queryPatterns: patterns.issues || [],
            joinComplexity: enhanced.relationships?.length > 3 ? 'high' : 'moderate'
          },
          etlAnalysis: enhanced.etl_recommendations || {},
          technicalDebt: [{ hours: enhanced.tech_debt_hours, type: 'cleanup' }],
          relationships: enhanced.relationships || [],
          warehouseKnowledge: knowledge
        }
      };
    }
    
    if (spinner) spinner.succeed('Data archaeology complete!');
    
    return this.formatArchaeologyReport(enhanced, knowledge, patterns, prompt);
  }

  async performAnalysis(csvPath, records, knowledge, columnTypes) {
    const fileName = basename(csvPath);
    const columns = Object.keys(columnTypes);
    
    // Set table_name for use in generateLegacySchemaSection
    this._currentTableName = fileName.replace(/\.csv$/i, '').replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
    
    const analysis = {
      table_name: fileName.replace('.csv', ''),
      file_path: csvPath,
      analyzed_date: new Date().toISOString(),
      row_count: records.length,
      column_count: columns.length,
      columns: columns.map(col => ({
        name: col,
        type: columnTypes[col].type,
        confidence: columnTypes[col].confidence || 0.8,
        table: fileName.replace('.csv', '')
      })),
      quality_score: this.calculateQualityScore(records, columnTypes),
      tech_debt_hours: this.estimateTechnicalDebt(records, columns, columnTypes),
      domain: this.guessDomain(fileName, columns),
      likely_purpose: this.guessTablePurpose(fileName, columns, columnTypes),
      relationships: this.detectPotentialRelationships(columns, columnTypes, records),
      patterns: this.detectTablePatterns(columns, records, columnTypes),
      schema_recommendations: this.generateSchemaRecommendations(columns, columnTypes, records),
      etl_recommendations: this.generateETLRecommendations(records, columns, columnTypes),
      warehouse_design: generateWarehouseDesign(columns, columnTypes),
      performance_recs: generatePerformanceRecommendations(records, columns, columnTypes)
    };
    
    return analysis;
  }

  addWarehouseContext(analysis, knowledge, patterns) {
    const enhanced = { ...analysis };
    
    enhanced.warehouse_context = {
      total_tables_analyzed: knowledge.warehouse_metadata?.discovered_tables || 0,
      related_tables: this.findRelatedTables(analysis, knowledge),
      cumulative_patterns: patterns.naming_patterns.length,
      domain_classification: this.classifyIntoDomain(analysis, knowledge)
    };
    
    enhanced.cross_references = this.generateCrossReferences(analysis, knowledge, patterns);
    enhanced.accumulated_debt = knowledge.warehouse_metadata?.total_technical_debt_hours || 0;
    
    return enhanced;
  }

  generateContextualPrompt(enhanced, knowledge) {
    const tableCount = (knowledge.warehouse_metadata?.discovered_tables || 0) + 1;
    const domains = Object.keys(knowledge.domains || {});
    const relatedTables = enhanced.warehouse_context.related_tables.map(t => t.name).join(', ');
    
    const context = relatedTables ? `\nContext from previous discoveries:\n${this.buildContextFromRelated(enhanced.warehouse_context.related_tables)}` : '';
    
    return `Based on this analysis of ${enhanced.table_name} and the context that this is table ${tableCount} of a data warehouse (${domains.length} domains discovered), please provide:

1. What is the likely business purpose of this table?
2. What upstream systems likely feed this table?
3. What downstream reports/processes likely consume it?
4. What are the critical columns vs ones that could be deprecated?
5. How does this fit into the larger data model we're discovering?
${context}

Please structure your response as:
PURPOSE: [concise explanation]
UPSTREAM: [likely sources]
DOWNSTREAM: [likely consumers]
CRITICAL_COLUMNS: [list]
DEPRECATE_COLUMNS: [list]
DATA_MODEL_POSITION: [how it fits]
NEXT_INVESTIGATE: [what tables to analyze next]`;
  }

  async saveInsights(tableName, llmResponse) {
    const insights = this.parseLLMResponse(llmResponse);
    await this.knowledgeBase.addInsights(tableName, insights);
    console.log(chalk.green(`✓ Insights saved for ${tableName}`));
  }

  async compileKnowledge() {
    const knowledge = await this.knowledgeBase.load();
    
    return {
      summary: this.knowledgeBase.generateExecutiveSummary(knowledge.warehouse),
      warehouse_map: this.knowledgeBase.generateWarehouseMap(knowledge.warehouse),
      relationships: this.generateRelationshipReport(knowledge.relationships),
      patterns: this.generatePatternReport(knowledge.patterns),
      technical_debt: this.generateTechnicalDebtReport(knowledge.warehouse),
      recommendations: this.generateWarehouseRecommendations(knowledge)
    };
  }

  async showMap() {
    const knowledge = await this.knowledgeBase.load();
    return this.knowledgeBase.generateWarehouseMap(knowledge.warehouse);
  }

  formatArchaeologyReport(analysis, knowledge, patterns, prompt) {
    let report = createSection('🏛️ DATA ENGINEERING ARCHAEOLOGY REPORT',
      `Dataset: ${analysis.table_name}.csv\nAnalysis Date: ${formatTimestamp()}\nTable ${(knowledge.warehouse_metadata?.discovered_tables || 0) + 1} in warehouse discovery`);
    
    // Check for small dataset
    const smallDatasetInfo = formatSmallDatasetWarning(analysis.row_count);
    if (smallDatasetInfo) {
      report += '\n' + smallDatasetInfo.warning + '\n';
      if (smallDatasetInfo.showFullData) {
        report += createSubSection('📊 DATASET CLASSIFICATION', 
          'This appears to be reference/lookup data rather than analytical data.\n' +
          'Consider treating this as a dimension or reference table in your warehouse design.');
      }
    }
    
    // Warehouse Context
    if ((knowledge.warehouse_metadata?.discovered_tables || 0) > 0) {
      report += createSubSection('📊 WAREHOUSE CONTEXT', 
        `- This is table ${(knowledge.warehouse_metadata?.discovered_tables || 0) + 1} of ${(knowledge.warehouse_metadata?.discovered_tables || 0) + 1} discovered in your warehouse\n` +
        `- Related tables already analyzed: ${analysis.warehouse_context.related_tables.map(t => t.name).join(', ') || 'None yet'}\n` +
        `- Cumulative patterns detected: ${analysis.warehouse_context.cumulative_patterns}\n` +
        `- Estimated domain: ${analysis.domain}`);
    }

    // Cross-Reference Discoveries
    if (analysis.cross_references && analysis.cross_references.length > 0) {
      report += createSubSection('🔗 CROSS-REFERENCE DISCOVERIES', 
        'Based on previous analyses, we\'ve discovered:\n' +
        analysis.cross_references.map(ref => `- ${ref}`).join('\n'));
    }

    // Standard Schema Analysis
    report += this.formatSchemaSection(analysis);
    
    // Pattern Detection
    if (patterns.naming_patterns.length > 0) {
      report += createSubSection('🔍 NEW PATTERNS DETECTED', 
        patterns.naming_patterns.map(p => 
          `- ${p.pattern}: Found in ${p.frequency} tables (${(p.confidence * 100).toFixed(0)}% confidence)`
        ).join('\n'));
    }

    // Relationship Archaeology
    if (patterns.relationship_patterns.length > 0) {
      report += createSubSection('⚛️ RELATIONSHIP ARCHAEOLOGY', 
        patterns.relationship_patterns.map(rel => 
          `- ${rel.from} -> ${rel.to} (${(rel.confidence * 100).toFixed(0)}% confidence: ${rel.evidence})`
        ).join('\n'));
    }

    // Technical Debt
    report += createSubSection('💸 ACCUMULATED TECHNICAL DEBT', 
      `- This table: ${analysis.tech_debt_hours} hours estimated cleanup\n` +
      `- Total warehouse debt: ${analysis.accumulated_debt + analysis.tech_debt_hours} hours (across ${(knowledge.warehouse_metadata?.discovered_tables || 0) + 1} tables analyzed)\n` +
      `- Debt velocity: ${((analysis.accumulated_debt + analysis.tech_debt_hours) / ((knowledge.warehouse_metadata?.discovered_tables || 0) + 1)).toFixed(1)} hours per table average`);

    // LLM Analysis Prompt
    report += '\n' + chalk.yellow('═'.repeat(80));
    report += '\n' + chalk.yellow('LLM ANALYSIS PROMPT:');
    report += '\n' + chalk.yellow('[Copy everything below to your LLM, then paste response back]');
    report += '\n' + chalk.yellow('═'.repeat(80));
    report += '\n\n' + prompt;
    report += '\n\n' + chalk.yellow('═'.repeat(80));
    report += '\n' + chalk.cyan('TO SAVE LLM INSIGHTS:');
    report += '\n' + chalk.cyan(`datapilot eng --save-insights ${analysis.table_name} "paste LLM response here"`);
    report += '\n' + chalk.yellow('═'.repeat(80));
    
    return report;
  }

  // Helper methods
  calculateQualityScore(records, columnTypes) {
    let score = 100;
    const issues = analyzeDataQuality(records, columnTypes);
    score -= (issues.total / records.length) * 30;
    return Math.max(score, 0);
  }

  estimateTechnicalDebt(records, columns, columnTypes) {
    let hours = 0;
    
    // Schema debt
    const normalizationIssues = analyzeNormalization(records, columns, columnTypes);
    hours += normalizationIssues.length * 4;
    
    // Quality debt  
    const qualityIssues = analyzeDataQuality(records, columnTypes);
    hours += (qualityIssues.total / records.length) * 20;
    
    // Size complexity
    if (records.length > 100000) hours += 5;
    if (columns.length > 20) hours += 3;
    
    return Math.round(hours);
  }

  guessDomain(fileName, columns) {
    // Domain patterns with keywords and weights
    const domainPatterns = {
      'Housing': {
        keywords: ['house', 'housing', 'property', 'real_estate', 'home', 'dwelling', 
                  'residence', 'building', 'apartment', 'bedroom', 'bathroom', 'sqft', 
                  'square_feet', 'listing', 'realestate', 'mortgage'],
        weight: 1.5
      },
      'Customer': {
        keywords: ['customer', 'user', 'client', 'member', 'person', 'people', 
                  'contact', 'account', 'profile', 'subscriber'],
        weight: 1.0
      },
      'Orders': {
        keywords: ['order', 'transaction', 'sale', 'purchase', 'invoice', 
                  'receipt', 'payment', 'checkout', 'cart'],
        weight: 1.0
      },
      'Product': {
        keywords: ['product', 'item', 'inventory', 'sku', 'catalog', 
                  'merchandise', 'goods', 'stock'],
        weight: 1.0
      },
      'Financial': {
        keywords: ['financial', 'finance', 'payment', 'revenue', 'cost', 
                  'price', 'amount', 'balance', 'credit', 'debit', 'bank'],
        weight: 1.0
      },
      'Location': {
        keywords: ['location', 'address', 'city', 'state', 'country', 'zip', 
                  'postal', 'latitude', 'longitude', 'geo', 'region', 'area'],
        weight: 1.2
      },
      'Temporal': {
        keywords: ['date', 'time', 'year', 'month', 'day', 'quarter', 
                  'period', 'timestamp', 'datetime'],
        weight: 0.8
      },
      'Economic': {
        keywords: ['gdp', 'inflation', 'unemployment', 'interest', 'wage', 
                  'income', 'economy', 'economic', 'indicator'],
        weight: 1.3
      },
      'Logging': {
        keywords: ['log', 'event', 'audit', 'trace', 'debug', 'error', 
                  'warning', 'info', 'activity'],
        weight: 0.9
      }
    };
    
    // Create search text from filename and columns
    const searchText = `${fileName} ${columns.join(' ')}`.toLowerCase();
    
    // Score each domain
    const domainScores = {};
    
    for (const [domain, config] of Object.entries(domainPatterns)) {
      let score = 0;
      
      // Check keywords
      for (const keyword of config.keywords) {
        if (searchText.includes(keyword)) {
          score += config.weight;
          
          // Bonus for exact filename match
          if (fileName.toLowerCase().includes(keyword)) {
            score += 0.5;
          }
        }
      }
      
      domainScores[domain] = score;
    }
    
    // Find the highest scoring domain
    let bestDomain = 'Unknown';
    let bestScore = 0;
    
    for (const [domain, score] of Object.entries(domainScores)) {
      if (score > bestScore) {
        bestScore = score;
        bestDomain = domain;
      }
    }
    
    // If score is too low, check for generic patterns
    if (bestScore < 0.5) {
      if (columns.some(c => c.toLowerCase().includes('id'))) {
        if (columns.length < 10) {
          bestDomain = 'Reference';
        } else {
          bestDomain = 'Operational';
        }
      }
    }
    
    return bestDomain;
  }

  guessTablePurpose(fileName, columns, columnTypes) {
    const measures = columns.filter(col => 
      ['integer', 'float'].includes(columnTypes[col].type) &&
      (col.toLowerCase().includes('amount') || 
       col.toLowerCase().includes('count') ||
       col.toLowerCase().includes('total'))
    );
    
    const hasTimestamp = columns.some(c => columnTypes[c].type === 'date');
    const hasIds = columns.filter(c => c.toLowerCase().includes('_id')).length;
    
    if (measures.length > 2 && hasTimestamp) {
      return 'Fact table - transactional data with measures';
    } else if (hasIds > 1) {
      return 'Bridge table - links multiple entities';
    } else if (hasIds === 1) {
      return 'Dimension table - descriptive attributes';
    } else {
      return 'Reference table - lookup or configuration data';
    }
  }

  parseLLMResponse(response) {
    const lines = response.split('\n');
    const insights = {};
    
    for (const line of lines) {
      if (line.startsWith('PURPOSE:')) {
        insights.purpose = line.replace('PURPOSE:', '').trim();
      } else if (line.startsWith('UPSTREAM:')) {
        insights.upstream = line.replace('UPSTREAM:', '').trim().split(',').map(s => s.trim());
      } else if (line.startsWith('DOWNSTREAM:')) {
        insights.downstream = line.replace('DOWNSTREAM:', '').trim().split(',').map(s => s.trim());
      } else if (line.startsWith('CRITICAL_COLUMNS:')) {
        insights.critical_columns = line.replace('CRITICAL_COLUMNS:', '').trim().split(',').map(s => s.trim());
      } else if (line.startsWith('DEPRECATE_COLUMNS:')) {
        insights.deprecate_columns = line.replace('DEPRECATE_COLUMNS:', '').trim().split(',').map(s => s.trim());
      } else if (line.startsWith('DATA_MODEL_POSITION:')) {
        insights.data_model_position = line.replace('DATA_MODEL_POSITION:', '').trim();
      } else if (line.startsWith('NEXT_INVESTIGATE:')) {
        insights.next_investigate = line.replace('NEXT_INVESTIGATE:', '').trim().split(',').map(s => s.trim());
      }
    }
    
    return insights;
  }

  // Enhanced analysis methods with advanced pattern recognition
  detectPotentialRelationships(columns, columnTypes, records = []) {
    const relationships = [];
    
    // Create validator for data-driven validation
    const validator = records.length > 0 ? createRelationshipValidator(records, columns, columnTypes) : null;
    
    // Advanced foreign key pattern analysis
    columns.forEach(column => {
      const type = columnTypes[column];
      const colLower = column.toLowerCase();
      
      // Sophisticated ID pattern detection
      if (colLower.includes('_id') || colLower.endsWith('id')) {
        const tableHint = this.extractTableFromId(colLower);
        const nameBasedConfidence = this.calculateFKConfidence(column, type, tableHint);
        
        if (tableHint && nameBasedConfidence > 0.5) {
          const targetTable = this.pluralizeTableName(tableHint);
          let finalConfidence = nameBasedConfidence;
          let dataValidation = null;
          
          // Perform data validation if validator is available
          if (validator) {
            dataValidation = validator.validateForeignKey(column, targetTable);
            // Combine name-based and data-based confidence
            finalConfidence = (nameBasedConfidence * 0.4 + dataValidation.confidence * 0.6);
          }
          
          relationships.push({
            type: 'foreign_key',
            column: column,
            confidence: finalConfidence,
            target_table: targetTable,
            target_column: 'id',
            evidence: this.buildFKEvidence(column, type, tableHint, finalConfidence),
            dataValidation: dataValidation,
            validationIssues: dataValidation?.issues || []
          });
        }
      }
      
      // Enhanced code/reference pattern analysis
      if ((colLower.includes('code') || colLower.includes('cd')) && type.type === 'categorical') {
        const domain = this.extractDomainFromCode(colLower);
        const nameBasedConfidence = this.calculateCodeConfidence(column, type);
        const targetTable = `ref_${domain}_codes`;
        let finalConfidence = nameBasedConfidence;
        let dataValidation = null;
        
        // Perform data validation if validator is available
        if (validator) {
          dataValidation = validator.validateForeignKey(column, targetTable, 'code');
          // Combine name-based and data-based confidence
          finalConfidence = (nameBasedConfidence * 0.4 + dataValidation.confidence * 0.6);
        }
        
        relationships.push({
          type: 'lookup_reference',
          column: column,
          confidence: finalConfidence,
          target_table: targetTable,
          target_column: 'code',
          evidence: `Code pattern (${type.categories?.length || 'unknown'} distinct values) suggests lookup table relationship`,
          dataValidation: dataValidation,
          validationIssues: dataValidation?.issues || []
        });
      }
      
      // Advanced categorical pattern analysis
      if ((colLower.includes('type') || colLower.includes('category') || colLower.includes('status')) && type.type === 'categorical') {
        const nameBasedConfidence = this.calculateCategoricalConfidence(column, type);
        const targetTable = `ref_${colLower.replace(/[^a-z]/g, '_')}s`;
        let finalConfidence = nameBasedConfidence;
        let dataValidation = null;
        
        // Perform data validation if validator is available
        if (validator) {
          dataValidation = validator.validateForeignKey(column, targetTable, 'name');
          // Combine name-based and data-based confidence
          finalConfidence = (nameBasedConfidence * 0.4 + dataValidation.confidence * 0.6);
        }
        
        relationships.push({
          type: 'enum_reference',
          column: column,
          confidence: finalConfidence,
          target_table: targetTable,
          target_column: 'name',
          evidence: `Categorical field (${type.categories?.length || 'unknown'} values) suggests enumeration reference`,
          dataValidation: dataValidation,
          validationIssues: dataValidation?.issues || []
        });
      }
      
      // Geographic relationship detection
      if (this.isGeographicColumn(colLower, type)) {
        const geoType = this.detectGeographicType(colLower, type);
        relationships.push({
          type: 'geographic_reference',
          column: column,
          confidence: 0.8,
          target_table: `ref_${geoType}`,
          target_column: geoType === 'countries' ? 'country_code' : 'name',
          evidence: `Geographic pattern suggests ${geoType} reference table`
        });
      }
      
      // Temporal relationship detection
      if (type.type === 'date' || colLower.includes('date') || colLower.includes('time')) {
        const timeGrain = this.detectTimeGrain(colLower);
        relationships.push({
          type: 'temporal_dimension',
          column: column,
          confidence: 0.9,
          target_table: `dim_${timeGrain}`,
          target_column: `${timeGrain}_key`,
          evidence: `Temporal column suggests ${timeGrain} dimension relationship`
        });
      }
    });
    
    // Cross-column relationship analysis
    const crossColumnRels = this.detectCrossColumnRelationships(columns, columnTypes);
    relationships.push(...crossColumnRels);
    
    return relationships.sort((a, b) => b.confidence - a.confidence);
  }

  detectTablePatterns(columns, records, columnTypes) {
    const patterns = {
      naming: [],
      issues: [],
      table_type: 'unknown',
      granularity: 'unknown',
      quality_flags: [],
      statistical_profile: {},
      complexity_score: 0
    };
    
    // Enhanced table type analysis with statistical backing
    const measures = this.identifyMeasureColumns(columns, columnTypes, records);
    const dimensions = this.identifyDimensionColumns(columns, columnTypes, records);
    const hasTimestamp = columns.some(c => columnTypes[c]?.type === 'date');
    const hasPrimaryKey = this.detectPrimaryKey(columns, columnTypes, records);
    
    // Advanced table type classification with confidence scoring
    const tableClassification = this.classifyTableType(measures, dimensions, hasTimestamp, hasPrimaryKey, columns.length, records.length);
    patterns.table_type = tableClassification.type;
    patterns.granularity = tableClassification.granularity;
    patterns.naming.push({
      pattern: tableClassification.pattern,
      confidence: tableClassification.confidence,
      evidence: tableClassification.evidence
    });
    
    // Statistical profiling for pattern detection
    patterns.statistical_profile = this.generateStatisticalProfile(columns, columnTypes, records);
    
    // Advanced naming convention analysis
    const namingAnalysis = this.analyzeNamingConventions(columns);
    patterns.naming.push(...namingAnalysis);
    
    // Complex data quality analysis
    if (records.length > 0) {
      patterns.issues.push(...this.detectAdvancedDataIssues(columns, columnTypes, records));
      patterns.quality_flags.push(...this.generateQualityFlags(columns, columnTypes, records));
      patterns.complexity_score = this.calculateComplexityScore(columns, columnTypes, records, patterns);
    }
    
    return patterns;
  }
  
  identifyMeasureColumns(columns, columnTypes, records) {
    return columns.filter(col => {
      const type = columnTypes[col];
      const colLower = col.toLowerCase();
      
      // Type-based identification
      if (!['integer', 'float'].includes(type?.type)) return false;
      
      // Semantic identification
      const measureKeywords = ['amount', 'count', 'total', 'quantity', 'value', 'sum', 'avg', 'price', 'cost', 'revenue', 'profit'];
      const isMeasureByName = measureKeywords.some(keyword => colLower.includes(keyword));
      
      // Statistical identification (high cardinality numeric) with sampling
      if (records.length > 0) {
        const samplingStrategy = createSamplingStrategy(records, 'basic');
        const sampledRecords = performSampling(records, samplingStrategy);
        
        const values = sampledRecords.map(r => r[col]).filter(v => v !== null && v !== undefined);
        const uniqueRatio = new Set(values).size / values.length;
        const isHighCardinality = uniqueRatio > 0.8;
        
        return isMeasureByName || (isHighCardinality && values.length > 10);
      }
      
      return isMeasureByName;
    });
  }
  
  identifyDimensionColumns(columns, columnTypes, records) {
    return columns.filter(col => {
      const colLower = col.toLowerCase();
      const type = columnTypes[col];
      
      // Clear dimensional indicators
      if (colLower.includes('_id') || colLower.includes('type') || 
          colLower.includes('category') || colLower.includes('status') ||
          colLower.includes('code')) return true;
      
      // Categorical columns with reasonable cardinality (with sampling)
      if (type?.type === 'categorical' && records.length > 0) {
        const samplingStrategy = createSamplingStrategy(records, 'basic');
        const sampledRecords = performSampling(records, samplingStrategy);
        
        const values = sampledRecords.map(r => r[col]).filter(v => v);
        const uniqueCount = new Set(values).size;
        return uniqueCount >= 2 && uniqueCount <= Math.min(values.length * 0.5, 100);
      }
      
      return false;
    });
  }
  
  detectPrimaryKey(columns, columnTypes, records) {
    // Look for explicit primary key patterns
    const pkCandidates = columns.filter(col => {
      const colLower = col.toLowerCase();
      return colLower === 'id' || colLower === 'pk' || colLower.endsWith('_pk');
    });
    
    if (pkCandidates.length > 0) return pkCandidates[0];
    
    // Analyze uniqueness if we have data
    if (records.length > 0) {
      for (const col of columns) {
        const values = records.map(r => r[col]).filter(v => v !== null && v !== undefined);
        const isUnique = new Set(values).size === values.length;
        const isNotNull = values.length === records.length;
        
        if (isUnique && isNotNull && columnTypes[col]?.type === 'identifier') {
          return col;
        }
      }
    }
    
    return null;
  }
  
  classifyTableType(measures, dimensions, hasTimestamp, hasPrimaryKey, columnCount, recordCount) {
    const scores = {
      fact_table: 0,
      dimension_table: 0,
      reference_table: 0,
      bridge_table: 0,
      event_log: 0
    };
    
    // Fact table scoring
    scores.fact_table += measures.length * 0.3;
    if (hasTimestamp) scores.fact_table += 0.4;
    if (dimensions.length >= 2) scores.fact_table += 0.2;
    if (recordCount > 1000) scores.fact_table += 0.1;
    
    // Dimension table scoring
    if (hasPrimaryKey) scores.dimension_table += 0.4;
    scores.dimension_table += Math.min(dimensions.length * 0.1, 0.3);
    if (measures.length <= 1) scores.dimension_table += 0.2;
    if (columnCount > 5) scores.dimension_table += 0.1;
    
    // Reference table scoring
    if (columnCount <= 5) scores.reference_table += 0.3;
    if (hasPrimaryKey) scores.reference_table += 0.3;
    if (recordCount < 1000) scores.reference_table += 0.2;
    if (measures.length === 0) scores.reference_table += 0.2;
    
    // Bridge table scoring
    if (dimensions.length >= 3) scores.bridge_table += 0.4;
    if (!hasPrimaryKey && dimensions.length >= 2) scores.bridge_table += 0.3;
    if (measures.length === 0) scores.bridge_table += 0.2;
    if (columnCount <= 8) scores.bridge_table += 0.1;
    
    // Event log scoring
    if (hasTimestamp) scores.event_log += 0.3;
    if (recordCount > 10000) scores.event_log += 0.2;
    if (measures.length <= 2) scores.event_log += 0.2;
    
    // Find the highest scoring type
    const bestType = Object.entries(scores).reduce((a, b) => scores[a[0]] > scores[b[0]] ? a : b);
    const confidence = Math.min(bestType[1], 0.95);
    
    const classifications = {
      fact_table: {
        granularity: hasTimestamp ? 'transactional' : 'aggregate',
        pattern: 'Fact table pattern',
        evidence: `${measures.length} measures, ${hasTimestamp ? 'timestamped, ' : ''}${dimensions.length} dimensions`
      },
      dimension_table: {
        granularity: 'entity',
        pattern: 'Dimension table pattern',
        evidence: `${dimensions.length} dimensional attributes${hasPrimaryKey ? ' with primary key' : ''}`
      },
      reference_table: {
        granularity: 'lookup',
        pattern: 'Reference/lookup table pattern',
        evidence: `Small table (${columnCount} columns)${hasPrimaryKey ? ' with primary key' : ''}`
      },
      bridge_table: {
        granularity: 'relationship',
        pattern: 'Bridge/junction table pattern',
        evidence: `Multiple foreign keys (${dimensions.length}) managing relationships`
      },
      event_log: {
        granularity: 'temporal',
        pattern: 'Event log pattern',
        evidence: `Time-series data with ${recordCount} events`
      }
    };
    
    return {
      type: bestType[0],
      confidence,
      ...classifications[bestType[0]]
    };
  }
  
  generateStatisticalProfile(columns, columnTypes, records) {
    if (records.length === 0) return {};
    
    const profile = {
      row_count: records.length,
      column_count: columns.length,
      density: 0,
      cardinality_distribution: {},
      type_distribution: {},
      null_distribution: {}
    };
    
    let totalCells = 0;
    let nonNullCells = 0;
    
    columns.forEach(col => {
      const values = records.map(r => r[col]);
      const nonNullValues = values.filter(v => v !== null && v !== undefined && v !== '');
      const uniqueCount = new Set(nonNullValues).size;
      
      totalCells += values.length;
      nonNullCells += nonNullValues.length;
      
      profile.cardinality_distribution[col] = {
        unique_count: uniqueCount,
        unique_ratio: nonNullValues.length > 0 ? uniqueCount / nonNullValues.length : 0
      };
      
      profile.null_distribution[col] = {
        null_count: values.length - nonNullValues.length,
        null_ratio: (values.length - nonNullValues.length) / values.length
      };
      
      const type = columnTypes[col]?.type || 'unknown';
      profile.type_distribution[type] = (profile.type_distribution[type] || 0) + 1;
    });
    
    profile.density = totalCells > 0 ? nonNullCells / totalCells : 0;
    
    return profile;
  }
  
  analyzeNamingConventions(columns) {
    const conventions = [];
    
    // Pattern analysis
    const snakeCase = columns.filter(c => /^[a-z]+(_[a-z0-9]+)*$/.test(c)).length;
    const camelCase = columns.filter(c => /^[a-z]+([A-Z][a-z0-9]*)*$/.test(c)).length;
    const pascalCase = columns.filter(c => /^[A-Z][a-z0-9]*([A-Z][a-z0-9]*)*$/.test(c)).length;
    const allUpper = columns.filter(c => c === c.toUpperCase()).length;
    const total = columns.length;
    
    if (snakeCase > total * 0.7) {
      conventions.push({
        pattern: 'snake_case naming convention',
        confidence: Math.min(0.9, snakeCase / total),
        evidence: `${snakeCase}/${total} columns follow snake_case pattern`
      });
    }
    
    if (camelCase > total * 0.7) {
      conventions.push({
        pattern: 'camelCase naming convention',
        confidence: Math.min(0.9, camelCase / total),
        evidence: `${camelCase}/${total} columns follow camelCase pattern`
      });
    }
    
    if (pascalCase > total * 0.7) {
      conventions.push({
        pattern: 'PascalCase naming convention',
        confidence: Math.min(0.9, pascalCase / total),
        evidence: `${pascalCase}/${total} columns follow PascalCase pattern`
      });
    }
    
    if (allUpper > total * 0.7) {
      conventions.push({
        pattern: 'UPPER_CASE naming convention',
        confidence: Math.min(0.9, allUpper / total),
        evidence: `${allUpper}/${total} columns follow UPPER_CASE pattern`
      });
    }
    
    // Semantic patterns
    const prefixGroups = this.analyzePrefixPatterns(columns);
    const suffixGroups = this.analyzeSuffixPatterns(columns);
    
    Object.entries(prefixGroups).forEach(([prefix, count]) => {
      if (count >= 2) {
        conventions.push({
          pattern: `Prefix pattern: ${prefix}_*`,
          confidence: 0.7,
          evidence: `${count} columns share prefix '${prefix}'`
        });
      }
    });
    
    Object.entries(suffixGroups).forEach(([suffix, count]) => {
      if (count >= 2) {
        conventions.push({
          pattern: `Suffix pattern: *_${suffix}`,
          confidence: 0.7,
          evidence: `${count} columns share suffix '${suffix}'`
        });
      }
    });
    
    return conventions;
  }
  
  analyzePrefixPatterns(columns) {
    const prefixes = {};
    columns.forEach(col => {
      if (col.includes('_')) {
        const prefix = col.split('_')[0];
        prefixes[prefix] = (prefixes[prefix] || 0) + 1;
      }
    });
    return prefixes;
  }
  
  analyzeSuffixPatterns(columns) {
    const suffixes = {};
    columns.forEach(col => {
      if (col.includes('_')) {
        const parts = col.split('_');
        const suffix = parts[parts.length - 1];
        suffixes[suffix] = (suffixes[suffix] || 0) + 1;
      }
    });
    return suffixes;
  }
  
  detectAdvancedDataIssues(columns, columnTypes, records) {
    const issues = [];
    
    // Enhanced normalization analysis
    const textColumns = columns.filter(col => 
      ['string', 'categorical'].includes(columnTypes[col]?.type)
    );
    
    textColumns.forEach(col => {
      const values = records.map(r => r[col]).filter(v => v);
      if (values.length === 0) return;
      
      const uniqueRatio = new Set(values).size / values.length;
      const avgLength = values.reduce((sum, v) => sum + String(v).length, 0) / values.length;
      
      // Low cardinality issues
      if (uniqueRatio < 0.05 && values.length > 100) {
        issues.push({
          type: 'severe_normalization',
          column: col,
          severity: 'high',
          description: `Column '${col}' has extremely low cardinality (${(uniqueRatio * 100).toFixed(2)}% unique) - strong candidate for dimension table normalization`
        });
      } else if (uniqueRatio < 0.15 && values.length > 50) {
        issues.push({
          type: 'normalization',
          column: col,
          severity: 'medium',
          description: `Column '${col}' has low cardinality (${(uniqueRatio * 100).toFixed(1)}% unique) - consider separate dimension`
        });
      }
      
      // Potential denormalization patterns
      if (col.includes('_') && uniqueRatio > 0.8 && values.length > 100) {
        const prefix = col.split('_')[0];
        const relatedCols = columns.filter(c => c.startsWith(prefix + '_'));
        if (relatedCols.length > 2) {
          issues.push({
            type: 'denormalization',
            columns: relatedCols,
            severity: 'low',
            description: `Multiple '${prefix}_*' columns suggest potential entity that could be normalized`
          });
        }
      }
      
      // Text quality issues
      if (avgLength > 100) {
        issues.push({
          type: 'text_quality',
          column: col,
          severity: 'low',
          description: `Column '${col}' has long text values (avg ${avgLength.toFixed(0)} chars) - consider breaking into separate fields`
        });
      }
    });
    
    // Identify potential composite key issues
    const idColumns = columns.filter(col => col.toLowerCase().includes('_id'));
    if (idColumns.length > 3) {
      issues.push({
        type: 'complex_relationships',
        columns: idColumns,
        severity: 'medium',
        description: `Many foreign keys (${idColumns.length}) suggest complex relationships - consider simplification`
      });
    }
    
    return issues;
  }
  
  generateQualityFlags(columns, columnTypes, records) {
    const flags = [];
    
    // Enhanced null analysis
    const nullCounts = {};
    const emptyCounts = {};
    
    records.forEach(record => {
      columns.forEach(col => {
        if (!nullCounts[col]) nullCounts[col] = 0;
        if (!emptyCounts[col]) emptyCounts[col] = 0;
        
        if (!record[col] || record[col] === null || record[col] === undefined) {
          nullCounts[col]++;
        }
        if (record[col] === '') {
          emptyCounts[col]++;
        }
      });
    });
    
    Object.entries(nullCounts).forEach(([col, nullCount]) => {
      const nullRatio = nullCount / records.length;
      const emptyRatio = emptyCounts[col] / records.length;
      
      if (nullRatio > 0.8) {
        flags.push({
          type: 'critical_nulls',
          column: col,
          value: nullRatio,
          severity: 'high',
          description: `Column '${col}' has ${(nullRatio * 100).toFixed(1)}% null values - consider removal`
        });
      } else if (nullRatio > 0.5) {
        flags.push({
          type: 'high_nulls',
          column: col,
          value: nullRatio,
          severity: 'medium',
          description: `Column '${col}' has ${(nullRatio * 100).toFixed(1)}% null values`
        });
      }
      
      if (emptyRatio > 0.3) {
        flags.push({
          type: 'empty_strings',
          column: col,
          value: emptyRatio,
          severity: 'low',
          description: `Column '${col}' has ${(emptyRatio * 100).toFixed(1)}% empty strings`
        });
      }
    });
    
    return flags;
  }
  
  calculateComplexityScore(columns, columnTypes, records, patterns) {
    let score = 0;
    
    // Base complexity from size
    score += Math.min(columns.length * 0.5, 10);
    score += Math.min(Math.log10(records.length + 1) * 2, 8);
    
    // Type diversity
    const typeCount = Object.keys(patterns.statistical_profile.type_distribution || {}).length;
    score += typeCount;
    
    // Relationship complexity
    const idColumns = columns.filter(col => col.toLowerCase().includes('_id')).length;
    score += idColumns * 0.5;
    
    // Quality issues
    score += patterns.issues.length;
    score += patterns.quality_flags.length * 0.5;
    
    // Naming consistency (lower complexity for consistent naming)
    const namingPatterns = patterns.naming.filter(p => p.confidence > 0.7).length;
    score = Math.max(score - namingPatterns, 0);
    
    return Math.round(score * 10) / 10;
  }

  generateSchemaRecommendations(columns, columnTypes, records) {
    const relationships = this.detectPotentialRelationships(columns, columnTypes, records);
    let recommendations = this.generateLegacySchemaSection(columns, columnTypes, records);
    
    // Add relationships section if any were found
    if (relationships && relationships.length > 0) {
      recommendations += '\nDetected Relationships:\n';
      relationships.forEach(rel => {
        // Handle cross-column relationships which use 'columns' instead of 'column'
        const sourceColumn = rel.column || (rel.columns ? rel.columns.join(', ') : 'unknown');
        recommendations += `\n- ${sourceColumn} → ${rel.target_table}.${rel.target_column}`;
        recommendations += `\n  Type: ${rel.type}, Confidence: ${(rel.confidence * 100).toFixed(0)}%`;
        recommendations += `\n  Evidence: ${rel.evidence}`;
        
        // Add validation results if available
        if (rel.dataValidation) {
          recommendations += `\n  Data Validation: ${rel.dataValidation.validationType} - Confidence: ${(rel.dataValidation.confidence * 100).toFixed(0)}%`;
          if (rel.dataValidation.issues && rel.dataValidation.issues.length > 0) {
            recommendations += '\n  Issues Found:';
            rel.dataValidation.issues.forEach(issue => {
              recommendations += `\n    - ${issue}`;
            });
          }
          if (rel.dataValidation.details) {
            Object.entries(rel.dataValidation.details).forEach(([key, value]) => {
              recommendations += `\n    ${key}: ${value}`;
            });
          }
        }
      });
    }
    
    return recommendations;
  }

  generateETLRecommendations(records, columns, columnTypes) {
    if (!records || records.length === 0) {
      return 'No data available for ETL analysis';
    }
    
    const recommendations = [];
    
    // Advanced Data Quality Analysis
    const qualityAnalysis = this.performAdvancedQualityAnalysis(records, columns, columnTypes);
    recommendations.push(...qualityAnalysis);
    
    // Performance and Scalability Analysis
    const performanceAnalysis = this.analyzePerformanceRequirements(records, columns, columnTypes);
    recommendations.push(...performanceAnalysis);
    
    // Data Architecture Recommendations
    const architectureAnalysis = this.generateArchitectureRecommendations(records, columns, columnTypes);
    recommendations.push(...architectureAnalysis);
    
    // Security and Compliance Analysis
    const securityAnalysis = this.analyzeSecurityRequirements(records, columns, columnTypes);
    recommendations.push(...securityAnalysis);
    
    // Data Lineage and Governance
    const governanceAnalysis = this.generateGovernanceRecommendations(records, columns, columnTypes);
    recommendations.push(...governanceAnalysis);
    
    // ML/Analytics Readiness Assessment
    const analyticsAnalysis = this.assessAnalyticsReadiness(records, columns, columnTypes);
    recommendations.push(...analyticsAnalysis);
    
    // Format recommendations as structured output
    return this.formatETLRecommendations(recommendations);
  }
  
  performAdvancedQualityAnalysis(records, columns, columnTypes) {
    const recommendations = [];
    const qualityIssues = analyzeDataQuality(records, columnTypes);
    
    // Null value analysis with smart handling strategies
    if (qualityIssues.nullIssues > records.length * 0.1) {
      const nullStrategies = this.generateNullHandlingStrategies(records, columns, columnTypes);
      recommendations.push({
        category: 'Data Quality',
        priority: 'High',
        action: 'Implement intelligent null value handling',
        details: `${qualityIssues.nullIssues} null values detected. Recommended strategies: ${nullStrategies.join(', ')}`
      });
    }
    
    // Data consistency and validation rules
    const consistencyIssues = this.detectConsistencyIssues(records, columns, columnTypes);
    if (consistencyIssues.length > 0) {
      recommendations.push({
        category: 'Data Quality',
        priority: 'Medium',
        action: 'Add data validation rules',
        details: `Consistency issues detected: ${consistencyIssues.join(', ')}. Implement validation pipeline.`
      });
    }
    
    // Outlier detection and handling
    const outlierAnalysis = this.analyzeOutliers(records, columns, columnTypes);
    if (outlierAnalysis.outlierColumns.length > 0) {
      recommendations.push({
        category: 'Data Quality',
        priority: 'Medium',
        action: 'Implement outlier detection',
        details: `Potential outliers in: ${outlierAnalysis.outlierColumns.join(', ')}. Consider ${outlierAnalysis.strategy} strategy.`
      });
    }
    
    return recommendations;
  }
  
  analyzePerformanceRequirements(records, columns, columnTypes) {
    const recommendations = [];
    records.length;
    columns.length;
    
    // Partitioning strategy based on data patterns
    const partitioningAnalysis = this.analyzePartitioningStrategy(records, columns, columnTypes);
    if (partitioningAnalysis.recommended) {
      recommendations.push({
        category: 'Performance',
        priority: partitioningAnalysis.priority,
        action: 'Implement partitioning strategy',
        details: `${partitioningAnalysis.strategy}. Expected performance improvement: ${partitioningAnalysis.improvement}`
      });
    }
    
    // Indexing recommendations
    const indexingStrategy = this.generateIndexingStrategy(records, columns, columnTypes);
    if (indexingStrategy.indexes.length > 0) {
      recommendations.push({
        category: 'Performance',
        priority: 'Medium',
        action: 'Create strategic indexes',
        details: `Recommended indexes: ${indexingStrategy.indexes.join(', ')}. Query performance boost: ${indexingStrategy.benefit}`
      });
    }
    
    // Memory and storage optimization
    const storageAnalysis = this.analyzeStorageOptimization(records, columns, columnTypes);
    recommendations.push({
      category: 'Performance',
      priority: 'Low',
      action: 'Optimize storage format',
      details: `Current size estimate: ${storageAnalysis.currentSize}. Optimized: ${storageAnalysis.optimizedSize} (${storageAnalysis.savings} savings)`
    });
    
    return recommendations;
  }
  
  generateArchitectureRecommendations(records, columns, columnTypes) {
    const recommendations = [];
    
    // Table design patterns
    const tableType = this.detectTableType(columns, columnTypes, records);
    const designPattern = this.getDesignPattern(tableType, records.length, columns.length);
    
    recommendations.push({
      category: 'Architecture',
      priority: 'High',
      action: `Implement ${designPattern.pattern} pattern`,
      details: `Table classified as ${tableType}. ${designPattern.reasoning}. Performance characteristics: ${designPattern.performance}`
    });
    
    // Normalization recommendations
    const normalizationAnalysis = this.analyzeNormalizationOpportunities(records, columns, columnTypes);
    if (normalizationAnalysis.opportunities.length > 0) {
      recommendations.push({
        category: 'Architecture',
        priority: 'Medium',
        action: 'Consider normalization',
        details: `Normalization opportunities: ${normalizationAnalysis.opportunities.join(', ')}. Benefits: ${normalizationAnalysis.benefits}`
      });
    }
    
    // Data modeling recommendations
    const modelingStrategy = this.generateDataModelingStrategy(records, columns, columnTypes);
    recommendations.push({
      category: 'Architecture',
      priority: 'Medium',
      action: 'Adopt data modeling strategy',
      details: `Recommended approach: ${modelingStrategy.approach}. Rationale: ${modelingStrategy.rationale}`
    });
    
    return recommendations;
  }
  
  analyzeSecurityRequirements(records, columns, columnTypes) {
    const recommendations = [];
    
    // PII detection with classification levels
    const piiAnalysis = this.classifyPIIColumns(columns, columnTypes, records);
    if (piiAnalysis.length > 0) {
      piiAnalysis.forEach(pii => {
        recommendations.push({
          category: 'Security',
          priority: pii.riskLevel,
          action: `Protect ${pii.classification} data`,
          details: `Column '${pii.column}' contains ${pii.classification}. Recommended protection: ${pii.protection}`
        });
      });
    }
    
    // Data masking strategies
    const maskingStrategy = this.generateMaskingStrategy(columns, columnTypes, records);
    if (maskingStrategy.required) {
      recommendations.push({
        category: 'Security',
        priority: 'High',
        action: 'Implement data masking',
        details: `Masking required for: ${maskingStrategy.columns.join(', ')}. Strategy: ${maskingStrategy.method}`
      });
    }
    
    // Access control recommendations
    const accessControl = this.generateAccessControlStrategy(columns, columnTypes);
    recommendations.push({
      category: 'Security',
      priority: 'Medium',
      action: 'Define access controls',
      details: `Recommended access levels: ${accessControl.levels.join(', ')}. Implementation: ${accessControl.method}`
    });
    
    return recommendations;
  }
  
  generateGovernanceRecommendations(records, columns, columnTypes) {
    const recommendations = [];
    
    // Data lineage tracking
    const lineageStrategy = this.generateLineageStrategy(columns, columnTypes);
    recommendations.push({
      category: 'Governance',
      priority: 'Medium',
      action: 'Implement data lineage tracking',
      details: `Track lineage for: ${lineageStrategy.criticalColumns.join(', ')}. Method: ${lineageStrategy.method}`
    });
    
    // Data quality monitoring
    const monitoringStrategy = this.generateMonitoringStrategy(records, columns, columnTypes);
    recommendations.push({
      category: 'Governance',
      priority: 'High',
      action: 'Set up quality monitoring',
      details: `Monitor: ${monitoringStrategy.metrics.join(', ')}. Frequency: ${monitoringStrategy.frequency}`
    });
    
    // Retention and archival policies
    const retentionStrategy = this.generateRetentionStrategy(records, columns, columnTypes);
    recommendations.push({
      category: 'Governance',
      priority: 'Low',
      action: 'Define retention policy',
      details: `Recommended retention: ${retentionStrategy.period}. Archival strategy: ${retentionStrategy.archival}`
    });
    
    return recommendations;
  }
  
  assessAnalyticsReadiness(records, columns, columnTypes) {
    const recommendations = [];
    
    // Feature engineering opportunities
    const featureAnalysis = this.analyzeFeatureEngineering(records, columns, columnTypes);
    if (featureAnalysis.opportunities.length > 0) {
      recommendations.push({
        category: 'Analytics',
        priority: 'Medium',
        action: 'Implement feature engineering',
        details: `Opportunities: ${featureAnalysis.opportunities.join(', ')}. ML readiness score: ${featureAnalysis.readinessScore}/10`
      });
    }
    
    // Data preparation for analytics
    const prepAnalysis = this.analyzeDataPreparation(records, columns, columnTypes);
    recommendations.push({
      category: 'Analytics',
      priority: 'Medium',
      action: 'Prepare data for analytics',
      details: `Required steps: ${prepAnalysis.steps.join(', ')}. Complexity: ${prepAnalysis.complexity}`
    });
    
    // Real-time vs batch processing
    const processingStrategy = this.recommendProcessingStrategy(records, columns, columnTypes);
    recommendations.push({
      category: 'Analytics',
      priority: 'Low',
      action: `Implement ${processingStrategy.type} processing`,
      details: `Recommended: ${processingStrategy.type}. Rationale: ${processingStrategy.rationale}`
    });
    
    return recommendations;
  }
  
  formatETLRecommendations(recommendations) {
    if (recommendations.length === 0) {
      return 'No specific ETL recommendations - data appears well-structured';
    }
    
    let output = 'ADVANCED ETL IMPLEMENTATION RECOMMENDATIONS:\n\n';
    
    // Group by category and priority
    const groupedRecs = recommendations.reduce((acc, rec) => {
      if (!acc[rec.category]) acc[rec.category] = { High: [], Medium: [], Low: [] };
      acc[rec.category][rec.priority].push(rec);
      return acc;
    }, {});
    
    Object.entries(groupedRecs).forEach(([category, priorities]) => {
      output += `${category.toUpperCase()}:\n`;
      
      ['High', 'Medium', 'Low'].forEach(priority => {
        if (priorities[priority].length > 0) {
          priorities[priority].forEach(rec => {
            output += `  🔸 [${priority}] ${rec.action}\n`;
            output += `     ${rec.details}\n\n`;
          });
        }
      });
    });
    
    // Add implementation priority summary
    const highPriority = recommendations.filter(r => r.priority === 'High').length;
    const mediumPriority = recommendations.filter(r => r.priority === 'Medium').length;
    const lowPriority = recommendations.filter(r => r.priority === 'Low').length;
    
    output += `IMPLEMENTATION SUMMARY:\n`;
    output += `  High Priority: ${highPriority} items (implement first)\n`;
    output += `  Medium Priority: ${mediumPriority} items (implement next)\n`;
    output += `  Low Priority: ${lowPriority} items (implement when resources allow)\n`;
    
    return output;
  }
  // Helper methods for advanced relationship detection
  extractTableFromId(columnName) {
    // Remove common ID suffixes and clean the name
    let tableName = columnName
      .replace(/_id$|_key$|id$/, '')
      .replace(/^fk_/, '')
      .replace(/[^a-z]/g, '_');
    
    // Handle common patterns
    if (tableName === 'cust' || tableName === 'customer') return 'customer';
    if (tableName === 'prod' || tableName === 'product') return 'product';
    if (tableName === 'order' || tableName === 'ord') return 'order';
    if (tableName === 'user' || tableName === 'usr') return 'user';
    
    return tableName;
  }
  
  calculateFKConfidence(column, type, tableHint) {
    let confidence = 0.5;
    
    // Boost confidence for standard patterns
    if (column.toLowerCase().endsWith('_id')) confidence += 0.3;
    if (type.type === 'integer' || type.type === 'identifier') confidence += 0.2;
    if (tableHint && tableHint.length > 2) confidence += 0.1;
    
    // Penalize for very generic names
    if (['id', 'key', 'ref'].includes(tableHint)) confidence -= 0.2;
    
    return Math.min(confidence, 0.95);
  }
  
  extractDomainFromCode(columnName) {
    return columnName
      .replace(/_?code$|_?cd$/, '')
      .replace(/[^a-z]/g, '_');
  }
  
  calculateCodeConfidence(column, type) {
    let confidence = 0.6;
    
    // Higher confidence for fewer categories (more likely to be lookup)
    if (type.categories && type.categories.length <= 20) confidence += 0.2;
    if (type.categories && type.categories.length <= 10) confidence += 0.1;
    
    // Pattern-based confidence boosts
    if (column.toLowerCase().includes('status')) confidence += 0.1;
    if (column.toLowerCase().includes('type')) confidence += 0.1;
    
    return Math.min(confidence, 0.9);
  }
  
  calculateCategoricalConfidence(column, type) {
    let confidence = 0.5;
    
    // More categories = higher chance of being a separate reference
    if (type.categories && type.categories.length > 5) confidence += 0.2;
    if (type.categories && type.categories.length > 15) confidence += 0.2;
    
    return Math.min(confidence, 0.85);
  }
  
  isGeographicColumn(columnName, type) {
    const geoKeywords = ['country', 'state', 'province', 'region', 'city', 'location', 'zip', 'postal'];
    return geoKeywords.some(keyword => columnName.includes(keyword)) ||
           (type.type === 'postcode');
  }
  
  detectGeographicType(columnName, type) {
    if (columnName.includes('country')) return 'countries';
    if (columnName.includes('state') || columnName.includes('province')) return 'states';
    if (columnName.includes('city')) return 'cities';
    if (columnName.includes('zip') || columnName.includes('postal') || type.type === 'postcode') return 'postal_codes';
    return 'locations';
  }
  
  detectTimeGrain(columnName) {
    if (columnName.includes('year')) return 'year';
    if (columnName.includes('quarter')) return 'quarter';
    if (columnName.includes('month')) return 'month';
    if (columnName.includes('week')) return 'week';
    if (columnName.includes('day') || columnName.includes('date')) return 'date';
    return 'time';
  }
  
  pluralizeTableName(tableName) {
    // Simple pluralization rules
    if (tableName.endsWith('y')) return tableName.slice(0, -1) + 'ies';
    if (tableName.endsWith('s') || tableName.endsWith('x') || tableName.endsWith('z')) return tableName + 'es';
    return tableName + 's';
  }
  
  buildFKEvidence(column, type, tableHint, confidence) {
    const factors = [];
    
    if (column.toLowerCase().endsWith('_id')) factors.push('standard naming convention');
    if (type.type === 'integer') factors.push('integer type');
    if (type.type === 'identifier') factors.push('identifier pattern');
    if (confidence > 0.8) factors.push('high pattern match');
    
    return `Foreign key indicators: ${factors.join(', ')}`;
  }
  
  detectCrossColumnRelationships(columns, columnTypes) {
    const relationships = [];
    
    // Look for composite key patterns
    const idColumns = columns.filter(col => 
      col.toLowerCase().includes('_id') || col.toLowerCase().endsWith('id')
    );
    
    if (idColumns.length >= 2) {
      relationships.push({
        type: 'composite_key',
        columns: idColumns,
        confidence: 0.7,
        target_table: 'bridge_table',
        target_column: 'composite_key',
        evidence: `Multiple ID columns (${idColumns.join(', ')}) suggest many-to-many relationship bridge`
      });
    }
    
    // Look for hierarchical patterns (parent_id, level, etc.)
    const hierarchyIndicators = columns.filter(col => {
      const colLower = col.toLowerCase();
      return colLower.includes('parent') || colLower.includes('level') || colLower.includes('hierarchy');
    });
    
    if (hierarchyIndicators.length > 0) {
      relationships.push({
        type: 'hierarchical_relationship',
        columns: hierarchyIndicators,
        confidence: 0.8,
        target_table: 'self_reference',
        target_column: 'parent_key',
        evidence: `Hierarchical indicators (${hierarchyIndicators.join(', ')}) suggest self-referencing hierarchy`
      });
    }
    
    return relationships;
  }
  
  // ETL Analysis Helper Methods
  generateNullHandlingStrategies(records, columns, columnTypes) {
    const strategies = [];
    
    columns.forEach(col => {
      const values = records.map(r => r[col]);
      const nullCount = values.filter(v => v === null || v === undefined || v === '').length;
      const nullRatio = nullCount / records.length;
      
      if (nullRatio > 0.1) {
        const type = columnTypes[col]?.type;
        if (type === 'categorical') strategies.push('mode imputation');
        else if (['integer', 'float'].includes(type)) strategies.push('median imputation');
        else strategies.push('forward fill');
      }
    });
    
    return [...new Set(strategies)];
  }
  
  detectConsistencyIssues(records, columns, columnTypes) {
    const issues = [];
    
    columns.forEach(col => {
      const type = columnTypes[col];
      if (type?.type === 'categorical' && type.categories) {
        // Check for case inconsistencies
        const values = records.map(r => r[col]).filter(v => v);
        const caseIssues = values.filter(v => {
          const lower = String(v).toLowerCase();
          return type.categories.some(cat => String(cat).toLowerCase() === lower && cat !== v);
        });
        
        if (caseIssues.length > 0) {
          issues.push(`${col}: case inconsistencies`);
        }
      }
    });
    
    return issues;
  }
  
  analyzeOutliers(records, columns, columnTypes) {
    const outlierColumns = [];
    let strategy = 'IQR-based detection';
    
    columns.forEach(col => {
      const type = columnTypes[col];
      if (['integer', 'float'].includes(type?.type)) {
        const values = records.map(r => r[col]).filter(v => typeof v === 'number' && !isNaN(v));
        if (values.length > 10) {
          values.sort((a, b) => a - b);
          const q1 = values[Math.floor(values.length * 0.25)];
          const q3 = values[Math.floor(values.length * 0.75)];
          const iqr = q3 - q1;
          const outliers = values.filter(v => v < q1 - 1.5 * iqr || v > q3 + 1.5 * iqr);
          
          if (outliers.length > values.length * 0.05) {
            outlierColumns.push(col);
          }
        }
      }
    });
    
    if (outlierColumns.length > 3) strategy = 'statistical modeling';
    
    return { outlierColumns, strategy };
  }
  
  analyzePartitioningStrategy(records, columns, columnTypes) {
    const dateColumns = columns.filter(col => columnTypes[col]?.type === 'date');
    const rowCount = records.length;
    
    if (rowCount > 100000 && dateColumns.length > 0) {
      return {
        recommended: true,
        strategy: `Monthly partitioning by ${dateColumns[0]}`,
        priority: 'High',
        improvement: '60-80% query performance boost'
      };
    } else if (rowCount > 50000) {
      const idColumns = columns.filter(col => col.toLowerCase().includes('_id'));
      if (idColumns.length > 0) {
        return {
          recommended: true,
          strategy: `Hash partitioning by ${idColumns[0]}`,
          priority: 'Medium',
          improvement: '30-50% query performance boost'
        };
      }
    }
    
    return { recommended: false };
  }
  
  generateIndexingStrategy(records, columns, columnTypes) {
    const indexes = [];
    const idColumns = columns.filter(col => col.toLowerCase().includes('_id') || col.toLowerCase() === 'id');
    const dateColumns = columns.filter(col => columnTypes[col]?.type === 'date');
    const categoricalColumns = columns.filter(col => columnTypes[col]?.type === 'categorical');
    
    // Primary indexes
    indexes.push(...idColumns.map(col => `${col} (primary)`));
    
    // Temporal indexes
    if (dateColumns.length > 0) {
      indexes.push(`${dateColumns[0]} (temporal queries)`);
    }
    
    // Categorical indexes for filtering
    const highCardinalityCategorical = categoricalColumns.filter(col => {
      const type = columnTypes[col];
      return type.categories && type.categories.length <= 20;
    });
    indexes.push(...highCardinalityCategorical.map(col => `${col} (filtering)`));
    
    return {
      indexes,
      benefit: indexes.length > 3 ? '50-70%' : '20-40%'
    };
  }
  
  analyzeStorageOptimization(records, columns, columnTypes) {
    let currentSize = records.length * columns.length * 50; // Rough estimate in bytes
    let optimizedSize = currentSize;
    
    // Compression estimates
    const categoricalRatio = columns.filter(col => columnTypes[col]?.type === 'categorical').length / columns.length;
    const compressionRatio = categoricalRatio > 0.5 ? 4 : 3;
    
    optimizedSize = Math.floor(currentSize / compressionRatio);
    
    const savings = Math.round((1 - optimizedSize / currentSize) * 100);
    
    return {
      currentSize: this.formatBytes(currentSize),
      optimizedSize: this.formatBytes(optimizedSize),
      savings: `${savings}%`
    };
  }
  
  formatBytes(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
    if (bytes < 1024 * 1024 * 1024) return Math.round(bytes / (1024 * 1024)) + ' MB';
    return Math.round(bytes / (1024 * 1024 * 1024)) + ' GB';
  }
  
  detectTableType(columns, columnTypes, records) {
    const measures = this.identifyMeasureColumns(columns, columnTypes, records);
    const dimensions = this.identifyDimensionColumns(columns, columnTypes, records);
    const hasTimestamp = columns.some(c => columnTypes[c]?.type === 'date');
    
    if (measures.length >= 2 && hasTimestamp) return 'fact';
    if (dimensions.length >= 2 && measures.length <= 1) return 'dimension';
    if (columns.length <= 5) return 'reference';
    return 'operational';
  }
  
  getDesignPattern(tableType, rowCount, columnCount) {
    const patterns = {
      fact: {
        pattern: 'Star Schema Fact Table',
        reasoning: 'Optimized for analytical queries with measures and foreign keys',
        performance: 'Excellent for aggregations, partition-friendly'
      },
      dimension: {
        pattern: 'Slowly Changing Dimension',
        reasoning: 'Descriptive data that changes slowly over time',
        performance: 'Good for lookups, consider Type 2 SCD for history'
      },
      reference: {
        pattern: 'Reference/Lookup Table',
        reasoning: 'Static data for normalization and validation',
        performance: 'Cache-friendly, minimal storage overhead'
      },
      operational: {
        pattern: 'Operational Data Store',
        reasoning: 'Business process data requiring normalization',
        performance: 'Optimize for transactions, consider read replicas'
      }
    };
    
    return patterns[tableType] || patterns.operational;
  }
  
  analyzeNormalizationOpportunities(records, columns, columnTypes) {
    const opportunities = [];
    const benefits = [];
    
    // Look for repeated value patterns
    columns.forEach(col => {
      const type = columnTypes[col];
      if (type?.type === 'categorical' && type.categories && type.categories.length > 10) {
        opportunities.push(`${col} lookup table`);
        benefits.push('reduced storage');
      }
    });
    
    // Look for composite data
    const addressColumns = columns.filter(col => 
      col.toLowerCase().includes('address') || 
      col.toLowerCase().includes('city') || 
      col.toLowerCase().includes('state')
    );
    
    if (addressColumns.length >= 2) {
      opportunities.push('address normalization');
      benefits.push('data consistency');
    }
    
    return {
      opportunities,
      benefits: [...new Set(benefits)].join(', ')
    };
  }
  
  generateDataModelingStrategy(records, columns, columnTypes) {
    const rowCount = records.length;
    const columnCount = columns.length;
    const hasTimestamp = columns.some(c => columnTypes[c]?.type === 'date');
    
    if (rowCount > 100000 && hasTimestamp) {
      return {
        approach: 'Time-series optimized data model',
        rationale: 'Large temporal dataset benefits from time-partitioned architecture'
      };
    } else if (columnCount > 20) {
      return {
        approach: 'Normalized relational model',
        rationale: 'Wide table suggests normalization opportunities for better maintainability'
      };
    } else {
      return {
        approach: 'Denormalized analytical model',
        rationale: 'Compact dataset suitable for analytical workloads'
      };
    }
  }
  
  classifyPIIColumns(columns, columnTypes, records) {
    const piiColumns = [];
    
    columns.forEach(col => {
      const colLower = col.toLowerCase();
      const type = columnTypes[col];
      
      if (colLower.includes('email') || type?.type === 'email') {
        piiColumns.push({
          column: col,
          classification: 'email',
          riskLevel: 'High',
          protection: 'encryption + tokenization'
        });
      } else if (colLower.includes('phone')) {
        piiColumns.push({
          column: col,
          classification: 'phone number',
          riskLevel: 'Medium',
          protection: 'masking + encryption'
        });
      } else if (colLower.includes('ssn') || colLower.includes('social')) {
        piiColumns.push({
          column: col,
          classification: 'SSN',
          riskLevel: 'High',
          protection: 'tokenization + restricted access'
        });
      } else if (colLower.includes('name') && type?.type === 'string') {
        piiColumns.push({
          column: col,
          classification: 'personal name',
          riskLevel: 'Medium',
          protection: 'pseudonymization'
        });
      }
    });
    
    return piiColumns;
  }
  
  generateMaskingStrategy(columns, columnTypes, records) {
    const sensitiveColumns = columns.filter(col => {
      const colLower = col.toLowerCase();
      return colLower.includes('email') || colLower.includes('phone') || 
             colLower.includes('ssn') || colLower.includes('credit');
    });
    
    if (sensitiveColumns.length > 0) {
      return {
        required: true,
        columns: sensitiveColumns,
        method: 'format-preserving encryption with role-based unmasking'
      };
    }
    
    return { required: false };
  }
  
  generateAccessControlStrategy(columns, columnTypes) {
    const idColumns = columns.filter(col => col.toLowerCase().includes('_id'));
    const sensitiveColumns = columns.filter(col => {
      const colLower = col.toLowerCase();
      return colLower.includes('email') || colLower.includes('salary') || 
             colLower.includes('phone') || colLower.includes('address');
    });
    
    const levels = ['public'];
    if (idColumns.length > 0) levels.push('internal');
    if (sensitiveColumns.length > 0) levels.push('restricted');
    
    return {
      levels,
      method: 'row-level security with column-level permissions'
    };
  }
  
  generateLineageStrategy(columns, columnTypes) {
    const criticalColumns = columns.filter(col => {
      const colLower = col.toLowerCase();
      return colLower.includes('_id') || colLower.includes('amount') || 
             colLower.includes('date') || colLower.includes('status');
    });
    
    return {
      criticalColumns,
      method: 'automated lineage tracking with data flow documentation'
    };
  }
  
  generateMonitoringStrategy(records, columns, columnTypes) {
    const metrics = ['completeness', 'uniqueness'];
    
    if (columns.some(col => ['integer', 'float'].includes(columnTypes[col]?.type))) {
      metrics.push('statistical drift');
    }
    
    if (columns.some(col => columnTypes[col]?.type === 'categorical')) {
      metrics.push('domain consistency');
    }
    
    const frequency = records.length > 100000 ? 'daily' : 'weekly';
    
    return { metrics, frequency };
  }
  
  generateRetentionStrategy(records, columns, columnTypes) {
    const hasTimestamp = columns.some(c => columnTypes[c]?.type === 'date');
    const hasPII = columns.some(col => {
      const colLower = col.toLowerCase();
      return colLower.includes('email') || colLower.includes('phone') || colLower.includes('name');
    });
    
    let period = '7 years';
    let archival = 'cold storage after 2 years';
    
    if (hasPII) {
      period = '3 years (compliance-driven)';
      archival = 'encrypted archival with anonymization option';
    } else if (!hasTimestamp) {
      period = 'indefinite (reference data)';
      archival = 'periodic backup only';
    }
    
    return { period, archival };
  }
  
  analyzeFeatureEngineering(records, columns, columnTypes) {
    const opportunities = [];
    let readinessScore = 5;
    
    // Date feature engineering
    const dateColumns = columns.filter(col => columnTypes[col]?.type === 'date');
    if (dateColumns.length > 0) {
      opportunities.push('temporal features (day/month/year)');
      readinessScore += 1;
    }
    
    // Categorical encoding
    const categoricalColumns = columns.filter(col => columnTypes[col]?.type === 'categorical');
    if (categoricalColumns.length > 0) {
      opportunities.push('categorical encoding');
      readinessScore += 1;
    }
    
    // Numerical scaling
    const numericColumns = columns.filter(col => ['integer', 'float'].includes(columnTypes[col]?.type));
    if (numericColumns.length > 1) {
      opportunities.push('feature scaling/normalization');
      readinessScore += 1;
    }
    
    // Interaction features
    if (numericColumns.length >= 2) {
      opportunities.push('interaction features');
      readinessScore += 1;
    }
    
    return {
      opportunities,
      readinessScore: Math.min(readinessScore, 10)
    };
  }
  
  analyzeDataPreparation(records, columns, columnTypes) {
    const steps = [];
    let complexity = 'Low';
    
    // Check for missing values
    const nullCounts = {};
    records.forEach(record => {
      columns.forEach(col => {
        if (!nullCounts[col]) nullCounts[col] = 0;
        if (!record[col]) nullCounts[col]++;
      });
    });
    
    const hasNulls = Object.values(nullCounts).some(count => count > 0);
    if (hasNulls) {
      steps.push('missing value imputation');
      complexity = 'Medium';
    }
    
    // Check for categorical variables
    const categoricalColumns = columns.filter(col => columnTypes[col]?.type === 'categorical');
    if (categoricalColumns.length > 0) {
      steps.push('categorical encoding');
    }
    
    // Check for skewed distributions
    const numericColumns = columns.filter(col => ['integer', 'float'].includes(columnTypes[col]?.type));
    if (numericColumns.length > 0) {
      steps.push('distribution analysis');
      if (numericColumns.length > 5) complexity = 'High';
    }
    
    if (steps.length === 0) steps.push('data validation only');
    
    return { steps, complexity };
  }
  
  recommendProcessingStrategy(records, columns, columnTypes) {
    const rowCount = records.length;
    const hasTimestamp = columns.some(c => columnTypes[c]?.type === 'date');
    
    if (rowCount > 500000 && hasTimestamp) {
      return {
        type: 'streaming',
        rationale: 'Large temporal dataset benefits from real-time processing'
      };
    } else if (rowCount > 100000) {
      return {
        type: 'micro-batch',
        rationale: 'Balanced approach for medium-scale data with good latency'
      };
    } else {
      return {
        type: 'batch',
        rationale: 'Simple batch processing sufficient for dataset size'
      };
    }
  }
  
  findRelatedTables(analysis, knowledge) { 
    const relatedTables = [];
    
    if (!knowledge.warehouse || !knowledge.warehouse.tables) {
      return relatedTables;
    }
    
    const currentColumns = analysis.columns.map(c => c.name.toLowerCase());
    
    // Find tables with shared column patterns
    Object.entries(knowledge.warehouse.tables).forEach(([tableName, tableInfo]) => {
      if (tableName === analysis.table_name) return; // Skip self
      
      const tableColumns = (tableInfo.columns || []).map(c => c.name?.toLowerCase() || c.toLowerCase());
      const sharedColumns = currentColumns.filter(col => tableColumns.includes(col));
      
      if (sharedColumns.length > 0) {
        const relationshipStrength = sharedColumns.length / Math.min(currentColumns.length, tableColumns.length);
        
        relatedTables.push({
          name: tableName,
          sharedColumns,
          relationshipStrength,
          confidence: Math.min(relationshipStrength * 0.8, 0.9)
        });
      }
    });
    
    // Sort by relationship strength
    return relatedTables
      .sort((a, b) => b.relationshipStrength - a.relationshipStrength)
      .slice(0, 5); // Top 5 related tables
  }
  classifyIntoDomain(analysis, knowledge) { 
    // Use existing domain knowledge to classify new tables
    if (!knowledge.warehouse?.domains) {
      return analysis.domain;
    }
    
    const currentColumns = analysis.columns.map(c => c.name.toLowerCase());
    const domainScores = {};
    
    // Score against existing domains
    Object.entries(knowledge.warehouse.domains).forEach(([domain, domainInfo]) => {
      const domainColumns = (domainInfo.common_columns || []).map(c => c.toLowerCase());
      const overlap = currentColumns.filter(col => domainColumns.includes(col)).length;
      
      if (overlap > 0) {
        domainScores[domain] = overlap / domainColumns.length;
      }
    });
    
    // Find best matching domain
    const bestDomain = Object.entries(domainScores).reduce((best, [domain, score]) => {
      return score > (best.score || 0) ? { domain, score } : best;
    }, {});
    
    // Return best match if confidence is high enough, otherwise use analysis result
    return bestDomain.score > 0.3 ? bestDomain.domain : analysis.domain;
  }
  generateCrossReferences(analysis, knowledge, patterns) { 
    const refs = [];
    
    // Pattern-based cross-references
    patterns.naming_patterns.forEach(pattern => {
      if (pattern.frequency > 1) {
        refs.push(`"${pattern.pattern}" matches pattern found in ${pattern.frequency} other tables`);
      }
    });
    
    // Relationship-based cross-references
    if (analysis.relationships && analysis.relationships.length > 0) {
      analysis.relationships.forEach(rel => {
        if (rel.confidence > 0.7) {
          refs.push(`${rel.column} likely references ${rel.target_table}.${rel.target_column}`);
        }
      });
    }
    
    // Domain-based cross-references
    if (knowledge.warehouse?.domains && knowledge.warehouse.domains[analysis.domain]) {
      const domainTables = knowledge.warehouse.domains[analysis.domain].tables || [];
      if (domainTables.length > 1) {
        refs.push(`Part of ${analysis.domain} domain with ${domainTables.length - 1} other tables`);
      }
    }
    
    // Quality pattern cross-references
    if (analysis.patterns?.issues && analysis.patterns.issues.length > 0) {
      const commonIssues = analysis.patterns.issues.filter(issue => {
        return knowledge.patterns?.common_issues?.some(common => 
          common.type === issue.type
        );
      });
      
      if (commonIssues.length > 0) {
        refs.push(`Shares ${commonIssues.length} common data quality issues with other tables`);
      }
    }
    
    return refs;
  }
  buildContextFromRelated(relatedTables) { return '- Related tables: ' + relatedTables.map(t => t.name).join(', '); }
  formatSchemaSection(analysis) {
    // Ensure we have schema recommendations
    if (!analysis.schema_recommendations || analysis.schema_recommendations.trim() === '') {
      // Generate it if missing
      const recommendations = this.generateLegacySchemaSection(
        analysis.columns.map(c => c.name),
        analysis.columns.reduce((acc, col) => {
          acc[col.name] = { type: col.type, confidence: col.confidence };
          return acc;
        }, {}),
        [] // We don't have records in this context
      );
      return createSubSection('🗄️ SCHEMA RECOMMENDATIONS', recommendations);
    }
    return createSubSection('🗄️ SCHEMA RECOMMENDATIONS', analysis.schema_recommendations);
  }
  generateRelationshipReport(relationships) { return jsYaml.dump(relationships || {}); }
  generatePatternReport(patterns) { return jsYaml.dump(patterns || {}); }
  generateTechnicalDebtReport(warehouse) { return `Total: ${warehouse?.warehouse_metadata?.total_technical_debt_hours || 0} hours`; }
  generateWarehouseRecommendations(knowledge) { return 'Analyze more tables to build recommendations'; }

  generateLegacySchemaSection(columns, columnTypes, records) {
    // Generate a proper table name from the analysis context
    const tableName = this.generateTableName(columns, columnTypes);
    
    let schema = '\nSuggested Table Structure:\n```sql\n';
    schema += '-- Recommended data types based on analysis\n';
    schema += `CREATE TABLE ${tableName} (\n`;
    
    const columnDefinitions = [];
    columns.forEach(column => {
      const type = columnTypes[column];
      const sqlType = getSQLType(type, records.map(r => r[column]));
      const constraints = getConstraints(column, type, records);
      columnDefinitions.push(`    ${column.toLowerCase().replace(/[^a-z0-9]/g, '_')}${sqlType}${constraints}`);
    });
    
    schema += columnDefinitions.join(',\n');
    schema += '\n);\n```\n';
    
    return schema;
  }

  generateTableName(columns, columnTypes) {
    // Use the table name from the file if available
    if (this._currentTableName) {
      // Ensure it doesn't match any column names
      if (columns.some(col => col.toLowerCase() === this._currentTableName)) {
        return `tbl_${this._currentTableName}`;
      }
      return this._currentTableName;
    }
    
    // Fallback to generating based on data characteristics
    // Check for common table patterns
    const hasCustomerId = columns.some(c => c.toLowerCase().includes('customer'));
    const hasOrderId = columns.some(c => c.toLowerCase().includes('order'));
    const hasProductId = columns.some(c => c.toLowerCase().includes('product'));
    const hasDate = Object.values(columnTypes).some(t => t.type === 'date');
    const hasMeasures = columns.some(c => 
      c.toLowerCase().includes('amount') || 
      c.toLowerCase().includes('count') ||
      c.toLowerCase().includes('total')
    );
    
    // Determine table type and name
    if (hasMeasures && hasDate) {
      if (hasOrderId) return 'fact_orders';
      if (hasCustomerId && hasProductId) return 'fact_sales';
      if (hasCustomerId) return 'fact_customer_transactions';
      return 'fact_transactions';
    } else if (hasCustomerId && !hasMeasures) {
      return 'dim_customers';
    } else if (hasProductId && !hasMeasures) {
      return 'dim_products';
    } else if (columns.length < 5 && columns.some(c => c.toLowerCase().includes('name'))) {
      return 'ref_lookup';
    } else {
      // Default to a generic name based on column count and types
      const numCategorical = Object.values(columnTypes).filter(t => t.type === 'categorical').length;
      if (numCategorical > columns.length * 0.5) {
        return 'dim_reference';
      }
      return 'tbl_data';
    }
  }
}

async function engineering(filePath, options = {}) {
  const outputHandler = new OutputHandler(options);
  
  if (options.saveInsights) {
    const [tableName, insights] = options.saveInsights;
    const engine = new ArchaeologyEngine();
    await engine.saveInsights(tableName, insights);
    outputHandler.finalize();
    return;
  }
  
  if (options.compileKnowledge) {
    const engine = new ArchaeologyEngine();
    const compilation = await engine.compileKnowledge();
    
    console.log(createSection('📚 WAREHOUSE KNOWLEDGE COMPILATION', formatTimestamp()));
    console.log(compilation.summary);
    console.log(compilation.warehouse_map);
    
    if (options.output) {
      const fullReport = Object.values(compilation).join('\n\n');
      outputHandler.finalize(fullReport);
    } else {
      outputHandler.finalize();
    }
    return;
  }
  
  if (options.showMap) {
    const engine = new ArchaeologyEngine();
    const map = await engine.showMap();
    console.log(map);
    outputHandler.finalize();
    return;
  }
  
  // Use archaeology engine if no specific options
  const engine = new ArchaeologyEngine();
  const report = await engine.analyzeTable(filePath, options);
  
  // Only output to console if not in structured mode (not being called by LLM command)
  if (!options.structuredOutput && !options.llmMode) {
    console.log(report);
  }
  
  outputHandler.finalize();
  
  // Return the report for structured consumption
  return report;
}

// Legacy functions preserved for compatibility
function getSQLType(type, values) {
  const padded = ' '.repeat(Math.max(25 - type.type.length, 1));
  
  switch (type.type) {
    case 'identifier':
      const maxLength = Math.max(...values.filter(v => v).map(v => String(v).length));
      return `${padded}VARCHAR(${Math.max(maxLength * 1.5, 20)})`;
      
    case 'integer':
      const intValues = values.filter(v => typeof v === 'number');
      const maxInt = Math.max(...intValues);
      if (maxInt < 32767) return `${padded}SMALLINT`;
      if (maxInt < 2147483647) return `${padded}INTEGER`;
      return `${padded}BIGINT`;
      
    case 'float':
      return `${padded}DECIMAL(10,2)`;
      
    case 'date':
      const hasTime = values.some(v => v instanceof Date && (v.getHours() !== 0 || v.getMinutes() !== 0));
      return hasTime ? `${padded}TIMESTAMP` : `${padded}DATE`;
      
    case 'email':
      return `${padded}VARCHAR(255)`;
      
    case 'phone':
      return `${padded}VARCHAR(20)`;
      
    case 'postcode':
      return `${padded}CHAR(4)`;
      
    case 'categorical':
      const maxCatLength = Math.max(...type.categories.map(c => String(c).length));
      return `${padded}VARCHAR(${Math.max(maxCatLength * 1.5, 20)})`;
      
    default:
      const maxStrLength = Math.max(...values.filter(v => v).map(v => String(v).length));
      return `${padded}VARCHAR(${Math.max(maxStrLength * 1.5, 50)})`;
  }
}

function getConstraints(column, type, records) {
  const values = records.map(r => r[column]);
  const hasNulls = values.some(v => v === null || v === undefined);
  const isUnique = new Set(values.filter(v => v !== null)).size === values.filter(v => v !== null).length;
  
  let constraints = '';
  
  if (!hasNulls) {
    constraints += ' NOT NULL';
  }
  
  if (isUnique && type.type === 'identifier') {
    constraints += ' PRIMARY KEY';
  }
  
  if (column.toLowerCase() === 'status' && type.type === 'categorical') {
    constraints += ` CHECK (${column} IN (${type.categories.map(c => `'${c}'`).join(', ')}))`;
  }
  
  return constraints;
}

function analyzeDataQuality(records, columnTypes) {
  const issues = {
    total: 0,
    dateIssues: 0,
    nullIssues: 0,
    typeConversions: 0
  };
  
  records.forEach(record => {
    let hasIssue = false;
    
    Object.entries(record).forEach(([column, value]) => {
      const type = columnTypes[column];
      
      if (value === null || value === undefined || value === '') {
        issues.nullIssues++;
        hasIssue = true;
      }
      
      if (type.type === 'date' && value && !(value instanceof Date)) {
        issues.dateIssues++;
        hasIssue = true;
      }
      
      if (type.type === 'integer' && value && typeof value === 'string') {
        issues.typeConversions++;
        hasIssue = true;
      }
    });
    
    if (hasIssue) issues.total++;
  });
  
  return issues;
}

function analyzeNormalization(records, columns, columnTypes) {
  const issues = [];
  
  const textColumns = columns.filter(col => 
    ['string', 'categorical'].includes(columnTypes[col].type)
  );
  
  textColumns.forEach(col => {
    const values = records.map(r => r[col]).filter(v => v);
    const uniqueRatio = new Set(values).size / values.length;
    
    if (uniqueRatio < 0.1 && values.length > 100) {
      issues.push(`${col} appears in ${formatNumber((1 - uniqueRatio) * 100, 1)}% of rows (consider separate dimension table)`);
    }
  });
  
  return issues;
}

function generateWarehouseDesign(columns, columnTypes, records) {
  let design = '';
  
  const measureColumns = columns.filter(col => 
    ['integer', 'float'].includes(columnTypes[col].type) &&
    (col.toLowerCase().includes('amount') || 
     col.toLowerCase().includes('count') ||
     col.toLowerCase().includes('quantity') ||
     col.toLowerCase().includes('total'))
  );
  
  const dimensionColumns = columns.filter(col => 
    columnTypes[col].type === 'categorical' ||
    col.toLowerCase().includes('_id') ||
    col.toLowerCase().includes('type') ||
    col.toLowerCase().includes('category')
  );
  
  design += 'Fact Table: fact_' + (measureColumns[0]?.toLowerCase().replace(/[^a-z]/g, '_') || 'transactions') + '\n';
  design += '- Grain: One row per record\n';
  design += '- Measures: ' + (measureColumns.length > 0 ? measureColumns.join(', ') : 'count(*)') + '\n';
  design += '- Keys: ' + dimensionColumns.filter(c => c.includes('_id')).join(', ') + '\n\n';
  
  return design;
}

function generatePerformanceRecommendations(records, columns, columnTypes) {
  const recommendations = [];
  
  const dateColumns = columns.filter(col => columnTypes[col].type === 'date');
  if (dateColumns.length > 0 && records.length > 100000) {
    recommendations.push(`Partition by ${dateColumns[0]} (monthly partitions)`);
  }
  
  if (columns.length > 20) {
    recommendations.push('Consider columnar storage for analytical queries');
  }
  
  const categoricalColumns = columns.filter(col => columnTypes[col].type === 'categorical');
  if (categoricalColumns.length > columns.length * 0.3) {
    recommendations.push('Compression ratio estimate: 4:1 (high categorical data)');
  } else {
    recommendations.push('Compression ratio estimate: 3:1');
  }
  
  return recommendations;
}

/**
 * LLM Utility Functions
 * Extracted from llm.js to avoid circular dependencies
 */


function getDateRange$1(records, dateColumns) {
  if (dateColumns.length === 0) return null;
  
  const dates = records
    .map(r => r[dateColumns[0]])
    .filter(d => d instanceof Date)
    .sort((a, b) => a - b);
  
  if (dates.length === 0) return null;
  
  return {
    start: formatDate$1(dates[0]),
    end: formatDate$1(dates[dates.length - 1])
  };
}

function formatDate$1(date) {
  if (!(date instanceof Date)) return 'Invalid date';
  const months = ['January', 'February', 'March', 'April', 'May', 'June',
                  'July', 'August', 'September', 'October', 'November', 'December'];
  return `${months[date.getMonth()]} ${date.getFullYear()}`;
}

function inferDataType$1(columns, columnTypes) {
  const columnNames = columns.map(c => c.toLowerCase()).join(' ');
  
  // Medical/Healthcare domain
  if (columnNames.includes('patient') || columnNames.includes('diagnosis') || columnNames.includes('treatment') || 
      columnNames.includes('medical') || columnNames.includes('health') || columnNames.includes('hospital') ||
      columnNames.includes('doctor') || columnNames.includes('medication') || columnNames.includes('symptom') ||
      columnNames.includes('diabetes') || columnNames.includes('glucose') || columnNames.includes('blood') ||
      columnNames.includes('pressure') || columnNames.includes('cholesterol') || columnNames.includes('bmi')) {
    return 'medical/healthcare data';
  }
  
  // Scientific/Research domain
  if (columnNames.includes('experiment') || columnNames.includes('measurement') || columnNames.includes('sample') ||
      columnNames.includes('trial') || columnNames.includes('research') || columnNames.includes('lab') ||
      columnNames.includes('test') && columnNames.includes('result')) {
    return 'scientific/research data';
  }
  
  // Education domain
  if (columnNames.includes('student') || columnNames.includes('grade') || columnNames.includes('course') ||
      columnNames.includes('school') || columnNames.includes('teacher') || columnNames.includes('exam')) {
    return 'educational data';
  }
  
  // Environmental/Climate domain
  if (columnNames.includes('temperature') || columnNames.includes('climate') || columnNames.includes('weather') ||
      columnNames.includes('pollution') || columnNames.includes('emission') || columnNames.includes('environment')) {
    return 'environmental data';
  }
  
  // Manufacturing/Production domain
  if (columnNames.includes('production') || columnNames.includes('manufacturing') || columnNames.includes('assembly') ||
      columnNames.includes('defect') || columnNames.includes('quality') && columnNames.includes('control')) {
    return 'manufacturing/production data';
  }
  
  // Transportation/Logistics domain
  if (columnNames.includes('shipment') || columnNames.includes('delivery') || columnNames.includes('route') ||
      columnNames.includes('vehicle') || columnNames.includes('transport') || columnNames.includes('logistics')) {
    return 'transportation/logistics data';
  }
  
  // Business/Sales domains (moved to later priority)
  if (columnNames.includes('transaction') || columnNames.includes('order') || columnNames.includes('sale')) {
    return 'sales transaction data';
  }
  if (columnNames.includes('customer') && columnNames.includes('purchase')) {
    return 'customer purchase data';
  }
  if (columnNames.includes('product') && columnNames.includes('inventory')) {
    return 'product inventory data';
  }
  if (columnNames.includes('user') || columnNames.includes('account')) {
    return 'user account data';
  }
  if (columnNames.includes('employee') || columnNames.includes('staff')) {
    return 'employee/HR data';
  }
  if (columnNames.includes('revenue') || columnNames.includes('profit')) {
    return 'financial data';
  }
  
  // Look at column types
  const hasTransactionLikeData = columns.some(c => 
    columnTypes[c] && columnTypes[c].type === 'identifier' && columns.some(c2 => columnTypes[c2] && ['float', 'integer'].includes(columnTypes[c2].type))
  );
  
  if (hasTransactionLikeData) {
    return 'transactional data';
  }
  
  return 'general structured data';
}

function analyzeSeasonality$1(records, dateColumn, columns, columnTypes) {
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  if (numericColumns.length === 0) return null;
  
  const monthlyData = {};
  records.forEach(record => {
    const date = record[dateColumn];
    if (date instanceof Date) {
      const month = date.getMonth();
      if (!monthlyData[month]) monthlyData[month] = [];
      
      numericColumns.forEach(col => {
        if (typeof record[col] === 'number') {
          monthlyData[month].push(record[col]);
        }
      });
    }
  });
  
  if (Object.keys(monthlyData).length < 6) return null;
  
  const monthlyAverages = Object.entries(monthlyData)
    .map(([month, values]) => ({
      month: parseInt(month),
      avg: values.reduce((a, b) => a + b, 0) / values.length
    }));
  
  const overallAvg = monthlyAverages.reduce((a, b) => a + b.avg, 0) / monthlyAverages.length;
  const peak = monthlyAverages.reduce((a, b) => a.avg > b.avg ? a : b);
  
  if (peak.avg > overallAvg * 1.2) {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];
    return `Strong seasonal pattern with ${monthNames[peak.month]} showing ${formatPercentage((peak.avg / overallAvg) - 1)} above average`;
  }
  
  return null;
}

function analyzeSegments$1(records, columns, columnTypes) {
  const segmentColumns = columns.filter(c => 
    c.toLowerCase().includes('segment') || 
    c.toLowerCase().includes('tier') ||
    c.toLowerCase().includes('type') ||
    c.toLowerCase().includes('category') ||
    c.toLowerCase().includes('group') ||
    c.toLowerCase().includes('class')
  ).filter(c => columnTypes[c] && columnTypes[c].type === 'categorical');
  
  if (segmentColumns.length === 0) return null;
  
  const valueColumns = columns.filter(c => 
    (c.toLowerCase().includes('amount') || c.toLowerCase().includes('value') || 
     c.toLowerCase().includes('score') || c.toLowerCase().includes('count') ||
     c.toLowerCase().includes('result') || c.toLowerCase().includes('outcome')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  if (valueColumns.length === 0) return null;
  
  const segmentCol = segmentColumns[0];
  const valueCol = valueColumns[0];
  
  const segmentStats = {};
  records.forEach(record => {
    const segment = record[segmentCol];
    const value = record[valueCol];
    
    if (segment && typeof value === 'number') {
      if (!segmentStats[segment]) {
        segmentStats[segment] = { sum: 0, count: 0 };
      }
      segmentStats[segment].sum += value;
      segmentStats[segment].count++;
    }
  });
  
  const segments = Object.entries(segmentStats)
    .map(([name, stats]) => ({
      name,
      average: stats.sum / stats.count,
      percentage: stats.count / records.length
    }))
    .sort((a, b) => b.average - a.average);
  
  if (segments.length >= 2) {
    const top = segments[0];
    const totalValue = segments.reduce((sum, s) => sum + s.average * s.percentage, 0);
    const topValueShare = (top.average * top.percentage) / totalValue;
    
    // Determine appropriate title based on data type
    const dataType = inferDataType$1(columns, columnTypes);
    let title = 'SEGMENT ANALYSIS';
    let entityType = 'records';
    
    if (dataType === 'medical/healthcare data') {
      title = 'PATIENT GROUP ANALYSIS';
      entityType = 'patients';
    } else if (dataType === 'educational data') {
      title = 'STUDENT GROUP ANALYSIS';
      entityType = 'students';
    } else if (dataType === 'scientific/research data') {
      title = 'EXPERIMENTAL GROUP ANALYSIS';
      entityType = 'samples';
    } else if (dataType.includes('customer')) {
      title = 'CUSTOMER BEHAVIOR';
      entityType = 'customers';
    } else if (dataType.includes('product')) {
      title = 'PRODUCT CATEGORY ANALYSIS';
      entityType = 'products';
    }
    
    return {
      title: title,
      insight: `${top.name} ${entityType} account for ${formatPercentage(top.percentage)} of ${entityType} but ${formatPercentage(topValueShare)} of total ${valueCol}. Average ${valueCol}: ${formatNumber(top.average)}`
    };
  }
  
  return null;
}

function analyzeCategoryPerformance$1(records, columns, columnTypes) {
  const categoryColumns = columns.filter(c => 
    (c.toLowerCase().includes('category') || c.toLowerCase().includes('product')) &&
    columnTypes[c] && columnTypes[c].type === 'categorical'
  );
  
  if (categoryColumns.length === 0) return null;
  
  const performanceColumns = columns.filter(c => 
    (c.toLowerCase().includes('margin') || 
     c.toLowerCase().includes('profit') ||
     c.toLowerCase().includes('revenue')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  if (performanceColumns.length === 0) return null;
  
  const categoryCol = categoryColumns[0];
  const perfCol = performanceColumns[0];
  
  const categoryPerformance = {};
  records.forEach(record => {
    const category = record[categoryCol];
    const performance = record[perfCol];
    
    if (category && typeof performance === 'number') {
      if (!categoryPerformance[category]) {
        categoryPerformance[category] = { values: [], count: 0 };
      }
      categoryPerformance[category].values.push(performance);
      categoryPerformance[category].count++;
    }
  });
  
  const categories = Object.entries(categoryPerformance)
    .map(([name, data]) => ({
      name,
      average: data.values.reduce((a, b) => a + b, 0) / data.values.length,
      volume: data.count
    }))
    .sort((a, b) => b.average - a.average);
  
  if (categories.length >= 2) {
    const highMargin = categories[0];
    const highVolume = categories.sort((a, b) => b.volume - a.volume)[0];
    
    if (highMargin.name !== highVolume.name) {
      return {
        title: 'PRODUCT PERFORMANCE',
        insight: `${highMargin.name} shows highest ${perfCol} (${formatNumber(highMargin.average)}) but ${highVolume.name} has highest volume (${highVolume.volume} records)`
      };
    }
  }
  
  return null;
}

function analyzePricing$1(records, columns, columnTypes) {
  const priceColumns = columns.filter(c => 
    c.toLowerCase().includes('price') &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  if (priceColumns.length === 0) return null;
  
  const priceCol = priceColumns[0];
  const prices = records.map(r => r[priceCol]).filter(p => typeof p === 'number' && p > 0);
  
  if (prices.length === 0) return null;
  
  // Check for psychological pricing
  const endingIn99 = prices.filter(p => {
    const cents = Math.round((p % 1) * 100);
    return cents === 99;
  });
  
  const roundPrices = prices.filter(p => p % 1 === 0);
  
  const insights = [];
  
  if (endingIn99.length > prices.length * 0.3) {
    insights.push(`${formatPercentage(endingIn99.length / prices.length)} of prices end in .99`);
  }
  
  if (roundPrices.length > prices.length * 0.4) {
    const commonRoundPrices = {};
    roundPrices.forEach(p => {
      commonRoundPrices[p] = (commonRoundPrices[p] || 0) + 1;
    });
    
    const topPrices = Object.entries(commonRoundPrices)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([price]) => formatCurrency(parseFloat(price)));
    
    insights.push(`Common price points: ${topPrices.join(', ')}`);
  }
  
  if (insights.length > 0) {
    insights.push('(psychological pricing effect detected)');
    return insights.join('. ');
  }
  
  return null;
}

function detectAnomalies$1(records, columns, columnTypes) {
  const anomalies = [];
  const dataType = inferDataType$1(columns, columnTypes);
  
  // Check for zero values in numeric columns
  const numericColumns = columns.filter(c => 
    (c.toLowerCase().includes('amount') || c.toLowerCase().includes('value') || 
     c.toLowerCase().includes('score') || c.toLowerCase().includes('result') ||
     c.toLowerCase().includes('measurement') || c.toLowerCase().includes('count')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  numericColumns.forEach(col => {
    const zeros = records.filter(r => r[col] === 0).length;
    if (zeros > 0) {
      let context = 'records';
      let explanation = '';
      
      if (dataType === 'medical/healthcare data') {
        context = 'patients';
        explanation = '(potential missing or baseline measurements)';
      } else if (dataType === 'educational data') {
        context = 'students';
        explanation = '(potential missing assignments or zero scores)';
      } else if (dataType === 'scientific/research data') {
        context = 'measurements';
        explanation = '(potential calibration or measurement issues)';
      } else if (dataType.includes('sales') || dataType.includes('transaction')) {
        context = 'transactions';
        explanation = '(likely returns or errors)';
      } else {
        explanation = '(potential data quality issues)';
      }
      
      anomalies.push(`${zeros} ${context} with zero ${col} ${explanation}`);
    }
    
    // Check for negative values where they shouldn't exist
    const negatives = records.filter(r => typeof r[col] === 'number' && r[col] < 0).length;
    if (negatives > 0 && !col.toLowerCase().includes('profit') && !col.toLowerCase().includes('loss')) {
      anomalies.push(`${negatives} records with negative ${col} values`);
    }
  });
  
  // Check for suspicious patterns
  const idColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'identifier');
  if (idColumns.length > 0) {
    // Check for duplicate IDs
    const ids = records.map(r => r[idColumns[0]]).filter(id => id !== null);
    const uniqueIds = new Set(ids);
    if (uniqueIds.size < ids.length) {
      anomalies.push(`${ids.length - uniqueIds.size} duplicate ${idColumns[0]} values found`);
    }
  }
  
  // Check for outliers in date data
  const dateColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'date');
  if (dateColumns.length > 0) {
    const dates = records.map(r => r[dateColumns[0]]).filter(d => d instanceof Date);
    if (dates.length > 100) {
      const sorted = dates.sort((a, b) => a - b);
      const gaps = [];
      
      for (let i = 1; i < sorted.length; i++) {
        const daysDiff = (sorted[i] - sorted[i-1]) / (1000 * 60 * 60 * 24);
        if (daysDiff > 30) {
          gaps.push({ start: sorted[i-1], end: sorted[i], days: daysDiff });
        }
      }
      
      if (gaps.length > 0) {
        anomalies.push(`Data gaps detected: ${gaps.length} periods with >30 day gaps`);
      }
    }
  }
  
  return anomalies;
}

function calculateDataQuality$1(records, columns) {
  const totalCells = records.length * columns.length;
  let missingCells = 0;
  const missingByColumn = {};
  
  columns.forEach(col => {
    const missing = records.filter(r => r[col] === null || r[col] === undefined).length;
    missingCells += missing;
    if (missing > 0) {
      missingByColumn[col] = missing;
    }
  });
  
  const topMissing = Object.entries(missingByColumn)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 2)
    .map(([col, count]) => `${col} (${formatPercentage(count / records.length)})`);
  
  const duplicates = findDuplicateRows$1(records);
  
  return {
    completeness: (totalCells - missingCells) / totalCells,
    missingDetails: topMissing.length > 0 ? topMissing.join(', ') : 'No missing values',
    duplicates: duplicates.length,
    dateGaps: null // Will be filled by date analysis
  };
}

function findDuplicateRows$1(records) {
  const seen = new Set();
  const duplicates = [];
  
  records.forEach((record, idx) => {
    const key = JSON.stringify(record);
    if (seen.has(key)) {
      duplicates.push(idx);
    } else {
      seen.add(key);
    }
  });
  
  return duplicates;
}

function generateSummaryStatistics$1(records, columns, columnTypes) {
  const stats = [];
  
  // Total value statistics
  const valueColumns = columns.filter(c => 
    (c.toLowerCase().includes('amount') || 
     c.toLowerCase().includes('total') ||
     c.toLowerCase().includes('revenue')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  valueColumns.forEach(col => {
    const values = records.map(r => r[col]).filter(v => typeof v === 'number');
    if (values.length > 0) {
      const total = values.reduce((a, b) => a + b, 0);
      const avg = total / values.length;
      const sorted = [...values].sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];
      
      stats.push(`Total ${col}: ${formatCurrency(total)}`);
      stats.push(`Average ${col}: ${formatCurrency(avg)}`);
      stats.push(`Median ${col}: ${formatCurrency(median)}`);
    }
  });
  
  return stats;
}

function findSignificantCorrelations$1(records, columns, columnTypes) {
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  const correlations = [];
  
  for (let i = 0; i < numericColumns.length; i++) {
    for (let j = i + 1; j < numericColumns.length; j++) {
      const col1 = numericColumns[i];
      const col2 = numericColumns[j];
      const values1 = records.map(r => r[col1]);
      const values2 = records.map(r => r[col2]);
      const corr = calculateCorrelation(values1, values2);
      
      if (corr !== null && Math.abs(corr) > 0.5) {
        const strength = Math.abs(corr) > 0.8 ? 'Strong' : 'Moderate';
        const direction = corr > 0 ? 'positive' : 'negative';
        correlations.push(`${strength} ${direction}: ${col1} vs ${col2} (${formatNumber(corr, 2)})`);
      }
    }
  }
  
  return correlations.slice(0, 5);
}

function generateAnalysisSuggestions$1(columns, columnTypes) {
  const suggestions = [];
  const columnNames = columns.map(c => c.toLowerCase()).join(' ');
  const dataType = inferDataType$1(columns, columnTypes);
  
  // Medical/Healthcare specific suggestions
  if (dataType === 'medical/healthcare data') {
    if (columns.some(c => c.toLowerCase().includes('patient'))) {
      suggestions.push('Patient outcome analysis and risk stratification');
      suggestions.push('Treatment effectiveness comparison');
    }
    if (columns.some(c => c.toLowerCase().includes('diagnosis') || c.toLowerCase().includes('condition'))) {
      suggestions.push('Disease progression modeling and prediction');
      suggestions.push('Comorbidity analysis and pattern detection');
    }
    if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
      suggestions.push('Treatment timeline analysis and optimization');
      suggestions.push('Patient readmission risk prediction');
    }
    if (columnNames.includes('glucose') || columnNames.includes('diabetes')) {
      suggestions.push('Glucose pattern analysis and diabetes management insights');
      suggestions.push('Risk factor identification for diabetic complications');
    }
    return suggestions;
  }
  
  // Scientific/Research specific suggestions
  if (dataType === 'scientific/research data') {
    suggestions.push('Experiment result validation and reproducibility analysis');
    suggestions.push('Statistical significance testing and confidence intervals');
    if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
      suggestions.push('Temporal trend analysis in experimental results');
    }
    return suggestions;
  }
  
  // Educational specific suggestions
  if (dataType === 'educational data') {
    if (columns.some(c => c.toLowerCase().includes('student'))) {
      suggestions.push('Student performance prediction and early intervention');
      suggestions.push('Learning pattern analysis and personalization');
    }
    if (columns.some(c => c.toLowerCase().includes('grade') || c.toLowerCase().includes('score'))) {
      suggestions.push('Grade distribution analysis and fairness assessment');
      suggestions.push('Performance factors and correlation analysis');
    }
    return suggestions;
  }
  
  // Environmental specific suggestions
  if (dataType === 'environmental data') {
    suggestions.push('Environmental impact assessment and trend analysis');
    suggestions.push('Anomaly detection in environmental measurements');
    if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
      suggestions.push('Seasonal pattern analysis and climate modeling');
    }
    return suggestions;
  }
  
  // Manufacturing specific suggestions
  if (dataType === 'manufacturing/production data') {
    suggestions.push('Quality control analysis and defect prediction');
    suggestions.push('Production efficiency optimization');
    if (columns.some(c => c.toLowerCase().includes('defect'))) {
      suggestions.push('Root cause analysis for defects');
    }
    return suggestions;
  }
  
  // Transportation/Logistics specific suggestions
  if (dataType === 'transportation/logistics data') {
    suggestions.push('Route optimization and delivery performance analysis');
    suggestions.push('Fleet efficiency and utilization analysis');
    if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
      suggestions.push('Delivery time prediction and delay analysis');
    }
    return suggestions;
  }
  
  // Business/Sales suggestions (existing logic)
  if (columns.some(c => c.toLowerCase().includes('customer'))) {
    suggestions.push('Customer Lifetime Value (CLV) calculation and segmentation');
  }
  
  if (columns.some(c => c.toLowerCase().includes('product') || c.toLowerCase().includes('sku'))) {
    suggestions.push('Market basket analysis to find product associations');
  }
  
  if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
    if (dataType.includes('sales') || dataType.includes('transaction')) {
      suggestions.push('Time series forecasting for demand prediction');
    }
    
    if (columns.some(c => c.toLowerCase().includes('customer'))) {
      suggestions.push('Cohort analysis for customer retention');
    }
  }
  
  return suggestions;
}

function generateDataQuestions$1(columns, columnTypes, dataType) {
  const questions = [];
  const columnNames = columns.map(c => c.toLowerCase()).join(' ');
  
  // Medical/Healthcare questions
  if (dataType === 'medical/healthcare data') {
    questions.push('What are the key risk factors for adverse patient outcomes?');
    questions.push('Which treatments show the highest effectiveness rates?');
    questions.push('Are there patterns in patient demographics and health conditions?');
    questions.push('What factors correlate with successful treatment outcomes?');
    questions.push('How do different patient groups respond to various treatments?');
    questions.push('What are the early warning signs for complications?');
    if (columnNames.includes('diabetes') || columnNames.includes('glucose')) {
      questions.push('What patterns exist in glucose levels across different patient groups?');
      questions.push('Which factors most strongly correlate with diabetes complications?');
    }
  }
  
  // Scientific/Research questions
  else if (dataType === 'scientific/research data') {
    questions.push('What variables show the strongest correlations in the experiments?');
    questions.push('Are there any unexpected patterns in the research data?');
    questions.push('Which experimental conditions yield the most consistent results?');
    questions.push('What factors might be influencing measurement variability?');
    questions.push('Are there any outliers that warrant further investigation?');
  }
  
  // Educational questions
  else if (dataType === 'educational data') {
    questions.push('What factors most strongly predict student success?');
    questions.push('Are there achievement gaps between different student groups?');
    questions.push('Which teaching methods or courses show the best outcomes?');
    questions.push('What early indicators suggest students need additional support?');
    questions.push('How do attendance and engagement correlate with performance?');
  }
  
  // Environmental questions
  else if (dataType === 'environmental data') {
    questions.push('What are the long-term trends in environmental indicators?');
    questions.push('Which factors show the strongest environmental impact?');
    questions.push('Are there seasonal or cyclical patterns in the data?');
    questions.push('What anomalies or extreme events are present in the data?');
    questions.push('How do different environmental variables interact?');
  }
  
  // Manufacturing questions
  else if (dataType === 'manufacturing/production data') {
    questions.push('What factors contribute most to production defects?');
    questions.push('Which production lines or shifts show the best quality metrics?');
    questions.push('Are there patterns in equipment failures or maintenance needs?');
    questions.push('What variables correlate with production efficiency?');
    questions.push('How can quality control processes be optimized?');
  }
  
  // Transportation/Logistics questions
  else if (dataType === 'transportation/logistics data') {
    questions.push('What factors cause delivery delays?');
    questions.push('Which routes show the best efficiency metrics?');
    questions.push('Are there patterns in vehicle performance or maintenance?');
    questions.push('How do external factors (weather, traffic) impact operations?');
    questions.push('What opportunities exist for route optimization?');
  }
  
  // Business/Sales questions (existing logic)
  else if (dataType.includes('sales') || dataType.includes('transaction')) {
    questions.push('What factors drive sales performance?');
    questions.push('Which products/services generate the most revenue?');
    questions.push('What are the seasonal trends in sales?');
    questions.push('How do pricing changes affect sales volume?');
    questions.push('Which customer segments drive the most value?');
  }
  
  else if (dataType.includes('customer')) {
    questions.push('What factors drive customer loyalty?');
    questions.push('Which customer segments are most valuable?');
    questions.push('What is the typical customer journey?');
    questions.push('How can customer churn be predicted and prevented?');
    questions.push('What patterns exist in customer behavior?');
  }
  
  // General questions for unclassified data
  else {
    questions.push('What are the key patterns and trends in this data?');
    questions.push('Which variables show the strongest correlations?');
    questions.push('Are there any notable outliers or anomalies?');
    questions.push('What insights can be derived from the data distribution?');
    questions.push('How has the data changed over time?');
  }
  
  return questions.slice(0, 8);
}

async function generateTechnicalNotes$1(records, columns, columnTypes) {
  const notes = [];
  
  // Check for skewed distributions
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  
  for (const col of numericColumns) {
    const values = records.map(r => r[col]).filter(v => typeof v === 'number');
    if (values.length > 0) {
      const dist = await analyzeDistribution(values);
      if (Math.abs(dist.skewness) > 2) {
        notes.push(`Log transformation recommended for ${col} (heavy ${dist.skewness > 0 ? 'right' : 'left'} skew)`);
      }
    }
  }
  
  return notes;
}

/**
 * EDA Summary Extractor
 * Extracts key findings from comprehensive EDA analysis for LLM context
 */

function extractEdaSummary(edaResults, options = {}) {
  const summary = {
    keyFindings: [],
    criticalInsights: [],
    metrics: {},
    patterns: [],
    correlations: []
  };

  // Extract top statistical insights
  if (edaResults.statisticalInsights && Array.isArray(edaResults.statisticalInsights) && edaResults.statisticalInsights.length > 0) {
    const topInsights = edaResults.statisticalInsights
      .filter(insight => insight && (insight.importance === 'high' || insight.significance > 0.8))
      .slice(0, 3);
    
    summary.keyFindings.push(...topInsights.map(insight => ({
      type: 'statistical',
      finding: insight.finding,
      impact: insight.businessImpact || 'Data characteristic identified',
      confidence: insight.confidence || 0.9
    })));
  }

  // Extract critical data quality issues
  if (edaResults.dataQuality) {
    const criticalQuality = Object.entries(edaResults.dataQuality)
      .filter(([metric, value]) => {
        if (metric === 'completeness' && value < 0.8) return true;
        if (metric === 'duplicateRows' && value > 0.05) return true;
        if (metric === 'outlierPercentage' && value > 0.1) return true;
        return false;
      })
      .map(([metric, value]) => ({
        type: 'quality',
        finding: formatQualityIssue(metric, value),
        impact: getQualityImpact(metric),
        confidence: 1.0
      }));
    
    summary.criticalInsights.push(...criticalQuality);
  }

  // Extract significant correlations
  if (edaResults.correlations && Array.isArray(edaResults.correlations) && edaResults.correlations.length > 0) {
    const significantCorrelations = edaResults.correlations
      .filter(corr => corr && corr.value && Math.abs(corr.value) > 0.5)
      .sort((a, b) => Math.abs(b.value || 0) - Math.abs(a.value || 0))
      .slice(0, 3)
      .map(corr => ({
        columns: [corr.column1, corr.column2],
        strength: Math.abs(corr.value),
        direction: corr.value > 0 ? 'positive' : 'negative',
        businessMeaning: inferCorrelationMeaning(corr)
      }));
    
    summary.correlations = significantCorrelations;
  }

  // Extract distribution patterns
  if (edaResults.distributions && Array.isArray(edaResults.distributions) && edaResults.distributions.length > 0) {
    const notableDistributions = edaResults.distributions
      .filter(dist => dist && (dist.skewness > 2 || dist.kurtosis > 7 || dist.bimodal))
      .slice(0, 3)
      .map(dist => ({
        column: dist.column,
        pattern: describeDistribution(dist),
        recommendation: getDistributionRecommendation(dist)
      }));
    
    summary.patterns.push(...notableDistributions.map(dist => ({
      type: 'distribution',
      finding: dist.pattern,
      impact: dist.recommendation,
      confidence: 0.95
    })));
  }

  // Extract time series patterns
  if (edaResults.timeSeries) {
    const timePatterns = [];
    
    if (edaResults.timeSeries.trend) {
      timePatterns.push({
        type: 'trend',
        finding: `${edaResults.timeSeries.trend.direction} trend detected with ${edaResults.timeSeries.trend.strength} strength`,
        impact: edaResults.timeSeries.trend.growthRate ? 
          `${(edaResults.timeSeries.trend.growthRate * 100).toFixed(1)}% growth rate` : 
          'Systematic change over time',
        confidence: edaResults.timeSeries.trend.confidence || 0.85
      });
    }
    
    if (edaResults.timeSeries.seasonality) {
      timePatterns.push({
        type: 'seasonality',
        finding: `${edaResults.timeSeries.seasonality.type} seasonality with peak in ${edaResults.timeSeries.seasonality.peak}`,
        impact: `${edaResults.timeSeries.seasonality.amplitude}% variation from baseline`,
        confidence: edaResults.timeSeries.seasonality.confidence || 0.9
      });
    }
    
    summary.patterns.push(...timePatterns);
  }

  // Extract key metrics for summary statistics
  if (edaResults.summaryStats) {
    // Only include the most business-relevant metrics
    const relevantColumns = identifyBusinessMetrics(edaResults.columns || []);
    
    relevantColumns.forEach(col => {
      if (edaResults.summaryStats[col]) {
        const stats = edaResults.summaryStats[col];
        summary.metrics[col] = {
          total: stats.sum,
          average: stats.mean,
          median: stats.median,
          growth: stats.growthRate || null
        };
      }
    });
  }

  // ML readiness summary
  if (edaResults.mlReadiness) {
    if (edaResults.mlReadiness.overallScore < 0.7) {
      summary.criticalInsights.push({
        type: 'ml_readiness',
        finding: `Low ML readiness score: ${(edaResults.mlReadiness.overallScore * 100).toFixed(0)}%`,
        impact: edaResults.mlReadiness.majorIssues ? edaResults.mlReadiness.majorIssues.join(', ') : 'Data preparation needed',
        confidence: 0.95
      });
    }
  }

  return summary;
}

function formatQualityIssue(metric, value) {
  switch (metric) {
    case 'completeness':
      return `Only ${(value * 100).toFixed(1)}% data completeness`;
    case 'duplicateRows':
      return `${(value * 100).toFixed(1)}% duplicate records detected`;
    case 'outlierPercentage':
      return `${(value * 100).toFixed(1)}% outliers found in numeric data`;
    default:
      return `${metric}: ${value}`;
  }
}

function getQualityImpact(metric, value) {
  switch (metric) {
    case 'completeness':
      return 'May affect analysis accuracy and model performance';
    case 'duplicateRows':
      return 'Inflated metrics and biased analysis results';
    case 'outlierPercentage':
      return 'Potential data quality issues or genuine anomalies to investigate';
    default:
      return 'Data quality concern';
  }
}

function inferCorrelationMeaning(correlation) {
  const col1 = correlation.column1.toLowerCase();
  const col2 = correlation.column2.toLowerCase();
  const strength = Math.abs(correlation.value);
  
  // Price/revenue correlations
  if ((col1.includes('price') && col2.includes('quantity')) ||
      (col2.includes('price') && col1.includes('quantity'))) {
    return correlation.value < 0 ? 
      'Price elasticity detected - higher prices reduce demand' :
      'Unusual positive price-quantity relationship';
  }
  
  // Customer behavior
  if ((col1.includes('age') && col2.includes('spend')) ||
      (col2.includes('age') && col1.includes('spend'))) {
    return correlation.value > 0 ?
      'Older customers tend to spend more' :
      'Younger customers are higher spenders';
  }
  
  // Time-based correlations
  if (col1.includes('time') || col2.includes('time') || 
      col1.includes('duration') || col2.includes('duration')) {
    return 'Time-dependent relationship detected';
  }
  
  // Generic interpretation
  if (strength > 0.8) {
    return 'Strong predictive relationship';
  } else if (strength > 0.6) {
    return 'Moderate relationship worth investigating';
  } else {
    return 'Meaningful correlation detected';
  }
}

function describeDistribution(dist) {
  const descriptions = [];
  
  if (dist.bimodal) {
    descriptions.push('Bimodal distribution suggesting two distinct groups');
  }
  
  if (dist.skewness > 2) {
    descriptions.push(`Heavy right skew (${dist.skewness.toFixed(1)})`);
  } else if (dist.skewness < -2) {
    descriptions.push(`Heavy left skew (${dist.skewness.toFixed(1)})`);
  }
  
  if (dist.kurtosis > 7) {
    descriptions.push('Extreme outliers present');
  }
  
  if (dist.zeroinflated) {
    descriptions.push(`${(dist.zeroPercentage * 100).toFixed(0)}% zero values`);
  }
  
  return descriptions.join(', ') || 'Non-normal distribution';
}

function getDistributionRecommendation(dist) {
  if (dist.bimodal) {
    return 'Consider segmentation analysis to identify groups';
  }
  
  if (Math.abs(dist.skewness) > 2) {
    return 'Log transformation recommended for modeling';
  }
  
  if (dist.kurtosis > 7) {
    return 'Outlier treatment required before analysis';
  }
  
  if (dist.zeroinflated) {
    return 'Consider zero-inflated models or separate zero analysis';
  }
  
  return 'May require transformation for parametric analysis';
}

function identifyBusinessMetrics(columns) {
  if (!columns || !Array.isArray(columns)) return [];
  
  const businessKeywords = [
    'revenue', 'sales', 'amount', 'total', 'price',
    'cost', 'profit', 'margin', 'quantity', 'count',
    'value', 'payment', 'balance', 'spend'
  ];
  
  return columns.filter(col => {
    if (!col || typeof col !== 'string') return false;
    const colLower = col.toLowerCase();
    return businessKeywords.some(keyword => colLower.includes(keyword));
  }).slice(0, 5); // Limit to top 5 business metrics
}

/**
 * INT (Data Integrity) Summary Extractor
 * Extracts critical data quality issues and validation insights for LLM context
 */

function extractIntSummary(intResults, options = {}) {
  const summary = {
    criticalIssues: [],
    businessRules: [],
    automatedFixes: [],
    qualityScore: null,
    validationFailures: []
  };

  // Extract overall quality score
  if (intResults.overallQuality) {
    summary.qualityScore = {
      score: intResults.overallQuality.score,
      grade: intResults.overallQuality.grade,
      trend: intResults.overallQuality.trend || 'stable'
    };
  }

  // Extract critical data quality issues
  const validationResults = Array.isArray(intResults.validationResults) ? 
    intResults.validationResults : 
    (intResults.validationResults ? [intResults.validationResults] : []);
    
  if (validationResults && validationResults.length > 0) {
    const criticalValidations = validationResults
      .filter(v => v && (v.severity === 'critical' || v.failureRate > 0.1))
      .sort((a, b) => (b.recordsAffected || 0) - (a.recordsAffected || 0))
      .slice(0, 5);
    
    summary.criticalIssues.push(...criticalValidations.map(validation => ({
      type: validation.type,
      column: validation.column,
      issue: validation.description,
      impact: formatImpact(validation),
      fixAvailable: validation.autoFixAvailable || false,
      confidence: validation.confidence || 0.95
    })));
  }

  // Extract detected business rules
  const businessRules = Array.isArray(intResults.businessRules) ? 
    intResults.businessRules : 
    (intResults.businessRules ? [intResults.businessRules] : []);
    
  if (businessRules && businessRules.length > 0) {
    const highConfidenceRules = businessRules
      .filter(rule => rule && (rule.confidence || 0) > 0.95)
      .slice(0, 5)
      .map(rule => ({
        rule: rule.description,
        type: rule.type,
        columns: rule.columns,
        violations: rule.violations || 0,
        confidence: rule.confidence
      }));
    
    summary.businessRules = highConfidenceRules;
  }

  // Extract referential integrity issues
  if (intResults.referentialIntegrity && Array.isArray(intResults.referentialIntegrity)) {
    const orphanedRecords = intResults.referentialIntegrity
      .filter(ref => ref && ref.orphanedCount > 0)
      .map(ref => ({
        type: 'referential_integrity',
        column: ref.foreignKey,
        issue: `${ref.orphanedCount} orphaned records without matching ${ref.referencedTable}`,
        impact: `${((ref.orphanedCount / ref.totalRecords) * 100).toFixed(1)}% of data has invalid references`,
        fixAvailable: true,
        confidence: 1.0
      }));
    
    summary.criticalIssues.push(...orphanedRecords);
  }

  // Extract pattern anomalies - handle both array and object formats
  const patternAnomalies = Array.isArray(intResults.patternAnomalies) ? 
    intResults.patternAnomalies : 
    (intResults.patternAnomalies ? [intResults.patternAnomalies] : []);
    
  if (patternAnomalies && patternAnomalies.length > 0) {
    const significantAnomalies = patternAnomalies
      .filter(anomaly => anomaly && (anomaly.severity === 'high' || anomaly.count > 100))
      .slice(0, 3)
      .map(anomaly => ({
        type: 'pattern_anomaly',
        column: anomaly.column,
        issue: anomaly.description || anomaly.issue,
        impact: `${anomaly.count || 0} records deviate from expected pattern`,
        fixAvailable: anomaly.suggestedFix ? true : false,
        confidence: anomaly.confidence || 0.9
      }));
    
    summary.criticalIssues.push(...significantAnomalies);
  }

  // Extract automated fixes available
  const suggestedFixes = Array.isArray(intResults.suggestedFixes) ? 
    intResults.suggestedFixes : 
    (intResults.suggestedFixes ? [intResults.suggestedFixes] : []);
    
  if (suggestedFixes && suggestedFixes.length > 0) {
    const automatedFixes = suggestedFixes
      .filter(fix => fix && fix.automatable && (fix.confidence || 0) > 0.9)
      .slice(0, 5)
      .map(fix => ({
        issue: fix.issue,
        fix: fix.description,
        recordsAffected: fix.recordsAffected,
        estimatedImprovement: fix.qualityImprovement || 'Unknown',
        sqlSnippet: fix.sqlSnippet || null,
        pythonSnippet: fix.pythonSnippet || null
      }));
    
    summary.automatedFixes = automatedFixes;
  }

  // Extract validation dimension failures
  if (intResults.dimensions) {
    const dimensions = ['completeness', 'accuracy', 'consistency', 'validity', 'uniqueness', 'timeliness'];
    
    dimensions.forEach(dimension => {
      if (intResults.dimensions[dimension]) {
        const dimResult = intResults.dimensions[dimension];
        
        if (dimResult.score < 0.8) {
          summary.validationFailures.push({
            dimension,
            score: dimResult.score,
            mainIssue: dimResult.primaryIssue || `Low ${dimension} score`,
            affectedColumns: dimResult.affectedColumns || [],
            recommendation: getdimensionRecommendation(dimension, dimResult)
          });
        }
      }
    });
  }

  // Australian-specific validations
  if (intResults.australianValidation) {
    const auIssues = [];
    
    if (intResults.australianValidation.invalidPostcodes > 0) {
      auIssues.push({
        type: 'australian_format',
        column: 'postcode',
        issue: `${intResults.australianValidation.invalidPostcodes} invalid Australian postcodes`,
        impact: 'Geographic analysis and shipping calculations affected',
        fixAvailable: true,
        confidence: 1.0
      });
    }
    
    if (intResults.australianValidation.invalidPhones > 0) {
      auIssues.push({
        type: 'australian_format',
        column: 'phone',
        issue: `${intResults.australianValidation.invalidPhones} invalid Australian phone numbers`,
        impact: 'Customer contact data compromised',
        fixAvailable: true,
        confidence: 1.0
      });
    }
    
    summary.criticalIssues.push(...auIssues);
  }

  return summary;
}

function formatImpact(validation) {
  const percentAffected = (validation.recordsAffected / validation.totalRecords) * 100;
  
  if (validation.businessImpact) {
    return validation.businessImpact;
  }
  
  // Generate impact based on validation type
  switch (validation.type) {
    case 'missing_values':
      return `${percentAffected.toFixed(1)}% incomplete data affecting analysis accuracy`;
    
    case 'duplicate_keys':
      return `${validation.recordsAffected} duplicate records inflating metrics`;
    
    case 'referential_integrity':
      return `${percentAffected.toFixed(1)}% orphaned records breaking relationships`;
    
    case 'format_violation':
      return `${validation.recordsAffected} records with invalid format preventing processing`;
    
    case 'business_rule_violation':
      return `${percentAffected.toFixed(1)}% of data violates business constraints`;
    
    case 'outlier':
      return `${validation.recordsAffected} extreme values skewing analysis`;
    
    case 'consistency':
      return `Data inconsistency affecting ${percentAffected.toFixed(1)}% of records`;
    
    default:
      return `${percentAffected.toFixed(1)}% of records affected`;
  }
}

function getdimensionRecommendation(dimension, result) {
  const recommendations = {
    completeness: 'Implement data collection validation and mandatory field enforcement',
    accuracy: 'Add input validation rules and automated correction procedures',
    consistency: 'Standardize data formats and implement consistency checks',
    validity: 'Define clear validation rules and rejection criteria',
    uniqueness: 'Add unique constraints and duplicate detection processes',
    timeliness: 'Implement data freshness monitoring and update schedules'
  };
  
  if (result.specificRecommendation) {
    return result.specificRecommendation;
  }
  
  return recommendations[dimension] || 'Review and improve data quality processes';
}

/**
 * VIS (Visualization) Summary Extractor
 * Extracts top visualization recommendations and insights for LLM context
 */

function extractVisSummary(visResults, options = {}) {
  const summary = {
    topVisualizations: [],
    dashboardLayout: null,
    antiPatterns: [],
    interactiveFeatures: []
  };

  // Extract top 3 visualization recommendations
  if (visResults.recommendations && Array.isArray(visResults.recommendations) && visResults.recommendations.length > 0) {
    const topRecs = visResults.recommendations
      .filter(rec => rec && rec.score !== undefined)
      .sort((a, b) => (b.score || 0) - (a.score || 0))
      .slice(0, 3)
      .map(rec => ({
        type: rec.chartType,
        purpose: rec.analyticalTask,
        dataCoverage: rec.columns,
        insight: rec.expectedInsight,
        implementation: formatImplementationNotes(rec)
      }));
    
    summary.topVisualizations = topRecs;
  }

  // Extract primary dashboard layout recommendation
  if (visResults.dashboardRecommendation) {
    const dash = visResults.dashboardRecommendation;
    summary.dashboardLayout = {
      primaryView: dash.mainVisualization,
      supportingViews: dash.supportingVisualizations && Array.isArray(dash.supportingVisualizations) ? dash.supportingVisualizations.slice(0, 3) : [],
      keyMetrics: dash.kpiCards || [],
      interactivity: dash.interactiveElements || [],
      flow: dash.analyticalFlow || 'overview-to-detail'
    };
  }

  // Extract critical anti-patterns to avoid
  if (visResults.antiPatterns && Array.isArray(visResults.antiPatterns) && visResults.antiPatterns.length > 0) {
    const criticalAntiPatterns = visResults.antiPatterns
      .filter(ap => ap && (ap.severity === 'high' || ap.commonMistake))
      .slice(0, 3)
      .map(ap => ({
        pattern: ap.name,
        issue: ap.description,
        alternative: ap.recommendation,
        example: ap.example || null
      }));
    
    summary.antiPatterns = criticalAntiPatterns;
  }

  // Extract task-specific visualizations
  if (visResults.taskAnalysis) {
    const taskVis = condensetaskVisualizations(visResults.taskAnalysis);
    
    // Merge task-specific recommendations with general ones
    summary.topVisualizations = mergeVisualizations(
      summary.topVisualizations,
      taskVis
    );
  }

  // Extract accessibility and perceptual considerations
  if (visResults.perceptualAnalysis) {
    const perceptual = visResults.perceptualAnalysis;
    
    if (perceptual.colorPalette) {
      summary.colorGuidance = {
        palette: perceptual.colorPalette.name,
        type: perceptual.colorPalette.type,
        accessibility: perceptual.colorPalette.colorblindSafe ? 'Safe' : 'Review needed'
      };
    }
    
    if (perceptual.warnings && Array.isArray(perceptual.warnings) && perceptual.warnings.length > 0) {
      summary.perceptualWarnings = perceptual.warnings.slice(0, 2);
    }
  }

  // Extract multivariate pattern visualizations
  if (visResults.multivariatePatterns && Array.isArray(visResults.multivariatePatterns) && visResults.multivariatePatterns.length > 0) {
    const mvPatterns = visResults.multivariatePatterns
      .filter(pattern => pattern && pattern.strength > 0.7)
      .slice(0, 2)
      .map(pattern => ({
        type: getMultivariateVizType(pattern),
        purpose: `Explore ${pattern.type} relationship`,
        dataCoverage: pattern.variables,
        insight: pattern.interpretation,
        implementation: `Use ${pattern.technique} to reveal ${pattern.pattern}`
      }));
    
    summary.topVisualizations.push(...mvPatterns);
  }

  // Extract interactive features for exploration
  if (visResults.interactiveRecommendations) {
    summary.interactiveFeatures = visResults.interactiveRecommendations
      .filter(feature => feature.importance === 'high')
      .slice(0, 3)
      .map(feature => ({
        feature: feature.name,
        purpose: feature.purpose,
        userBenefit: feature.benefit
      }));
  }

  // Limit to top 3 visualizations after all sources
  summary.topVisualizations = summary.topVisualizations.slice(0, 3);

  return summary;
}

function formatImplementationNotes(recommendation) {
  const notes = [];
  
  // Chart type specific guidance
  switch (recommendation.chartType) {
    case 'time_series':
      notes.push('Include trend line and anomaly highlighting');
      break;
    case 'scatter':
      notes.push('Add regression line and confidence intervals');
      break;
    case 'heatmap':
      notes.push('Use diverging color scheme for correlations');
      break;
    case 'sankey':
      notes.push('Order nodes by flow volume for clarity');
      break;
    case 'treemap':
      notes.push('Use hierarchical coloring for categories');
      break;
  }
  
  // Data considerations
  if (recommendation.dataTransformation) {
    notes.push(recommendation.dataTransformation);
  }
  
  // Scale considerations
  if (recommendation.scaleType) {
    notes.push(`Use ${recommendation.scaleType} scale`);
  }
  
  return notes.join('. ');
}

function condensetaskVisualizations(taskAnalysis) {
  const taskVis = [];
  
  // Comparison tasks
  if (taskAnalysis.comparison && taskAnalysis.comparison.score > 0.8) {
    taskVis.push({
      type: taskAnalysis.comparison.bestChart,
      purpose: 'Compare values across categories',
      dataCoverage: taskAnalysis.comparison.dimensions,
      insight: 'Relative differences and rankings',
      implementation: 'Sort by value for easier comparison'
    });
  }
  
  // Trend analysis
  if (taskAnalysis.trend && taskAnalysis.trend.hasTimeSeries) {
    taskVis.push({
      type: 'time_series_with_forecast',
      purpose: 'Analyze trends and patterns over time',
      dataCoverage: [taskAnalysis.trend.timeColumn, ...taskAnalysis.trend.metrics],
      insight: taskAnalysis.trend.pattern || 'Temporal patterns',
      implementation: 'Include moving average and seasonality decomposition'
    });
  }
  
  // Distribution analysis
  if (taskAnalysis.distribution && taskAnalysis.distribution.interestingDists > 0) {
    taskVis.push({
      type: taskAnalysis.distribution.recommendedChart,
      purpose: 'Understand data distribution and outliers',
      dataCoverage: taskAnalysis.distribution.columns,
      insight: 'Skewness, modes, and extreme values',
      implementation: 'Add statistical overlays (mean, median, percentiles)'
    });
  }
  
  // Relationship exploration
  if (taskAnalysis.relationship && taskAnalysis.relationship.strongRelationships > 0) {
    taskVis.push({
      type: 'scatter_matrix',
      purpose: 'Explore multivariate relationships',
      dataCoverage: taskAnalysis.relationship.keyVariables,
      insight: 'Correlations and clustering patterns',
      implementation: 'Color by categories, size by importance metric'
    });
  }
  
  return taskVis;
}

function mergeVisualizations(primary, secondary) {
  const merged = [...primary];
  const existingTypes = new Set(primary.map(v => v.type));
  
  // Add non-duplicate visualizations from secondary
  secondary.forEach(vis => {
    if (!existingTypes.has(vis.type) && merged.length < 5) {
      merged.push(vis);
      existingTypes.add(vis.type);
    }
  });
  
  return merged;
}

function getMultivariateVizType(pattern) {
  switch (pattern.type) {
    case 'cluster':
      return 'scatter_plot_with_clustering';
    case 'correlation_network':
      return 'network_diagram';
    case 'dimensional_reduction':
      return 'pca_biplot';
    case 'hierarchical':
      return 'dendrogram';
    case 'flow':
      return 'sankey_diagram';
    default:
      return 'parallel_coordinates';
  }
}

/**
 * ENG (Data Engineering) Summary Extractor
 * Extracts critical engineering insights and schema recommendations for LLM context
 */

function extractEngSummary(engResults, options = {}) {
  const summary = {
    schemaRecommendation: null,
    performanceConsiderations: [],
    etlRequirements: [],
    technicalDebt: [],
    relationships: []
  };

  // Extract primary schema recommendation
  if (engResults.schemaRecommendations) {
    const topSchema = engResults.schemaRecommendations[0];
    summary.schemaRecommendation = {
      approach: topSchema.type,
      rationale: topSchema.rationale,
      keyTables: formatKeyTables(topSchema.tables),
      complexity: topSchema.complexity || 'moderate'
    };
  }

  // Extract critical performance considerations
  if (engResults.performanceAnalysis) {
    const perf = engResults.performanceAnalysis;
    const criticalConsiderations = [];
    
    if (perf.dataVolume > 1000000) {
      criticalConsiderations.push({
        aspect: 'Data Volume',
        issue: `${(perf.dataVolume / 1000000).toFixed(1)}M records require partitioning`,
        recommendation: perf.partitioningStrategy || 'Partition by date or key dimension'
      });
    }
    
    if (perf.queryPatterns) {
      const hotPaths = perf.queryPatterns.filter(p => p.frequency === 'high');
      if (hotPaths.length > 0) {
        criticalConsiderations.push({
          aspect: 'Query Optimization',
          issue: `${hotPaths.length} high-frequency query patterns identified`,
          recommendation: 'Create indexes on: ' + hotPaths.map(p => p.columns.join(', ')).join('; ')
        });
      }
    }
    
    if (perf.joinComplexity === 'high') {
      criticalConsiderations.push({
        aspect: 'Join Performance',
        issue: 'Multiple large table joins detected',
        recommendation: 'Consider materialized views or denormalization for critical paths'
      });
    }
    
    summary.performanceConsiderations = criticalConsiderations.slice(0, 3);
  }

  // Extract key ETL requirements
  if (engResults.etlAnalysis) {
    const etl = engResults.etlAnalysis;
    const keyRequirements = [];
    
    if (etl.dataQualityIssues && Array.isArray(etl.dataQualityIssues) && etl.dataQualityIssues.length > 0) {
      keyRequirements.push({
        stage: 'Cleansing',
        requirement: 'Data quality fixes needed',
        specifics: etl.dataQualityIssues.slice(0, 3).map(i => i && i.issue || 'Unknown issue').join(', ')
      });
    }
    
    if (etl.transformations && etl.transformations.length > 0) {
      const complexTransforms = etl.transformations.filter(t => t.complexity === 'high');
      if (complexTransforms.length > 0) {
        keyRequirements.push({
          stage: 'Transformation',
          requirement: `${complexTransforms.length} complex transformations required`,
          specifics: complexTransforms[0].description
        });
      }
    }
    
    if (etl.incrementalStrategy) {
      keyRequirements.push({
        stage: 'Loading',
        requirement: 'Incremental load strategy',
        specifics: etl.incrementalStrategy.description
      });
    }
    
    summary.etlRequirements = keyRequirements;
  }

  // Extract technical debt insights
  if (engResults.technicalDebt && Array.isArray(engResults.technicalDebt) && engResults.technicalDebt.length > 0) {
    const criticalDebt = engResults.technicalDebt
      .filter(debt => debt && (debt.severity === 'high' || debt.impact === 'blocking'))
      .slice(0, 3)
      .map(debt => ({
        issue: debt.description,
        impact: debt.businessImpact || 'Processing efficiency reduced',
        effort: debt.estimatedEffort || 'medium',
        priority: debt.priority || 'high'
      }));
    
    summary.technicalDebt = criticalDebt;
  }

  // Extract discovered relationships
  if (engResults.relationships && Array.isArray(engResults.relationships) && engResults.relationships.length > 0) {
    const strongRelationships = engResults.relationships
      .filter(rel => rel && rel.confidence > 0.9)
      .slice(0, 5)
      .map(rel => ({
        type: rel.type,
        from: rel.sourceTable || rel.sourceColumn,
        to: rel.targetTable || rel.targetColumn,
        cardinality: rel.cardinality || 'many-to-one',
        strength: rel.confidence
      }));
    
    summary.relationships = strongRelationships;
  }

  // Extract warehouse-specific insights if available
  if (engResults.warehouseKnowledge) {
    const knowledge = engResults.warehouseKnowledge;
    
    if (knowledge.tableClassification) {
      summary.tableClassification = {
        factTables: knowledge.tableClassification.facts || [],
        dimensions: knowledge.tableClassification.dimensions || [],
        bridges: knowledge.tableClassification.bridges || []
      };
    }
    
    if (knowledge.commonPatterns && Array.isArray(knowledge.commonPatterns) && knowledge.commonPatterns.length > 0) {
      summary.patterns = knowledge.commonPatterns
        .slice(0, 3)
        .map(p => ({
          pattern: p.name,
          description: p.description,
          recommendation: p.recommendation
        }));
    }
  }

  return summary;
}

function formatKeyTables(tables) {
  if (!tables || tables.length === 0) return [];
  
  return tables.slice(0, 5).map(table => ({
    name: table.name,
    type: table.type || inferTableType(table),
    keyColumns: table.keyColumns || [],
    recordCount: table.estimatedRows || 'unknown'
  }));
}

function inferTableType(table) {
  const name = table.name.toLowerCase();
  
  // Fact table patterns
  if (name.includes('fact') || name.includes('transaction') || 
      name.includes('event') || name.includes('sales')) {
    return 'fact';
  }
  
  // Dimension patterns
  if (name.includes('dim') || name.includes('customer') || 
      name.includes('product') || name.includes('location') ||
      name.includes('date') || name.includes('time')) {
    return 'dimension';
  }
  
  // Bridge/junction patterns
  if (name.includes('bridge') || name.includes('link') || 
      name.includes('xref') || name.includes('mapping')) {
    return 'bridge';
  }
  
  // Staging patterns
  if (name.includes('stg') || name.includes('staging') || 
      name.includes('temp') || name.includes('load')) {
    return 'staging';
  }
  
  return 'operational';
}

/**
 * Insight Synthesizer
 * Connects findings across EDA, INT, VIS, and ENG analyses to create unified insights
 */

function synthesizeInsights(edaSummary, intSummary, visSummary, engSummary) {
  const synthesized = {
    connectedInsights: [],
    crossAnalysisPatterns: [],
    unifiedRecommendations: [],
    criticalPath: []
  };

  // Connect statistical patterns with quality issues
  connectStatisticalAndQuality(edaSummary, intSummary, synthesized);

  // Connect visualization needs with data characteristics
  connectVisualizationAndData(visSummary, edaSummary, intSummary, synthesized);

  // Connect engineering requirements with quality and volume
  connectEngineeringAndOperational(engSummary, intSummary, edaSummary, synthesized);

  // Identify cross-cutting patterns
  identifyCrossCuttingPatterns(edaSummary, intSummary, visSummary, engSummary, synthesized);

  // Generate unified recommendations
  generateUnifiedRecommendations(synthesized, edaSummary, intSummary, visSummary, engSummary);

  // Determine critical path for improvements
  determineCriticalPath(synthesized, intSummary);

  return synthesized;
}

function connectStatisticalAndQuality(eda, int, synthesized) {
  // Connect outliers with data quality
  if (eda.patterns && int.criticalIssues) {
    eda.patterns.forEach(pattern => {
      if (pattern.type === 'distribution' && pattern.finding.includes('outliers')) {
        const relatedQuality = int.criticalIssues.find(issue => 
          issue.type === 'outlier' || issue.type === 'pattern_anomaly'
        );
        
        if (relatedQuality) {
          synthesized.connectedInsights.push({
            insight: `Statistical outliers in ${pattern.finding} are confirmed as data quality issues`,
            impact: 'high',
            action: relatedQuality.fixAvailable ? 
              'Automated fix available for outlier treatment' : 
              'Manual review required for outlier handling',
            confidence: Math.min(pattern.confidence, relatedQuality.confidence)
          });
        }
      }
    });
  }

  // Connect missing data patterns with completeness issues
  if (eda.metrics && int.validationFailures) {
    const completenessFailure = int.validationFailures.find(f => f.dimension === 'completeness');
    
    if (completenessFailure && completenessFailure.score < 0.8) {
      const affectedMetrics = Object.entries(eda.metrics)
        .filter(([col, stats]) => completenessFailure.affectedColumns.includes(col))
        .map(([col]) => col);
      
      if (affectedMetrics.length > 0) {
        synthesized.connectedInsights.push({
          insight: `Low completeness (${(completenessFailure.score * 100).toFixed(0)}%) affects key business metrics: ${affectedMetrics.join(', ')}`,
          impact: 'critical',
          action: 'Prioritize data collection for these business-critical fields',
          confidence: 0.95
        });
      }
    }
  }

  // Connect correlations with referential integrity
  if (eda.correlations && int.criticalIssues) {
    eda.correlations.forEach(corr => {
      const integrityIssue = int.criticalIssues.find(issue => 
        issue.type === 'referential_integrity' &&
        (issue.column === corr.columns[0] || issue.column === corr.columns[1])
      );
      
      if (integrityIssue) {
        synthesized.connectedInsights.push({
          insight: `Strong ${corr.direction} correlation between ${corr.columns.join(' and ')} compromised by ${integrityIssue.issue}`,
          impact: 'high',
          action: 'Fix referential integrity before correlation-based analysis',
          confidence: 0.9
        });
      }
    });
  }
}

function connectVisualizationAndData(vis, eda, int, synthesized) {
  // Connect visualization recommendations with data quality
  if (vis.topVisualizations && int.qualityScore) {
    vis.topVisualizations.forEach(viz => {
      if (int.qualityScore.score < 0.8) {
        const qualityWarning = {
          insight: `${viz.type} visualization recommended but data quality score is ${int.qualityScore.grade}`,
          impact: 'medium',
          action: 'Address data quality issues before creating production visualizations',
          confidence: 0.85
        };
        
        // Check if specific columns have issues
        const vizColumns = Array.isArray(viz.dataCoverage) ? viz.dataCoverage : [viz.dataCoverage];
        const columnIssues = int.criticalIssues.filter(issue => 
          vizColumns.includes(issue.column)
        );
        
        if (columnIssues.length > 0) {
          qualityWarning.impact = 'high';
          qualityWarning.action = `Fix ${columnIssues[0].issue} before implementing ${viz.type}`;
        }
        
        synthesized.connectedInsights.push(qualityWarning);
      }
    });
  }

  // Connect time series visualizations with seasonality patterns
  if (vis.topVisualizations && eda.patterns) {
    const timeSeriesViz = vis.topVisualizations.find(v => v.type.includes('time_series'));
    const seasonalityPattern = eda.patterns.find(p => p.type === 'seasonality');
    
    if (timeSeriesViz && seasonalityPattern) {
      synthesized.connectedInsights.push({
        insight: `Time series visualization aligns with detected ${seasonalityPattern.finding}`,
        impact: 'medium',
        action: `Include ${seasonalityPattern.finding.toLowerCase()} in visualization annotations`,
        confidence: 0.9
      });
    }
  }

  // Connect distribution visualizations with skewness
  const distributionViz = vis.topVisualizations.find(v => 
    v.purpose.toLowerCase().includes('distribution')
  );
  const skewedDistribution = eda.patterns.find(p => 
    p.type === 'distribution' && p.finding.includes('skew')
  );
  
  if (distributionViz && skewedDistribution) {
    synthesized.connectedInsights.push({
      insight: `Distribution visualization should account for ${skewedDistribution.finding}`,
      impact: 'medium',
      action: skewedDistribution.impact || 'Consider log scale or transformation in visualization',
      confidence: 0.85
    });
  }
}

function connectEngineeringAndOperational(eng, int, eda, synthesized) {
  // Connect schema recommendations with data volume
  if (eng.schemaRecommendation && eda.metrics) {
    const totalRecords = Object.values(eda.metrics)[0]?.recordCount || 0;
    
    if (totalRecords > 1000000 && eng.schemaRecommendation.approach !== 'star_schema') {
      synthesized.connectedInsights.push({
        insight: `${eng.schemaRecommendation.approach} schema with ${(totalRecords/1000000).toFixed(1)}M records may need optimization`,
        impact: 'high',
        action: 'Consider star schema or partitioning strategy for better performance',
        confidence: 0.8
      });
    }
  }

  // Connect ETL requirements with data quality fixes
  if (eng.etlRequirements && int.automatedFixes) {
    const cleansingETL = eng.etlRequirements.find(req => req.stage === 'Cleansing');
    
    if (cleansingETL && int.automatedFixes && Array.isArray(int.automatedFixes) && int.automatedFixes.length > 0) {
      synthesized.connectedInsights.push({
        insight: `ETL cleansing stage can implement ${int.automatedFixes.length} automated data quality fixes`,
        impact: 'high',
        action: `Integrate fixes into ETL pipeline: ${(int.automatedFixes && Array.isArray(int.automatedFixes) && int.automatedFixes.length > 0) ? int.automatedFixes.slice(0, 2).map(f => f.fix).join(', ') : 'Available via data integrity analysis'}`,
        confidence: 0.95
      });
    }
  }

  // Connect performance considerations with correlations
  if (eng.performanceConsiderations && eda.correlations) {
    const indexingRec = eng.performanceConsiderations.find(p => 
      p.aspect === 'Query Optimization'
    );
    
    if (indexingRec && eda.correlations.length > 0) {
      const correlatedColumns = new Set();
      eda.correlations.forEach(corr => {
        correlatedColumns.add(corr.columns[0]);
        correlatedColumns.add(corr.columns[1]);
      });
      
      synthesized.connectedInsights.push({
        insight: 'Highly correlated columns should be considered for composite indexes',
        impact: 'medium',
        action: `Create composite indexes on correlated pairs: ${Array.from(correlatedColumns).slice(0, 4).join(', ')}`,
        confidence: 0.75
      });
    }
  }
}

function identifyCrossCuttingPatterns(eda, int, vis, eng, synthesized) {
  const patterns = [];

  // Pattern: Rapid growth with quality degradation
  if (eda.patterns && int.qualityScore) {
    const growthPattern = eda.patterns.find(p => 
      p.type === 'trend' && p.finding.includes('growth')
    );
    
    if (growthPattern && int.qualityScore.score < 0.85) {
      patterns.push({
        pattern: 'Growth-Quality Trade-off',
        description: `${growthPattern.finding} coincides with ${int.qualityScore.grade} data quality`,
        implication: 'Rapid growth may be compromising data collection standards',
        recommendation: 'Implement stricter validation during high-growth periods'
      });
    }
  }

  // Pattern: Segmentation opportunity with visualization
  if (eda.patterns && vis.topVisualizations) {
    const segmentPattern = eda.keyFindings?.find(f => 
      f.finding.toLowerCase().includes('segment') || 
      f.finding.toLowerCase().includes('group')
    );
    
    const segmentViz = vis.topVisualizations.find(v => 
      v.type.includes('cluster') || v.type.includes('scatter')
    );
    
    if (segmentPattern && segmentViz) {
      patterns.push({
        pattern: 'Segmentation Opportunity',
        description: 'Natural customer segments detected with visualization support',
        implication: segmentPattern.finding,
        recommendation: `Use ${segmentViz.type} to explore and validate segments`
      });
    }
  }

  // Pattern: Complex relationships requiring engineering
  if (eng.relationships && eng.relationships.length > 3) {
    const complexRelationships = eng.relationships.filter(r => 
      r.type === 'many-to-many' || r.cardinality === 'many-to-many'
    );
    
    if (complexRelationships.length > 0) {
      patterns.push({
        pattern: 'Complex Relationship Network',
        description: `${eng.relationships.length} relationships with ${complexRelationships.length} many-to-many connections`,
        implication: 'Data model complexity may impact query performance',
        recommendation: 'Consider bridge tables or denormalization for critical paths'
      });
    }
  }

  synthesized.crossAnalysisPatterns = patterns;
}

function generateUnifiedRecommendations(synthesized, eda, int, vis, eng) {
  const recommendations = [];
  const addedRecommendations = new Set();

  // Priority 1: Critical data quality fixes
  if (int.automatedFixes && int.automatedFixes.length > 0) {
    const topFix = int.automatedFixes[0];
    const rec = {
      priority: 1,
      category: 'Data Quality',
      action: topFix.fix,
      impact: `Improves data quality for ${topFix.recordsAffected} records`,
      effort: 'Low (automated)',
      implementation: topFix.sqlSnippet || topFix.pythonSnippet || 'See automated fix details'
    };
    
    recommendations.push(rec);
    addedRecommendations.add(rec.action);
  }

  // Priority 2: High-impact visualizations
  if (vis.topVisualizations && vis.topVisualizations.length > 0) {
    const topViz = vis.topVisualizations[0];
    const rec = {
      priority: 2,
      category: 'Visualization',
      action: `Implement ${topViz.type} for ${topViz.purpose}`,
      impact: topViz.insight,
      effort: 'Medium',
      implementation: topViz.implementation
    };
    
    if (!addedRecommendations.has(rec.action)) {
      recommendations.push(rec);
      addedRecommendations.add(rec.action);
    }
  }

  // Priority 3: Performance optimizations
  if (eng.performanceConsiderations && eng.performanceConsiderations.length > 0) {
    const topPerf = eng.performanceConsiderations[0];
    const rec = {
      priority: 3,
      category: 'Performance',
      action: topPerf.recommendation,
      impact: `Addresses: ${topPerf.issue}`,
      effort: 'Medium to High',
      implementation: 'See engineering recommendations'
    };
    
    if (!addedRecommendations.has(rec.action)) {
      recommendations.push(rec);
      addedRecommendations.add(rec.action);
    }
  }

  // Priority 4: Analytical opportunities
  const analyticalOps = [];
  
  // From correlations
  if (eda.correlations && eda.correlations.length > 0) {
    const topCorr = eda.correlations[0];
    analyticalOps.push({
      priority: 4,
      category: 'Analysis',
      action: `Investigate ${topCorr.direction} relationship between ${topCorr.columns.join(' and ')}`,
      impact: topCorr.businessMeaning,
      effort: 'Low',
      implementation: 'Statistical analysis or predictive modeling'
    });
  }

  // From patterns
  if (eda.patterns && eda.patterns.length > 0) {
    const significantPattern = eda.patterns.find(p => p.confidence > 0.9);
    if (significantPattern) {
      analyticalOps.push({
        priority: 4,
        category: 'Analysis',
        action: `Leverage ${significantPattern.type} pattern: ${significantPattern.finding}`,
        impact: significantPattern.impact,
        effort: 'Low to Medium',
        implementation: 'Time series analysis or segmentation'
      });
    }
  }

  // Add best analytical opportunity
  if (analyticalOps.length > 0 && !addedRecommendations.has(analyticalOps[0].action)) {
    recommendations.push(analyticalOps[0]);
  }

  synthesized.unifiedRecommendations = recommendations.slice(0, 5);
}

function determineCriticalPath(synthesized, intSummary) {
  const criticalPath = [];

  // Step 1: Fix critical data quality issues
  if (intSummary.qualityScore && intSummary.qualityScore.score < 0.8) {
    criticalPath.push({
      step: 1,
      action: 'Address critical data quality issues',
      reason: `Current quality score ${intSummary.qualityScore.grade} blocks accurate analysis`,
      timeframe: 'Immediate'
    });
  }

  // Step 2: Implement ETL fixes
  const etlFixes = synthesized.connectedInsights.find(i => 
    i.insight.includes('ETL') && i.impact === 'high'
  );
  
  if (etlFixes) {
    criticalPath.push({
      step: criticalPath.length + 1,
      action: 'Integrate quality fixes into ETL pipeline',
      reason: 'Prevent future quality degradation',
      timeframe: 'Week 1-2'
    });
  }

  // Step 3: Deploy key visualizations
  const vizRec = synthesized.unifiedRecommendations.find(r => 
    r.category === 'Visualization'
  );
  
  if (vizRec) {
    criticalPath.push({
      step: criticalPath.length + 1,
      action: vizRec.action,
      reason: 'Enable data-driven decision making',
      timeframe: 'Week 2-3'
    });
  }

  // Step 4: Performance optimization
  const perfRec = synthesized.unifiedRecommendations.find(r => 
    r.category === 'Performance'
  );
  
  if (perfRec) {
    criticalPath.push({
      step: criticalPath.length + 1,
      action: perfRec.action,
      reason: 'Ensure scalability for growing data',
      timeframe: 'Week 3-4'
    });
  }

  // Step 5: Advanced analytics
  const analyticsRec = synthesized.unifiedRecommendations.find(r => 
    r.category === 'Analysis'
  );
  
  if (analyticsRec) {
    criticalPath.push({
      step: criticalPath.length + 1,
      action: analyticsRec.action,
      reason: 'Extract business value from clean, optimized data',
      timeframe: 'Week 4+'
    });
  }

  synthesized.criticalPath = criticalPath;
}

/**
 * Key Finding Selector
 * Prioritizes and selects the most important findings based on impact scoring
 */

class KeyFindingSelector {
  constructor(options = {}) {
    this.maxFindings = options.maxFindings || 5;
    this.maxPatternsPerCategory = options.maxPatternsPerCategory || 2;
    this.scoringWeights = {
      businessImpact: options.businessImpactWeight || 0.3,
      dataQuality: options.dataQualityWeight || 0.25,
      actionability: options.actionabilityWeight || 0.2,
      crossAnalysis: options.crossAnalysisWeight || 0.15,
      confidence: options.confidenceWeight || 0.1
    };
  }

  selectKeyFindings(allFindings) {
    // Flatten all findings from different sources
    const flattenedFindings = this.flattenFindings(allFindings);
    
    // Score each finding
    const scoredFindings = flattenedFindings.map(finding => ({
      ...finding,
      impactScore: this.calculateImpactScore(finding)
    }));
    
    // Sort by impact score
    const sortedFindings = scoredFindings.sort((a, b) => b.impactScore - a.impactScore);
    
    // Apply diversity rules to ensure variety
    const diverseFindings = this.ensureDiversity(sortedFindings);
    
    // Return top findings
    return diverseFindings.slice(0, this.maxFindings);
  }

  flattenFindings(allFindings) {
    const flattened = [];
    
    // Extract from summaries
    ['eda', 'int', 'vis', 'eng'].forEach(source => {
      const summary = allFindings[source + 'Summary'];
      if (!summary) return;
      
      // Key findings
      if (summary.keyFindings) {
        summary.keyFindings.forEach(finding => {
          flattened.push({
            ...finding,
            source,
            category: 'key_finding'
          });
        });
      }
      
      // Critical insights
      if (summary.criticalInsights) {
        summary.criticalInsights.forEach(insight => {
          flattened.push({
            ...insight,
            source,
            category: 'critical_insight'
          });
        });
      }
      
      // Patterns
      if (summary.patterns) {
        summary.patterns.forEach(pattern => {
          flattened.push({
            ...pattern,
            source,
            category: 'pattern'
          });
        });
      }
      
      // Critical issues (INT specific)
      if (summary.criticalIssues) {
        summary.criticalIssues.forEach(issue => {
          flattened.push({
            ...issue,
            source,
            category: 'critical_issue'
          });
        });
      }
    });
    
    // Extract from synthesis
    const synthesis = allFindings.synthesis;
    if (synthesis) {
      // Connected insights get bonus for cross-analysis
      if (synthesis.connectedInsights) {
        synthesis.connectedInsights.forEach(insight => {
          flattened.push({
            ...insight,
            source: 'synthesis',
            category: 'connected_insight',
            crossAnalysis: true
          });
        });
      }
      
      // Cross-cutting patterns
      if (synthesis.crossAnalysisPatterns) {
        synthesis.crossAnalysisPatterns.forEach(pattern => {
          flattened.push({
            finding: pattern.description,
            impact: pattern.implication,
            action: pattern.recommendation,
            source: 'synthesis',
            category: 'cross_pattern',
            crossAnalysis: true,
            confidence: 0.9
          });
        });
      }
    }
    
    return flattened;
  }

  calculateImpactScore(finding) {
    let score = 0;
    
    // Business impact scoring
    score += this.scoreBusinessImpact(finding) * this.scoringWeights.businessImpact;
    
    // Data quality impact
    score += this.scoreDataQualityImpact(finding) * this.scoringWeights.dataQuality;
    
    // Actionability
    score += this.scoreActionability(finding) * this.scoringWeights.actionability;
    
    // Cross-analysis relevance
    score += this.scoreCrossAnalysisRelevance(finding) * this.scoringWeights.crossAnalysis;
    
    // Confidence
    score += (finding.confidence || 0.8) * this.scoringWeights.confidence;
    
    return score;
  }

  scoreBusinessImpact(finding) {
    let score = 0.5; // Base score
    
    // Check for revenue/cost implications
    const impactText = (finding.impact || finding.finding || '').toLowerCase();
    
    if (impactText.includes('revenue') || impactText.includes('sales')) {
      score += 0.3;
    }
    
    if (impactText.includes('cost') || impactText.includes('efficiency')) {
      score += 0.2;
    }
    
    if (impactText.includes('customer') || impactText.includes('retention')) {
      score += 0.25;
    }
    
    if (impactText.includes('risk') || impactText.includes('compliance')) {
      score += 0.25;
    }
    
    // Check for quantified impact
    const hasPercentage = /\d+(\.\d+)?%/.test(impactText);
    const hasCurrency = /\$[\d,]+/.test(impactText);
    const hasLargeNumber = /\d{4,}/.test(impactText);
    
    if (hasPercentage || hasCurrency || hasLargeNumber) {
      score += 0.2;
    }
    
    // Critical issues get high scores
    if (finding.category === 'critical_issue' || finding.category === 'critical_insight') {
      score = Math.max(score, 0.9);
    }
    
    return Math.min(score, 1.0);
  }

  scoreDataQualityImpact(finding) {
    let score = 0.3; // Base score
    
    // Quality-specific findings
    if (finding.source === 'int' || finding.type === 'quality') {
      score += 0.3;
    }
    
    // Check for quality keywords
    const text = (finding.finding || finding.issue || '').toLowerCase();
    
    if (text.includes('missing') || text.includes('incomplete')) {
      score += 0.2;
    }
    
    if (text.includes('duplicate') || text.includes('inconsistent')) {
      score += 0.2;
    }
    
    if (text.includes('invalid') || text.includes('corrupt')) {
      score += 0.3;
    }
    
    if (text.includes('outlier') || text.includes('anomaly')) {
      score += 0.15;
    }
    
    // Records affected
    if (finding.recordsAffected) {
      if (finding.recordsAffected > 1000) score += 0.2;
      if (finding.recordsAffected > 10000) score += 0.1;
    }
    
    return Math.min(score, 1.0);
  }

  scoreActionability(finding) {
    let score = 0.2; // Base score
    
    // Has specific action
    if (finding.action) {
      score += 0.3;
    }
    
    // Has automated fix
    if (finding.fixAvailable || finding.automatedFix) {
      score += 0.4;
    }
    
    // Has implementation details
    if (finding.implementation || finding.sqlSnippet || finding.pythonSnippet) {
      score += 0.2;
    }
    
    // Check for specific recommendations
    const actionText = (finding.action || finding.recommendation || '').toLowerCase();
    
    if (actionText.includes('create') || actionText.includes('implement')) {
      score += 0.1;
    }
    
    if (actionText.includes('fix') || actionText.includes('correct')) {
      score += 0.15;
    }
    
    if (actionText.includes('optimize') || actionText.includes('improve')) {
      score += 0.1;
    }
    
    // Low effort increases actionability
    if (finding.effort === 'low' || finding.effort === 'Low (automated)') {
      score += 0.2;
    }
    
    return Math.min(score, 1.0);
  }

  scoreCrossAnalysisRelevance(finding) {
    let score = 0.0;
    
    // Explicit cross-analysis flag
    if (finding.crossAnalysis) {
      score += 0.5;
    }
    
    // From synthesis
    if (finding.source === 'synthesis') {
      score += 0.3;
    }
    
    // Connected insights
    if (finding.category === 'connected_insight' || finding.category === 'cross_pattern') {
      score += 0.4;
    }
    
    // Mentions multiple analysis areas
    const text = (finding.finding || finding.insight || '').toLowerCase();
    const analysisAreas = ['statistical', 'quality', 'visualization', 'engineering', 'etl', 'schema'];
    const mentionedAreas = analysisAreas.filter(area => text.includes(area));
    
    if (mentionedAreas.length >= 2) {
      score += 0.3;
    }
    
    return Math.min(score, 1.0);
  }

  ensureDiversity(sortedFindings) {
    const selected = [];
    const categoryCounts = {};
    const sourceCounts = {};
    
    for (const finding of sortedFindings) {
      // Check category limits
      const category = finding.category || 'other';
      categoryCounts[category] = (categoryCounts[category] || 0) + 1;
      
      if (categoryCounts[category] > this.maxPatternsPerCategory) {
        continue; // Skip if we have too many from this category
      }
      
      // Check source diversity
      const source = finding.source || 'unknown';
      sourceCounts[source] = (sourceCounts[source] || 0) + 1;
      
      // Allow more from synthesis as it's cross-cutting
      const maxPerSource = source === 'synthesis' ? 3 : 2;
      
      if (sourceCounts[source] > maxPerSource) {
        continue; // Skip if we have too many from this source
      }
      
      selected.push(finding);
      
      if (selected.length >= this.maxFindings * 2) {
        break; // We have enough candidates
      }
    }
    
    return selected;
  }

  formatForPresentation(findings) {
    return findings.map((finding, index) => {
      const formatted = {
        rank: index + 1,
        title: this.generateTitle(finding),
        description: finding.finding || finding.insight || finding.issue,
        impact: finding.impact,
        action: finding.action || finding.recommendation,
        confidence: finding.confidence || 0.85,
        source: finding.source,
        category: finding.category
      };
      
      // Add additional context if available
      if (finding.fixAvailable) {
        formatted.quickWin = true;
      }
      
      if (finding.recordsAffected) {
        formatted.scope = `${finding.recordsAffected} records affected`;
      }
      
      return formatted;
    });
  }

  generateTitle(finding) {
    // Generate a concise title based on the finding type
    if (finding.type === 'quality') {
      return 'DATA QUALITY ISSUE';
    } else if (finding.type === 'statistical') {
      return 'STATISTICAL INSIGHT';
    } else if (finding.type === 'pattern_anomaly') {
      return 'PATTERN ANOMALY';
    } else if (finding.category === 'connected_insight') {
      return 'CONNECTED INSIGHT';
    } else if (finding.category === 'cross_pattern') {
      return 'CROSS-ANALYSIS PATTERN';
    } else if (finding.source === 'vis') {
      return 'VISUALIZATION OPPORTUNITY';
    } else if (finding.source === 'eng') {
      return 'ENGINEERING CONSIDERATION';
    } else {
      return finding.type?.toUpperCase() || 'KEY FINDING';
    }
  }
}

/**
 * LLM Output Formatter
 * Formats the synthesized analysis into the familiar LLM-ready context format
 */


function formatLLMOutput(analysisResults, fileName) {
  let report = '';
  
  // Header
  report += createSection('LLM-READY CONTEXT',
    `Dataset: ${fileName}\nGenerated: ${formatTimestamp()}`);
  
  // Dataset summary
  report += formatDatasetSummary(analysisResults);
  
  // Key columns and characteristics
  report += formatKeyColumns(analysisResults);
  
  // Important patterns and insights (enhanced with synthesis)
  report += formatImportantPatterns(analysisResults);
  
  // Data quality notes (filtered from INT)
  report += formatDataQualityNotes(analysisResults);
  
  // Statistical summary (key metrics from EDA)
  report += formatStatisticalSummary(analysisResults);
  
  // Correlations discovered (significant only)
  report += formatCorrelations(analysisResults);
  
  // Visualization priorities (top 3 from VIS)
  report += formatVisualizationPriorities(analysisResults);
  
  // Engineering considerations (critical from ENG)
  report += formatEngineeringConsiderations(analysisResults);
  
  // Suggested analyses
  report += formatSuggestedAnalyses(analysisResults);
  
  // Questions this data could answer
  report += formatDataQuestions(analysisResults);
  
  // Technical notes
  report += formatTechnicalNotes(analysisResults);
  
  report += '\nEND OF CONTEXT\n';
  
  return report;
}

function formatDatasetSummary(results) {
  let summary = createSubSection('DATASET SUMMARY FOR AI ANALYSIS', '');
  
  const { originalAnalysis, summaries } = results;
  summaries.edaSummary;
  
  // Basic dataset info
  const recordCount = originalAnalysis.recordCount || 0;
  const columnCount = originalAnalysis.columnCount || 0;
  const dataType = originalAnalysis.dataType || 'structured business data';
  
  summary += `I have a CSV dataset with ${recordCount.toLocaleString()} rows and ${columnCount} columns containing ${dataType}`;
  
  // Date range if available
  if (originalAnalysis.dateRange) {
    summary += `. The data spans from ${originalAnalysis.dateRange.start} to ${originalAnalysis.dateRange.end}`;
  }
  
  summary += '.\n';
  
  // Add quality context if critical
  const intSummary = summaries.intSummary;
  if (intSummary?.qualityScore && intSummary.qualityScore.score < 0.8) {
    summary += `\nIMPORTANT: Data quality is ${intSummary.qualityScore.grade} (${(intSummary.qualityScore.score * 100).toFixed(0)}%), which may affect analysis accuracy.\n`;
  }
  
  return summary;
}

function formatKeyColumns(results) {
  let section = createSubSection('KEY COLUMNS AND THEIR CHARACTERISTICS', '');
  
  const { originalAnalysis } = results;
  const columns = originalAnalysis.columns || [];
  const columnTypes = originalAnalysis.columnTypes || {};
  
  // Limit to most important columns
  const keyColumns = identifyKeyColumns(columns, columnTypes, results.summaries);
  
  keyColumns.forEach((column, idx) => {
    section += `\n${idx + 1}. ${column.name}: `;
    section += column.description;
    
    if (column.qualityIssue) {
      section += ` (⚠️ ${column.qualityIssue})`;
    }
  });
  
  section += '\n';
  
  return section;
}

function formatImportantPatterns(results) {
  let section = createSubSection('IMPORTANT PATTERNS AND INSIGHTS', '');
  
  const { keyFindings, synthesis, originalAnalysis } = results;
  
  // Try to get findings from multiple sources
  let findings = keyFindings || [];
  
  // Fallback: Extract patterns from original analysis if no key findings
  if ((!findings || findings.length === 0) && originalAnalysis) {
    findings = extractFallbackPatterns(originalAnalysis, results);
  }
  
  if (!findings || findings.length === 0) {
    section += '\nNo significant patterns detected in the data.\n';
    return section;
  }
  
  // Format key findings with enhanced context
  findings.forEach((finding, idx) => {
    section += `\n${idx + 1}. ${finding.title}: `;
    
    // Main finding
    section += finding.description;
    
    // Add impact if available
    if (finding.impact && finding.impact !== finding.description) {
      section += `, ${finding.impact}`;
    }
    
    // Add action if available
    if (finding.action) {
      section += `. ${finding.action}`;
    }
    
    // Add confidence indicator for uncertain findings
    if (finding.confidence < 0.8) {
      section += ' (moderate confidence)';
    }
    
    section += '\n';
  });
  
  // Add cross-analysis patterns if significant
  if (synthesis?.crossAnalysisPatterns && synthesis.crossAnalysisPatterns.length > 0) {
    const topPattern = synthesis.crossAnalysisPatterns[0];
    section += `\n${findings.length + 1}. PATTERN: ${topPattern.pattern} - ${topPattern.description}\n`;
  }
  
  return section;
}

function formatDataQualityNotes(results) {
  const intSummary = results.summaries.intSummary;
  const notes = [];
  
  // Overall quality score
  if (intSummary?.qualityScore) {
    // Score is already in 0-100 range, don't multiply by 100
    notes.push(`Overall quality: ${intSummary.qualityScore.grade} (${intSummary.qualityScore.score}%)`);
  }
  
  // Critical issues only
  if (intSummary?.criticalIssues) {
    const topIssues = intSummary.criticalIssues.slice(0, 2);
    topIssues.forEach(issue => {
      notes.push(`${issue.issue}${issue.fixAvailable ? ' (automated fix available)' : ''}`);
    });
  }
  
  // Validation failures
  if (intSummary?.validationFailures) {
    const criticalFailures = intSummary.validationFailures
      .filter(f => f.score < 0.7)
      .slice(0, 1);
    
    criticalFailures.forEach(failure => {
      notes.push(`Low ${failure.dimension}: ${failure.mainIssue}`);
    });
  }
  
  // Missing data from original analysis
  if (results.originalAnalysis?.qualityMetrics) {
    const metrics = results.originalAnalysis.qualityMetrics;
    if (metrics.missingDetails && metrics.missingDetails !== 'No missing values') {
      notes.push(`Missing values: ${metrics.missingDetails}`);
    }
  }
  
  return createSubSection('DATA QUALITY NOTES', bulletList(notes));
}

function formatStatisticalSummary(results) {
  let section = createSubSection('STATISTICAL SUMMARY', '');
  
  const edaSummary = results.summaries.edaSummary;
  const stats = [];
  
  // Key metrics from EDA summary
  if (edaSummary?.metrics) {
    Object.entries(edaSummary.metrics).forEach(([column, metrics]) => {
      if (metrics.total) {
        stats.push(`Total ${column}: ${formatValue$1(metrics.total, column)}`);
      }
      if (metrics.average) {
        stats.push(`Average ${column}: ${formatValue$1(metrics.average, column)}`);
      }
      if (metrics.growth) {
        stats.push(`${column} growth rate: ${formatPercentage(metrics.growth)}`);
      }
    });
  }
  
  // Add original summary stats if available
  if (results.originalAnalysis?.summaryStats) {
    results.originalAnalysis.summaryStats
      .filter(stat => !stats.some(s => s.includes(stat.split(':')[0])))
      .slice(0, 3)
      .forEach(stat => stats.push(stat));
  }
  
  stats.forEach(stat => {
    section += `- ${stat}\n`;
  });
  
  return section;
}

function formatCorrelations(results) {
  const edaSummary = results.summaries.edaSummary;
  
  if (!edaSummary?.correlations || edaSummary.correlations.length === 0) {
    return '';
  }
  
  let section = createSubSection('CORRELATIONS DISCOVERED', '');
  
  edaSummary.correlations.forEach(corr => {
    const strength = corr.strength > 0.8 ? 'Strong' : 'Moderate';
    section += `- ${strength} ${corr.direction}: ${corr.columns[0]} vs ${corr.columns[1]} (${formatNumber(corr.strength, 2)})`;
    
    if (corr.businessMeaning) {
      section += ` - ${corr.businessMeaning}`;
    }
    
    section += '\n';
  });
  
  return section;
}

function formatVisualizationPriorities(results) {
  const visSummary = results.summaries.visSummary;
  
  if (!visSummary?.topVisualizations || visSummary.topVisualizations.length === 0) {
    return '';
  }
  
  let section = createSubSection('VISUALIZATION PRIORITIES', '');
  
  visSummary.topVisualizations.forEach((viz, idx) => {
    section += `${idx + 1}. ${viz.type} for ${viz.purpose}`;
    
    if (viz.insight) {
      section += ` (${viz.insight})`;
    }
    
    section += '\n';
  });
  
  return section;
}

function formatEngineeringConsiderations(results) {
  const engSummary = results.summaries.engSummary;
  const considerations = [];
  
  // Schema recommendation
  if (engSummary?.schemaRecommendation) {
    considerations.push(`Schema: ${engSummary.schemaRecommendation.approach} approach recommended (${engSummary.schemaRecommendation.rationale})`);
  }
  
  // Performance considerations
  if (engSummary?.performanceConsiderations) {
    engSummary.performanceConsiderations.slice(0, 2).forEach(perf => {
      considerations.push(`${perf.aspect}: ${perf.recommendation}`);
    });
  }
  
  // Critical ETL requirements
  if (engSummary?.etlRequirements && engSummary.etlRequirements.length > 0) {
    const critical = engSummary.etlRequirements[0];
    considerations.push(`ETL: ${critical.requirement} - ${critical.specifics}`);
  }
  
  if (considerations.length === 0) {
    return '';
  }
  
  return createSubSection('ENGINEERING CONSIDERATIONS', bulletList(considerations));
}

function formatSuggestedAnalyses(results) {
  let section = createSubSection('SUGGESTED ANALYSES FOR THIS DATA', '');
  
  const suggestions = [];
  
  // From unified recommendations
  if (results.synthesis?.unifiedRecommendations) {
    results.synthesis.unifiedRecommendations
      .filter(rec => rec.category === 'Analysis')
      .forEach(rec => {
        suggestions.push(rec.action);
      });
  }
  
  // From original analysis suggestions
  if (results.originalAnalysis?.analysisSuggestions && Array.isArray(results.originalAnalysis.analysisSuggestions)) {
    results.originalAnalysis.analysisSuggestions
      .filter(sugg => sugg && !suggestions.some(s => s.includes(sugg.split(' ')[0])))
      .slice(0, 5 - suggestions.length)
      .forEach(sugg => suggestions.push(sugg));
  }
  
  // Default suggestions based on data characteristics
  if (suggestions.length < 3) {
    const defaults = generateDefaultSuggestions(results);
    if (defaults && Array.isArray(defaults)) {
      defaults
        .filter(sugg => sugg && !suggestions.includes(sugg))
        .slice(0, 5 - suggestions.length)
        .forEach(sugg => suggestions.push(sugg));
    }
  }
  
  suggestions.forEach((suggestion, idx) => {
    section += `\n${idx + 1}. ${suggestion}`;
  });
  
  section += '\n';
  
  return section;
}

function formatDataQuestions(results) {
  let section = createSubSection('QUESTIONS THIS DATA COULD ANSWER', '');
  
  const questions = results.originalAnalysis?.dataQuestions || [];
  
  // Add synthesis-driven questions
  if (results.synthesis?.crossAnalysisPatterns) {
    results.synthesis.crossAnalysisPatterns.forEach(pattern => {
      const question = patternToQuestion(pattern);
      if (question && !questions.includes(question)) {
        questions.unshift(question);
      }
    });
  }
  
  questions.slice(0, 8).forEach(question => {
    section += `- ${question}\n`;
  });
  
  return section;
}

function formatTechnicalNotes(results) {
  const notes = [];
  
  // From EDA patterns
  const edaSummary = results.summaries.edaSummary;
  if (edaSummary?.patterns) {
    edaSummary.patterns
      .filter(p => p.type === 'distribution' && p.impact)
      .forEach(p => notes.push(p.impact));
  }
  
  // From engineering
  const engSummary = results.summaries.engSummary;
  if (engSummary?.performanceConsiderations) {
    engSummary.performanceConsiderations
      .filter(c => c.aspect === 'Data Volume')
      .forEach(c => notes.push(c.issue));
  }
  
  // From original technical notes
  if (results.originalAnalysis?.technicalNotes) {
    results.originalAnalysis.technicalNotes
      .filter(note => !notes.some(n => n.includes(note.split(' ')[0])))
      .slice(0, 3)
      .forEach(note => notes.push(note));
  }
  
  if (notes.length === 0) {
    return '';
  }
  
  return createSubSection('TECHNICAL NOTES FOR ANALYSIS', bulletList(notes));
}

// Helper functions

function identifyKeyColumns(columns, columnTypes, summaries) {
  const keyColumns = [];
  const MAX_COLUMNS = 10;
  
  // Priority 1: Business metrics
  const businessKeywords = ['amount', 'revenue', 'price', 'cost', 'profit', 'total', 'value'];
  const businessColumns = columns.filter(col => 
    businessKeywords.some(keyword => col.toLowerCase().includes(keyword))
  );
  
  // Priority 2: Key dimensions
  const dimensionKeywords = ['customer', 'product', 'date', 'category', 'region', 'segment'];
  const dimensionColumns = columns.filter(col => 
    dimensionKeywords.some(keyword => col.toLowerCase().includes(keyword))
  );
  
  // Priority 3: Columns with quality issues
  const qualityIssueColumns = [];
  if (summaries.intSummary?.criticalIssues) {
    summaries.intSummary.criticalIssues.forEach(issue => {
      if (issue.column && !qualityIssueColumns.includes(issue.column)) {
        qualityIssueColumns.push({
          name: issue.column,
          issue: issue.issue
        });
      }
    });
  }
  
  // Combine and format
  [...businessColumns, ...dimensionColumns].forEach(col => {
    if (keyColumns.length >= MAX_COLUMNS) return;
    
    const type = columnTypes[col];
    const qualityIssue = qualityIssueColumns.find(q => q.name === col);
    
    keyColumns.push({
      name: col,
      description: formatColumnDescription(col, type),
      qualityIssue: qualityIssue?.issue
    });
  });
  
  // Fill with other columns if needed
  columns.forEach(col => {
    if (keyColumns.length >= MAX_COLUMNS) return;
    if (keyColumns.some(kc => kc.name === col)) return;
    
    keyColumns.push({
      name: col,
      description: formatColumnDescription(col, columnTypes[col])
    });
  });
  
  return keyColumns.slice(0, MAX_COLUMNS);
}

function formatColumnDescription(column, type) {
  if (!type) return 'Unknown type';
  
  if (type.type === 'identifier') {
    const unique = type.uniqueCount || 'unknown';
    return `Unique identifier (${unique} values)`;
  } else if (type.type === 'integer' || type.type === 'float') {
    const purpose = inferColumnPurpose$1(column);
    if (type.stats) {
      return `${purpose} (range: ${formatValue$1(type.stats.min, column)} to ${formatValue$1(type.stats.max, column)})`;
    }
    return purpose;
  } else if (type.type === 'categorical') {
    const categories = type.categories ? type.categories.length : 'unknown';
    return `${categories} categories`;
  } else if (type.type === 'date') {
    return 'Date field';
  } else {
    return type.type.charAt(0).toUpperCase() + type.type.slice(1);
  }
}

function inferColumnPurpose$1(column) {
  const col = column.toLowerCase();
  
  if (col.includes('amount') || col.includes('total')) return 'Transaction amount';
  if (col.includes('price')) return 'Price information';
  if (col.includes('quantity') || col.includes('qty')) return 'Quantity/count';
  if (col.includes('age')) return 'Age data';
  if (col.includes('score') || col.includes('rating')) return 'Score/rating';
  if (col.includes('discount')) return 'Discount percentage/amount';
  if (col.includes('id')) return 'Identifier';
  
  return 'Numeric field';
}

function formatValue$1(value, column) {
  if (column.toLowerCase().includes('amount') || 
      column.toLowerCase().includes('price') || 
      column.toLowerCase().includes('total') ||
      column.toLowerCase().includes('revenue') ||
      column.toLowerCase().includes('cost')) {
    return formatCurrency(value);
  }
  
  if (column.toLowerCase().includes('percent') || column.toLowerCase().includes('rate')) {
    return formatPercentage(value / 100);
  }
  
  return formatNumber(value);
}

function generateDefaultSuggestions(results) {
  const suggestions = [];
  const { summaries } = results;
  
  // Based on data characteristics
  if (summaries.edaSummary?.correlations && summaries.edaSummary.correlations.length > 0) {
    suggestions.push('Predictive modeling based on discovered correlations');
  }
  
  if (summaries.edaSummary?.patterns?.some(p => p.type === 'seasonality')) {
    suggestions.push('Time series forecasting with seasonal decomposition');
  }
  
  if (summaries.intSummary?.criticalIssues?.length > 3) {
    suggestions.push('Data quality improvement pipeline implementation');
  }
  
  if (summaries.visSummary?.dashboardLayout) {
    suggestions.push('Interactive dashboard development for monitoring');
  }
  
  // Generic valuable analyses
  suggestions.push(
    'Customer segmentation analysis',
    'Anomaly detection for fraud/errors',
    'Cohort analysis for retention',
    'A/B testing framework setup'
  );
  
  return suggestions;
}

function patternToQuestion(pattern) {
  switch (pattern.pattern) {
    case 'Growth-Quality Trade-off':
      return 'How is rapid growth affecting data quality and reliability?';
    case 'Segmentation Opportunity':
      return 'What distinct customer segments exist and how do they differ?';
    case 'Complex Relationship Network':
      return 'How do entity relationships impact business operations?';
    default:
      return null;
  }
}

function extractFallbackPatterns(originalAnalysis, results) {
  const patterns = [];
  
  // Extract from correlations if available
  if (originalAnalysis.correlations && originalAnalysis.correlations.length > 0) {
    originalAnalysis.correlations.slice(0, 2).forEach(corr => {
      patterns.push({
        title: 'CORRELATION',
        description: corr,
        confidence: 0.8
      });
    });
  }
  
  // Extract from seasonal patterns
  if (originalAnalysis.seasonalPattern) {
    patterns.push({
      title: 'SEASONALITY',
      description: originalAnalysis.seasonalPattern,
      confidence: 0.9
    });
  }
  
  // Extract from segment analysis
  if (originalAnalysis.segmentAnalysis) {
    patterns.push({
      title: originalAnalysis.segmentAnalysis.title,
      description: originalAnalysis.segmentAnalysis.insight,
      confidence: 0.8
    });
  }
  
  // Extract from category analysis
  if (originalAnalysis.categoryAnalysis) {
    patterns.push({
      title: originalAnalysis.categoryAnalysis.title,
      description: originalAnalysis.categoryAnalysis.insight,
      confidence: 0.8
    });
  }
  
  // Extract from pricing insights
  if (originalAnalysis.pricingInsights) {
    patterns.push({
      title: 'PRICING INSIGHTS',
      description: originalAnalysis.pricingInsights,
      confidence: 0.7
    });
  }
  
  // Extract from anomalies
  if (originalAnalysis.anomalies && originalAnalysis.anomalies.length > 0) {
    patterns.push({
      title: 'ANOMALIES DETECTED',
      description: originalAnalysis.anomalies.slice(0, 2).join('; '),
      confidence: 0.9
    });
  }
  
  // Extract statistical insights from summaries if available
  if (results.summaries?.edaSummary?.statisticalInsights) {
    results.summaries.edaSummary.statisticalInsights.slice(0, 2).forEach(insight => {
      patterns.push({
        title: 'STATISTICAL INSIGHT',
        description: insight.finding || insight.description || insight,
        confidence: insight.confidence || 0.8
      });
    });
  }
  
  return patterns;
}

/**
 * LLM Command Implementation
 * Orchestrates all analyses in summary mode and synthesizes insights
 */


// Cache for analysis results
const analysisCache = new Map();

async function comprehensiveLLMAnalysis(records, headers, filePath, options = {}) {
  const spinner = options.quiet ? null : ora('Generating comprehensive LLM context...').start();
  
  // Performance optimization: Use sampling for comprehensive analysis
  const samplingStrategy = createSamplingStrategy(records, 'basic');
  let sampledRecords = records;
  
  // More aggressive sampling for comprehensive analysis
  if (samplingStrategy.method !== 'none' && records.length > 5000) {
    // For comprehensive analysis, use even more aggressive sampling
    const maxSampleSize = 2000; // Limit to 2000 rows for sub-analyses
    if (sampledRecords.length > maxSampleSize) {
      maxSampleSize / records.length;
      sampledRecords = performSampling(records, { ...samplingStrategy});
    }
    if (spinner) {
      spinner.text = `Using smart sampling (${sampledRecords.length.toLocaleString()} of ${records.length.toLocaleString()} rows) for faster analysis...`;
    }
  }
  
  try {
    const fileName = basename(filePath);
    const columnTypes = sampledRecords.length > 0 ? detectColumnTypes(sampledRecords) : {};
    const columns = Object.keys(columnTypes);
    
    // Check cache
    const cacheKey = `${filePath}_${sampledRecords.length}_${columns.length}`;
    if (analysisCache.has(cacheKey) && !options.noCache) {
      const cached = analysisCache.get(cacheKey);
      const age = Date.now() - cached.timestamp;
      if (age < 300000) { // 5 minutes
        if (spinner) spinner.succeed('LLM context generated from cache!');
        return cached.result;
      }
    }
    
    if (spinner) spinner.text = 'Running exploratory data analysis...';
    
    // Run all analyses in parallel with summary mode using sampled data
    // Add individual error handling to prevent one failure from blocking all
    const analysisPromises = [
      runEdaAnalysis(sampledRecords, headers, filePath, options, columnTypes).catch(e => {
        console.error('EDA analysis failed:', e.message);
        return {};
      }),
      runIntAnalysis(sampledRecords, headers, filePath, options, columnTypes).catch(e => {
        console.error('INT analysis failed:', e.message);
        return {};
      }),
      runVisAnalysis(sampledRecords, headers, filePath, options, columnTypes).catch(e => {
        console.error('VIS analysis failed:', e.message);
        return {};
      }),
      runEngAnalysis(sampledRecords, headers, filePath, options, columnTypes).catch(e => {
        console.error('ENG analysis failed:', e.message);
        return {};
      }),
      generateOriginalContext(sampledRecords, columns, columnTypes).catch(e => {
        console.error('Original context generation failed:', e.message);
        return {};
      })
    ];
    
    const [edaResults, intResults, visResults, engResults, originalContext] = await Promise.all(analysisPromises);
    
    if (spinner) spinner.text = 'Extracting key insights...';
    
    // Extract summaries from each analysis
    const summaries = {
      edaSummary: extractEdaSummary(edaResults),
      intSummary: extractIntSummary(intResults),
      visSummary: extractVisSummary(visResults),
      engSummary: extractEngSummary(engResults)
    };
    
    if (spinner) spinner.text = 'Synthesizing cross-analysis insights...';
    
    // Synthesize insights across analyses
    const synthesis = synthesizeInsights(
      summaries.edaSummary,
      summaries.intSummary,
      summaries.visSummary,
      summaries.engSummary
    );
    
    if (spinner) spinner.text = 'Selecting most impactful findings...';
    
    // Select key findings
    const selector = new KeyFindingSelector({
      maxFindings: 5,
      maxPatternsPerCategory: 2
    });
    
    const allFindings = {
      edaSummary: summaries.edaSummary,
      intSummary: summaries.intSummary,
      visSummary: summaries.visSummary,
      engSummary: summaries.engSummary,
      synthesis
    };
    
    const keyFindings = selector.selectKeyFindings(allFindings);
    const formattedFindings = selector.formatForPresentation(keyFindings);
    
    if (spinner) spinner.text = 'Formatting LLM context...';
    
    // Prepare analysis results for formatter
    const analysisResults = {
      originalAnalysis: originalContext,
      summaries,
      synthesis,
      keyFindings: formattedFindings,
      recordCount: records.length,
      columnCount: columns.length,
      dataType: originalContext.dataType
    };
    
    // Format the output
    const formattedOutput = formatLLMOutput(analysisResults, fileName);
    
    // Cache the result
    const result = {
      output: formattedOutput,
      metadata: {
        recordCount: records.length,
        columnCount: columns.length,
        keyFindingsCount: keyFindings.length,
        qualityScore: summaries.intSummary?.qualityScore?.score,
        visualizationCount: summaries.visSummary?.topVisualizations?.length || 0
      }
    };
    
    analysisCache.set(cacheKey, {
      result,
      timestamp: Date.now()
    });
    
    // Clear old cache entries
    if (analysisCache.size > 10) {
      const oldestKey = analysisCache.keys().next().value;
      analysisCache.delete(oldestKey);
    }
    
    if (spinner) spinner.succeed('Comprehensive LLM context generated!');
    
    return result;
    
  } catch (error) {
    if (spinner) spinner.error({ text: 'Error generating LLM context' });
    console.error('Comprehensive LLM analysis error:', error.message);
    // Don't exit process here, let caller handle the error
    throw error;
  }
}

// Analysis runners - now use real command outputs

async function runEdaAnalysis(records, headers, filePath, options, columnTypes) {
  const captureOptions = {
    ...options,
    structuredOutput: true,
    quiet: true,
    preloadedData: { records, columnTypes }
  };
  
  try {
    // Add timeout for large dataset analysis
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('EDA analysis timeout')), 10000); // 10 second timeout
    });
    
    const analysisPromise = eda(filePath, captureOptions);
    const result = await Promise.race([analysisPromise, timeoutPromise]);
    
    return result?.structuredResults || {};
  } catch (error) {
    console.error('EDA analysis error:', error.message);
    // Fallback to minimal structure
    return {
      statisticalInsights: [],
      dataQuality: { completeness: 0.8, duplicateRows: 0, outlierPercentage: 0 },
      correlations: [],
      distributions: [],
      timeSeries: null,
      summaryStats: {},
      mlReadiness: { overallScore: 0.8, majorIssues: [] },
      columns: headers
    };
  }
}

async function runIntAnalysis(records, _headers, filePath, options, columnTypes) {
  const captureOptions = {
    ...options,
    structuredOutput: true,
    quiet: true,
    preloadedData: { records, columnTypes }
  };
  
  try {
    const result = await integrity(filePath, captureOptions);
    return result?.structuredResults || {};
  } catch (error) {
    console.error('INT analysis error:', error);
    // Fallback to minimal structure
    return {
      overallQuality: { score: 0.8, grade: 'B', trend: 'stable' },
      validationResults: [],
      businessRules: [],
      referentialIntegrity: [],
      patternAnomalies: [],
      suggestedFixes: [],
      dimensions: {
        completeness: { score: 0.8 },
        accuracy: { score: 0.8 },
        consistency: { score: 0.8 },
        validity: { score: 0.8 },
        uniqueness: { score: 0.8 },
        timeliness: { score: 0.8 }
      }
    };
  }
}

async function runVisAnalysis(records, _headers, filePath, options, columnTypes) {
  const captureOptions = {
    ...options,
    structuredOutput: true,
    quiet: true,
    preloadedData: { records, columnTypes }
  };
  
  try {
    const result = await visualize(filePath, captureOptions);
    return result?.structuredResults || {};
  } catch (error) {
    console.error('VIS analysis error:', error);
    // Fallback to minimal structure
    return {
      recommendations: [],
      dashboardRecommendation: null,
      antiPatterns: [],
      taskAnalysis: {},
      perceptualAnalysis: {},
      multivariatePatterns: [],
      interactiveRecommendations: []
    };
  }
}

async function runEngAnalysis(records, _headers, filePath, options, columnTypes) {
  const captureOptions = {
    ...options,
    structuredOutput: true,
    quiet: true,
    preloadedData: { records, columnTypes }
  };
  
  try {
    const result = await engineering(filePath, captureOptions);
    return result?.structuredResults || {};
  } catch (error) {
    console.error('ENG analysis error:', error);
    // Fallback to minimal structure
    return {
      schemaRecommendations: [],
      performanceAnalysis: {
        dataVolume: records.length,
        queryPatterns: [],
        joinComplexity: 'moderate'
      },
      etlAnalysis: {},
      technicalDebt: [],
      relationships: [],
      warehouseKnowledge: {}
    };
  }
}

// Generate original context data for compatibility
async function generateOriginalContext(records, columns, columnTypes) {
  try {
    // This maintains compatibility with the original LLM format
    const dateColumns = columns.filter(col => columnTypes[col] && columnTypes[col].type === 'date');
    const dateRange = getDateRange$1(records, dateColumns);
    const dataType = inferDataType$1(columns, columnTypes);
    
    // Run only essential analysis functions for large datasets
    const isLargeDataset = records.length > 5000;
    
    const seasonalPattern = !isLargeDataset && dateColumns.length > 0 ? 
      analyzeSeasonality$1(records, dateColumns[0], columns, columnTypes) : null;
    
    const segmentAnalysis = !isLargeDataset ? analyzeSegments$1(records, columns, columnTypes) : null;
    const categoryAnalysis = !isLargeDataset ? analyzeCategoryPerformance$1(records, columns, columnTypes) : null;
    const pricingInsights = !isLargeDataset ? analyzePricing$1(records, columns, columnTypes) : null;
    const anomalies = !isLargeDataset ? detectAnomalies$1(records, columns, columnTypes) : [];
    const qualityMetrics = calculateDataQuality$1(records, columns);
    const summaryStats = generateSummaryStatistics$1(records, columns, columnTypes);
    const correlations = !isLargeDataset ? findSignificantCorrelations$1(records, columns, columnTypes) : [];
    const analysisSuggestions = generateAnalysisSuggestions$1(columns, columnTypes);
    const dataQuestions = generateDataQuestions$1(columns, columnTypes, dataType);
    const technicalNotes = !isLargeDataset ? await generateTechnicalNotes$1(records, columns, columnTypes) : [];
  
  return {
    recordCount: records.length,
    columnCount: columns.length,
    columns,
    columnTypes,
    dateRange,
    dataType,
    seasonalPattern,
    segmentAnalysis,
    categoryAnalysis,
    pricingInsights,
    anomalies,
    qualityMetrics,
    summaryStats,
    correlations,
    analysisSuggestions,
    dataQuestions,
    technicalNotes
  };
  } catch (error) {
    console.error('Original context generation error:', error.message);
    // Return minimal context on error
    return {
      recordCount: records.length,
      columnCount: columns.length,
      columns,
      columnTypes,
      dateRange: null,
      dataType: 'unknown',
      qualityMetrics: { overallQuality: 0.8 }
    };
  }
}

const llmContext = withErrorBoundary(async function llmContextInternal(filePath, options = {}) {
  const outputHandler = new OutputHandler(options);
  const spinner = options.quiet ? null : ora('Reading CSV file...').start();
  
  // Set timeout for analysis (default 60 seconds for LLM as it's more complex)
  const timeoutMs = options.timeout || 60000;
  
  const analysisPromise = performLLMAnalysis();
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`⏱️  LLM analysis timed out after ${timeoutMs / 1000} seconds. This may indicate issues with the data format or file size.`));
    }, timeoutMs);
  });
  
  try {
    return await Promise.race([analysisPromise, timeoutPromise]);
  } catch (error) {
    outputHandler.restore();
    if (spinner) spinner.fail('LLM analysis failed or timed out');
    
    if (error.message.includes('timed out')) {
      console.error(chalk.red('🚨 LLM Analysis Timeout'));
      console.error(chalk.yellow('💡 Suggestions:'));
      console.error(chalk.yellow('   • Try using a smaller sample of your data'));
      console.error(chalk.yellow('   • Check if the CSV file has formatting issues'));
      console.error(chalk.yellow('   • Use --timeout flag to increase timeout (e.g., --timeout 120000 for 2 minutes)'));
      console.error(chalk.yellow('   • Try the --comprehensive=false flag for faster processing'));
    } else {
      console.error(error.message);
    }
    
    if (!options.quiet) process.exit(1);
    throw error;
  }
  
  async function performLLMAnalysis() {
    try {
      // Check if we should use comprehensive analysis
      const useComprehensive = options.comprehensive !== false; // Default to true
      
      // Use preloaded data if available
      let records, columnTypes, headers;
      if (options.preloadedData) {
        records = options.preloadedData.records;
        columnTypes = options.preloadedData.columnTypes;
        headers = Object.keys(columnTypes);
      } else {
        // Parse CSV with enhanced error handling
        try {
          const allRecords = await parseCSV(filePath, { quiet: options.quiet, header: options.header });
          const originalSize = allRecords.length;
          
          // Validate parsed data
          if (!allRecords || allRecords.length === 0) {
            throw new Error('No data found in CSV file. Please check the file format and content.');
          }
          
          // Create smart sampling strategy for large datasets
          const samplingStrategy = createSamplingStrategy(allRecords, 'basic');
          
          // Handle large datasets with user-friendly notifications
          let maxRowsForLLM = 10000;
          
          if (originalSize > 10000) {
            console.log(chalk.yellow(`\n⚠️  Large dataset detected: ${originalSize.toLocaleString()} rows`));
            
            if (originalSize > 50000) {
              // Very large dataset
              maxRowsForLLM = 10000;
              console.log(chalk.cyan('📊 Using intelligent sampling for LLM context generation.'));
              console.log(chalk.cyan(`   Processing ${maxRowsForLLM.toLocaleString()} representative rows...`));
            } else {
              // Medium-large dataset
              maxRowsForLLM = 20000;
              console.log(chalk.cyan('⏱️  Analysis may take up to 30 seconds...'));
              console.log(chalk.cyan(`   Processing ${Math.min(maxRowsForLLM, originalSize).toLocaleString()} rows...`));
            }
            
            if (spinner) {
              spinner.text = `Analyzing ${Math.min(maxRowsForLLM, originalSize).toLocaleString()} rows...`;
            }
          } else if (spinner) {
            spinner.text = `Analyzing ${originalSize.toLocaleString()} rows...`;
          }
          
          if (originalSize > maxRowsForLLM) {
            
            const customStrategy = {
              method: 'systematic',
              sampleSize: maxRowsForLLM,
              targetSize: maxRowsForLLM,
              sampleRate: maxRowsForLLM / originalSize
            };
            records = performSampling(allRecords, customStrategy);
            if (records.length === 0) {
              console.error('❌ Sampling returned 0 records! Falling back to first 5000 rows');
              records = allRecords.slice(0, maxRowsForLLM);
            }
            console.log(`⚠️  Large dataset sampled: ${records.length.toLocaleString()} of ${originalSize.toLocaleString()} rows`);
          } else if (samplingStrategy.method !== 'none') {
            if (spinner) {
              spinner.text = `Dataset detected (${originalSize.toLocaleString()} rows). Applying smart sampling...`;
            }
            records = performSampling(allRecords, samplingStrategy);
            console.log(`⚠️  Dataset sampled: ${records.length.toLocaleString()} of ${originalSize.toLocaleString()} rows (${samplingStrategy.method} sampling)`);
          } else {
            records = allRecords;
          }
          
          if (spinner) spinner.text = 'Generating LLM context...';
          
          try {
            columnTypes = detectColumnTypes(records);
            headers = Object.keys(columnTypes);
          } catch (typeError) {
            throw new Error(`Column type detection failed: ${typeError.message}`);
          }
          
        } catch (parseError) {
          throw new Error(`CSV parsing failed: ${parseError.message}`);
        }
      }
      
      // Add safety check for undefined values
      if (records.length > 0) {
        const sampleRecord = records[0];
        const undefinedCount = Object.values(sampleRecord).filter(v => v === undefined).length;
        if (undefinedCount > Object.keys(sampleRecord).length * 0.5) {
          console.log(chalk.yellow('⚠️  Warning: High number of undefined values detected in data.'));
          console.log(chalk.yellow('   This may indicate CSV parsing issues. Consider checking file encoding.'));
          
          // Option to continue with degraded analysis
          if (!options.force) {
            throw new Error('Data quality issues detected. Use --force flag to continue anyway.');
          }
        }
      }
      
      // Use comprehensive analysis if enabled
      if (useComprehensive && records.length > 0) {
        try {
          const result = await comprehensiveLLMAnalysis(records, headers, filePath, options);
          console.log(result.output);
          outputHandler.finalize();
          return;
        } catch (error) {
          // Fall back to original implementation if comprehensive fails
          console.error(chalk.yellow(`Comprehensive analysis failed (${error.message}), using simplified analysis...`));
        }
      }
      
      const fileName = basename(filePath);
      const columns = Object.keys(columnTypes);
      
      // Handle empty dataset
      if (records.length === 0) {
        let report = createSection('LLM-READY CONTEXT',
          `Dataset: ${fileName}\nGenerated: ${formatTimestamp()}\n\n⚠️  Empty dataset - no context to generate`);
        
        // Still include the required section header
        report += createSubSection('DATASET SUMMARY FOR AI ANALYSIS', 'No data available for analysis');
        
        console.log(report);
        outputHandler.finalize();
        return;
      }
      
      // Build report
      let report = createSection('LLM-READY CONTEXT',
        `Dataset: ${fileName}\nGenerated: ${formatTimestamp()}`);
      
      // Check for small dataset
      const smallDatasetInfo = formatSmallDatasetWarning(records.length);
      if (smallDatasetInfo) {
        report += '\n' + smallDatasetInfo.warning + '\n';
      }
      
      // Add parsing metadata
      report += createSubSection('PARSING METADATA', bulletList([
        `File encoding: ${options.encoding || 'UTF-8 (auto-detected)'}`,
        `Delimiter: ${options.delimiter || 'comma (auto-detected)'}`,
        `Header detection: ${options.header === false ? 'No headers (generated column names)' : 'Headers detected'}`,
        `Rows processed: ${records.length}`,
        `Analysis confidence: ${smallDatasetInfo ? 'Reduced due to small sample size' : 'High'}`
      ]));
      
      report += createSubSection('DATASET SUMMARY FOR AI ANALYSIS', '');
      
      // Generate natural language summary
      const dateColumns = columns.filter(col => columnTypes[col] && columnTypes[col].type === 'date');
      const dateRange = getDateRange(records, dateColumns);
      
      report += `I have a CSV dataset with ${records.length.toLocaleString()} rows and ${columns.length} columns`;
      
      // Try to infer what kind of data this is
      const dataType = inferDataType(columns, columnTypes);
      report += ` containing ${dataType}`;
      
      if (dateRange) {
        report += `. The data spans from ${dateRange.start} to ${dateRange.end}`;
      }
      report += '.\n';
      
      // Key columns and characteristics
      report += createSubSection('KEY COLUMNS AND THEIR CHARACTERISTICS', '');
      
      // For large datasets, use simpler column descriptions
      const isLargeDataset = records.length > 5000;
      
      for (let idx = 0; idx < columns.length; idx++) {
        const column = columns[idx];
        const type = safeGet(columnTypes, column, { type: 'unknown' });
        
        report += `\n${idx + 1}. ${column}: `;
        
        if (type.type === 'identifier') {
          report += `Unique identifier`;
        } else if (type.type === 'integer' || type.type === 'float') {
          if (isLargeDataset) {
            // For large datasets, just show the type without calculating stats
            report += `${inferColumnPurpose(column)} (numeric)`;
          } else {
            const values = SafeArrayOps.safeMap(records, r => safeGet(r, column), []);
            const stats = await calculateStats(values);
            const range = `range: ${formatValue(stats.min, column)} to ${formatValue(stats.max, column)}`;
            report += `${inferColumnPurpose(column)} (${range})`;
          }
        } else if (type.type === 'categorical') {
          const topValues = isLargeDataset ? 'multiple categories' : getTopCategoricalValues(SafeArrayOps.safeMap(records, r => safeGet(r, column), []), 3);
          const categoryCount = type.categories ? type.categories.length : 0;
          report += `${categoryCount} categories${isLargeDataset ? '' : `: ${topValues}`}`;
        } else if (type.type === 'date') {
          report += 'Date field';
          if (!isLargeDataset) {
            const values = SafeArrayOps.safeMap(records, r => safeGet(r, column), []);
            const dates = values.filter(v => v instanceof Date);
            if (dates.length > 0) {
              const sorted = dates.sort((a, b) => a - b);
              report += ` (${formatDate(sorted[0])} to ${formatDate(sorted[sorted.length - 1])})`;
            }
          }
        } else {
          report += type.type.charAt(0).toUpperCase() + type.type.slice(1);
        }
      }
      
      // Important patterns and insights
      report += '\n' + createSubSection('IMPORTANT PATTERNS AND INSIGHTS', '');
      
      let insightNumber = 1;
      
      // Seasonality analysis
      if (dateColumns.length > 0) {
        const seasonalPattern = analyzeSeasonality(records, dateColumns[0], columns, columnTypes);
        if (seasonalPattern) {
          report += `\n${insightNumber}. SEASONALITY: ${seasonalPattern}\n`;
          insightNumber++;
        }
      }
      
      // Customer/segment analysis
      const segmentAnalysis = analyzeSegments(records, columns, columnTypes);
      if (segmentAnalysis) {
        report += `\n${insightNumber}. ${segmentAnalysis.title}: ${segmentAnalysis.insight}\n`;
        insightNumber++;
      }
      
      // Category performance
      const categoryAnalysis = analyzeCategoryPerformance(records, columns, columnTypes);
      if (categoryAnalysis) {
        report += `\n${insightNumber}. ${categoryAnalysis.title}: ${categoryAnalysis.insight}\n`;
        insightNumber++;
      }
      
      // Pricing insights
      const pricingInsights = analyzePricing(records, columns, columnTypes);
      if (pricingInsights) {
        report += `\n${insightNumber}. PRICING INSIGHTS: ${pricingInsights}\n`;
        insightNumber++;
      }
      
      // Anomalies
      const anomalies = detectAnomalies(records, columns, columnTypes);
      if (anomalies.length > 0) {
        report += `\n${insightNumber}. ANOMALIES DETECTED:\n`;
        anomalies.forEach(anomaly => {
          report += `   - ${anomaly}\n`;
        });
        insightNumber++;
      }
      
      // Data quality notes
      const qualityMetrics = calculateDataQuality(records, columns);
      report += createSubSection('DATA QUALITY NOTES', bulletList([
        `Missing values: ${qualityMetrics.missingDetails}`,
        `Completeness: ${formatPercentage(qualityMetrics.completeness)} overall`,
        qualityMetrics.duplicates > 0 ? `${qualityMetrics.duplicates} duplicate records identified` : 'No duplicate records found',
        qualityMetrics.dateGaps ? qualityMetrics.dateGaps : 'Date range has no gaps'
      ]));
      
      // Statistical summary
      report += createSubSection('STATISTICAL SUMMARY', '');
      
      const summaryStats = generateSummaryStatistics(records, columns, columnTypes);
      summaryStats.forEach(stat => {
        report += `- ${stat}\n`;
      });
      
      // Correlations discovered - skip for large datasets to improve performance
      if (records.length < 10000) {
        const correlations = findSignificantCorrelations(records, columns, columnTypes);
        if (correlations.length > 0) {
          report += createSubSection('CORRELATIONS DISCOVERED', '');
          correlations.forEach(corr => {
            report += `- ${corr}\n`;
          });
        }
      }
      
      // Suggested analyses
      report += createSubSection('SUGGESTED ANALYSES FOR THIS DATA', '');
      
      const suggestions = generateAnalysisSuggestions(columns, columnTypes);
      suggestions.forEach((suggestion, idx) => {
        report += `\n${idx + 1}. ${suggestion}`;
      });
      
      // Questions this data could answer
      report += '\n' + createSubSection('QUESTIONS THIS DATA COULD ANSWER', '');
      
      const questions = generateDataQuestions(columns, columnTypes, dataType, records);
      questions.forEach(question => {
        report += `- ${question}\n`;
      });
      
      // Technical notes - skip for large datasets to improve performance
      if (records.length < 10000) {
        report += createSubSection('TECHNICAL NOTES FOR ANALYSIS', '');
        
        const technicalNotes = await generateTechnicalNotes(records, columns, columnTypes);
        technicalNotes.forEach(note => {
          report += `- ${note}\n`;
        });
      }
      
      // Show sample data for context
      if (records.length > 0) {
        report += createSubSection('SAMPLE DATA', 'First 5 rows and last 5 rows:');
        const sampleRows = [
          ...records.slice(0, 5),
          ...(records.length > 10 ? records.slice(-5) : [])
        ];
        report += formatDataTable(sampleRows, columns.slice(0, 5)); // Show first 5 columns
        if (columns.length > 5) {
          report += `\n(${columns.length - 5} additional columns not shown in sample)\n`;
        }
      }
      
      // Add suggested validation queries
      report += createSubSection('VALIDATION QUERIES', 'SQL queries to verify data integrity:');
      const validationQueries = generateValidationQueries(columns, columnTypes, records);
      validationQueries.forEach((query, idx) => {
        report += `\n${idx + 1}. ${query.purpose}:\n\`\`\`sql\n${query.sql}\n\`\`\`\n`;
      });
      
      report += '\nEND OF CONTEXT\n\n[Paste this into your preferred LLM and ask specific questions about the data]\n';
      
      if (spinner) {
        spinner.succeed('LLM context generated!');
      }
      console.log(report);
      
      outputHandler.finalize();
      
    } catch (error) {
      outputHandler.restore();
      if (spinner) spinner.fail('Error generating LLM context');
      console.error(error.message);
      if (!options.quiet) process.exit(1);
      throw error;
    }
  }
}, null, { function: 'llmContext' });

function getDateRange(records, dateColumns) {
  if (dateColumns.length === 0) return null;
  
  const dates = records
    .map(r => r[dateColumns[0]])
    .filter(d => d instanceof Date)
    .sort((a, b) => a - b);
  
  if (dates.length === 0) return null;
  
  return {
    start: formatDate(dates[0]),
    end: formatDate(dates[dates.length - 1])
  };
}

function formatDate(date) {
  if (!(date instanceof Date)) return 'Invalid date';
  const months = ['January', 'February', 'March', 'April', 'May', 'June',
                  'July', 'August', 'September', 'October', 'November', 'December'];
  return `${months[date.getMonth()]} ${date.getFullYear()}`;
}

function inferDataType(columns, columnTypes) {
  const columnNames = columns.map(c => c.toLowerCase()).join(' ');
  
  // Medical/Healthcare detection
  if (columnNames.includes('patient') || columnNames.includes('diagnosis') || 
      columnNames.includes('treatment') || columnNames.includes('medical') ||
      columnNames.includes('health') || columnNames.includes('disease') ||
      columnNames.includes('symptom') || columnNames.includes('medication') ||
      columnNames.includes('glucose') || columnNames.includes('blood') ||
      columnNames.includes('diabetes') || columnNames.includes('bmi')) {
    return 'medical/healthcare data';
  }
  
  // Scientific/Research detection
  if (columnNames.includes('experiment') || columnNames.includes('sample') ||
      columnNames.includes('measurement') || columnNames.includes('observation') ||
      columnNames.includes('hypothesis') || columnNames.includes('control')) {
    return 'scientific/research data';
  }
  
  // Educational detection
  if (columnNames.includes('student') || columnNames.includes('grade') ||
      columnNames.includes('score') || columnNames.includes('course') ||
      columnNames.includes('exam') || columnNames.includes('attendance')) {
    return 'educational data';
  }
  
  // Environmental detection
  if (columnNames.includes('temperature') || columnNames.includes('humidity') ||
      columnNames.includes('pollution') || columnNames.includes('emission') ||
      columnNames.includes('climate') || columnNames.includes('weather')) {
    return 'environmental data';
  }
  
  // Manufacturing detection
  if (columnNames.includes('defect') || columnNames.includes('quality') ||
      columnNames.includes('production') || columnNames.includes('batch') ||
      columnNames.includes('assembly') || columnNames.includes('inspection')) {
    return 'manufacturing/quality data';
  }
  
  // Transportation detection
  if (columnNames.includes('route') || columnNames.includes('trip') ||
      columnNames.includes('vehicle') || columnNames.includes('driver') ||
      columnNames.includes('delivery') || columnNames.includes('shipment')) {
    return 'transportation/logistics data';
  }
  
  // Insurance/Financial detection
  if (columnNames.includes('insurance') || columnNames.includes('premium') ||
      columnNames.includes('policy') || columnNames.includes('claim') ||
      columnNames.includes('coverage') || columnNames.includes('deductible') ||
      (columnNames.includes('charges') && columnNames.includes('smoker')) ||
      (columnNames.includes('charges') && columnNames.includes('bmi'))) {
    return 'insurance/financial data';
  }
  
  // Business/Sales detection (moved after specific domains)
  if (columnNames.includes('transaction') || columnNames.includes('order') || columnNames.includes('sale')) {
    return 'sales transaction data';
  }
  if (columnNames.includes('customer') && columnNames.includes('purchase')) {
    return 'customer purchase data';
  }
  if (columnNames.includes('product') && columnNames.includes('inventory')) {
    return 'product inventory data';
  }
  if (columnNames.includes('user') || columnNames.includes('account')) {
    return 'user account data';
  }
  if (columnNames.includes('employee') || columnNames.includes('staff')) {
    return 'employee/HR data';
  }
  if (columnNames.includes('revenue') || columnNames.includes('profit')) {
    return 'financial data';
  }
  
  // Look at column types
  const hasTransactionLikeData = columns.some(c => 
    columnTypes[c] && columnTypes[c].type === 'identifier' && columns.some(c2 => columnTypes[c2] && ['float', 'integer'].includes(columnTypes[c2].type))
  );
  
  if (hasTransactionLikeData) {
    return 'transactional data';
  }
  
  return 'structured data';
}

function inferColumnPurpose(column) {
  const col = column.toLowerCase();
  
  if (col.includes('amount') || col.includes('total') || col.includes('sum')) {
    return 'Transaction amount';
  }
  if (col.includes('price')) {
    return 'Price information';
  }
  if (col.includes('quantity') || col.includes('qty')) {
    return 'Quantity/count';
  }
  if (col.includes('age')) {
    return 'Age data';
  }
  if (col.includes('score') || col.includes('rating')) {
    return 'Score/rating';
  }
  if (col.includes('discount')) {
    return 'Discount percentage/amount';
  }
  if (col.includes('id')) {
    return 'Identifier';
  }
  
  return 'Numeric field';
}

function formatValue(value, column) {
  if (column.toLowerCase().includes('amount') || 
      column.toLowerCase().includes('price') || 
      column.toLowerCase().includes('total') ||
      column.toLowerCase().includes('revenue')) {
    return formatCurrency(value);
  }
  
  if (column.toLowerCase().includes('percent') || column.toLowerCase().includes('rate')) {
    return formatPercentage(value / 100);
  }
  
  return formatNumber(value);
}

function getTopCategoricalValues(values, limit) {
  if (!values || !Array.isArray(values) || values.length === 0) {
    return 'No values';
  }
  
  const counts = {};
  values.forEach(v => {
    if (v !== null) counts[v] = (counts[v] || 0) + 1;
  });
  
  const sorted = Object.entries(counts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, limit)
    .map(([val, count]) => `${val} (${formatPercentage(count / values.length)})`);
  
  return sorted.join(', ') + (Object.keys(counts).length > limit ? ', ...' : '');
}

function analyzeSeasonality(records, dateColumn, columns, columnTypes) {
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  if (numericColumns.length === 0) return null;
  
  const monthlyData = {};
  
  // Performance optimization: Use sampling for large datasets
  const samplingStrategy = createSamplingStrategy(records, 'timeseries');
  const sampledRecords = performSampling(records, samplingStrategy);
  
  SafeArrayOps.safeForEach(sampledRecords, record => {
    const date = safeGet(record, dateColumn);
    if (date instanceof Date) {
      const month = date.getMonth();
      if (!monthlyData[month]) monthlyData[month] = [];
      
      SafeArrayOps.safeForEach(numericColumns, col => {
        const value = safeGet(record, col);
        if (typeof value === 'number') {
          monthlyData[month].push(value);
        }
      });
    }
  });
  
  if (Object.keys(monthlyData).length < 6) return null;
  
  const monthlyAverages = Object.entries(monthlyData)
    .map(([month, values]) => ({
      month: parseInt(month),
      avg: values.reduce((a, b) => a + b, 0) / values.length
    }));
  
  const overallAvg = monthlyAverages.reduce((a, b) => a + b.avg, 0) / monthlyAverages.length;
  const peak = monthlyAverages.reduce((a, b) => a.avg > b.avg ? a : b);
  
  if (peak.avg > overallAvg * 1.2) {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];
    return `Strong seasonal pattern with ${monthNames[peak.month]} showing ${formatPercentage((peak.avg / overallAvg) - 1)} above average`;
  }
  
  return null;
}

function analyzeSegments(records, columns, columnTypes) {
  const segmentColumns = columns.filter(c => 
    c.toLowerCase().includes('segment') || 
    c.toLowerCase().includes('tier') ||
    c.toLowerCase().includes('type') ||
    c.toLowerCase().includes('category')
  ).filter(c => columnTypes[c] && columnTypes[c].type === 'categorical');
  
  if (segmentColumns.length === 0) return null;
  
  const valueColumns = columns.filter(c => 
    (c.toLowerCase().includes('amount') || c.toLowerCase().includes('value')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  if (valueColumns.length === 0) return null;
  
  const segmentCol = segmentColumns[0];
  const valueCol = valueColumns[0];
  
  const segmentStats = {};
  records.forEach(record => {
    const segment = record[segmentCol];
    const value = record[valueCol];
    
    if (segment && typeof value === 'number') {
      if (!segmentStats[segment]) {
        segmentStats[segment] = { sum: 0, count: 0 };
      }
      segmentStats[segment].sum += value;
      segmentStats[segment].count++;
    }
  });
  
  const segments = Object.entries(segmentStats)
    .map(([name, stats]) => ({
      name,
      average: stats.sum / stats.count,
      percentage: stats.count / records.length
    }))
    .sort((a, b) => b.average - a.average);
  
  if (segments.length >= 2) {
    const top = segments[0];
    const totalValue = segments.reduce((sum, s) => sum + s.average * s.percentage, 0);
    const topValueShare = (top.average * top.percentage) / totalValue;
    
    return {
      title: 'CUSTOMER BEHAVIOR',
      insight: `${top.name} customers account for ${formatPercentage(top.percentage)} of customer base but ${formatPercentage(topValueShare)} of value. Average ${valueCol}: ${formatCurrency(top.average)}`
    };
  }
  
  return null;
}

function analyzeCategoryPerformance(records, columns, columnTypes) {
  const categoryColumns = columns.filter(c => 
    (c.toLowerCase().includes('category') || c.toLowerCase().includes('product')) &&
    columnTypes[c] && columnTypes[c].type === 'categorical'
  );
  
  if (categoryColumns.length === 0) return null;
  
  const performanceColumns = columns.filter(c => 
    (c.toLowerCase().includes('margin') || 
     c.toLowerCase().includes('profit') ||
     c.toLowerCase().includes('revenue')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  if (performanceColumns.length === 0) return null;
  
  const categoryCol = categoryColumns[0];
  const perfCol = performanceColumns[0];
  
  const categoryPerformance = {};
  records.forEach(record => {
    const category = record[categoryCol];
    const performance = record[perfCol];
    
    if (category && typeof performance === 'number') {
      if (!categoryPerformance[category]) {
        categoryPerformance[category] = { values: [], count: 0 };
      }
      categoryPerformance[category].values.push(performance);
      categoryPerformance[category].count++;
    }
  });
  
  const categories = Object.entries(categoryPerformance)
    .map(([name, data]) => ({
      name,
      average: data.values.reduce((a, b) => a + b, 0) / data.values.length,
      volume: data.count
    }))
    .sort((a, b) => b.average - a.average);
  
  if (categories.length >= 2) {
    const highMargin = categories[0];
    const highVolume = categories.sort((a, b) => b.volume - a.volume)[0];
    
    if (highMargin.name !== highVolume.name) {
      return {
        title: 'PRODUCT PERFORMANCE',
        insight: `${highMargin.name} shows highest ${perfCol} (${formatNumber(highMargin.average)}) but ${highVolume.name} has highest volume (${highVolume.volume} records)`
      };
    }
  }
  
  return null;
}

function analyzePricing(records, columns, columnTypes) {
  const priceColumns = columns.filter(c => 
    c.toLowerCase().includes('price') &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  if (priceColumns.length === 0) return null;
  
  const priceCol = priceColumns[0];
  const prices = records.map(r => r[priceCol]).filter(p => typeof p === 'number' && p > 0);
  
  if (prices.length === 0) return null;
  
  // Check for psychological pricing
  const endingIn99 = prices.filter(p => {
    const cents = Math.round((p % 1) * 100);
    return cents === 99;
  });
  
  
  const roundPrices = prices.filter(p => p % 1 === 0);
  
  const insights = [];
  
  if (endingIn99.length > prices.length * 0.3) {
    insights.push(`${formatPercentage(endingIn99.length / prices.length)} of prices end in .99`);
  }
  
  if (roundPrices.length > prices.length * 0.4) {
    const commonRoundPrices = {};
    roundPrices.forEach(p => {
      commonRoundPrices[p] = (commonRoundPrices[p] || 0) + 1;
    });
    
    const topPrices = Object.entries(commonRoundPrices)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([price]) => formatCurrency(parseFloat(price)));
    
    insights.push(`Common price points: ${topPrices.join(', ')}`);
  }
  
  if (insights.length > 0) {
    insights.push('(psychological pricing effect detected)');
    return insights.join('. ');
  }
  
  return null;
}

function detectAnomalies(records, columns, columnTypes) {
  const anomalies = [];
  
  // Check for zero amounts
  const amountColumns = columns.filter(c => 
    c.toLowerCase().includes('amount') &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  amountColumns.forEach(col => {
    const zeros = records.filter(r => r[col] === 0).length;
    if (zeros > 0) {
      anomalies.push(`${zeros} transactions with $0 ${col} (likely returns or errors)`);
    }
  });
  
  // Check for suspicious patterns
  const idColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'identifier');
  if (idColumns.length > 0) {
    // Check for duplicate IDs
    const ids = records.map(r => r[idColumns[0]]).filter(id => id !== null);
    const uniqueIds = new Set(ids);
    if (uniqueIds.size < ids.length) {
      anomalies.push(`${ids.length - uniqueIds.size} duplicate ${idColumns[0]} values found`);
    }
  }
  
  // Check for outliers in date data
  const dateColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'date');
  if (dateColumns.length > 0) {
    const dates = records.map(r => r[dateColumns[0]]).filter(d => d instanceof Date);
    if (dates.length > 100) {
      const sorted = dates.sort((a, b) => a - b);
      const gaps = [];
      
      for (let i = 1; i < sorted.length; i++) {
        const daysDiff = (sorted[i] - sorted[i-1]) / (1000 * 60 * 60 * 24);
        if (daysDiff > 30) {
          gaps.push({ start: sorted[i-1], end: sorted[i], days: daysDiff });
        }
      }
      
      if (gaps.length > 0) {
        anomalies.push(`Data gaps detected: ${gaps.length} periods with >30 day gaps`);
      }
    }
  }
  
  return anomalies;
}

function calculateDataQuality(records, columns) {
  const totalCells = records.length * columns.length;
  let missingCells = 0;
  const missingByColumn = {};
  
  columns.forEach(col => {
    const missing = records.filter(r => r[col] === null || r[col] === undefined).length;
    missingCells += missing;
    if (missing > 0) {
      missingByColumn[col] = missing;
    }
  });
  
  const topMissing = Object.entries(missingByColumn)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 2)
    .map(([col, count]) => `${col} (${formatPercentage(count / records.length)})`);
  
  const duplicates = findDuplicateRows(records);
  
  return {
    completeness: (totalCells - missingCells) / totalCells,
    missingDetails: topMissing.length > 0 ? topMissing.join(', ') : 'No missing values',
    duplicates: duplicates.length,
    dateGaps: null // Will be filled by date analysis
  };
}

function findDuplicateRows(records) {
  const seen = new Set();
  const duplicates = [];
  
  records.forEach((record, idx) => {
    const key = JSON.stringify(record);
    if (seen.has(key)) {
      duplicates.push(idx);
    } else {
      seen.add(key);
    }
  });
  
  return duplicates;
}

function generateSummaryStatistics(records, columns, columnTypes) {
  const stats = [];
  
  // Total value statistics
  const valueColumns = columns.filter(c => 
    (c.toLowerCase().includes('amount') || 
     c.toLowerCase().includes('total') ||
     c.toLowerCase().includes('revenue')) &&
    columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type)
  );
  
  valueColumns.forEach(col => {
    const values = records.map(r => r[col]).filter(v => typeof v === 'number');
    if (values.length > 0) {
      const total = values.reduce((a, b) => a + b, 0);
      const avg = total / values.length;
      const sorted = [...values].sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];
      
      stats.push(`Total ${col}: ${formatCurrency(total)}`);
      stats.push(`Average ${col}: ${formatCurrency(avg)}`);
      stats.push(`Median ${col}: ${formatCurrency(median)}`);
    }
  });
  
  // Customer/entity statistics
  const customerColumns = columns.filter(c => 
    c.toLowerCase().includes('customer') && 
    columnTypes[c] && columnTypes[c].type === 'identifier'
  );
  
  if (customerColumns.length > 0) {
    const customers = new Set(records.map(r => r[customerColumns[0]]).filter(c => c !== null));
    const customerPurchases = {};
    
    records.forEach(record => {
      const customer = record[customerColumns[0]];
      if (customer) {
        customerPurchases[customer] = (customerPurchases[customer] || 0) + 1;
      }
    });
    
    const repeatCustomers = Object.values(customerPurchases).filter(count => count > 1).length;
    const retentionRate = repeatCustomers / customers.size;
    
    stats.push(`Customer retention rate: ${formatPercentage(retentionRate)} (based on repeat activity)`);
  }
  
  // Time-based statistics
  const dateColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'date');
  if (dateColumns.length > 0) {
    const dates = records.map(r => r[dateColumns[0]]).filter(d => d instanceof Date);
    
    if (dates.length > 0) {
      const dayOfWeekCounts = new Array(7).fill(0);
      const hourCounts = new Array(24).fill(0);
      
      dates.forEach(date => {
        dayOfWeekCounts[date.getDay()]++;
        hourCounts[date.getHours()]++;
      });
      
      const peakDay = dayOfWeekCounts.indexOf(Math.max(...dayOfWeekCounts));
      const peakHour = hourCounts.indexOf(Math.max(...hourCounts));
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      
      stats.push(`Most active day: ${dayNames[peakDay]} (${formatPercentage(dayOfWeekCounts[peakDay] / dates.length)} of activity)`);
      
      if (hourCounts.some(c => c > 0)) {
        stats.push(`Peak hour: ${peakHour}:00-${peakHour + 1}:00 (${formatPercentage(hourCounts[peakHour] / dates.length)} of activity)`);
      }
    }
  }
  
  return stats;
}

function findSignificantCorrelations(records, columns, columnTypes) {
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  const correlations = [];
  
  for (let i = 0; i < numericColumns.length; i++) {
    for (let j = i + 1; j < numericColumns.length; j++) {
      const col1 = numericColumns[i];
      const col2 = numericColumns[j];
      const values1 = records.map(r => r[col1]);
      const values2 = records.map(r => r[col2]);
      const corr = calculateCorrelation(values1, values2);
      
      if (corr !== null && Math.abs(corr) > 0.5) {
        const strength = Math.abs(corr) > 0.8 ? 'Strong' : 'Moderate';
        const direction = corr > 0 ? 'positive' : 'negative';
        correlations.push(`${strength} ${direction}: ${col1} vs ${col2} (${formatNumber(corr, 2)})`);
      }
    }
  }
  
  return correlations.slice(0, 5);
}

function generateAnalysisSuggestions(columns, columnTypes) {
  const suggestions = [];
  const dataType = inferDataType(columns, columnTypes);
  
  // Medical/Healthcare specific suggestions
  if (dataType === 'medical/healthcare data') {
    if (columns.some(c => c.toLowerCase().includes('patient'))) {
      suggestions.push('Patient outcome analysis and risk stratification');
      suggestions.push('Treatment effectiveness comparison');
    }
    if (columns.some(c => c.toLowerCase().includes('diagnosis') || c.toLowerCase().includes('condition'))) {
      suggestions.push('Disease progression modeling');
      suggestions.push('Comorbidity analysis');
    }
    if (columns.some(c => c.toLowerCase().includes('medication') || c.toLowerCase().includes('treatment'))) {
      suggestions.push('Treatment pattern analysis');
      suggestions.push('Medication adherence tracking');
    }
    if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
      suggestions.push('Temporal analysis of health trends');
      suggestions.push('Readmission risk prediction');
    }
    return suggestions;
  }
  
  // Scientific/Research specific suggestions
  if (dataType === 'scientific/research data') {
    suggestions.push('Statistical hypothesis testing');
    suggestions.push('Correlation and causation analysis');
    suggestions.push('Experimental design optimization');
    if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
      suggestions.push('Time series analysis of measurements');
    }
    return suggestions;
  }
  
  // Educational specific suggestions
  if (dataType === 'educational data') {
    suggestions.push('Student performance prediction');
    suggestions.push('Learning pattern analysis');
    suggestions.push('Grade distribution analysis');
    if (columns.some(c => c.toLowerCase().includes('attendance'))) {
      suggestions.push('Attendance impact on performance');
    }
    return suggestions;
  }
  
  // Default business suggestions for other data types
  // Check for customer analysis potential
  if (columns.some(c => c.toLowerCase().includes('customer'))) {
    suggestions.push('Customer Lifetime Value (CLV) calculation and segmentation');
  }
  
  // Check for product analysis
  if (columns.some(c => c.toLowerCase().includes('product') || c.toLowerCase().includes('sku'))) {
    suggestions.push('Market basket analysis to find product associations');
  }
  
  // Check for time series potential
  if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
    suggestions.push('Time series forecasting for demand prediction');
    
    if (columns.some(c => c.toLowerCase().includes('customer'))) {
      suggestions.push('Cohort analysis for customer retention');
    }
  }
  
  // Check for pricing analysis
  if (columns.some(c => c.toLowerCase().includes('price'))) {
    suggestions.push('Price elasticity analysis by product category');
  }
  
  // Check for churn analysis
  if (columns.some(c => c.toLowerCase().includes('status') || c.toLowerCase().includes('active'))) {
    suggestions.push('Churn prediction based on activity patterns');
  }
  
  // Check for inventory optimization
  if (columns.some(c => c.toLowerCase().includes('inventory') || c.toLowerCase().includes('stock'))) {
    suggestions.push('Inventory optimization based on sales velocity');
  }
  
  // Check for fraud detection
  if (columns.some(c => c.toLowerCase().includes('transaction'))) {
    suggestions.push('Fraud detection for suspicious transaction patterns');
  }
  
  // Check for A/B testing
  if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'categorical' && columnTypes[c].categories && columnTypes[c].categories.length === 2)) {
    suggestions.push('A/B test analysis for binary categorical variables');
  }
  
  return suggestions;
}

function generateDataQuestions(columns, columnTypes, dataType, records = []) {
  const questions = [];
  
  // Medical/Healthcare questions
  if (dataType === 'medical/healthcare data') {
    questions.push('What are the key risk factors for adverse patient outcomes?');
    questions.push('Which treatments show the highest effectiveness rates?');
    questions.push('Are there patterns in patient demographics and health conditions?');
    questions.push('What factors correlate with successful treatment outcomes?');
    questions.push('How do different patient groups respond to various treatments?');
  }
  // Scientific/Research questions
  else if (dataType === 'scientific/research data') {
    questions.push('What are the statistically significant findings?');
    questions.push('Which variables show the strongest correlations?');
    questions.push('Are there any unexpected patterns in the data?');
    questions.push('What factors influence the experimental outcomes?');
    questions.push('How do the results compare to the hypothesis?');
  }
  // Educational questions
  else if (dataType === 'educational data') {
    questions.push('What factors most influence student performance?');
    questions.push('Are there patterns in learning outcomes by demographics?');
    questions.push('Which teaching methods yield the best results?');
    questions.push('How does attendance correlate with grades?');
    questions.push('What early indicators predict student success?');
  }
  // Environmental questions
  else if (dataType === 'environmental data') {
    questions.push('What are the main environmental trends over time?');
    questions.push('Which factors contribute most to environmental changes?');
    questions.push('Are there seasonal patterns in the data?');
    questions.push('What are the critical threshold values?');
    questions.push('How do different regions compare?');
  }
  // Manufacturing questions
  else if (dataType === 'manufacturing/quality data') {
    questions.push('What are the main causes of defects?');
    questions.push('Which production lines have the highest quality?');
    questions.push('Are there patterns in quality issues by shift or time?');
    questions.push('What factors correlate with production efficiency?');
    questions.push('How can the process be optimized?');
  }
  // Business/Sales questions (only for actual business data)
  else if (dataType.includes('sales') || dataType.includes('transaction')) {
    questions.push('What factors drive sales performance?');
    questions.push('Which products/services generate the most revenue?');
    questions.push('What are the seasonal trends in sales?');
  }
  else if (dataType.includes('customer')) {
    questions.push('What factors drive customer loyalty?');
    questions.push('Which customer segments are most valuable?');
    questions.push('What is the typical customer journey?');
  }
  
  // Column-specific questions
  if (columns.some(c => c.toLowerCase().includes('price'))) {
    questions.push('How does pricing affect purchase behavior?');
    questions.push('What is the optimal pricing strategy?');
  }
  
  if (columns.some(c => c.toLowerCase().includes('discount'))) {
    questions.push('What is the optimal discount strategy?');
    questions.push('How do discounts impact profitability?');
  }
  
  if (columns.some(c => c.toLowerCase().includes('category'))) {
    questions.push('Which categories perform best?');
    questions.push('How do categories differ in customer behavior?');
  }
  
  if (columns.some(c => columnTypes[c] && columnTypes[c].type === 'date')) {
    questions.push('What are the growth trends over time?');
    questions.push('Are there any cyclical patterns?');
  }
  
  // Risk-related questions
  if (records && records.length > 1000) {
    questions.push('Which records represent outliers or anomalies?');
    questions.push('What patterns indicate risk or opportunity?');
  }
  
  return questions.slice(0, 8);
}

async function generateTechnicalNotes(records, columns, columnTypes) {
  const notes = [];
  
  // Check for skewed distributions
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  
  for (const col of numericColumns) {
    const values = records.map(r => r[col]).filter(v => typeof v === 'number');
    if (values.length > 0) {
      const dist = await analyzeDistribution(values);
      if (Math.abs(dist.skewness) > 2) {
        notes.push(`Log transformation recommended for ${col} (heavy ${dist.skewness > 0 ? 'right' : 'left'} skew)`);
      }
    }
  }
  
  // Check for cyclical features
  const dateColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'date');
  if (dateColumns.length > 0) {
    notes.push('Consider encoding cyclical features for day_of_week and month');
  }
  
  // Check for high cardinality
  const highCardColumns = columns.filter(c => {
    if (columnTypes[c] && columnTypes[c].type === 'identifier') return true;
    if (columnTypes[c] && columnTypes[c].type === 'categorical' && columnTypes[c].categories) {
      return columnTypes[c].categories.length > 50;
    }
    return false;
  });
  
  if (highCardColumns.length > 0) {
    notes.push(`${highCardColumns[0]} has high cardinality - consider embedding approaches`);
  }
  
  // Time series recommendations
  if (dateColumns.length > 0 && records.length > 100) {
    notes.push('Time series shows trend and seasonality - STL decomposition recommended');
  }
  
  // Sampling recommendations
  if (records.length > 100000) {
    notes.push('Large dataset - consider stratified sampling for initial exploration');
  }
  
  return notes;
}

function generateValidationQueries(columns, columnTypes, records) {
  const queries = [];
  const tableName = 'your_table'; // Placeholder
  
  // Check for orphaned foreign keys
  columns.forEach(col => {
    if (col.toLowerCase().includes('_id') && !col.toLowerCase().includes('transaction_id')) {
      const targetTable = col.replace('_id', '').toLowerCase();
      queries.push({
        purpose: `Verify ${col} foreign key relationship`,
        sql: `SELECT COUNT(*) as orphaned_records 
FROM ${tableName} t1
WHERE t1.${col} NOT IN (
  SELECT ${col} FROM ${targetTable}
) AND t1.${col} IS NOT NULL`
      });
    }
  });
  
  // Check date format consistency
  const dateColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'date');
  dateColumns.forEach(col => {
    queries.push({
      purpose: `Check ${col} date format consistency`,
      sql: `SELECT 
  COUNT(DISTINCT DATE_FORMAT(${col}, '%Y-%m-%d')) as formats,
  MIN(${col}) as earliest_date,
  MAX(${col}) as latest_date
FROM ${tableName}
WHERE ${col} IS NOT NULL`
    });
  });
  
  // Check for duplicate identifiers
  const idColumns = columns.filter(c => columnTypes[c] && columnTypes[c].type === 'identifier');
  if (idColumns.length > 0) {
    queries.push({
      purpose: `Check for duplicate ${idColumns[0]} values`,
      sql: `SELECT ${idColumns[0]}, COUNT(*) as occurrences
FROM ${tableName}
GROUP BY ${idColumns[0]}
HAVING COUNT(*) > 1
ORDER BY occurrences DESC
LIMIT 10`
    });
  }
  
  // Check numeric column ranges
  const numericColumns = columns.filter(c => columnTypes[c] && ['integer', 'float'].includes(columnTypes[c].type));
  if (numericColumns.length > 0) {
    const col = numericColumns[0];
    queries.push({
      purpose: `Verify ${col} value ranges and outliers`,
      sql: `WITH stats AS (
  SELECT 
    AVG(${col}) as mean,
    STDDEV(${col}) as std_dev
  FROM ${tableName}
  WHERE ${col} IS NOT NULL
)
SELECT COUNT(*) as outliers
FROM ${tableName}, stats
WHERE ${col} > mean + 3 * std_dev
   OR ${col} < mean - 3 * std_dev`
    });
  }
  
  return queries.slice(0, 5); // Limit to 5 most relevant queries
}

async function runAll(filePath, options = {}) {
  console.log(createSection('COMPLETE DATAPILOT ANALYSIS', 
    `File: ${filePath}\nTimestamp: ${new Date().toISOString()}`));
  console.log('');
  
  const spinner = ora('Running complete analysis suite...').start();
  
  let output = '';
  const captureOutput = (text) => {
    output += text + '\n';
  };
  
  // Temporarily override console.log to capture output
  const originalLog = console.log;
  if (options.output) {
    console.log = captureOutput;
  }
  
  try {
    // Parse the CSV once with options
    spinner.text = 'Parsing CSV file...';
    const records = await parseCSV(filePath, { 
      quiet: true,
      noSampling: !options.quick,
      header: options.header 
    });
    
    const columnTypes = detectColumnTypes(records);
    
    // Section divider
    const sectionDivider = '\n' + '='.repeat(80) + '\n';
    
    // Run each analysis in sequence
    spinner.text = 'Running exploratory data analysis...';
    console.log(sectionDivider);
    console.log('1. EXPLORATORY DATA ANALYSIS (EDA)');
    console.log(sectionDivider);
    await eda(filePath, { quiet: true, preloadedData: { records, columnTypes } });
    
    spinner.text = 'Running data integrity check...';
    console.log(sectionDivider);
    console.log('2. DATA INTEGRITY CHECK');
    console.log(sectionDivider);
    await integrity(filePath, { quiet: true, preloadedData: { records, columnTypes } });
    
    spinner.text = 'Generating visualization recommendations...';
    console.log(sectionDivider);
    console.log('3. VISUALIZATION RECOMMENDATIONS');
    console.log(sectionDivider);
    await visualize(filePath, { quiet: true, preloadedData: { records, columnTypes } });
    
    spinner.text = 'Running engineering analysis...';
    console.log(sectionDivider);
    console.log('4. DATA ENGINEERING ANALYSIS');
    console.log(sectionDivider);
    await engineering(filePath, { quiet: true, preloadedData: { records, columnTypes } });
    
    spinner.text = 'Generating LLM context...';
    console.log(sectionDivider);
    console.log('5. LLM CONTEXT GENERATION');
    console.log(sectionDivider);
    await llmContext(filePath, { quiet: true, preloadedData: { records, columnTypes } });
    
    // Summary section
    console.log(sectionDivider);
    console.log('ANALYSIS COMPLETE');
    console.log(sectionDivider);
    console.log(createSubSection('Summary', ''));
    console.log(`- Total rows analyzed: ${records.length.toLocaleString()}`);
    console.log(`- Total columns: ${Object.keys(columnTypes).length}`);
    console.log(`- Analysis timestamp: ${new Date().toISOString()}`);
    
    if (options.quick) {
      console.log(chalk.yellow('\n⚡ Quick mode: Some detailed analyses were skipped for speed'));
    }
    
    // Restore console.log
    console.log = originalLog;
    
    spinner.succeed('Complete analysis finished');
    
    // Write to file if output option is specified
    if (options.output) {
      writeFileSync(options.output, output);
      console.log(chalk.green(`\n✓ Analysis saved to: ${options.output}`));
      
      // Also show a preview
      console.log(chalk.gray('\nPreview of saved analysis:'));
      const lines = output.split('\n').slice(0, 10);
      lines.forEach(line => console.log(chalk.gray(line)));
      if (output.split('\n').length > 10) {
        console.log(chalk.gray('... (truncated)'));
      }
    }
    
  } catch (error) {
    outputHandler.restore();
    spinner.error({ text: 'Analysis failed' });
    console.error('Error during analysis:', error.message);
    if (!options.quiet) process.exit(1);
    throw error;
  }
}

var utils = {};

var ansiColors = {exports: {}};

var symbols = {exports: {}};

var hasRequiredSymbols$1;

function requireSymbols$1 () {
	if (hasRequiredSymbols$1) return symbols.exports;
	hasRequiredSymbols$1 = 1;
	(function (module) {

		const isHyper = typeof process !== 'undefined' && process.env.TERM_PROGRAM === 'Hyper';
		const isWindows = typeof process !== 'undefined' && process.platform === 'win32';
		const isLinux = typeof process !== 'undefined' && process.platform === 'linux';

		const common = {
		  ballotDisabled: '☒',
		  ballotOff: '☐',
		  ballotOn: '☑',
		  bullet: '•',
		  bulletWhite: '◦',
		  fullBlock: '█',
		  heart: '❤',
		  identicalTo: '≡',
		  line: '─',
		  mark: '※',
		  middot: '·',
		  minus: '－',
		  multiplication: '×',
		  obelus: '÷',
		  pencilDownRight: '✎',
		  pencilRight: '✏',
		  pencilUpRight: '✐',
		  percent: '%',
		  pilcrow2: '❡',
		  pilcrow: '¶',
		  plusMinus: '±',
		  question: '?',
		  section: '§',
		  starsOff: '☆',
		  starsOn: '★',
		  upDownArrow: '↕'
		};

		const windows = Object.assign({}, common, {
		  check: '√',
		  cross: '×',
		  ellipsisLarge: '...',
		  ellipsis: '...',
		  info: 'i',
		  questionSmall: '?',
		  pointer: '>',
		  pointerSmall: '»',
		  radioOff: '( )',
		  radioOn: '(*)',
		  warning: '‼'
		});

		const other = Object.assign({}, common, {
		  ballotCross: '✘',
		  check: '✔',
		  cross: '✖',
		  ellipsisLarge: '⋯',
		  ellipsis: '…',
		  info: 'ℹ',
		  questionFull: '？',
		  questionSmall: '﹖',
		  pointer: isLinux ? '▸' : '❯',
		  pointerSmall: isLinux ? '‣' : '›',
		  radioOff: '◯',
		  radioOn: '◉',
		  warning: '⚠'
		});

		module.exports = (isWindows && !isHyper) ? windows : other;
		Reflect.defineProperty(module.exports, 'common', { enumerable: false, value: common });
		Reflect.defineProperty(module.exports, 'windows', { enumerable: false, value: windows });
		Reflect.defineProperty(module.exports, 'other', { enumerable: false, value: other }); 
	} (symbols));
	return symbols.exports;
}

var hasRequiredAnsiColors;

function requireAnsiColors () {
	if (hasRequiredAnsiColors) return ansiColors.exports;
	hasRequiredAnsiColors = 1;

	const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

	/* eslint-disable no-control-regex */
	// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)
	const ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;

	const hasColor = () => {
	  if (typeof process !== 'undefined') {
	    return process.env.FORCE_COLOR !== '0';
	  }
	  return false;
	};

	const create = () => {
	  const colors = {
	    enabled: hasColor(),
	    visible: true,
	    styles: {},
	    keys: {}
	  };

	  const ansi = style => {
	    let open = style.open = `\u001b[${style.codes[0]}m`;
	    let close = style.close = `\u001b[${style.codes[1]}m`;
	    let regex = style.regex = new RegExp(`\\u001b\\[${style.codes[1]}m`, 'g');
	    style.wrap = (input, newline) => {
	      if (input.includes(close)) input = input.replace(regex, close + open);
	      let output = open + input + close;
	      // see https://github.com/chalk/chalk/pull/92, thanks to the
	      // chalk contributors for this fix. However, we've confirmed that
	      // this issue is also present in Windows terminals
	      return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
	    };
	    return style;
	  };

	  const wrap = (style, input, newline) => {
	    return typeof style === 'function' ? style(input) : style.wrap(input, newline);
	  };

	  const style = (input, stack) => {
	    if (input === '' || input == null) return '';
	    if (colors.enabled === false) return input;
	    if (colors.visible === false) return '';
	    let str = '' + input;
	    let nl = str.includes('\n');
	    let n = stack.length;
	    if (n > 0 && stack.includes('unstyle')) {
	      stack = [...new Set(['unstyle', ...stack])].reverse();
	    }
	    while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
	    return str;
	  };

	  const define = (name, codes, type) => {
	    colors.styles[name] = ansi({ name, codes });
	    let keys = colors.keys[type] || (colors.keys[type] = []);
	    keys.push(name);

	    Reflect.defineProperty(colors, name, {
	      configurable: true,
	      enumerable: true,
	      set(value) {
	        colors.alias(name, value);
	      },
	      get() {
	        let color = input => style(input, color.stack);
	        Reflect.setPrototypeOf(color, colors);
	        color.stack = this.stack ? this.stack.concat(name) : [name];
	        return color;
	      }
	    });
	  };

	  define('reset', [0, 0], 'modifier');
	  define('bold', [1, 22], 'modifier');
	  define('dim', [2, 22], 'modifier');
	  define('italic', [3, 23], 'modifier');
	  define('underline', [4, 24], 'modifier');
	  define('inverse', [7, 27], 'modifier');
	  define('hidden', [8, 28], 'modifier');
	  define('strikethrough', [9, 29], 'modifier');

	  define('black', [30, 39], 'color');
	  define('red', [31, 39], 'color');
	  define('green', [32, 39], 'color');
	  define('yellow', [33, 39], 'color');
	  define('blue', [34, 39], 'color');
	  define('magenta', [35, 39], 'color');
	  define('cyan', [36, 39], 'color');
	  define('white', [37, 39], 'color');
	  define('gray', [90, 39], 'color');
	  define('grey', [90, 39], 'color');

	  define('bgBlack', [40, 49], 'bg');
	  define('bgRed', [41, 49], 'bg');
	  define('bgGreen', [42, 49], 'bg');
	  define('bgYellow', [43, 49], 'bg');
	  define('bgBlue', [44, 49], 'bg');
	  define('bgMagenta', [45, 49], 'bg');
	  define('bgCyan', [46, 49], 'bg');
	  define('bgWhite', [47, 49], 'bg');

	  define('blackBright', [90, 39], 'bright');
	  define('redBright', [91, 39], 'bright');
	  define('greenBright', [92, 39], 'bright');
	  define('yellowBright', [93, 39], 'bright');
	  define('blueBright', [94, 39], 'bright');
	  define('magentaBright', [95, 39], 'bright');
	  define('cyanBright', [96, 39], 'bright');
	  define('whiteBright', [97, 39], 'bright');

	  define('bgBlackBright', [100, 49], 'bgBright');
	  define('bgRedBright', [101, 49], 'bgBright');
	  define('bgGreenBright', [102, 49], 'bgBright');
	  define('bgYellowBright', [103, 49], 'bgBright');
	  define('bgBlueBright', [104, 49], 'bgBright');
	  define('bgMagentaBright', [105, 49], 'bgBright');
	  define('bgCyanBright', [106, 49], 'bgBright');
	  define('bgWhiteBright', [107, 49], 'bgBright');

	  colors.ansiRegex = ANSI_REGEX;
	  colors.hasColor = colors.hasAnsi = str => {
	    colors.ansiRegex.lastIndex = 0;
	    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
	  };

	  colors.alias = (name, color) => {
	    let fn = typeof color === 'string' ? colors[color] : color;

	    if (typeof fn !== 'function') {
	      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
	    }

	    if (!fn.stack) {
	      Reflect.defineProperty(fn, 'name', { value: name });
	      colors.styles[name] = fn;
	      fn.stack = [name];
	    }

	    Reflect.defineProperty(colors, name, {
	      configurable: true,
	      enumerable: true,
	      set(value) {
	        colors.alias(name, value);
	      },
	      get() {
	        let color = input => style(input, color.stack);
	        Reflect.setPrototypeOf(color, colors);
	        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
	        return color;
	      }
	    });
	  };

	  colors.theme = custom => {
	    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');
	    for (let name of Object.keys(custom)) {
	      colors.alias(name, custom[name]);
	    }
	    return colors;
	  };

	  colors.alias('unstyle', str => {
	    if (typeof str === 'string' && str !== '') {
	      colors.ansiRegex.lastIndex = 0;
	      return str.replace(colors.ansiRegex, '');
	    }
	    return '';
	  });

	  colors.alias('noop', str => str);
	  colors.none = colors.clear = colors.noop;

	  colors.stripColor = colors.unstyle;
	  colors.symbols = requireSymbols$1();
	  colors.define = define;
	  return colors;
	};

	ansiColors.exports = create();
	ansiColors.exports.create = create;
	return ansiColors.exports;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {

		const toString = Object.prototype.toString;
		const colors = requireAnsiColors();
		let onExitCalled = false;
		let onExitCallbacks = new Set();

		const complements = {
		  'yellow': 'blue',
		  'cyan': 'red',
		  'green': 'magenta',
		  'black': 'white',
		  'blue': 'yellow',
		  'red': 'cyan',
		  'magenta': 'green',
		  'white': 'black'
		};

		exports.longest = (arr, prop) => {
		  return arr.reduce((a, v) => Math.max(a, prop ? v[prop].length : v.length), 0);
		};

		exports.hasColor = str => !!str && colors.hasColor(str);

		const isObject = exports.isObject = val => {
		  return val !== null && typeof val === 'object' && !Array.isArray(val);
		};

		exports.nativeType = val => {
		  return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, '');
		};

		exports.isAsyncFn = val => {
		  return exports.nativeType(val) === 'asyncfunction';
		};

		exports.isPrimitive = val => {
		  return val != null && typeof val !== 'object' && typeof val !== 'function';
		};

		exports.resolve = (context, value, ...rest) => {
		  if (typeof value === 'function') {
		    return value.call(context, ...rest);
		  }
		  return value;
		};

		exports.scrollDown = (choices = []) => [...choices.slice(1), choices[0]];
		exports.scrollUp = (choices = []) => [choices.pop(), ...choices];

		exports.reorder = (arr = []) => {
		  let res = arr.slice();
		  res.sort((a, b) => {
		    if (a.index > b.index) return 1;
		    if (a.index < b.index) return -1;
		    return 0;
		  });
		  return res;
		};

		exports.swap = (arr, index, pos) => {
		  let len = arr.length;
		  let idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
		  let choice = arr[index];
		  arr[index] = arr[idx];
		  arr[idx] = choice;
		};

		exports.width = (stream, fallback = 80) => {
		  let columns = (stream && stream.columns) ? stream.columns : fallback;
		  if (stream && typeof stream.getWindowSize === 'function') {
		    columns = stream.getWindowSize()[0];
		  }
		  if (process.platform === 'win32') {
		    return columns - 1;
		  }
		  return columns;
		};

		exports.height = (stream, fallback = 20) => {
		  let rows = (stream && stream.rows) ? stream.rows : fallback;
		  if (stream && typeof stream.getWindowSize === 'function') {
		    rows = stream.getWindowSize()[1];
		  }
		  return rows;
		};

		exports.wordWrap = (str, options = {}) => {
		  if (!str) return str;

		  if (typeof options === 'number') {
		    options = { width: options };
		  }

		  let { indent = '', newline = ('\n' + indent), width = 80 } = options;
		  let spaces = (newline + indent).match(/[^\S\n]/g) || [];
		  width -= spaces.length;
		  let source = `.{1,${width}}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)`;
		  let output = str.trim();
		  let regex = new RegExp(source, 'g');
		  let lines = output.match(regex) || [];
		  lines = lines.map(line => line.replace(/\n$/, ''));
		  if (options.padEnd) lines = lines.map(line => line.padEnd(width, ' '));
		  if (options.padStart) lines = lines.map(line => line.padStart(width, ' '));
		  return indent + lines.join(newline);
		};

		exports.unmute = color => {
		  let name = color.stack.find(n => colors.keys.color.includes(n));
		  if (name) {
		    return colors[name];
		  }
		  let bg = color.stack.find(n => n.slice(2) === 'bg');
		  if (bg) {
		    return colors[name.slice(2)];
		  }
		  return str => str;
		};

		exports.pascal = str => str ? str[0].toUpperCase() + str.slice(1) : '';

		exports.inverse = color => {
		  if (!color || !color.stack) return color;
		  let name = color.stack.find(n => colors.keys.color.includes(n));
		  if (name) {
		    let col = colors['bg' + exports.pascal(name)];
		    return col ? col.black : color;
		  }
		  let bg = color.stack.find(n => n.slice(0, 2) === 'bg');
		  if (bg) {
		    return colors[bg.slice(2).toLowerCase()] || color;
		  }
		  return colors.none;
		};

		exports.complement = color => {
		  if (!color || !color.stack) return color;
		  let name = color.stack.find(n => colors.keys.color.includes(n));
		  let bg = color.stack.find(n => n.slice(0, 2) === 'bg');
		  if (name && !bg) {
		    return colors[complements[name] || name];
		  }
		  if (bg) {
		    let lower = bg.slice(2).toLowerCase();
		    let comp = complements[lower];
		    if (!comp) return color;
		    return colors['bg' + exports.pascal(comp)] || color;
		  }
		  return colors.none;
		};

		exports.meridiem = date => {
		  let hours = date.getHours();
		  let minutes = date.getMinutes();
		  let ampm = hours >= 12 ? 'pm' : 'am';
		  hours = hours % 12;
		  let hrs = hours === 0 ? 12 : hours;
		  let min = minutes < 10 ? '0' + minutes : minutes;
		  return hrs + ':' + min + ' ' + ampm;
		};

		/**
		 * Set a value on the given object.
		 * @param {Object} obj
		 * @param {String} prop
		 * @param {any} value
		 */

		exports.set = (obj = {}, prop = '', val) => {
		  return prop.split('.').reduce((acc, k, i, arr) => {
		    let value = arr.length - 1 > i ? (acc[k] || {}) : val;
		    if (!exports.isObject(value) && i < arr.length - 1) value = {};
		    return (acc[k] = value);
		  }, obj);
		};

		/**
		 * Get a value from the given object.
		 * @param {Object} obj
		 * @param {String} prop
		 */

		exports.get = (obj = {}, prop = '', fallback) => {
		  let value = obj[prop] == null
		    ? prop.split('.').reduce((acc, k) => acc && acc[k], obj)
		    : obj[prop];
		  return value == null ? fallback : value;
		};

		exports.mixin = (target, b) => {
		  if (!isObject(target)) return b;
		  if (!isObject(b)) return target;
		  for (let key of Object.keys(b)) {
		    let desc = Object.getOwnPropertyDescriptor(b, key);
		    if (hasOwnProperty.call(desc, 'value')) {
		      if (hasOwnProperty.call(target, key) && isObject(desc.value)) {
		        let existing = Object.getOwnPropertyDescriptor(target, key);
		        if (isObject(existing.value) && existing.value !== desc.value) {
		          target[key] = exports.merge({}, target[key], b[key]);
		        } else {
		          Reflect.defineProperty(target, key, desc);
		        }
		      } else {
		        Reflect.defineProperty(target, key, desc);
		      }
		    } else {
		      Reflect.defineProperty(target, key, desc);
		    }
		  }
		  return target;
		};

		exports.merge = (...args) => {
		  let target = {};
		  for (let ele of args) exports.mixin(target, ele);
		  return target;
		};

		exports.mixinEmitter = (obj, emitter) => {
		  let proto = emitter.constructor.prototype;
		  for (let key of Object.keys(proto)) {
		    let val = proto[key];
		    if (typeof val === 'function') {
		      exports.define(obj, key, val.bind(emitter));
		    } else {
		      exports.define(obj, key, val);
		    }
		  }
		};

		const onExit = (quit, code) => {
		  if (onExitCalled) return;

		  onExitCalled = true;
		  onExitCallbacks.forEach(fn => fn());

		  if (quit === true) {
		    process.exit(128 + code);
		  }
		};
		const onSigTerm = onExit.bind(null, true, 15);
		const onSigInt = onExit.bind(null, true, 2);

		exports.onExit = callback => {
		  if (onExitCallbacks.size === 0) {
		    process.once('SIGTERM', onSigTerm);
		    process.once('SIGINT', onSigInt);
		    process.once('exit', onExit);
		  }

		  onExitCallbacks.add(callback);

		  return () => {
		    onExitCallbacks.delete(callback);
		    if (onExitCallbacks.size === 0) {
		      process.off('SIGTERM', onSigTerm);
		      process.off('SIGINT', onSigInt);
		      process.off('exit', onExit);
		    }
		  }
		};

		exports.define = (obj, key, value) => {
		  Reflect.defineProperty(obj, key, { value });
		};

		exports.defineExport = (obj, key, fn) => {
		  let custom;
		  Reflect.defineProperty(obj, key, {
		    enumerable: true,
		    configurable: true,
		    set(val) {
		      custom = val;
		    },
		    get() {
		      return custom ? custom() : fn();
		    }
		  });
		}; 
	} (utils));
	return utils;
}

var ansiRegex$2;
var hasRequiredAnsiRegex;

function requireAnsiRegex () {
	if (hasRequiredAnsiRegex) return ansiRegex$2;
	hasRequiredAnsiRegex = 1;

	ansiRegex$2 = ({onlyFirst = false} = {}) => {
		const pattern = [
			'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
			'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
		].join('|');

		return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};
	return ansiRegex$2;
}

var stripAnsi$2;
var hasRequiredStripAnsi;

function requireStripAnsi () {
	if (hasRequiredStripAnsi) return stripAnsi$2;
	hasRequiredStripAnsi = 1;
	const ansiRegex = requireAnsiRegex();

	stripAnsi$2 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
	return stripAnsi$2;
}

var combos = {};

var hasRequiredCombos;

function requireCombos () {
	if (hasRequiredCombos) return combos;
	hasRequiredCombos = 1;

	/**
	 * Actions are mappings from keypress event names to method names
	 * in the prompts.
	 */

	combos.ctrl = {
	  a: 'first',
	  b: 'backward',
	  c: 'cancel',
	  d: 'deleteForward',
	  e: 'last',
	  f: 'forward',
	  g: 'reset',
	  i: 'tab',
	  k: 'cutForward',
	  l: 'reset',
	  n: 'newItem',
	  m: 'cancel',
	  j: 'submit',
	  p: 'search',
	  r: 'remove',
	  s: 'save',
	  u: 'undo',
	  w: 'cutLeft',
	  x: 'toggleCursor',
	  v: 'paste'
	};

	combos.shift = {
	  up: 'shiftUp',
	  down: 'shiftDown',
	  left: 'shiftLeft',
	  right: 'shiftRight',
	  tab: 'prev'
	};

	combos.fn = {
	  up: 'pageUp',
	  down: 'pageDown',
	  left: 'pageLeft',
	  right: 'pageRight',
	  delete: 'deleteForward'
	};

	// <alt> on Windows
	combos.option = {
	  b: 'backward',
	  f: 'forward',
	  d: 'cutRight',
	  left: 'cutLeft',
	  up: 'altUp',
	  down: 'altDown'
	};

	combos.keys = {
	  pageup: 'pageUp', // <fn>+<up> (mac), <Page Up> (windows)
	  pagedown: 'pageDown', // <fn>+<down> (mac), <Page Down> (windows)
	  home: 'home', // <fn>+<left> (mac), <home> (windows)
	  end: 'end', // <fn>+<right> (mac), <end> (windows)
	  cancel: 'cancel',
	  delete: 'deleteForward',
	  backspace: 'delete',
	  down: 'down',
	  enter: 'submit',
	  escape: 'cancel',
	  left: 'left',
	  space: 'space',
	  number: 'number',
	  return: 'submit',
	  right: 'right',
	  tab: 'next',
	  up: 'up'
	};
	return combos;
}

var queue;
var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue;
	hasRequiredQueue = 1;

	queue = class Queue {
	  _queue = [];
	  _executing = false;
	  _jobRunner = null;

	  constructor(jobRunner) {
	    this._jobRunner = jobRunner;
	  }

	  enqueue = (...args) => {
	    this._queue.push(args);
	    this._dequeue();
	  };

	  destroy() {
	    this._queue.length = 0;
	    this._jobRunner = null;
	  }

	  _dequeue() {
	    if (this._executing || !this._queue.length) return;
	    this._executing = true;

	    this._jobRunner(...this._queue.shift());

	    setTimeout(() => {
	      this._executing = false;
	      this._dequeue();
	    });
	  }
	};
	return queue;
}

var keypress_1;
var hasRequiredKeypress;

function requireKeypress () {
	if (hasRequiredKeypress) return keypress_1;
	hasRequiredKeypress = 1;

	const readline = require$$0$7;
	const combos = requireCombos();
	const Queue = requireQueue();

	/* eslint-disable no-control-regex */
	const metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
	const fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
	const keyName = {
	  /* xterm/gnome ESC O letter */
	  'OP': 'f1',
	  'OQ': 'f2',
	  'OR': 'f3',
	  'OS': 'f4',
	  /* xterm/rxvt ESC [ number ~ */
	  '[11~': 'f1',
	  '[12~': 'f2',
	  '[13~': 'f3',
	  '[14~': 'f4',
	  /* from Cygwin and used in libuv */
	  '[[A': 'f1',
	  '[[B': 'f2',
	  '[[C': 'f3',
	  '[[D': 'f4',
	  '[[E': 'f5',
	  /* common */
	  '[15~': 'f5',
	  '[17~': 'f6',
	  '[18~': 'f7',
	  '[19~': 'f8',
	  '[20~': 'f9',
	  '[21~': 'f10',
	  '[23~': 'f11',
	  '[24~': 'f12',
	  /* xterm ESC [ letter */
	  '[A': 'up',
	  '[B': 'down',
	  '[C': 'right',
	  '[D': 'left',
	  '[E': 'clear',
	  '[F': 'end',
	  '[H': 'home',
	  /* xterm/gnome ESC O letter */
	  'OA': 'up',
	  'OB': 'down',
	  'OC': 'right',
	  'OD': 'left',
	  'OE': 'clear',
	  'OF': 'end',
	  'OH': 'home',
	  /* xterm/rxvt ESC [ number ~ */
	  '[1~': 'home',
	  '[2~': 'insert',
	  '[3~': 'delete',
	  '[4~': 'end',
	  '[5~': 'pageup',
	  '[6~': 'pagedown',
	  /* putty */
	  '[[5~': 'pageup',
	  '[[6~': 'pagedown',
	  /* rxvt */
	  '[7~': 'home',
	  '[8~': 'end',
	  /* rxvt keys with modifiers */
	  '[a': 'up',
	  '[b': 'down',
	  '[c': 'right',
	  '[d': 'left',
	  '[e': 'clear',

	  '[2$': 'insert',
	  '[3$': 'delete',
	  '[5$': 'pageup',
	  '[6$': 'pagedown',
	  '[7$': 'home',
	  '[8$': 'end',

	  'Oa': 'up',
	  'Ob': 'down',
	  'Oc': 'right',
	  'Od': 'left',
	  'Oe': 'clear',

	  '[2^': 'insert',
	  '[3^': 'delete',
	  '[5^': 'pageup',
	  '[6^': 'pagedown',
	  '[7^': 'home',
	  '[8^': 'end',
	  /* misc. */
	  '[Z': 'tab'
	};

	function isShiftKey(code) {
	  return ['[a', '[b', '[c', '[d', '[e', '[2$', '[3$', '[5$', '[6$', '[7$', '[8$', '[Z'].includes(code);
	}

	function isCtrlKey(code) {
	  return [ 'Oa', 'Ob', 'Oc', 'Od', 'Oe', '[2^', '[3^', '[5^', '[6^', '[7^', '[8^'].includes(code);
	}

	const keypress = (s = '', event = {}) => {
	  let parts;
	  let key = {
	    name: event.name,
	    ctrl: false,
	    meta: false,
	    shift: false,
	    option: false,
	    sequence: s,
	    raw: s,
	    ...event
	  };

	  if (Buffer.isBuffer(s)) {
	    if (s[0] > 127 && s[1] === void 0) {
	      s[0] -= 128;
	      s = '\x1b' + String(s);
	    } else {
	      s = String(s);
	    }
	  } else if (s !== void 0 && typeof s !== 'string') {
	    s = String(s);
	  } else if (!s) {
	    s = key.sequence || '';
	  }

	  key.sequence = key.sequence || s || key.name;

	  if (s === '\r') {
	    // carriage return
	    key.raw = void 0;
	    key.name = 'return';
	  } else if (s === '\n') {
	    // enter, should have been called linefeed
	    key.name = 'enter';
	  } else if (s === '\t') {
	    // tab
	    key.name = 'tab';
	  } else if (s === '\b' || s === '\x7f' || s === '\x1b\x7f' || s === '\x1b\b') {
	    // backspace or ctrl+h
	    key.name = 'backspace';
	    key.meta = s.charAt(0) === '\x1b';
	  } else if (s === '\x1b' || s === '\x1b\x1b') {
	    // escape key
	    key.name = 'escape';
	    key.meta = s.length === 2;
	  } else if (s === ' ' || s === '\x1b ') {
	    key.name = 'space';
	    key.meta = s.length === 2;
	  } else if (s <= '\x1a') {
	    // ctrl+letter
	    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
	    key.ctrl = true;
	  } else if (s.length === 1 && s >= '0' && s <= '9') {
	    // number
	    key.name = 'number';
	  } else if (s.length === 1 && s >= 'a' && s <= 'z') {
	    // lowercase letter
	    key.name = s;
	  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
	    // shift+letter
	    key.name = s.toLowerCase();
	    key.shift = true;
	  } else if ((parts = metaKeyCodeRe.exec(s))) {
	    // meta+character key
	    key.meta = true;
	    key.shift = /^[A-Z]$/.test(parts[1]);
	  } else if ((parts = fnKeyRe.exec(s))) {
	    let segs = [...s];

	    if (segs[0] === '\u001b' && segs[1] === '\u001b') {
	      key.option = true;
	    }

	    // ansi escape sequence
	    // reassemble the key code leaving out leading \x1b's,
	    // the modifier key bitflag and any meaningless "1;" sequence
	    let code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join('');
	    let modifier = (parts[3] || parts[5] || 1) - 1;

	    // Parse the key modifier
	    key.ctrl = !!(modifier & 4);
	    key.meta = !!(modifier & 10);
	    key.shift = !!(modifier & 1);
	    key.code = code;

	    key.name = keyName[code];
	    key.shift = isShiftKey(code) || key.shift;
	    key.ctrl = isCtrlKey(code) || key.ctrl;
	  }
	  return key;
	};

	keypress.listen = (options = {}, onKeypress) => {
	  let { stdin } = options;

	  if (!stdin || (stdin !== process.stdin && !stdin.isTTY)) {
	    throw new Error('Invalid stream passed');
	  }

	  let rl = readline.createInterface({ terminal: true, input: stdin });
	  readline.emitKeypressEvents(stdin, rl);

	  const queue = new Queue((buf, key) => onKeypress(buf, keypress(buf, key), rl));
	  let isRaw = stdin.isRaw;

	  if (stdin.isTTY) stdin.setRawMode(true);
	  stdin.on('keypress', queue.enqueue);
	  rl.resume();

	  let off = () => {
	    if (stdin.isTTY) stdin.setRawMode(isRaw);
	    stdin.removeListener('keypress', queue.enqueue);
	    queue.destroy();
	    rl.pause();
	    rl.close();
	  };

	  return off;
	};

	keypress.action = (buf, key, customActions) => {
	  let obj = { ...combos, ...customActions };
	  if (key.ctrl) {
	    key.action = obj.ctrl[key.name];
	    return key;
	  }

	  if (key.option && obj.option) {
	    key.action = obj.option[key.name];
	    return key;
	  }

	  if (key.shift) {
	    key.action = obj.shift[key.name];
	    return key;
	  }

	  key.action = obj.keys[key.name];
	  return key;
	};

	keypress_1 = keypress;
	return keypress_1;
}

var timer;
var hasRequiredTimer;

function requireTimer () {
	if (hasRequiredTimer) return timer;
	hasRequiredTimer = 1;

	timer = prompt => {
	  prompt.timers = prompt.timers || {};

	  let timers = prompt.options.timers;
	  if (!timers) return;

	  for (let key of Object.keys(timers)) {
	    let opts = timers[key];
	    if (typeof opts === 'number') {
	      opts = { interval: opts };
	    }
	    create(prompt, key, opts);
	  }
	};

	function create(prompt, name, options = {}) {
	  let timer = prompt.timers[name] = { name, start: Date.now(), ms: 0, tick: 0 };
	  let ms = options.interval || 120;
	  timer.frames = options.frames || [];
	  timer.loading = true;

	  let interval = setInterval(() => {
	    timer.ms = Date.now() - timer.start;
	    timer.tick++;
	    prompt.render();
	  }, ms);

	  timer.stop = () => {
	    timer.loading = false;
	    clearInterval(interval);
	  };

	  Reflect.defineProperty(timer, 'interval', { value: interval });
	  prompt.once('close', () => timer.stop());
	  return timer.stop;
	}
	return timer;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	const { define, width } = requireUtils();

	class State {
	  constructor(prompt) {
	    let options = prompt.options;
	    define(this, '_prompt', prompt);
	    this.type = prompt.type;
	    this.name = prompt.name;
	    this.message = '';
	    this.header = '';
	    this.footer = '';
	    this.error = '';
	    this.hint = '';
	    this.input = '';
	    this.cursor = 0;
	    this.index = 0;
	    this.lines = 0;
	    this.tick = 0;
	    this.prompt = '';
	    this.buffer = '';
	    this.width = width(options.stdout || process.stdout);
	    Object.assign(this, options);
	    this.name = this.name || this.message;
	    this.message = this.message || this.name;
	    this.symbols = prompt.symbols;
	    this.styles = prompt.styles;
	    this.required = new Set();
	    this.cancelled = false;
	    this.submitted = false;
	  }

	  clone() {
	    let state = { ...this };
	    state.status = this.status;
	    state.buffer = Buffer.from(state.buffer);
	    delete state.clone;
	    return state;
	  }

	  set color(val) {
	    this._color = val;
	  }
	  get color() {
	    let styles = this.prompt.styles;
	    if (this.cancelled) return styles.cancelled;
	    if (this.submitted) return styles.submitted;
	    let color = this._color || styles[this.status];
	    return typeof color === 'function' ? color : styles.pending;
	  }

	  set loading(value) {
	    this._loading = value;
	  }
	  get loading() {
	    if (typeof this._loading === 'boolean') return this._loading;
	    if (this.loadingChoices) return 'choices';
	    return false;
	  }

	  get status() {
	    if (this.cancelled) return 'cancelled';
	    if (this.submitted) return 'submitted';
	    return 'pending';
	  }
	}

	state = State;
	return state;
}

var styles_1;
var hasRequiredStyles;

function requireStyles () {
	if (hasRequiredStyles) return styles_1;
	hasRequiredStyles = 1;

	const utils = requireUtils();
	const colors = requireAnsiColors();

	const styles = {
	  default: colors.noop,
	  noop: colors.noop,

	  /**
	   * Modifiers
	   */

	  set inverse(custom) {
	    this._inverse = custom;
	  },
	  get inverse() {
	    return this._inverse || utils.inverse(this.primary);
	  },

	  set complement(custom) {
	    this._complement = custom;
	  },
	  get complement() {
	    return this._complement || utils.complement(this.primary);
	  },

	  /**
	   * Main color
	   */

	  primary: colors.cyan,

	  /**
	   * Main palette
	   */

	  success: colors.green,
	  danger: colors.magenta,
	  strong: colors.bold,
	  warning: colors.yellow,
	  muted: colors.dim,
	  disabled: colors.gray,
	  dark: colors.dim.gray,
	  underline: colors.underline,

	  set info(custom) {
	    this._info = custom;
	  },
	  get info() {
	    return this._info || this.primary;
	  },

	  set em(custom) {
	    this._em = custom;
	  },
	  get em() {
	    return this._em || this.primary.underline;
	  },

	  set heading(custom) {
	    this._heading = custom;
	  },
	  get heading() {
	    return this._heading || this.muted.underline;
	  },

	  /**
	   * Statuses
	   */

	  set pending(custom) {
	    this._pending = custom;
	  },
	  get pending() {
	    return this._pending || this.primary;
	  },

	  set submitted(custom) {
	    this._submitted = custom;
	  },
	  get submitted() {
	    return this._submitted || this.success;
	  },

	  set cancelled(custom) {
	    this._cancelled = custom;
	  },
	  get cancelled() {
	    return this._cancelled || this.danger;
	  },

	  /**
	   * Special styling
	   */

	  set typing(custom) {
	    this._typing = custom;
	  },
	  get typing() {
	    return this._typing || this.dim;
	  },

	  set placeholder(custom) {
	    this._placeholder = custom;
	  },
	  get placeholder() {
	    return this._placeholder || this.primary.dim;
	  },

	  set highlight(custom) {
	    this._highlight = custom;
	  },
	  get highlight() {
	    return this._highlight || this.inverse;
	  }
	};

	styles.merge = (options = {}) => {
	  if (options.styles && typeof options.styles.enabled === 'boolean') {
	    colors.enabled = options.styles.enabled;
	  }
	  if (options.styles && typeof options.styles.visible === 'boolean') {
	    colors.visible = options.styles.visible;
	  }

	  let result = utils.merge({}, styles, options.styles);
	  delete result.merge;

	  for (let key of Object.keys(colors)) {
	    if (!hasOwnProperty.call(result, key)) {
	      Reflect.defineProperty(result, key, { get: () => colors[key] });
	    }
	  }

	  for (let key of Object.keys(colors.styles)) {
	    if (!hasOwnProperty.call(result, key)) {
	      Reflect.defineProperty(result, key, { get: () => colors[key] });
	    }
	  }
	  return result;
	};

	styles_1 = styles;
	return styles_1;
}

var symbols_1;
var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols_1;
	hasRequiredSymbols = 1;

	const isWindows = process.platform === 'win32';
	const colors = requireAnsiColors();
	const utils = requireUtils();

	const symbols = {
	  ...colors.symbols,
	  upDownDoubleArrow: '⇕',
	  upDownDoubleArrow2: '⬍',
	  upDownArrow: '↕',
	  asterisk: '*',
	  asterism: '⁂',
	  bulletWhite: '◦',
	  electricArrow: '⌁',
	  ellipsisLarge: '⋯',
	  ellipsisSmall: '…',
	  fullBlock: '█',
	  identicalTo: '≡',
	  indicator: colors.symbols.check,
	  leftAngle: '‹',
	  mark: '※',
	  minus: '−',
	  multiplication: '×',
	  obelus: '÷',
	  percent: '%',
	  pilcrow: '¶',
	  pilcrow2: '❡',
	  pencilUpRight: '✐',
	  pencilDownRight: '✎',
	  pencilRight: '✏',
	  plus: '+',
	  plusMinus: '±',
	  pointRight: '☞',
	  rightAngle: '›',
	  section: '§',
	  hexagon: { off: '⬡', on: '⬢', disabled: '⬢' },
	  ballot: { on: '☑', off: '☐', disabled: '☒' },
	  stars: { on: '★', off: '☆', disabled: '☆' },
	  folder: { on: '▼', off: '▶', disabled: '▶' },
	  prefix: {
	    pending: colors.symbols.question,
	    submitted: colors.symbols.check,
	    cancelled: colors.symbols.cross
	  },
	  separator: {
	    pending: colors.symbols.pointerSmall,
	    submitted: colors.symbols.middot,
	    cancelled: colors.symbols.middot
	  },
	  radio: {
	    off: isWindows ? '( )' : '◯',
	    on: isWindows ? '(*)' : '◉',
	    disabled: isWindows ? '(|)' : 'Ⓘ'
	  },
	  numbers: ['⓪', '①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱', '⑲', '⑳', '㉑', '㉒', '㉓', '㉔', '㉕', '㉖', '㉗', '㉘', '㉙', '㉚', '㉛', '㉜', '㉝', '㉞', '㉟', '㊱', '㊲', '㊳', '㊴', '㊵', '㊶', '㊷', '㊸', '㊹', '㊺', '㊻', '㊼', '㊽', '㊾', '㊿']
	};

	symbols.merge = options => {
	  let result = utils.merge({}, colors.symbols, symbols, options.symbols);
	  delete result.merge;
	  return result;
	};

	symbols_1 = symbols;
	return symbols_1;
}

var theme;
var hasRequiredTheme;

function requireTheme () {
	if (hasRequiredTheme) return theme;
	hasRequiredTheme = 1;

	const styles = requireStyles();
	const symbols = requireSymbols();
	const utils = requireUtils();

	theme = prompt => {
	  prompt.options = utils.merge({}, prompt.options.theme, prompt.options);
	  prompt.symbols = symbols.merge(prompt.options);
	  prompt.styles = styles.merge(prompt.options);
	};
	return theme;
}

var ansi = {exports: {}};

var hasRequiredAnsi;

function requireAnsi () {
	if (hasRequiredAnsi) return ansi.exports;
	hasRequiredAnsi = 1;
	(function (module, exports) {

		const isTerm = process.env.TERM_PROGRAM === 'Apple_Terminal';
		const stripAnsi = requireStripAnsi();
		const utils = requireUtils();
		const ansi = module.exports = exports;
		const ESC = '\u001b[';
		const BEL = '\u0007';
		let hidden = false;

		const code = ansi.code = {
		  bell: BEL,
		  beep: BEL,
		  beginning: `${ESC}G`,
		  down: `${ESC}J`,
		  esc: ESC,
		  getPosition: `${ESC}6n`,
		  hide: `${ESC}?25l`,
		  line: `${ESC}2K`,
		  lineEnd: `${ESC}K`,
		  lineStart: `${ESC}1K`,
		  restorePosition: ESC + (isTerm ? '8' : 'u'),
		  savePosition: ESC + (isTerm ? '7' : 's'),
		  screen: `${ESC}2J`,
		  show: `${ESC}?25h`,
		  up: `${ESC}1J`
		};

		const cursor = ansi.cursor = {
		  get hidden() {
		    return hidden;
		  },

		  hide() {
		    hidden = true;
		    return code.hide;
		  },
		  show() {
		    hidden = false;
		    return code.show;
		  },

		  forward: (count = 1) => `${ESC}${count}C`,
		  backward: (count = 1) => `${ESC}${count}D`,
		  nextLine: (count = 1) => `${ESC}E`.repeat(count),
		  prevLine: (count = 1) => `${ESC}F`.repeat(count),

		  up: (count = 1) => count ? `${ESC}${count}A` : '',
		  down: (count = 1) => count ? `${ESC}${count}B` : '',
		  right: (count = 1) => count ? `${ESC}${count}C` : '',
		  left: (count = 1) => count ? `${ESC}${count}D` : '',

		  to(x, y) {
		    return y ? `${ESC}${y + 1};${x + 1}H` : `${ESC}${x + 1}G`;
		  },

		  move(x = 0, y = 0) {
		    let res = '';
		    res += (x < 0) ? cursor.left(-x) : (x > 0) ? cursor.right(x) : '';
		    res += (y < 0) ? cursor.up(-y) : (y > 0) ? cursor.down(y) : '';
		    return res;
		  },
		  strLen(str) {
		    // to suport chinese
		    var realLength = 0, len = str.length, charCode = -1;
		    for (var i = 0; i < len; i++) {
		      charCode = str.charCodeAt(i);
		      if (charCode >= 0 && charCode <= 128) realLength += 1;
		      else realLength += 2;
		    }
		    return realLength;
		  },
		  restore(state = {}) {
		    let { after, cursor, initial, input, prompt, size, value } = state;
		    initial = utils.isPrimitive(initial) ? String(initial) : '';
		    input = utils.isPrimitive(input) ? String(input) : '';
		    value = utils.isPrimitive(value) ? String(value) : '';

		    if (size) {
		      let codes = ansi.cursor.up(size) + ansi.cursor.to(this.strLen(prompt));
		      let diff = input.length - cursor;
		      if (diff > 0) {
		        codes += ansi.cursor.left(diff);
		      }
		      return codes;
		    }

		    if (value || after) {
		      let pos = (!input && !!initial) ? - this.strLen(initial) : -this.strLen(input) + cursor;
		      if (after) pos -= this.strLen(after);
		      if (input === '' && initial && !prompt.includes(initial)) {
		        pos += this.strLen(initial);
		      }
		      return ansi.cursor.move(pos);
		    }
		  }
		};

		const erase = ansi.erase = {
		  screen: code.screen,
		  up: code.up,
		  down: code.down,
		  line: code.line,
		  lineEnd: code.lineEnd,
		  lineStart: code.lineStart,
		  lines(n) {
		    let str = '';
		    for (let i = 0; i < n; i++) {
		      str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : '');
		    }
		    if (n) str += ansi.code.beginning;
		    return str;
		  }
		};

		ansi.clear = (input = '', columns = process.stdout.columns) => {
		  if (!columns) return erase.line + cursor.to(0);
		  let width = str => [...stripAnsi(str)].length;
		  let lines = input.split(/\r?\n/);
		  let rows = 0;
		  for (let line of lines) {
		    rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
		  }
		  return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
		}; 
	} (ansi, ansi.exports));
	return ansi.exports;
}

var prompt$1;
var hasRequiredPrompt;

function requirePrompt () {
	if (hasRequiredPrompt) return prompt$1;
	hasRequiredPrompt = 1;

	const Events = require$$0$2;
	const stripAnsi = requireStripAnsi();
	const keypress = requireKeypress();
	const timer = requireTimer();
	const State = requireState();
	const theme = requireTheme();
	const utils = requireUtils();
	const ansi = requireAnsi();

	/**
	 * Base class for creating a new Prompt.
	 * @param {Object} `options` Question object.
	 */

	class Prompt extends Events {
	  constructor(options = {}) {
	    super();
	    this.name = options.name;
	    this.type = options.type;
	    this.options = options;
	    theme(this);
	    timer(this);
	    this.state = new State(this);
	    this.initial = [options.initial, options.default].find(v => v != null);
	    this.stdout = options.stdout || process.stdout;
	    this.stdin = options.stdin || process.stdin;
	    this.scale = options.scale || 1;
	    this.term = this.options.term || process.env.TERM_PROGRAM;
	    this.margin = margin(this.options.margin);
	    this.setMaxListeners(0);
	    setOptions(this);
	  }

	  async keypress(input, event = {}) {
	    this.keypressed = true;
	    let key = keypress.action(input, keypress(input, event), this.options.actions);
	    this.state.keypress = key;
	    this.emit('keypress', input, key);
	    this.emit('state', this.state.clone());

	    const fn = this.options[key.action] || this[key.action] || this.dispatch;

	    if (typeof fn === 'function') {
	      return await fn.call(this, input, key);
	    }

	    this.alert();
	  }

	  alert() {
	    delete this.state.alert;
	    if (this.options.show === false) {
	      this.emit('alert');
	    } else {
	      this.stdout.write(ansi.code.beep);
	    }
	  }

	  cursorHide() {
	    this.stdout.write(ansi.cursor.hide());
	    const releaseOnExit = utils.onExit(() => this.cursorShow());
	    this.on('close', () => {
	      this.cursorShow();
	      releaseOnExit();
	    });
	  }

	  cursorShow() {
	    this.stdout.write(ansi.cursor.show());
	  }

	  write(str) {
	    if (!str) return;
	    if (this.stdout && this.state.show !== false) {
	      this.stdout.write(str);
	    }
	    this.state.buffer += str;
	  }

	  clear(lines = 0) {
	    let buffer = this.state.buffer;
	    this.state.buffer = '';
	    if ((!buffer && !lines) || this.options.show === false) return;
	    this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));
	  }

	  restore() {
	    if (this.state.closed || this.options.show === false) return;

	    let { prompt, after, rest } = this.sections();
	    let { cursor, initial = '', input = '', value = '' } = this;

	    let size = this.state.size = rest.length;
	    let state = { after, cursor, initial, input, prompt, size, value };
	    let codes = ansi.cursor.restore(state);
	    if (codes) {
	      this.stdout.write(codes);
	    }
	  }

	  sections() {
	    let { buffer, input, prompt } = this.state;
	    prompt = stripAnsi(prompt);
	    let buf = stripAnsi(buffer);
	    let idx = buf.indexOf(prompt);
	    let header = buf.slice(0, idx);
	    let rest = buf.slice(idx);
	    let lines = rest.split('\n');
	    let first = lines[0];
	    let last = lines[lines.length - 1];
	    let promptLine = prompt + (input ? ' ' + input : '');
	    let len = promptLine.length;
	    let after = len < first.length ? first.slice(len + 1) : '';
	    return { header, prompt: first, after, rest: lines.slice(1), last };
	  }

	  async submit() {
	    this.state.submitted = true;
	    this.state.validating = true;

	    // this will only be called when the prompt is directly submitted
	    // without initializing, i.e. when the prompt is skipped, etc. Otherwize,
	    // "options.onSubmit" is will be handled by the "initialize()" method.
	    if (this.options.onSubmit) {
	      await this.options.onSubmit.call(this, this.name, this.value, this);
	    }

	    let result = this.state.error || await this.validate(this.value, this.state);
	    if (result !== true) {
	      let error = '\n' + this.symbols.pointer + ' ';

	      if (typeof result === 'string') {
	        error += result.trim();
	      } else {
	        error += 'Invalid input';
	      }

	      this.state.error = '\n' + this.styles.danger(error);
	      this.state.submitted = false;
	      await this.render();
	      await this.alert();
	      this.state.validating = false;
	      this.state.error = void 0;
	      return;
	    }

	    this.state.validating = false;
	    await this.render();
	    await this.close();

	    this.value = await this.result(this.value);
	    this.emit('submit', this.value);
	  }

	  async cancel(err) {
	    this.state.cancelled = this.state.submitted = true;

	    await this.render();
	    await this.close();

	    if (typeof this.options.onCancel === 'function') {
	      await this.options.onCancel.call(this, this.name, this.value, this);
	    }

	    this.emit('cancel', await this.error(err));
	  }

	  async close() {
	    this.state.closed = true;

	    try {
	      let sections = this.sections();
	      let lines = Math.ceil(sections.prompt.length / this.width);
	      if (sections.rest) {
	        this.write(ansi.cursor.down(sections.rest.length));
	      }
	      this.write('\n'.repeat(lines));
	    } catch (err) { /* do nothing */ }

	    this.emit('close');
	  }

	  start() {
	    if (!this.stop && this.options.show !== false) {
	      this.stop = keypress.listen(this, this.keypress.bind(this));
	      this.once('close', this.stop);
	      this.emit('start', this);
	    }
	  }

	  async skip() {
	    this.skipped = this.options.skip === true;
	    if (typeof this.options.skip === 'function') {
	      this.skipped = await this.options.skip.call(this, this.name, this.value);
	    }
	    return this.skipped;
	  }

	  async initialize() {
	    let { format, options, result } = this;

	    this.format = () => format.call(this, this.value);
	    this.result = () => result.call(this, this.value);

	    if (typeof options.initial === 'function') {
	      this.initial = await options.initial.call(this, this);
	    }

	    if (typeof options.onRun === 'function') {
	      await options.onRun.call(this, this);
	    }

	    // if "options.onSubmit" is defined, we wrap the "submit" method to guarantee
	    // that "onSubmit" will always called first thing inside the submit
	    // method, regardless of how it's handled in inheriting prompts.
	    if (typeof options.onSubmit === 'function') {
	      let onSubmit = options.onSubmit.bind(this);
	      let submit = this.submit.bind(this);
	      delete this.options.onSubmit;
	      this.submit = async() => {
	        await onSubmit(this.name, this.value, this);
	        return submit();
	      };
	    }

	    await this.start();
	    await this.render();
	  }

	  render() {
	    throw new Error('expected prompt to have a custom render method');
	  }

	  run() {
	    return new Promise(async(resolve, reject) => {
	      this.once('submit', resolve);
	      this.once('cancel', reject);

	      if (await this.skip()) {
	        this.render = () => {};
	        return this.submit();
	      }

	      await this.initialize();
	      this.emit('run');
	    });
	  }

	  async element(name, choice, i) {
	    let { options, state, symbols, timers } = this;
	    let timer = timers && timers[name];
	    state.timer = timer;
	    let value = options[name] || state[name] || symbols[name];
	    let val = choice && choice[name] != null ? choice[name] : await value;
	    if (val === '') return val;

	    let res = await this.resolve(val, state, choice, i);
	    if (!res && choice && choice[name]) {
	      return this.resolve(value, state, choice, i);
	    }
	    return res;
	  }

	  async prefix() {
	    let element = await this.element('prefix') || this.symbols;
	    let timer = this.timers && this.timers.prefix;
	    let state = this.state;
	    state.timer = timer;
	    if (utils.isObject(element)) element = element[state.status] || element.pending;
	    if (!utils.hasColor(element)) {
	      let style = this.styles[state.status] || this.styles.pending;
	      return style(element);
	    }
	    return element;
	  }

	  async message() {
	    let message = await this.element('message');
	    if (!utils.hasColor(message)) {
	      return this.styles.strong(message);
	    }
	    return message;
	  }

	  async separator() {
	    let element = await this.element('separator') || this.symbols;
	    let timer = this.timers && this.timers.separator;
	    let state = this.state;
	    state.timer = timer;
	    let value = element[state.status] || element.pending || state.separator;
	    let ele = await this.resolve(value, state);
	    if (utils.isObject(ele)) ele = ele[state.status] || ele.pending;
	    if (!utils.hasColor(ele)) {
	      return this.styles.muted(ele);
	    }
	    return ele;
	  }

	  async pointer(choice, i) {
	    let val = await this.element('pointer', choice, i);

	    if (typeof val === 'string' && utils.hasColor(val)) {
	      return val;
	    }

	    if (val) {
	      let styles = this.styles;
	      let focused = this.index === i;
	      let style = focused ? styles.primary : val => val;
	      let ele = await this.resolve(val[focused ? 'on' : 'off'] || val, this.state);
	      let styled = !utils.hasColor(ele) ? style(ele) : ele;
	      return focused ? styled : ' '.repeat(ele.length);
	    }
	  }

	  async indicator(choice, i) {
	    let val = await this.element('indicator', choice, i);
	    if (typeof val === 'string' && utils.hasColor(val)) {
	      return val;
	    }

	    if (val) {
	      let styles = this.styles;
	      let enabled = choice.enabled === true;
	      let style = enabled ? styles.success : styles.dark;
	      let ele = val[enabled ? 'on' : 'off'] || val;
	      return !utils.hasColor(ele) ? style(ele) : ele;
	    }

	    return '';
	  }

	  body() {
	    return null;
	  }

	  footer() {
	    if (this.state.status === 'pending') {
	      return this.element('footer');
	    }
	  }

	  header() {
	    if (this.state.status === 'pending') {
	      return this.element('header');
	    }
	  }

	  async hint() {
	    if (this.state.status === 'pending' && !this.isValue(this.state.input)) {
	      let hint = await this.element('hint');
	      if (!utils.hasColor(hint)) {
	        return this.styles.muted(hint);
	      }
	      return hint;
	    }
	  }

	  error(err) {
	    return !this.state.submitted ? (err || this.state.error) : '';
	  }

	  format(value) {
	    return value;
	  }

	  result(value) {
	    return value;
	  }

	  validate(value) {
	    if (this.options.required === true) {
	      return this.isValue(value);
	    }
	    return true;
	  }

	  isValue(value) {
	    return value != null && value !== '';
	  }

	  resolve(value, ...args) {
	    return utils.resolve(this, value, ...args);
	  }

	  get base() {
	    return Prompt.prototype;
	  }

	  get style() {
	    return this.styles[this.state.status];
	  }

	  get height() {
	    return this.options.rows || utils.height(this.stdout, 25);
	  }
	  get width() {
	    return this.options.columns || utils.width(this.stdout, 80);
	  }
	  get size() {
	    return { width: this.width, height: this.height };
	  }

	  set cursor(value) {
	    this.state.cursor = value;
	  }
	  get cursor() {
	    return this.state.cursor;
	  }

	  set input(value) {
	    this.state.input = value;
	  }
	  get input() {
	    return this.state.input;
	  }

	  set value(value) {
	    this.state.value = value;
	  }
	  get value() {
	    let { input, value } = this.state;
	    let result = [value, input].find(this.isValue.bind(this));
	    return this.isValue(result) ? result : this.initial;
	  }

	  static get prompt() {
	    return options => new this(options).run();
	  }
	}

	function setOptions(prompt) {
	  let isValidKey = key => {
	    return prompt[key] === void 0 || typeof prompt[key] === 'function';
	  };

	  let ignore = [
	    'actions',
	    'choices',
	    'initial',
	    'margin',
	    'roles',
	    'styles',
	    'symbols',
	    'theme',
	    'timers',
	    'value'
	  ];

	  let ignoreFn = [
	    'body',
	    'footer',
	    'error',
	    'header',
	    'hint',
	    'indicator',
	    'message',
	    'prefix',
	    'separator',
	    'skip'
	  ];

	  for (let key of Object.keys(prompt.options)) {
	    if (ignore.includes(key)) continue;
	    if (/^on[A-Z]/.test(key)) continue;
	    let option = prompt.options[key];
	    if (typeof option === 'function' && isValidKey(key)) {
	      if (!ignoreFn.includes(key)) {
	        prompt[key] = option.bind(prompt);
	      }
	    } else if (typeof prompt[key] !== 'function') {
	      prompt[key] = option;
	    }
	  }
	}

	function margin(value) {
	  if (typeof value === 'number') {
	    value = [value, value, value, value];
	  }
	  let arr = [].concat(value || []);
	  let pad = i => i % 2 === 0 ? '\n' : ' ';
	  let res = [];
	  for (let i = 0; i < 4; i++) {
	    let char = pad(i);
	    if (arr[i]) {
	      res.push(char.repeat(arr[i]));
	    } else {
	      res.push('');
	    }
	  }
	  return res;
	}

	prompt$1 = Prompt;
	return prompt$1;
}

var prompts = {};

var roles_1;
var hasRequiredRoles;

function requireRoles () {
	if (hasRequiredRoles) return roles_1;
	hasRequiredRoles = 1;

	const utils = requireUtils();
	const roles = {
	  default(prompt, choice) {
	    return choice;
	  },
	  checkbox(prompt, choice) {
	    throw new Error('checkbox role is not implemented yet');
	  },
	  editable(prompt, choice) {
	    throw new Error('editable role is not implemented yet');
	  },
	  expandable(prompt, choice) {
	    throw new Error('expandable role is not implemented yet');
	  },
	  heading(prompt, choice) {
	    choice.disabled = '';
	    choice.indicator = [choice.indicator, ' '].find(v => v != null);
	    choice.message = choice.message || '';
	    return choice;
	  },
	  input(prompt, choice) {
	    throw new Error('input role is not implemented yet');
	  },
	  option(prompt, choice) {
	    return roles.default(prompt, choice);
	  },
	  radio(prompt, choice) {
	    throw new Error('radio role is not implemented yet');
	  },
	  separator(prompt, choice) {
	    choice.disabled = '';
	    choice.indicator = [choice.indicator, ' '].find(v => v != null);
	    choice.message = choice.message || prompt.symbols.line.repeat(5);
	    return choice;
	  },
	  spacer(prompt, choice) {
	    return choice;
	  }
	};

	roles_1 = (name, options = {}) => {
	  let role = utils.merge({}, roles, options.roles);
	  return role[name] || role.default;
	};
	return roles_1;
}

var array;
var hasRequiredArray;

function requireArray () {
	if (hasRequiredArray) return array;
	hasRequiredArray = 1;

	const stripAnsi = requireStripAnsi();
	const Prompt = requirePrompt();
	const roles = requireRoles();
	const utils = requireUtils();
	const { reorder, scrollUp, scrollDown, isObject, swap } = utils;

	class ArrayPrompt extends Prompt {
	  constructor(options) {
	    super(options);
	    this.cursorHide();
	    this.maxSelected = options.maxSelected || Infinity;
	    this.multiple = options.multiple || false;
	    this.initial = options.initial || 0;
	    this.delay = options.delay || 0;
	    this.longest = 0;
	    this.num = '';
	  }

	  async initialize() {
	    if (typeof this.options.initial === 'function') {
	      this.initial = await this.options.initial.call(this);
	    }
	    await this.reset(true);
	    await super.initialize();
	  }

	  async reset() {
	    let { choices, initial, autofocus, suggest } = this.options;
	    this.state._choices = [];
	    this.state.choices = [];

	    this.choices = await Promise.all(await this.toChoices(choices));
	    this.choices.forEach(ch => (ch.enabled = false));

	    if (typeof suggest !== 'function' && this.selectable.length === 0) {
	      throw new Error('At least one choice must be selectable');
	    }

	    if (isObject(initial)) initial = Object.keys(initial);
	    if (Array.isArray(initial)) {
	      if (autofocus != null) this.index = this.findIndex(autofocus);
	      initial.forEach(v => this.enable(this.find(v)));
	      await this.render();
	    } else {
	      if (autofocus != null) initial = autofocus;
	      if (typeof initial === 'string') initial = this.findIndex(initial);
	      if (typeof initial === 'number' && initial > -1) {
	        this.index = Math.max(0, Math.min(initial, this.choices.length));
	        this.enable(this.find(this.index));
	      }
	    }

	    if (this.isDisabled(this.focused)) {
	      await this.down();
	    }
	  }

	  async toChoices(value, parent) {
	    this.state.loadingChoices = true;
	    let choices = [];
	    let index = 0;

	    let toChoices = async(items, parent) => {
	      if (typeof items === 'function') items = await items.call(this);
	      if (items instanceof Promise) items = await items;

	      for (let i = 0; i < items.length; i++) {
	        let choice = items[i] = await this.toChoice(items[i], index++, parent);
	        choices.push(choice);

	        if (choice.choices) {
	          await toChoices(choice.choices, choice);
	        }
	      }
	      return choices;
	    };

	    return toChoices(value, parent)
	      .then(choices => {
	        this.state.loadingChoices = false;
	        return choices;
	      });
	  }

	  async toChoice(ele, i, parent) {
	    if (typeof ele === 'function') ele = await ele.call(this, this);
	    if (ele instanceof Promise) ele = await ele;
	    if (typeof ele === 'string') ele = { name: ele };

	    if (ele.normalized) return ele;
	    ele.normalized = true;

	    let origVal = ele.value;
	    let role = roles(ele.role, this.options);
	    ele = role(this, ele);

	    if (typeof ele.disabled === 'string' && !ele.hint) {
	      ele.hint = ele.disabled;
	      ele.disabled = true;
	    }

	    if (ele.disabled === true && ele.hint == null) {
	      ele.hint = '(disabled)';
	    }

	    // if the choice was already normalized, return it
	    if (ele.index != null) return ele;
	    ele.name = ele.name || ele.key || ele.title || ele.value || ele.message;
	    ele.message = ele.message || ele.name || '';
	    ele.value = [ele.value, ele.name].find(this.isValue.bind(this));

	    ele.input = '';
	    ele.index = i;
	    ele.cursor = 0;

	    utils.define(ele, 'parent', parent);
	    ele.level = parent ? parent.level + 1 : 1;
	    if (ele.indent == null) {
	      ele.indent = parent ? parent.indent + '  ' : (ele.indent || '');
	    }

	    ele.path = parent ? parent.path + '.' + ele.name : ele.name;
	    ele.enabled = !!(this.multiple && !this.isDisabled(ele) && (ele.enabled || this.isSelected(ele)));

	    if (!this.isDisabled(ele)) {
	      this.longest = Math.max(this.longest, stripAnsi(ele.message).length);
	    }

	    // shallow clone the choice first
	    let choice = { ...ele };

	    // then allow the choice to be reset using the "original" values
	    ele.reset = (input = choice.input, value = choice.value) => {
	      for (let key of Object.keys(choice)) ele[key] = choice[key];
	      ele.input = input;
	      ele.value = value;
	    };

	    if (origVal == null && typeof ele.initial === 'function') {
	      ele.input = await ele.initial.call(this, this.state, ele, i);
	    }

	    return ele;
	  }

	  async onChoice(choice, i) {
	    this.emit('choice', choice, i, this);

	    if (typeof choice.onChoice === 'function') {
	      await choice.onChoice.call(this, this.state, choice, i);
	    }
	  }

	  async addChoice(ele, i, parent) {
	    let choice = await this.toChoice(ele, i, parent);
	    this.choices.push(choice);
	    this.index = this.choices.length - 1;
	    this.limit = this.choices.length;
	    return choice;
	  }

	  async newItem(item, i, parent) {
	    let ele = { name: 'New choice name?', editable: true, newChoice: true, ...item };
	    let choice = await this.addChoice(ele, i, parent);

	    choice.updateChoice = () => {
	      delete choice.newChoice;
	      choice.name = choice.message = choice.input;
	      choice.input = '';
	      choice.cursor = 0;
	    };

	    return this.render();
	  }

	  indent(choice) {
	    if (choice.indent == null) {
	      return choice.level > 1 ? '  '.repeat(choice.level - 1) : '';
	    }
	    return choice.indent;
	  }

	  dispatch(s, key) {
	    if (this.multiple && this[key.name]) return this[key.name]();
	    this.alert();
	  }

	  focus(choice, enabled) {
	    if (typeof enabled !== 'boolean') enabled = choice.enabled;
	    if (enabled && !choice.enabled && this.selected.length >= this.maxSelected) {
	      return this.alert();
	    }
	    this.index = choice.index;
	    choice.enabled = enabled && !this.isDisabled(choice);
	    return choice;
	  }

	  space() {
	    if (!this.multiple) return this.alert();
	    if (!this.focused) return;
	    this.toggle(this.focused);
	    return this.render();
	  }

	  a() {
	    if (this.maxSelected < this.choices.length) return this.alert();
	    let enabled = this.selectable.every(ch => ch.enabled);
	    this.choices.forEach(ch => (ch.enabled = !enabled));
	    return this.render();
	  }

	  i() {
	    // don't allow choices to be inverted if it will result in
	    // more than the maximum number of allowed selected items.
	    if (this.choices.length - this.selected.length > this.maxSelected) {
	      return this.alert();
	    }
	    this.choices.forEach(ch => (ch.enabled = !ch.enabled));
	    return this.render();
	  }

	  g() {
	    if (!this.choices.some(ch => !!ch.parent)) return this.a();
	    const focused = this.focused;
	    this.toggle((focused.parent && !focused.choices) ? focused.parent : focused);
	    return this.render();
	  }

	  toggle(choice, enabled) {
	    if (!choice.enabled && this.selected.length >= this.maxSelected) {
	      return this.alert();
	    }

	    if (typeof enabled !== 'boolean') enabled = !choice.enabled;
	    choice.enabled = enabled;

	    if (choice.choices) {
	      choice.choices.forEach(ch => this.toggle(ch, enabled));
	    }

	    let parent = choice.parent;
	    while (parent) {
	      let choices = parent.choices.filter(ch => this.isDisabled(ch));
	      parent.enabled = choices.every(ch => ch.enabled === true);
	      parent = parent.parent;
	    }

	    reset(this, this.choices);
	    this.emit('toggle', choice, this);
	    return choice;
	  }

	  enable(choice) {
	    if (this.selected.length >= this.maxSelected) return this.alert();
	    choice.enabled = !this.isDisabled(choice);
	    choice.choices && choice.choices.forEach(this.enable.bind(this));
	    return choice;
	  }

	  disable(choice) {
	    choice.enabled = false;
	    choice.choices && choice.choices.forEach(this.disable.bind(this));
	    return choice;
	  }

	  number(n) {
	    this.num += n;

	    let number = num => {
	      let i = Number(num);
	      if (i > this.choices.length - 1) return this.alert();

	      let focused = this.focused;
	      let choice = this.choices.find(ch => i === ch.index);

	      if (!choice.enabled && this.selected.length >= this.maxSelected) {
	        return this.alert();
	      }

	      if (this.visible.indexOf(choice) === -1) {
	        let choices = reorder(this.choices);
	        let actualIdx = choices.indexOf(choice);

	        if (focused.index > actualIdx) {
	          let start = choices.slice(actualIdx, actualIdx + this.limit);
	          let end = choices.filter(ch => !start.includes(ch));
	          this.choices = start.concat(end);
	        } else {
	          let pos = actualIdx - this.limit + 1;
	          this.choices = choices.slice(pos).concat(choices.slice(0, pos));
	        }
	      }

	      this.index = this.choices.indexOf(choice);
	      this.toggle(this.focused);
	      return this.render();
	    };

	    clearTimeout(this.numberTimeout);

	    return new Promise(resolve => {
	      let len = this.choices.length;
	      let num = this.num;

	      let handle = (val = false, res) => {
	        clearTimeout(this.numberTimeout);
	        if (val) res = number(num);
	        this.num = '';
	        resolve(res);
	      };

	      if (num === '0' || (num.length === 1 && Number(num + '0') > len)) {
	        return handle(true);
	      }

	      if (Number(num) > len) {
	        return handle(false, this.alert());
	      }

	      this.numberTimeout = setTimeout(() => handle(true), this.delay);
	    });
	  }

	  home() {
	    this.choices = reorder(this.choices);
	    this.index = 0;
	    return this.render();
	  }

	  end() {
	    let pos = this.choices.length - this.limit;
	    let choices = reorder(this.choices);
	    this.choices = choices.slice(pos).concat(choices.slice(0, pos));
	    this.index = this.limit - 1;
	    return this.render();
	  }

	  first() {
	    this.index = 0;
	    return this.render();
	  }

	  last() {
	    this.index = this.visible.length - 1;
	    return this.render();
	  }

	  prev() {
	    if (this.visible.length <= 1) return this.alert();
	    return this.up();
	  }

	  next() {
	    if (this.visible.length <= 1) return this.alert();
	    return this.down();
	  }

	  right() {
	    if (this.cursor >= this.input.length) return this.alert();
	    this.cursor++;
	    return this.render();
	  }

	  left() {
	    if (this.cursor <= 0) return this.alert();
	    this.cursor--;
	    return this.render();
	  }

	  up() {
	    let len = this.choices.length;
	    let vis = this.visible.length;
	    let idx = this.index;
	    if (this.options.scroll === false && idx === 0) {
	      return this.alert();
	    }
	    if (len > vis && idx === 0) {
	      return this.scrollUp();
	    }
	    this.index = ((idx - 1 % len) + len) % len;
	    if (this.isDisabled() && !this.allChoicesAreDisabled()) {
	      return this.up();
	    }
	    return this.render();
	  }

	  down() {
	    let len = this.choices.length;
	    let vis = this.visible.length;
	    let idx = this.index;
	    if (this.options.scroll === false && idx === vis - 1) {
	      return this.alert();
	    }
	    if (len > vis && idx === vis - 1) {
	      return this.scrollDown();
	    }
	    this.index = (idx + 1) % len;
	    if (this.isDisabled() && !this.allChoicesAreDisabled()) {
	      return this.down();
	    }
	    return this.render();
	  }

	  scrollUp(i = 0) {
	    this.choices = scrollUp(this.choices);
	    this.index = i;
	    if (this.isDisabled()) {
	      return this.up();
	    }
	    return this.render();
	  }

	  scrollDown(i = this.visible.length - 1) {
	    this.choices = scrollDown(this.choices);
	    this.index = i;
	    if (this.isDisabled()) {
	      return this.down();
	    }
	    return this.render();
	  }

	  async shiftUp() {
	    if (this.options.sort === true) {
	      this.sorting = true;
	      this.swap(this.index - 1);
	      await this.up();
	      this.sorting = false;
	      return;
	    }
	    return this.scrollUp(this.index);
	  }

	  async shiftDown() {
	    if (this.options.sort === true) {
	      this.sorting = true;
	      this.swap(this.index + 1);
	      await this.down();
	      this.sorting = false;
	      return;
	    }
	    return this.scrollDown(this.index);
	  }

	  pageUp() {
	    if (this.visible.length <= 1) return this.alert();
	    this.limit = Math.max(this.limit - 1, 0);
	    this.index = Math.min(this.limit - 1, this.index);
	    this._limit = this.limit;
	    if (this.isDisabled()) {
	      return this.up();
	    }
	    return this.render();
	  }

	  pageDown() {
	    if (this.visible.length >= this.choices.length) return this.alert();
	    this.index = Math.max(0, this.index);
	    this.limit = Math.min(this.limit + 1, this.choices.length);
	    this._limit = this.limit;
	    if (this.isDisabled()) {
	      return this.down();
	    }
	    return this.render();
	  }

	  swap(pos) {
	    swap(this.choices, this.index, pos);
	  }

	  allChoicesAreDisabled(choices = this.choices) {
	    return choices.every(choice => this.isDisabled(choice));
	  }

	  isDisabled(choice = this.focused) {
	    let keys = ['disabled', 'collapsed', 'hidden', 'completing', 'readonly'];
	    if (choice && keys.some(key => choice[key] === true)) {
	      return true;
	    }
	    return choice && choice.role === 'heading';
	  }

	  isEnabled(choice = this.focused) {
	    if (Array.isArray(choice)) return choice.every(ch => this.isEnabled(ch));
	    if (choice.choices) {
	      let choices = choice.choices.filter(ch => !this.isDisabled(ch));
	      return choice.enabled && choices.every(ch => this.isEnabled(ch));
	    }
	    return choice.enabled && !this.isDisabled(choice);
	  }

	  isChoice(choice, value) {
	    return choice.name === value || choice.index === Number(value);
	  }

	  isSelected(choice) {
	    if (Array.isArray(this.initial)) {
	      return this.initial.some(value => this.isChoice(choice, value));
	    }
	    return this.isChoice(choice, this.initial);
	  }

	  map(names = [], prop = 'value') {
	    return [].concat(names || []).reduce((acc, name) => {
	      acc[name] = this.find(name, prop);
	      return acc;
	    }, {});
	  }

	  filter(value, prop) {
	    let isChoice = (ele, i) => [ele.name, i].includes(value);
	    let fn = typeof value === 'function' ? value : isChoice;
	    let choices = this.options.multiple ? this.state._choices : this.choices;
	    let result = choices.filter(fn);
	    if (prop) {
	      return result.map(ch => ch[prop]);
	    }
	    return result;
	  }

	  find(value, prop) {
	    if (isObject(value)) return prop ? value[prop] : value;
	    let isChoice = (ele, i) => [ele.name, i].includes(value);
	    let fn = typeof value === 'function' ? value : isChoice;
	    let choice = this.choices.find(fn);
	    if (choice) {
	      return prop ? choice[prop] : choice;
	    }
	  }

	  findIndex(value) {
	    return this.choices.indexOf(this.find(value));
	  }

	  async submit() {
	    let choice = this.focused;
	    if (!choice) return this.alert();

	    if (choice.newChoice) {
	      if (!choice.input) return this.alert();
	      choice.updateChoice();
	      return this.render();
	    }

	    if (this.choices.some(ch => ch.newChoice)) {
	      return this.alert();
	    }

	    let { reorder, sort } = this.options;
	    let multi = this.multiple === true;
	    let value = this.selected;
	    if (value === void 0) {
	      return this.alert();
	    }

	    // re-sort choices to original order
	    if (Array.isArray(value) && reorder !== false && sort !== true) {
	      value = utils.reorder(value);
	    }

	    this.value = multi ? value.map(ch => ch.name) : value.name;
	    return super.submit();
	  }

	  set choices(choices = []) {
	    this.state._choices = this.state._choices || [];
	    this.state.choices = choices;

	    for (let choice of choices) {
	      if (!this.state._choices.some(ch => ch.name === choice.name)) {
	        this.state._choices.push(choice);
	      }
	    }

	    if (!this._initial && this.options.initial) {
	      this._initial = true;
	      let init = this.initial;
	      if (typeof init === 'string' || typeof init === 'number') {
	        let choice = this.find(init);
	        if (choice) {
	          this.initial = choice.index;
	          this.focus(choice, true);
	        }
	      }
	    }
	  }
	  get choices() {
	    return reset(this, this.state.choices || []);
	  }

	  set visible(visible) {
	    this.state.visible = visible;
	  }
	  get visible() {
	    return (this.state.visible || this.choices).slice(0, this.limit);
	  }

	  set limit(num) {
	    this.state.limit = num;
	  }
	  get limit() {
	    let { state, options, choices } = this;
	    let limit = state.limit || this._limit || options.limit || choices.length;
	    return Math.min(limit, this.height);
	  }

	  set value(value) {
	    super.value = value;
	  }
	  get value() {
	    if (typeof super.value !== 'string' && super.value === this.initial) {
	      return this.input;
	    }
	    return super.value;
	  }

	  set index(i) {
	    this.state.index = i;
	  }
	  get index() {
	    return Math.max(0, this.state ? this.state.index : 0);
	  }

	  get enabled() {
	    return this.filter(this.isEnabled.bind(this));
	  }

	  get focused() {
	    let choice = this.choices[this.index];
	    if (choice && this.state.submitted && this.multiple !== true) {
	      choice.enabled = true;
	    }
	    return choice;
	  }

	  get selectable() {
	    return this.choices.filter(choice => !this.isDisabled(choice));
	  }

	  get selected() {
	    return this.multiple ? this.enabled : this.focused;
	  }
	}

	function reset(prompt, choices) {
	  if (choices instanceof Promise) return choices;
	  if (typeof choices === 'function') {
	    if (utils.isAsyncFn(choices)) return choices;
	    choices = choices.call(prompt, prompt);
	  }
	  for (let choice of choices) {
	    if (Array.isArray(choice.choices)) {
	      let items = choice.choices.filter(ch => !prompt.isDisabled(ch));
	      choice.enabled = items.every(ch => ch.enabled === true);
	    }
	    if (prompt.isDisabled(choice) === true) {
	      delete choice.enabled;
	    }
	  }
	  return choices;
	}

	array = ArrayPrompt;
	return array;
}

var select;
var hasRequiredSelect;

function requireSelect () {
	if (hasRequiredSelect) return select;
	hasRequiredSelect = 1;

	const ArrayPrompt = requireArray();
	const utils = requireUtils();

	class SelectPrompt extends ArrayPrompt {
	  constructor(options) {
	    super(options);
	    this.emptyError = this.options.emptyError || 'No items were selected';
	  }

	  async dispatch(s, key) {
	    if (this.multiple) {
	      return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
	    }
	    this.alert();
	  }

	  separator() {
	    if (this.options.separator) return super.separator();
	    let sep = this.styles.muted(this.symbols.ellipsis);
	    return this.state.submitted ? super.separator() : sep;
	  }

	  pointer(choice, i) {
	    return (!this.multiple || this.options.pointer) ? super.pointer(choice, i) : '';
	  }

	  indicator(choice, i) {
	    return this.multiple ? super.indicator(choice, i) : '';
	  }

	  choiceMessage(choice, i) {
	    let message = this.resolve(choice.message, this.state, choice, i);
	    if (choice.role === 'heading' && !utils.hasColor(message)) {
	      message = this.styles.strong(message);
	    }
	    return this.resolve(message, this.state, choice, i);
	  }

	  choiceSeparator() {
	    return ':';
	  }

	  async renderChoice(choice, i) {
	    await this.onChoice(choice, i);

	    let focused = this.index === i;
	    let pointer = await this.pointer(choice, i);
	    let check = await this.indicator(choice, i) + (choice.pad || '');
	    let hint = await this.resolve(choice.hint, this.state, choice, i);

	    if (hint && !utils.hasColor(hint)) {
	      hint = this.styles.muted(hint);
	    }

	    let ind = this.indent(choice);
	    let msg = await this.choiceMessage(choice, i);
	    let line = () => [this.margin[3], ind + pointer + check, msg, this.margin[1], hint].filter(Boolean).join(' ');

	    if (choice.role === 'heading') {
	      return line();
	    }

	    if (choice.disabled) {
	      if (!utils.hasColor(msg)) {
	        msg = this.styles.disabled(msg);
	      }
	      return line();
	    }

	    if (focused) {
	      msg = this.styles.em(msg);
	    }

	    return line();
	  }

	  async renderChoices() {
	    if (this.state.loading === 'choices') {
	      return this.styles.warning('Loading choices');
	    }

	    if (this.state.submitted) return '';
	    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
	    let visible = await Promise.all(choices);
	    if (!visible.length) visible.push(this.styles.danger('No matching choices'));
	    let result = this.margin[0] + visible.join('\n');
	    let header;

	    if (this.options.choicesHeader) {
	      header = await this.resolve(this.options.choicesHeader, this.state);
	    }

	    return [header, result].filter(Boolean).join('\n');
	  }

	  format() {
	    if (!this.state.submitted || this.state.cancelled) return '';
	    if (Array.isArray(this.selected)) {
	      return this.selected.map(choice => this.styles.primary(choice.name)).join(', ');
	    }
	    return this.styles.primary(this.selected.name);
	  }

	  async render() {
	    let { submitted, size } = this.state;

	    let prompt = '';
	    let header = await this.header();
	    let prefix = await this.prefix();
	    let separator = await this.separator();
	    let message = await this.message();

	    if (this.options.promptLine !== false) {
	      prompt = [prefix, message, separator, ''].join(' ');
	      this.state.prompt = prompt;
	    }

	    let output = await this.format();
	    let help = (await this.error()) || (await this.hint());
	    let body = await this.renderChoices();
	    let footer = await this.footer();

	    if (output) prompt += output;
	    if (help && !prompt.includes(help)) prompt += ' ' + help;

	    if (submitted && !output && !body.trim() && this.multiple && this.emptyError != null) {
	      prompt += this.styles.danger(this.emptyError);
	    }

	    this.clear(size);
	    this.write([header, prompt, body, footer].filter(Boolean).join('\n'));
	    this.write(this.margin[2]);
	    this.restore();
	  }
	}

	select = SelectPrompt;
	return select;
}

var autocomplete;
var hasRequiredAutocomplete;

function requireAutocomplete () {
	if (hasRequiredAutocomplete) return autocomplete;
	hasRequiredAutocomplete = 1;

	const Select = requireSelect();

	const highlight = (input, color) => {
	  const regex = input ? new RegExp(input, 'ig') : /$^/;

	  return str => {
	    return input ? str.replace(regex, match => color(match)) : str;
	  };
	};

	class AutoComplete extends Select {
	  constructor(options) {
	    super(options);
	    this.cursorShow();
	  }

	  moveCursor(n) {
	    this.state.cursor += n;
	  }

	  dispatch(ch) {
	    return this.append(ch);
	  }

	  space(ch) {
	    return this.options.multiple ? super.space(ch) : this.append(ch);
	  }

	  append(ch) {
	    let { cursor, input } = this.state;
	    this.input = input.slice(0, cursor) + ch + input.slice(cursor);
	    this.moveCursor(1);
	    return this.complete();
	  }

	  delete() {
	    let { cursor, input } = this.state;
	    if (!input) return this.alert();
	    this.input = input.slice(0, cursor - 1) + input.slice(cursor);
	    this.moveCursor(-1);
	    return this.complete();
	  }

	  deleteForward() {
	    let { cursor, input } = this.state;
	    if (input[cursor] === void 0) return this.alert();
	    this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
	    return this.complete();
	  }

	  number(ch) {
	    return this.append(ch);
	  }

	  async complete() {
	    this.completing = true;
	    this.choices = await this.suggest(this.input, this.state._choices);
	    this.state.limit = void 0; // allow getter/setter to reset limit
	    this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index);
	    await this.render();
	    this.completing = false;
	  }

	  suggest(input = this.input, choices = this.state._choices) {
	    if (typeof this.options.suggest === 'function') {
	      return this.options.suggest.call(this, input, choices);
	    }
	    let str = input.toLowerCase();
	    return choices.filter(ch => ch.message.toLowerCase().includes(str));
	  }

	  pointer() {
	    return '';
	  }

	  format() {
	    if (!this.focused) return this.input;

	    if (this.options.multiple && this.state.submitted) {
	      return this.selected.map(ch => this.styles.primary(ch.message)).join(', ');
	    }

	    if (this.state.submitted) {
	      let value = this.value = this.input = this.focused.value;
	      return this.styles.primary(value);
	    }

	    return this.input;
	  }

	  async render() {
	    if (this.state.status !== 'pending') return super.render();
	    const hl = this.options.highlight || this.styles.complement;

	    const style = (input, color) => {
	      if (!input) return input;
	      if (hl.stack) return hl(input);
	      return hl.call(this, input);
	    };

	    const color = highlight(this.input, style);
	    const choices = this.choices;
	    this.choices = choices.map(ch => ({ ...ch, message: color(ch.message) }));
	    await super.render();
	    this.choices = choices;
	  }

	  submit() {
	    if (this.options.multiple) {
	      this.value = this.selected.map(ch => ch.name);
	    }
	    return super.submit();
	  }
	}

	autocomplete = AutoComplete;
	return autocomplete;
}

var placeholder;
var hasRequiredPlaceholder;

function requirePlaceholder () {
	if (hasRequiredPlaceholder) return placeholder;
	hasRequiredPlaceholder = 1;

	const utils = requireUtils();

	/**
	 * Render a placeholder value with cursor and styling based on the
	 * position of the cursor.
	 *
	 * @param {Object} `prompt` Prompt instance.
	 * @param {String} `input` Input string.
	 * @param {String} `initial` The initial user-provided value.
	 * @param {Number} `pos` Current cursor position.
	 * @param {Boolean} `showCursor` Render a simulated cursor using the inverse primary style.
	 * @return {String} Returns the styled placeholder string.
	 * @api public
	 */

	placeholder = (prompt, options = {}) => {
	  prompt.cursorHide();

	  let { input = '', initial = '', pos, showCursor = true, color } = options;
	  let style = color || prompt.styles.placeholder;
	  let inverse = utils.inverse(prompt.styles.primary);
	  let blinker = str => inverse(prompt.styles.black(str));
	  let output = input;
	  let char = ' ';
	  let reverse = blinker(char);

	  if (prompt.blink && prompt.blink.off === true) {
	    blinker = str => str;
	    reverse = '';
	  }

	  if (showCursor && pos === 0 && initial === '' && input === '') {
	    return blinker(char);
	  }

	  if (showCursor && pos === 0 && (input === initial || input === '')) {
	    return blinker(initial[0]) + style(initial.slice(1));
	  }

	  initial = utils.isPrimitive(initial) ? `${initial}` : '';
	  input = utils.isPrimitive(input) ? `${input}` : '';

	  let placeholder = initial && initial.startsWith(input) && initial !== input;
	  let cursor = placeholder ? blinker(initial[input.length]) : reverse;

	  if (pos !== input.length && showCursor === true) {
	    output = input.slice(0, pos) + blinker(input[pos]) + input.slice(pos + 1);
	    cursor = '';
	  }

	  if (showCursor === false) {
	    cursor = '';
	  }

	  if (placeholder) {
	    let raw = prompt.styles.unstyle(output + cursor);
	    return output + cursor + style(initial.slice(raw.length));
	  }

	  return output + cursor;
	};
	return placeholder;
}

var form;
var hasRequiredForm;

function requireForm () {
	if (hasRequiredForm) return form;
	hasRequiredForm = 1;

	const stripAnsi = requireStripAnsi();
	const SelectPrompt = requireSelect();
	const placeholder = requirePlaceholder();

	class FormPrompt extends SelectPrompt {
	  constructor(options) {
	    super({ ...options, multiple: true });
	    this.type = 'form';
	    this.initial = this.options.initial;
	    this.align = [this.options.align, 'right'].find(v => v != null);
	    this.emptyError = '';
	    this.values = {};
	  }

	  async reset(first) {
	    await super.reset();
	    if (first === true) this._index = this.index;
	    this.index = this._index;
	    this.values = {};
	    this.choices.forEach(choice => choice.reset && choice.reset());
	    return this.render();
	  }

	  dispatch(char) {
	    return !!char && this.append(char);
	  }

	  append(char) {
	    let choice = this.focused;
	    if (!choice) return this.alert();
	    let { cursor, input } = choice;
	    choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);
	    choice.cursor++;
	    return this.render();
	  }

	  delete() {
	    let choice = this.focused;
	    if (!choice || choice.cursor <= 0) return this.alert();
	    let { cursor, input } = choice;
	    choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);
	    choice.cursor--;
	    return this.render();
	  }

	  deleteForward() {
	    let choice = this.focused;
	    if (!choice) return this.alert();
	    let { cursor, input } = choice;
	    if (input[cursor] === void 0) return this.alert();
	    let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
	    choice.value = choice.input = str;
	    return this.render();
	  }

	  right() {
	    let choice = this.focused;
	    if (!choice) return this.alert();
	    if (choice.cursor >= choice.input.length) return this.alert();
	    choice.cursor++;
	    return this.render();
	  }

	  left() {
	    let choice = this.focused;
	    if (!choice) return this.alert();
	    if (choice.cursor <= 0) return this.alert();
	    choice.cursor--;
	    return this.render();
	  }

	  space(ch, key) {
	    return this.dispatch(ch, key);
	  }

	  number(ch, key) {
	    return this.dispatch(ch, key);
	  }

	  next() {
	    let ch = this.focused;
	    if (!ch) return this.alert();
	    let { initial, input } = ch;
	    if (initial && initial.startsWith(input) && input !== initial) {
	      ch.value = ch.input = initial;
	      ch.cursor = ch.value.length;
	      return this.render();
	    }
	    return super.next();
	  }

	  prev() {
	    let ch = this.focused;
	    if (!ch) return this.alert();
	    if (ch.cursor === 0) return super.prev();
	    ch.value = ch.input = '';
	    ch.cursor = 0;
	    return this.render();
	  }

	  separator() {
	    return '';
	  }

	  format(value) {
	    return !this.state.submitted ? super.format(value) : '';
	  }

	  pointer() {
	    return '';
	  }

	  indicator(choice) {
	    return choice.input ? '⦿' : '⊙';
	  }

	  async choiceSeparator(choice, i) {
	    let sep = await this.resolve(choice.separator, this.state, choice, i) || ':';
	    return sep ? ' ' + this.styles.disabled(sep) : '';
	  }

	  async renderChoice(choice, i) {
	    await this.onChoice(choice, i);

	    let { state, styles } = this;
	    let { cursor, initial = '', name, input = '' } = choice;
	    let { muted, submitted, primary, danger } = styles;

	    let focused = this.index === i;
	    let validate = choice.validate || (() => true);
	    let sep = await this.choiceSeparator(choice, i);
	    let msg = choice.message;

	    if (this.align === 'right') msg = msg.padStart(this.longest + 1, ' ');
	    if (this.align === 'left') msg = msg.padEnd(this.longest + 1, ' ');

	    // re-populate the form values (answers) object
	    let value = this.values[name] = (input || initial);
	    let color = input ? 'success' : 'dark';

	    if ((await validate.call(choice, value, this.state)) !== true) {
	      color = 'danger';
	    }

	    let style = styles[color];
	    let indicator = style(await this.indicator(choice, i)) + (choice.pad || '');

	    let indent = this.indent(choice);
	    let line = () => [indent, indicator, msg + sep, input ].filter(Boolean).join(' ');

	    if (state.submitted) {
	      msg = stripAnsi(msg);
	      input = submitted(input);

	      return line();
	    }

	    if (choice.format) {
	      input = await choice.format.call(this, input, choice, i);
	    } else {
	      let color = this.styles.muted;
	      let options = { input, initial, pos: cursor, showCursor: focused, color };
	      input = placeholder(this, options);
	    }

	    if (!this.isValue(input)) {
	      input = this.styles.muted(this.symbols.ellipsis);
	    }

	    if (choice.result) {
	      this.values[name] = await choice.result.call(this, value, choice, i);
	    }

	    if (focused) {
	      msg = primary(msg);
	    }

	    if (choice.error) {
	      input += (input ? ' ' : '') + danger(choice.error.trim());
	    } else if (choice.hint) {
	      input += (input ? ' ' : '') + muted(choice.hint.trim());
	    }

	    return line();
	  }

	  async submit() {
	    this.value = this.values;
	    return super.base.submit.call(this);
	  }
	}

	form = FormPrompt;
	return form;
}

var auth;
var hasRequiredAuth;

function requireAuth () {
	if (hasRequiredAuth) return auth;
	hasRequiredAuth = 1;

	const FormPrompt = requireForm();

	const defaultAuthenticate = () => {
	  throw new Error('expected prompt to have a custom authenticate method');
	};

	const factory = (authenticate = defaultAuthenticate) => {

	  class AuthPrompt extends FormPrompt {
	    constructor(options) {
	      super(options);
	    }

	    async submit() {
	      this.value = await authenticate.call(this, this.values, this.state);
	      super.base.submit.call(this);
	    }

	    static create(authenticate) {
	      return factory(authenticate);
	    }
	  }

	  return AuthPrompt;
	};

	auth = factory();
	return auth;
}

var basicauth;
var hasRequiredBasicauth;

function requireBasicauth () {
	if (hasRequiredBasicauth) return basicauth;
	hasRequiredBasicauth = 1;

	const AuthPrompt = requireAuth();

	function defaultAuthenticate(value, state) {
	  if (value.username === this.options.username && value.password === this.options.password) {
	    return true;
	  }
	  return false;
	}

	const factory = (authenticate = defaultAuthenticate) => {
	  const choices = [
	    { name: 'username', message: 'username' },
	    {
	      name: 'password',
	      message: 'password',
	      format(input) {
	        if (this.options.showPassword) {
	          return input;
	        }
	        let color = this.state.submitted ? this.styles.primary : this.styles.muted;
	        return color(this.symbols.asterisk.repeat(input.length));
	      }
	    }
	  ];

	  class BasicAuthPrompt extends AuthPrompt.create(authenticate) {
	    constructor(options) {
	      super({ ...options, choices });
	    }

	    static create(authenticate) {
	      return factory(authenticate);
	    }
	  }

	  return BasicAuthPrompt;
	};

	basicauth = factory();
	return basicauth;
}

var boolean;
var hasRequiredBoolean;

function requireBoolean () {
	if (hasRequiredBoolean) return boolean;
	hasRequiredBoolean = 1;

	const Prompt = requirePrompt();
	const { isPrimitive, hasColor } = requireUtils();

	class BooleanPrompt extends Prompt {
	  constructor(options) {
	    super(options);
	    this.cursorHide();
	  }

	  async initialize() {
	    let initial = await this.resolve(this.initial, this.state);
	    this.input = await this.cast(initial);
	    await super.initialize();
	  }

	  dispatch(ch) {
	    if (!this.isValue(ch)) return this.alert();
	    this.input = ch;
	    return this.submit();
	  }

	  format(value) {
	    let { styles, state } = this;
	    return !state.submitted ? styles.primary(value) : styles.success(value);
	  }

	  cast(input) {
	    return this.isTrue(input);
	  }

	  isTrue(input) {
	    return /^[ty1]/i.test(input);
	  }

	  isFalse(input) {
	    return /^[fn0]/i.test(input);
	  }

	  isValue(value) {
	    return isPrimitive(value) && (this.isTrue(value) || this.isFalse(value));
	  }

	  async hint() {
	    if (this.state.status === 'pending') {
	      let hint = await this.element('hint');
	      if (!hasColor(hint)) {
	        return this.styles.muted(hint);
	      }
	      return hint;
	    }
	  }

	  async render() {
	    let { input, size } = this.state;

	    let prefix = await this.prefix();
	    let sep = await this.separator();
	    let msg = await this.message();
	    let hint = this.styles.muted(this.default);

	    let promptLine = [prefix, msg, hint, sep].filter(Boolean).join(' ');
	    this.state.prompt = promptLine;

	    let header = await this.header();
	    let value = this.value = this.cast(input);
	    let output = await this.format(value);
	    let help = (await this.error()) || (await this.hint());
	    let footer = await this.footer();

	    if (help && !promptLine.includes(help)) output += ' ' + help;
	    promptLine += ' ' + output;

	    this.clear(size);
	    this.write([header, promptLine, footer].filter(Boolean).join('\n'));
	    this.restore();
	  }

	  set value(value) {
	    super.value = value;
	  }
	  get value() {
	    return this.cast(super.value);
	  }
	}

	boolean = BooleanPrompt;
	return boolean;
}

var confirm;
var hasRequiredConfirm;

function requireConfirm () {
	if (hasRequiredConfirm) return confirm;
	hasRequiredConfirm = 1;

	const BooleanPrompt = requireBoolean();

	class ConfirmPrompt extends BooleanPrompt {
	  constructor(options) {
	    super(options);
	    this.default = this.options.default || (this.initial ? '(Y/n)' : '(y/N)');
	  }
	}

	confirm = ConfirmPrompt;
	return confirm;
}

var editable;
var hasRequiredEditable;

function requireEditable () {
	if (hasRequiredEditable) return editable;
	hasRequiredEditable = 1;

	const Select = requireSelect();
	const Form = requireForm();
	const form = Form.prototype;

	class Editable extends Select {
	  constructor(options) {
	    super({ ...options, multiple: true });
	    this.align = [this.options.align, 'left'].find(v => v != null);
	    this.emptyError = '';
	    this.values = {};
	  }

	  dispatch(char, key) {
	    let choice = this.focused;
	    let parent = choice.parent || {};
	    if (!choice.editable && !parent.editable) {
	      if (char === 'a' || char === 'i') return super[char]();
	    }
	    return form.dispatch.call(this, char, key);
	  }

	  append(char, key) {
	    return form.append.call(this, char, key);
	  }

	  delete(char, key) {
	    return form.delete.call(this, char, key);
	  }

	  space(char) {
	    return this.focused.editable ? this.append(char) : super.space();
	  }

	  number(char) {
	    return this.focused.editable ? this.append(char) : super.number(char);
	  }

	  next() {
	    return this.focused.editable ? form.next.call(this) : super.next();
	  }

	  prev() {
	    return this.focused.editable ? form.prev.call(this) : super.prev();
	  }

	  async indicator(choice, i) {
	    let symbol = choice.indicator || '';
	    let value = choice.editable ? symbol : super.indicator(choice, i);
	    return await this.resolve(value, this.state, choice, i) || '';
	  }

	  indent(choice) {
	    return choice.role === 'heading' ? '' : (choice.editable ? ' ' : '  ');
	  }

	  async renderChoice(choice, i) {
	    choice.indent = '';
	    if (choice.editable) return form.renderChoice.call(this, choice, i);
	    return super.renderChoice(choice, i);
	  }

	  error() {
	    return '';
	  }

	  footer() {
	    return this.state.error;
	  }

	  async validate() {
	    let result = true;

	    for (let choice of this.choices) {
	      if (typeof choice.validate !== 'function') {
	        continue;
	      }

	      if (choice.role === 'heading') {
	        continue;
	      }

	      let val = choice.parent ? this.value[choice.parent.name] : this.value;

	      if (choice.editable) {
	        val = choice.value === choice.name ? choice.initial || '' : choice.value;
	      } else if (!this.isDisabled(choice)) {
	        val = choice.enabled === true;
	      }

	      result = await choice.validate(val, this.state);

	      if (result !== true) {
	        break;
	      }
	    }

	    if (result !== true) {
	      this.state.error = typeof result === 'string' ? result : 'Invalid Input';
	    }

	    return result;
	  }

	  submit() {
	    if (this.focused.newChoice === true) return super.submit();
	    if (this.choices.some(ch => ch.newChoice)) {
	      return this.alert();
	    }

	    this.value = {};

	    for (let choice of this.choices) {
	      let val = choice.parent ? this.value[choice.parent.name] : this.value;

	      if (choice.role === 'heading') {
	        this.value[choice.name] = {};
	        continue;
	      }

	      if (choice.editable) {
	        val[choice.name] = choice.value === choice.name
	          ? (choice.initial || '')
	          : choice.value;

	      } else if (!this.isDisabled(choice)) {
	        val[choice.name] = choice.enabled === true;
	      }
	    }

	    return this.base.submit.call(this);
	  }
	}

	editable = Editable;
	return editable;
}

var string;
var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string;
	hasRequiredString = 1;

	const Prompt = requirePrompt();
	const keypress = requireKeypress();
	const placeholder = requirePlaceholder();
	const { isPrimitive } = requireUtils();

	class StringPrompt extends Prompt {
	  constructor(options) {
	    super(options);
	    this.initial = isPrimitive(this.initial) ? String(this.initial) : '';
	    if (this.initial) this.cursorHide();
	    this.state.prevCursor = 0;
	    this.state.clipboard = [];
	    this.keypressTimeout =
	      this.options.keypressTimeout !== undefined
	        ? this.options.keypressTimeout
	        : null;
	  }

	  async keypress(input, key = input ? keypress(input, {}) : {}) {
	    const now = Date.now();
	    const elapsed = now - this.lastKeypress;
	    this.lastKeypress = now;

	    const isEnterKey = key.name === 'return' || key.name === 'enter';
	    let prev = this.state.prevKeypress;
	    let append;
	    this.state.prevKeypress = key;

	    if (this.keypressTimeout != null && isEnterKey) {
	      if (elapsed < this.keypressTimeout) {
	        return this.submit();
	      }

	      this.state.multilineBuffer = this.state.multilineBuffer || '';
	      this.state.multilineBuffer += input;
	      append = true;
	      prev = null;
	    }

	    if (append || (this.options.multiline && isEnterKey)) {
	      if (!prev || prev.name !== 'return') {
	        return this.append('\n', key);
	      }
	    }

	    return super.keypress(input, key);
	  }

	  moveCursor(n) {
	    this.cursor += n;
	  }

	  reset() {
	    this.input = this.value = '';
	    this.cursor = 0;
	    return this.render();
	  }

	  dispatch(ch, key) {
	    if (!ch || key.ctrl || key.code) return this.alert();
	    this.append(ch);
	  }

	  append(ch) {
	    let { cursor, input } = this.state;
	    this.input = `${input}`.slice(0, cursor) + ch + `${input}`.slice(cursor);
	    this.moveCursor(String(ch).length);
	    this.render();
	  }

	  insert(str) {
	    this.append(str);
	  }

	  delete() {
	    let { cursor, input } = this.state;
	    if (cursor <= 0) return this.alert();
	    this.input = `${input}`.slice(0, cursor - 1) + `${input}`.slice(cursor);
	    this.moveCursor(-1);
	    this.render();
	  }

	  deleteForward() {
	    let { cursor, input } = this.state;
	    if (input[cursor] === void 0) return this.alert();
	    this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
	    this.render();
	  }

	  cutForward() {
	    let pos = this.cursor;
	    if (this.input.length <= pos) return this.alert();
	    this.state.clipboard.push(this.input.slice(pos));
	    this.input = this.input.slice(0, pos);
	    this.render();
	  }

	  cutLeft() {
	    let pos = this.cursor;
	    if (pos === 0) return this.alert();
	    let before = this.input.slice(0, pos);
	    let after = this.input.slice(pos);
	    let words = before.split(' ');
	    this.state.clipboard.push(words.pop());
	    this.input = words.join(' ');
	    this.cursor = this.input.length;
	    this.input += after;
	    this.render();
	  }

	  paste() {
	    if (!this.state.clipboard.length) return this.alert();
	    this.insert(this.state.clipboard.pop());
	    this.render();
	  }

	  toggleCursor() {
	    if (this.state.prevCursor) {
	      this.cursor = this.state.prevCursor;
	      this.state.prevCursor = 0;
	    } else {
	      this.state.prevCursor = this.cursor;
	      this.cursor = 0;
	    }
	    this.render();
	  }

	  first() {
	    this.cursor = 0;
	    this.render();
	  }

	  last() {
	    this.cursor = this.input.length - 1;
	    this.render();
	  }

	  next() {
	    let init = this.initial != null ? String(this.initial) : '';
	    if (!init || !init.startsWith(this.input)) return this.alert();
	    this.input = this.initial;
	    this.cursor = this.initial.length;
	    this.render();
	  }

	  prev() {
	    if (!this.input) return this.alert();
	    this.reset();
	  }

	  backward() {
	    return this.left();
	  }

	  forward() {
	    return this.right();
	  }

	  right() {
	    if (this.cursor >= this.input.length) return this.alert();
	    this.moveCursor(1);
	    return this.render();
	  }

	  left() {
	    if (this.cursor <= 0) return this.alert();
	    this.moveCursor(-1);
	    return this.render();
	  }

	  isValue(value) {
	    return !!value;
	  }

	  async format(input = this.value) {
	    let initial = await this.resolve(this.initial, this.state);
	    if (!this.state.submitted) {
	      return placeholder(this, { input, initial, pos: this.cursor });
	    }
	    return this.styles.submitted(input || initial);
	  }

	  async render() {
	    let size = this.state.size;

	    let prefix = await this.prefix();
	    let separator = await this.separator();
	    let message = await this.message();

	    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
	    this.state.prompt = prompt;

	    let header = await this.header();
	    let output = await this.format();
	    let help = (await this.error()) || (await this.hint());
	    let footer = await this.footer();

	    if (help && !output.includes(help)) output += ' ' + help;
	    prompt += ' ' + output;

	    this.clear(size);
	    this.write([header, prompt, footer].filter(Boolean).join('\n'));
	    this.restore();
	  }
	}

	string = StringPrompt;
	return string;
}

var completer;
var hasRequiredCompleter;

function requireCompleter () {
	if (hasRequiredCompleter) return completer;
	hasRequiredCompleter = 1;

	const unique = arr => arr.filter((v, i) => arr.lastIndexOf(v) === i);
	const compact = arr => unique(arr).filter(Boolean);

	completer = (action, data = {}, value = '') => {
	  let { past = [], present = '' } = data;
	  let rest, prev;

	  switch (action) {
	    case 'prev':
	    case 'undo':
	      rest = past.slice(0, past.length - 1);
	      prev = past[past.length - 1] || '';
	      return {
	        past: compact([value, ...rest]),
	        present: prev
	      };

	    case 'next':
	    case 'redo':
	      rest = past.slice(1);
	      prev = past[0] || '';
	      return {
	        past: compact([...rest, value]),
	        present: prev
	      };

	    case 'save':
	      return {
	        past: compact([...past, value]),
	        present: ''
	      };

	    case 'remove':
	      prev = compact(past.filter(v => v !== value));
	      present = '';

	      if (prev.length) {
	        present = prev.pop();
	      }

	      return {
	        past: prev,
	        present
	      };

	    default: {
	      throw new Error(`Invalid action: "${action}"`);
	    }
	  }
	};
	return completer;
}

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;

	const Prompt = requireString();
	const completer = requireCompleter();

	class Input extends Prompt {
	  constructor(options) {
	    super(options);
	    let history = this.options.history;
	    if (history && history.store) {
	      let initial = history.values || this.initial;
	      this.autosave = !!history.autosave;
	      this.store = history.store;
	      this.data = this.store.get('values') || { past: [], present: initial };
	      this.initial = this.data.present || this.data.past[this.data.past.length - 1];
	    }
	  }

	  completion(action) {
	    if (!this.store) return this.alert();
	    this.data = completer(action, this.data, this.input);
	    if (!this.data.present) return this.alert();
	    this.input = this.data.present;
	    this.cursor = this.input.length;
	    return this.render();
	  }

	  altUp() {
	    return this.completion('prev');
	  }

	  altDown() {
	    return this.completion('next');
	  }

	  prev() {
	    this.save();
	    return super.prev();
	  }

	  save() {
	    if (!this.store) return;
	    this.data = completer('save', this.data, this.input);
	    this.store.set('values', this.data);
	  }

	  submit() {
	    if (this.store && this.autosave === true) {
	      this.save();
	    }
	    return super.submit();
	  }
	}

	input = Input;
	return input;
}

var invisible;
var hasRequiredInvisible;

function requireInvisible () {
	if (hasRequiredInvisible) return invisible;
	hasRequiredInvisible = 1;

	const StringPrompt = requireString();

	class InvisiblePrompt extends StringPrompt {
	  format() {
	    return '';
	  }
	}

	invisible = InvisiblePrompt;
	return invisible;
}

var list;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return list;
	hasRequiredList = 1;

	const StringPrompt = requireString();

	class ListPrompt extends StringPrompt {
	  constructor(options = {}) {
	    super(options);
	    this.sep = this.options.separator || /, */;
	    this.initial = options.initial || '';
	  }

	  split(input = this.value) {
	    return input ? String(input).split(this.sep) : [];
	  }

	  format() {
	    let style = this.state.submitted ? this.styles.primary : val => val;
	    return this.list.map(style).join(', ');
	  }

	  async submit(value) {
	    let result = this.state.error || await this.validate(this.list, this.state);
	    if (result !== true) {
	      this.state.error = result;
	      return super.submit();
	    }
	    this.value = this.list;
	    return super.submit();
	  }

	  get list() {
	    return this.split();
	  }
	}

	list = ListPrompt;
	return list;
}

var multiselect;
var hasRequiredMultiselect;

function requireMultiselect () {
	if (hasRequiredMultiselect) return multiselect;
	hasRequiredMultiselect = 1;

	const Select = requireSelect();

	class MultiSelect extends Select {
	  constructor(options) {
	    super({ ...options, multiple: true });
	  }
	}

	multiselect = MultiSelect;
	return multiselect;
}

var number;
var hasRequiredNumber;

function requireNumber () {
	if (hasRequiredNumber) return number;
	hasRequiredNumber = 1;

	const StringPrompt = requireString();

	class NumberPrompt extends StringPrompt {
	  constructor(options = {}) {
	    super({ style: 'number', ...options });
	    this.min = this.isValue(options.min) ? this.toNumber(options.min) : -Infinity;
	    this.max = this.isValue(options.max) ? this.toNumber(options.max) : Infinity;
	    this.delay = options.delay != null ? options.delay : 1000;
	    this.float = options.float !== false;
	    this.round = options.round === true || options.float === false;
	    this.major = options.major || 10;
	    this.minor = options.minor || 1;
	    this.initial = options.initial != null ? options.initial : '';
	    this.input = String(this.initial);
	    this.cursor = this.input.length;
	    this.cursorShow();
	  }

	  append(ch) {
	    if (!/[-+.]/.test(ch) || (ch === '.' && this.input.includes('.'))) {
	      return this.alert('invalid number');
	    }
	    return super.append(ch);
	  }

	  number(ch) {
	    return super.append(ch);
	  }

	  next() {
	    if (this.input && this.input !== this.initial) return this.alert();
	    if (!this.isValue(this.initial)) return this.alert();
	    this.input = this.initial;
	    this.cursor = String(this.initial).length;
	    return this.render();
	  }

	  up(number) {
	    let step = number || this.minor;
	    let num = this.toNumber(this.input);
	    if (num > this.max + step) return this.alert();
	    this.input = `${num + step}`;
	    return this.render();
	  }

	  down(number) {
	    let step = number || this.minor;
	    let num = this.toNumber(this.input);
	    if (num < this.min - step) return this.alert();
	    this.input = `${num - step}`;
	    return this.render();
	  }

	  shiftDown() {
	    return this.down(this.major);
	  }

	  shiftUp() {
	    return this.up(this.major);
	  }

	  format(input = this.input) {
	    if (typeof this.options.format === 'function') {
	      return this.options.format.call(this, input);
	    }
	    return this.styles.info(input);
	  }

	  toNumber(value = '') {
	    return this.float ? +value : Math.round(+value);
	  }

	  isValue(value) {
	    return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(value);
	  }

	  submit() {
	    let value = [this.input, this.initial].find(v => this.isValue(v));
	    this.value = this.toNumber(value || 0);
	    return super.submit();
	  }
	}

	number = NumberPrompt;
	return number;
}

var numeral;
var hasRequiredNumeral;

function requireNumeral () {
	if (hasRequiredNumeral) return numeral;
	hasRequiredNumeral = 1;
	numeral = requireNumber();
	return numeral;
}

var password;
var hasRequiredPassword;

function requirePassword () {
	if (hasRequiredPassword) return password;
	hasRequiredPassword = 1;

	const StringPrompt = requireString();

	class PasswordPrompt extends StringPrompt {
	  constructor(options) {
	    super(options);
	    this.cursorShow();
	  }

	  format(input = this.input) {
	    if (!this.keypressed) return '';
	    let color = this.state.submitted ? this.styles.primary : this.styles.muted;
	    return color(this.symbols.asterisk.repeat(input.length));
	  }
	}

	password = PasswordPrompt;
	return password;
}

var scale;
var hasRequiredScale;

function requireScale () {
	if (hasRequiredScale) return scale;
	hasRequiredScale = 1;

	const stripAnsi = requireStripAnsi();
	const ArrayPrompt = requireArray();
	const utils = requireUtils();

	class LikertScale extends ArrayPrompt {
	  constructor(options = {}) {
	    super(options);
	    this.widths = [].concat(options.messageWidth || 50);
	    this.align = [].concat(options.align || 'left');
	    this.linebreak = options.linebreak || false;
	    this.edgeLength = options.edgeLength || 3;
	    this.newline = options.newline || '\n   ';
	    let start = options.startNumber || 1;
	    if (typeof this.scale === 'number') {
	      this.scaleKey = false;
	      this.scale = Array(this.scale).fill(0).map((v, i) => ({ name: i + start }));
	    }
	  }

	  async reset() {
	    this.tableized = false;
	    await super.reset();
	    return this.render();
	  }

	  tableize() {
	    if (this.tableized === true) return;
	    this.tableized = true;
	    let longest = 0;

	    for (let ch of this.choices) {
	      longest = Math.max(longest, ch.message.length);
	      ch.scaleIndex = ch.initial || 2;
	      ch.scale = [];

	      for (let i = 0; i < this.scale.length; i++) {
	        ch.scale.push({ index: i });
	      }
	    }
	    this.widths[0] = Math.min(this.widths[0], longest + 3);
	  }

	  async dispatch(s, key) {
	    if (this.multiple) {
	      return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
	    }
	    this.alert();
	  }

	  heading(msg, item, i) {
	    return this.styles.strong(msg);
	  }

	  separator() {
	    return this.styles.muted(this.symbols.ellipsis);
	  }

	  right() {
	    let choice = this.focused;
	    if (choice.scaleIndex >= this.scale.length - 1) return this.alert();
	    choice.scaleIndex++;
	    return this.render();
	  }

	  left() {
	    let choice = this.focused;
	    if (choice.scaleIndex <= 0) return this.alert();
	    choice.scaleIndex--;
	    return this.render();
	  }

	  indent() {
	    return '';
	  }

	  format() {
	    if (this.state.submitted) {
	      let values = this.choices.map(ch => this.styles.info(ch.index));
	      return values.join(', ');
	    }
	    return '';
	  }

	  pointer() {
	    return '';
	  }

	  /**
	   * Render the scale "Key". Something like:
	   * @return {String}
	   */

	  renderScaleKey() {
	    if (this.scaleKey === false) return '';
	    if (this.state.submitted) return '';
	    let scale = this.scale.map(item => `   ${item.name} - ${item.message}`);
	    let key = ['', ...scale].map(item => this.styles.muted(item));
	    return key.join('\n');
	  }

	  /**
	   * Render the heading row for the scale.
	   * @return {String}
	   */

	  renderScaleHeading(max) {
	    let keys = this.scale.map(ele => ele.name);
	    if (typeof this.options.renderScaleHeading === 'function') {
	      keys = this.options.renderScaleHeading.call(this, max);
	    }
	    let diff = this.scaleLength - keys.join('').length;
	    let spacing = Math.round(diff / (keys.length - 1));
	    let names = keys.map(key => this.styles.strong(key));
	    let headings = names.join(' '.repeat(spacing));
	    let padding = ' '.repeat(this.widths[0]);
	    return this.margin[3] + padding + this.margin[1] + headings;
	  }

	  /**
	   * Render a scale indicator => ◯ or ◉ by default
	   */

	  scaleIndicator(choice, item, i) {
	    if (typeof this.options.scaleIndicator === 'function') {
	      return this.options.scaleIndicator.call(this, choice, item, i);
	    }
	    let enabled = choice.scaleIndex === item.index;
	    if (item.disabled) return this.styles.hint(this.symbols.radio.disabled);
	    if (enabled) return this.styles.success(this.symbols.radio.on);
	    return this.symbols.radio.off;
	  }

	  /**
	   * Render the actual scale => ◯────◯────◉────◯────◯
	   */

	  renderScale(choice, i) {
	    let scale = choice.scale.map(item => this.scaleIndicator(choice, item, i));
	    let padding = this.term === 'Hyper' ? '' : ' ';
	    return scale.join(padding + this.symbols.line.repeat(this.edgeLength));
	  }

	  /**
	   * Render a choice, including scale =>
	   *   "The website is easy to navigate. ◯───◯───◉───◯───◯"
	   */

	  async renderChoice(choice, i) {
	    await this.onChoice(choice, i);

	    let focused = this.index === i;
	    let pointer = await this.pointer(choice, i);
	    let hint = await choice.hint;

	    if (hint && !utils.hasColor(hint)) {
	      hint = this.styles.muted(hint);
	    }

	    let pad = str => this.margin[3] + str.replace(/\s+$/, '').padEnd(this.widths[0], ' ');
	    let newline = this.newline;
	    let ind = this.indent(choice);
	    let message = await this.resolve(choice.message, this.state, choice, i);
	    let scale = await this.renderScale(choice, i);
	    let margin = this.margin[1] + this.margin[3];
	    this.scaleLength = stripAnsi(scale).length;
	    this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - margin.length);
	    let msg = utils.wordWrap(message, { width: this.widths[0], newline });
	    let lines = msg.split('\n').map(line => pad(line) + this.margin[1]);

	    if (focused) {
	      scale = this.styles.info(scale);
	      lines = lines.map(line => this.styles.info(line));
	    }

	    lines[0] += scale;

	    if (this.linebreak) lines.push('');
	    return [ind + pointer, lines.join('\n')].filter(Boolean);
	  }

	  async renderChoices() {
	    if (this.state.submitted) return '';
	    this.tableize();
	    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
	    let visible = await Promise.all(choices);
	    let heading = await this.renderScaleHeading();
	    return this.margin[0] + [heading, ...visible.map(v => v.join(' '))].join('\n');
	  }

	  async render() {
	    let { submitted, size } = this.state;

	    let prefix = await this.prefix();
	    let separator = await this.separator();
	    let message = await this.message();

	    let prompt = '';
	    if (this.options.promptLine !== false) {
	      prompt = [prefix, message, separator, ''].join(' ');
	      this.state.prompt = prompt;
	    }

	    let header = await this.header();
	    let output = await this.format();
	    let key = await this.renderScaleKey();
	    let help = await this.error() || await this.hint();
	    let body = await this.renderChoices();
	    let footer = await this.footer();
	    let err = this.emptyError;

	    if (output) prompt += output;
	    if (help && !prompt.includes(help)) prompt += ' ' + help;

	    if (submitted && !output && !body.trim() && this.multiple && err != null) {
	      prompt += this.styles.danger(err);
	    }

	    this.clear(size);
	    this.write([header, prompt, key, body, footer].filter(Boolean).join('\n'));
	    if (!this.state.submitted) {
	      this.write(this.margin[2]);
	    }
	    this.restore();
	  }

	  submit() {
	    this.value = {};
	    for (let choice of this.choices) {
	      this.value[choice.name] = choice.scaleIndex;
	    }
	    return this.base.submit.call(this);
	  }
	}

	scale = LikertScale;
	return scale;
}

var interpolate;
var hasRequiredInterpolate;

function requireInterpolate () {
	if (hasRequiredInterpolate) return interpolate;
	hasRequiredInterpolate = 1;

	const stripAnsi = requireStripAnsi();
	const clean = (str = '') => {
	  return typeof str === 'string' ? str.replace(/^['"]|['"]$/g, '') : '';
	};

	/**
	 * This file contains the interpolation and rendering logic for
	 * the Snippet prompt.
	 */

	class Item {
	  constructor(token) {
	    this.name = token.key;
	    this.field = token.field || {};
	    this.value = clean(token.initial || this.field.initial || '');
	    this.message = token.message || this.name;
	    this.cursor = 0;
	    this.input = '';
	    this.lines = [];
	  }
	}

	const tokenize = async(options = {}, defaults = {}, fn = token => token) => {
	  let unique = new Set();
	  let fields = options.fields || [];
	  let input = options.template;
	  let tabstops = [];
	  let items = [];
	  let keys = [];
	  let line = 1;

	  if (typeof input === 'function') {
	    input = await input();
	  }

	  let i = -1;
	  let next = () => input[++i];
	  let peek = () => input[i + 1];
	  let push = token => {
	    token.line = line;
	    tabstops.push(token);
	  };

	  push({ type: 'bos', value: '' });

	  while (i < input.length - 1) {
	    let value = next();

	    if (/^[^\S\n ]$/.test(value)) {
	      push({ type: 'text', value });
	      continue;
	    }

	    if (value === '\n') {
	      push({ type: 'newline', value });
	      line++;
	      continue;
	    }

	    if (value === '\\') {
	      value += next();
	      push({ type: 'text', value });
	      continue;
	    }

	    if ((value === '$' || value === '#' || value === '{') && peek() === '{') {
	      let n = next();
	      value += n;

	      let token = { type: 'template', open: value, inner: '', close: '', value };
	      let ch;

	      while ((ch = next())) {
	        if (ch === '}') {
	          if (peek() === '}') ch += next();
	          token.value += ch;
	          token.close = ch;
	          break;
	        }

	        if (ch === ':') {
	          token.initial = '';
	          token.key = token.inner;
	        } else if (token.initial !== void 0) {
	          token.initial += ch;
	        }

	        token.value += ch;
	        token.inner += ch;
	      }

	      token.template = token.open + (token.initial || token.inner) + token.close;
	      token.key = token.key || token.inner;

	      if (hasOwnProperty.call(defaults, token.key)) {
	        token.initial = defaults[token.key];
	      }

	      token = fn(token);
	      push(token);

	      keys.push(token.key);
	      unique.add(token.key);

	      let item = items.find(item => item.name === token.key);
	      token.field = fields.find(ch => ch.name === token.key);

	      if (!item) {
	        item = new Item(token);
	        items.push(item);
	      }

	      item.lines.push(token.line - 1);
	      continue;
	    }

	    let last = tabstops[tabstops.length - 1];
	    if (last.type === 'text' && last.line === line) {
	      last.value += value;
	    } else {
	      push({ type: 'text', value });
	    }
	  }

	  push({ type: 'eos', value: '' });
	  return { input, tabstops, unique, keys, items };
	};

	interpolate = async prompt => {
	  let options = prompt.options;
	  let required = new Set(options.required === true ? [] : (options.required || []));
	  let defaults = { ...options.values, ...options.initial };
	  let { tabstops, items, keys } = await tokenize(options, defaults);

	  let result = createFn('result', prompt);
	  let format = createFn('format', prompt);
	  let isValid = createFn('validate', prompt, options, true);
	  let isVal = prompt.isValue.bind(prompt);

	  return async(state = {}, submitted = false) => {
	    let index = 0;

	    state.required = required;
	    state.items = items;
	    state.keys = keys;
	    state.output = '';

	    let validate = async(value, state, item, index) => {
	      let error = await isValid(value, state, item, index);
	      if (error === false) {
	        return 'Invalid field ' + item.name;
	      }
	      return error;
	    };

	    for (let token of tabstops) {
	      let value = token.value;
	      let key = token.key;

	      if (token.type !== 'template') {
	        if (value) state.output += value;
	        continue;
	      }

	      if (token.type === 'template') {
	        let item = items.find(ch => ch.name === key);

	        if (options.required === true) {
	          state.required.add(item.name);
	        }

	        let val = [item.input, state.values[item.value], item.value, value].find(isVal);
	        let field = item.field || {};
	        let message = field.message || token.inner;

	        if (submitted) {
	          let error = await validate(state.values[key], state, item, index);
	          if ((error && typeof error === 'string') || error === false) {
	            state.invalid.set(key, error);
	            continue;
	          }

	          state.invalid.delete(key);
	          let res = await result(state.values[key], state, item, index);
	          state.output += stripAnsi(res);
	          continue;
	        }

	        item.placeholder = false;

	        let before = value;
	        value = await format(value, state, item, index);

	        if (val !== value) {
	          state.values[key] = val;
	          value = prompt.styles.typing(val);
	          state.missing.delete(message);

	        } else {
	          state.values[key] = void 0;
	          val = `<${message}>`;
	          value = prompt.styles.primary(val);
	          item.placeholder = true;

	          if (state.required.has(key)) {
	            state.missing.add(message);
	          }
	        }

	        if (state.missing.has(message) && state.validating) {
	          value = prompt.styles.warning(val);
	        }

	        if (state.invalid.has(key) && state.validating) {
	          value = prompt.styles.danger(val);
	        }

	        if (index === state.index) {
	          if (before !== value) {
	            value = prompt.styles.underline(value);
	          } else {
	            value = prompt.styles.heading(stripAnsi(value));
	          }
	        }

	        index++;
	      }

	      if (value) {
	        state.output += value;
	      }
	    }

	    let lines = state.output.split('\n').map(l => ' ' + l);
	    let len = items.length;
	    let done = 0;

	    for (let item of items) {
	      if (state.invalid.has(item.name)) {
	        item.lines.forEach(i => {
	          if (lines[i][0] !== ' ') return;
	          lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
	        });
	      }

	      if (prompt.isValue(state.values[item.name])) {
	        done++;
	      }
	    }

	    state.completed = ((done / len) * 100).toFixed(0);
	    state.output = lines.join('\n');
	    return state.output;
	  };
	};

	function createFn(prop, prompt, options, fallback) {
	  return (value, state, item, index) => {
	    if (typeof item.field[prop] === 'function') {
	      return item.field[prop].call(prompt, value, state, item, index);
	    }
	    return [fallback, value].find(v => prompt.isValue(v));
	  };
	}
	return interpolate;
}

var snippet;
var hasRequiredSnippet;

function requireSnippet () {
	if (hasRequiredSnippet) return snippet;
	hasRequiredSnippet = 1;

	const stripAnsi = requireStripAnsi();
	const interpolate = requireInterpolate();
	const Prompt = requirePrompt();

	class SnippetPrompt extends Prompt {
	  constructor(options) {
	    super(options);
	    this.cursorHide();
	    this.reset(true);
	  }

	  async initialize() {
	    this.interpolate = await interpolate(this);
	    await super.initialize();
	  }

	  async reset(first) {
	    this.state.keys = [];
	    this.state.invalid = new Map();
	    this.state.missing = new Set();
	    this.state.completed = 0;
	    this.state.values = {};

	    if (first !== true) {
	      await this.initialize();
	      await this.render();
	    }
	  }

	  moveCursor(n) {
	    let item = this.getItem();
	    this.cursor += n;
	    item.cursor += n;
	  }

	  dispatch(ch, key) {
	    if (!key.code && !key.ctrl && ch != null && this.getItem()) {
	      this.append(ch, key);
	      return;
	    }
	    this.alert();
	  }

	  append(ch, key) {
	    let item = this.getItem();
	    let prefix = item.input.slice(0, this.cursor);
	    let suffix = item.input.slice(this.cursor);
	    this.input = item.input = `${prefix}${ch}${suffix}`;
	    this.moveCursor(1);
	    this.render();
	  }

	  delete() {
	    let item = this.getItem();
	    if (this.cursor <= 0 || !item.input) return this.alert();
	    let suffix = item.input.slice(this.cursor);
	    let prefix = item.input.slice(0, this.cursor - 1);
	    this.input = item.input = `${prefix}${suffix}`;
	    this.moveCursor(-1);
	    this.render();
	  }

	  increment(i) {
	    return i >= this.state.keys.length - 1 ? 0 : i + 1;
	  }

	  decrement(i) {
	    return i <= 0 ? this.state.keys.length - 1 : i - 1;
	  }

	  first() {
	    this.state.index = 0;
	    this.render();
	  }

	  last() {
	    this.state.index = this.state.keys.length - 1;
	    this.render();
	  }

	  right() {
	    if (this.cursor >= this.input.length) return this.alert();
	    this.moveCursor(1);
	    this.render();
	  }

	  left() {
	    if (this.cursor <= 0) return this.alert();
	    this.moveCursor(-1);
	    this.render();
	  }

	  prev() {
	    this.state.index = this.decrement(this.state.index);
	    this.getItem();
	    this.render();
	  }

	  next() {
	    this.state.index = this.increment(this.state.index);
	    this.getItem();
	    this.render();
	  }

	  up() {
	    this.prev();
	  }

	  down() {
	    this.next();
	  }

	  format(value) {
	    let color = this.state.completed < 100 ? this.styles.warning : this.styles.success;
	    if (this.state.submitted === true && this.state.completed !== 100) {
	      color = this.styles.danger;
	    }
	    return color(`${this.state.completed}% completed`);
	  }

	  async render() {
	    let { index, keys = [], submitted, size } = this.state;

	    let newline = [this.options.newline, '\n'].find(v => v != null);
	    let prefix = await this.prefix();
	    let separator = await this.separator();
	    let message = await this.message();

	    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
	    this.state.prompt = prompt;

	    let header = await this.header();
	    let error = (await this.error()) || '';
	    let hint = (await this.hint()) || '';
	    let body = submitted ? '' : await this.interpolate(this.state);

	    let key = this.state.key = keys[index] || '';
	    let input = await this.format(key);
	    let footer = await this.footer();
	    if (input) prompt += ' ' + input;
	    if (hint && !input && this.state.completed === 0) prompt += ' ' + hint;

	    this.clear(size);
	    let lines = [header, prompt, body, footer, error.trim()];
	    this.write(lines.filter(Boolean).join(newline));
	    this.restore();
	  }

	  getItem(name) {
	    let { items, keys, index } = this.state;
	    let item = items.find(ch => ch.name === keys[index]);
	    if (item && item.input != null) {
	      this.input = item.input;
	      this.cursor = item.cursor;
	    }
	    return item;
	  }

	  async submit() {
	    if (typeof this.interpolate !== 'function') await this.initialize();
	    await this.interpolate(this.state, true);

	    let { invalid, missing, output, values } = this.state;
	    if (invalid.size) {
	      let err = '';
	      for (let [key, value] of invalid) err += `Invalid ${key}: ${value}\n`;
	      this.state.error = err;
	      return super.submit();
	    }

	    if (missing.size) {
	      this.state.error = 'Required: ' + [...missing.keys()].join(', ');
	      return super.submit();
	    }

	    let lines = stripAnsi(output).split('\n');
	    let result = lines.map(v => v.slice(1)).join('\n');
	    this.value = { values, result };
	    return super.submit();
	  }
	}

	snippet = SnippetPrompt;
	return snippet;
}

var sort;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort;
	hasRequiredSort = 1;

	const hint = '(Use <shift>+<up/down> to sort)';
	const Prompt = requireSelect();

	class Sort extends Prompt {
	  constructor(options) {
	    super({ ...options, reorder: false, sort: true, multiple: true });
	    this.state.hint = [this.options.hint, hint].find(this.isValue.bind(this));
	  }

	  indicator() {
	    return '';
	  }

	  async renderChoice(choice, i) {
	    let str = await super.renderChoice(choice, i);
	    let sym = this.symbols.identicalTo + ' ';
	    let pre = (this.index === i && this.sorting) ? this.styles.muted(sym) : '  ';
	    if (this.options.drag === false) pre = '';
	    if (this.options.numbered === true) {
	      return pre + `${i + 1} - ` + str;
	    }
	    return pre + str;
	  }

	  get selected() {
	    return this.choices;
	  }

	  submit() {
	    this.value = this.choices.map(choice => choice.value);
	    return super.submit();
	  }
	}

	sort = Sort;
	return sort;
}

var survey;
var hasRequiredSurvey;

function requireSurvey () {
	if (hasRequiredSurvey) return survey;
	hasRequiredSurvey = 1;

	const ArrayPrompt = requireArray();

	class Survey extends ArrayPrompt {
	  constructor(options = {}) {
	    super(options);
	    this.emptyError = options.emptyError || 'No items were selected';
	    this.term = process.env.TERM_PROGRAM;

	    if (!this.options.header) {
	      let header = ['', '4 - Strongly Agree', '3 - Agree', '2 - Neutral', '1 - Disagree', '0 - Strongly Disagree', ''];
	      header = header.map(ele => this.styles.muted(ele));
	      this.state.header = header.join('\n   ');
	    }
	  }

	  async toChoices(...args) {
	    if (this.createdScales) return false;
	    this.createdScales = true;
	    let choices = await super.toChoices(...args);
	    for (let choice of choices) {
	      choice.scale = createScale(5, this.options);
	      choice.scaleIdx = 2;
	    }
	    return choices;
	  }

	  dispatch() {
	    this.alert();
	  }

	  space() {
	    let choice = this.focused;
	    let ele = choice.scale[choice.scaleIdx];
	    let selected = ele.selected;
	    choice.scale.forEach(e => (e.selected = false));
	    ele.selected = !selected;
	    return this.render();
	  }

	  indicator() {
	    return '';
	  }

	  pointer() {
	    return '';
	  }

	  separator() {
	    return this.styles.muted(this.symbols.ellipsis);
	  }

	  right() {
	    let choice = this.focused;
	    if (choice.scaleIdx >= choice.scale.length - 1) return this.alert();
	    choice.scaleIdx++;
	    return this.render();
	  }

	  left() {
	    let choice = this.focused;
	    if (choice.scaleIdx <= 0) return this.alert();
	    choice.scaleIdx--;
	    return this.render();
	  }

	  indent() {
	    return '   ';
	  }

	  async renderChoice(item, i) {
	    await this.onChoice(item, i);
	    let focused = this.index === i;
	    let isHyper = this.term === 'Hyper';
	    let n = !isHyper ? 8 : 9;
	    let s = !isHyper ? ' ' : '';
	    let ln = this.symbols.line.repeat(n);
	    let sp = ' '.repeat(n + (isHyper ? 0 : 1));
	    let dot = enabled => (enabled ? this.styles.success('◉') : '◯') + s;

	    let num = i + 1 + '.';
	    let color = focused ? this.styles.heading : this.styles.noop;
	    let msg = await this.resolve(item.message, this.state, item, i);
	    let indent = this.indent(item);
	    let scale = indent + item.scale.map((e, i) => dot(i === item.scaleIdx)).join(ln);
	    let val = i => i === item.scaleIdx ? color(i) : i;
	    let next = indent + item.scale.map((e, i) => val(i)).join(sp);

	    let line = () => [num, msg].filter(Boolean).join(' ');
	    let lines = () => [line(), scale, next, ' '].filter(Boolean).join('\n');

	    if (focused) {
	      scale = this.styles.cyan(scale);
	      next = this.styles.cyan(next);
	    }

	    return lines();
	  }

	  async renderChoices() {
	    if (this.state.submitted) return '';
	    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
	    let visible = await Promise.all(choices);
	    if (!visible.length) visible.push(this.styles.danger('No matching choices'));
	    return visible.join('\n');
	  }

	  format() {
	    if (this.state.submitted) {
	      let values = this.choices.map(ch => this.styles.info(ch.scaleIdx));
	      return values.join(', ');
	    }
	    return '';
	  }

	  async render() {
	    let { submitted, size } = this.state;

	    let prefix = await this.prefix();
	    let separator = await this.separator();
	    let message = await this.message();

	    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
	    this.state.prompt = prompt;

	    let header = await this.header();
	    let output = await this.format();
	    let help = await this.error() || await this.hint();
	    let body = await this.renderChoices();
	    let footer = await this.footer();

	    if (output || !help) prompt += ' ' + output;
	    if (help && !prompt.includes(help)) prompt += ' ' + help;

	    if (submitted && !output && !body && this.multiple && this.type !== 'form') {
	      prompt += this.styles.danger(this.emptyError);
	    }

	    this.clear(size);
	    this.write([prompt, header, body, footer].filter(Boolean).join('\n'));
	    this.restore();
	  }

	  submit() {
	    this.value = {};
	    for (let choice of this.choices) {
	      this.value[choice.name] = choice.scaleIdx;
	    }
	    return this.base.submit.call(this);
	  }
	}

	function createScale(n, options = {}) {
	  if (Array.isArray(options.scale)) {
	    return options.scale.map(ele => ({ ...ele }));
	  }
	  let scale = [];
	  for (let i = 1; i < n + 1; i++) scale.push({ i, selected: false });
	  return scale;
	}

	survey = Survey;
	return survey;
}

var text;
var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text;
	hasRequiredText = 1;
	text = requireInput();
	return text;
}

var toggle;
var hasRequiredToggle;

function requireToggle () {
	if (hasRequiredToggle) return toggle;
	hasRequiredToggle = 1;

	const BooleanPrompt = requireBoolean();

	class TogglePrompt extends BooleanPrompt {
	  async initialize() {
	    await super.initialize();
	    this.value = this.initial = this.resolve(this.options.initial);
	    this.disabled = this.options.disabled || 'no';
	    this.enabled = this.options.enabled || 'yes';
	    await this.render();
	  }

	  reset() {
	    this.value = this.initial;
	    this.render();
	  }

	  delete() {
	    this.alert();
	  }

	  toggle() {
	    this.value = !this.value;
	    this.render();
	  }

	  enable() {
	    if (this.value === true) return this.alert();
	    this.value = true;
	    this.render();
	  }
	  disable() {
	    if (this.value === false) return this.alert();
	    this.value = false;
	    this.render();
	  }

	  up() {
	    this.toggle();
	  }
	  down() {
	    this.toggle();
	  }
	  right() {
	    this.toggle();
	  }
	  left() {
	    this.toggle();
	  }
	  next() {
	    this.toggle();
	  }
	  prev() {
	    this.toggle();
	  }

	  dispatch(ch = '', key) {
	    switch (ch.toLowerCase()) {
	      case ' ':
	        return this.toggle();
	      case '1':
	      case 'y':
	      case 't':
	        return this.enable();
	      case '0':
	      case 'n':
	      case 'f':
	        return this.disable();
	      default: {
	        return this.alert();
	      }
	    }
	  }

	  format() {
	    let active = str => this.styles.primary.underline(str);
	    let value = [
	      this.value ? this.disabled : active(this.disabled),
	      this.value ? active(this.enabled) : this.enabled
	    ];
	    return value.join(this.styles.muted(' / '));
	  }

	  async render() {
	    let { size } = this.state;

	    let header = await this.header();
	    let prefix = await this.prefix();
	    let separator = await this.separator();
	    let message = await this.message();

	    let output = await this.format();
	    let help = (await this.error()) || (await this.hint());
	    let footer = await this.footer();

	    let prompt = [prefix, message, separator, output].join(' ');
	    this.state.prompt = prompt;

	    if (help && !prompt.includes(help)) prompt += ' ' + help;

	    this.clear(size);
	    this.write([header, prompt, footer].filter(Boolean).join('\n'));
	    this.write(this.margin[2]);
	    this.restore();
	  }
	}

	toggle = TogglePrompt;
	return toggle;
}

var quiz;
var hasRequiredQuiz;

function requireQuiz () {
	if (hasRequiredQuiz) return quiz;
	hasRequiredQuiz = 1;

	const SelectPrompt = requireSelect();

	class Quiz extends SelectPrompt {
	  constructor(options) {
	    super(options);
	    if (typeof this.options.correctChoice !== 'number' || this.options.correctChoice < 0) {
	      throw new Error('Please specify the index of the correct answer from the list of choices');
	    }
	  }

	  async toChoices(value, parent) {
	    let choices = await super.toChoices(value, parent);
	    if (choices.length < 2) {
	      throw new Error('Please give at least two choices to the user');
	    }
	    if (this.options.correctChoice > choices.length) {
	      throw new Error('Please specify the index of the correct answer from the list of choices');
	    }
	    return choices;
	  }

	  check(state) {
	    return state.index === this.options.correctChoice;
	  }

	  async result(selected) {
	    return {
	      selectedAnswer: selected,
	      correctAnswer: this.options.choices[this.options.correctChoice].value,
	      correct: await this.check(this.state)
	    };
	  }
	}

	quiz = Quiz;
	return quiz;
}

var hasRequiredPrompts;

function requirePrompts () {
	if (hasRequiredPrompts) return prompts;
	hasRequiredPrompts = 1;
	(function (exports) {

		const utils = requireUtils();

		const define = (key, fn) => {
		  utils.defineExport(exports, key, fn);
		  utils.defineExport(exports, key.toLowerCase(), fn);
		};

		define('AutoComplete', () => requireAutocomplete());
		define('BasicAuth', () => requireBasicauth());
		define('Confirm', () => requireConfirm());
		define('Editable', () => requireEditable());
		define('Form', () => requireForm());
		define('Input', () => requireInput());
		define('Invisible', () => requireInvisible());
		define('List', () => requireList());
		define('MultiSelect', () => requireMultiselect());
		define('Numeral', () => requireNumeral());
		define('Password', () => requirePassword());
		define('Scale', () => requireScale());
		define('Select', () => requireSelect());
		define('Snippet', () => requireSnippet());
		define('Sort', () => requireSort());
		define('Survey', () => requireSurvey());
		define('Text', () => requireText());
		define('Toggle', () => requireToggle());
		define('Quiz', () => requireQuiz()); 
	} (prompts));
	return prompts;
}

var types$1;
var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types$1;
	hasRequiredTypes = 1;
	types$1 = {
	  ArrayPrompt: requireArray(),
	  AuthPrompt: requireAuth(),
	  BooleanPrompt: requireBoolean(),
	  NumberPrompt: requireNumber(),
	  StringPrompt: requireString()
	};
	return types$1;
}

var enquirer$1;
var hasRequiredEnquirer;

function requireEnquirer () {
	if (hasRequiredEnquirer) return enquirer$1;
	hasRequiredEnquirer = 1;

	const assert = require$$0$3;
	const Events = require$$0$2;
	const utils = requireUtils();

	/**
	 * Create an instance of `Enquirer`.
	 *
	 * ```js
	 * const Enquirer = require('enquirer');
	 * const enquirer = new Enquirer();
	 * ```
	 * @name Enquirer
	 * @param {Object} `options` (optional) Options to use with all prompts.
	 * @param {Object} `answers` (optional) Answers object to initialize with.
	 * @api public
	 */

	class Enquirer extends Events {
	  constructor(options, answers) {
	    super();
	    this.options = utils.merge({}, options);
	    this.answers = { ...answers };
	  }

	  /**
	   * Register a custom prompt type.
	   *
	   * ```js
	   * const Enquirer = require('enquirer');
	   * const enquirer = new Enquirer();
	   * enquirer.register('customType', require('./custom-prompt'));
	   * ```
	   * @name register()
	   * @param {String} `type`
	   * @param {Function|Prompt} `fn` `Prompt` class, or a function that returns a `Prompt` class.
	   * @return {Object} Returns the Enquirer instance
	   * @api public
	   */

	  register(type, fn) {
	    if (utils.isObject(type)) {
	      for (let key of Object.keys(type)) this.register(key, type[key]);
	      return this;
	    }

	    assert.equal(typeof fn, 'function', 'expected a function');
	    const name = type.toLowerCase();

	    if (fn.prototype instanceof this.Prompt) {
	      this.prompts[name] = fn;
	    } else {
	      this.prompts[name] = fn(this.Prompt, this);
	    }

	    return this;
	  }

	  /**
	   * Prompt function that takes a "question" object or array of question objects,
	   * and returns an object with responses from the user.
	   *
	   * ```js
	   * const Enquirer = require('enquirer');
	   * const enquirer = new Enquirer();
	   *
	   * const response = await enquirer.prompt({
	   *   type: 'input',
	   *   name: 'username',
	   *   message: 'What is your username?'
	   * });
	   * console.log(response);
	   * ```
	   * @name prompt()
	   * @param {Array|Object} `questions` Options objects for one or more prompts to run.
	   * @return {Promise} Promise that returns an "answers" object with the user's responses.
	   * @api public
	   */

	  async prompt(questions = []) {
	    for (let question of [].concat(questions)) {
	      try {
	        if (typeof question === 'function') question = await question.call(this);
	        await this.ask(utils.merge({}, this.options, question));
	      } catch (err) {
	        return Promise.reject(err);
	      }
	    }
	    return this.answers;
	  }

	  async ask(question) {
	    if (typeof question === 'function') {
	      question = await question.call(this);
	    }

	    let opts = utils.merge({}, this.options, question);
	    let { type, name } = question;
	    let { set, get } = utils;

	    if (typeof type === 'function') {
	      type = await type.call(this, question, this.answers);
	    }

	    if (!type) return this.answers[name];
	    if (type === 'number') type = 'numeral';

	    assert(this.prompts[type], `Prompt "${type}" is not registered`);

	    let prompt = new this.prompts[type](opts);
	    let value = get(this.answers, name);

	    prompt.state.answers = this.answers;
	    prompt.enquirer = this;

	    if (name) {
	      prompt.on('submit', value => {
	        this.emit('answer', name, value, prompt);
	        set(this.answers, name, value);
	      });
	    }

	    // bubble events
	    let emit = prompt.emit.bind(prompt);
	    prompt.emit = (...args) => {
	      this.emit.call(this, ...args);
	      return emit(...args);
	    };

	    this.emit('prompt', prompt, this);

	    if (opts.autofill && value != null) {
	      prompt.value = prompt.input = value;

	      // if "autofill=show" render the prompt, otherwise stay "silent"
	      if (opts.autofill === 'show') {
	        await prompt.submit();
	      }
	    } else {
	      value = prompt.value = await prompt.run();
	    }

	    return value;
	  }

	  /**
	   * Use an enquirer plugin.
	   *
	   * ```js
	   * const Enquirer = require('enquirer');
	   * const enquirer = new Enquirer();
	   * const plugin = enquirer => {
	   *   // do stuff to enquire instance
	   * };
	   * enquirer.use(plugin);
	   * ```
	   * @name use()
	   * @param {Function} `plugin` Plugin function that takes an instance of Enquirer.
	   * @return {Object} Returns the Enquirer instance.
	   * @api public
	   */

	  use(plugin) {
	    plugin.call(this, this);
	    return this;
	  }

	  set Prompt(value) {
	    this._Prompt = value;
	  }
	  get Prompt() {
	    return this._Prompt || this.constructor.Prompt;
	  }

	  get prompts() {
	    return this.constructor.prompts;
	  }

	  static set Prompt(value) {
	    this._Prompt = value;
	  }
	  static get Prompt() {
	    return this._Prompt || requirePrompt();
	  }

	  static get prompts() {
	    return requirePrompts();
	  }

	  static get types() {
	    return requireTypes();
	  }

	  /**
	   * Prompt function that takes a "question" object or array of question objects,
	   * and returns an object with responses from the user.
	   *
	   * ```js
	   * const { prompt } = require('enquirer');
	   * const response = await prompt({
	   *   type: 'input',
	   *   name: 'username',
	   *   message: 'What is your username?'
	   * });
	   * console.log(response);
	   * ```
	   * @name Enquirer#prompt
	   * @param {Array|Object} `questions` Options objects for one or more prompts to run.
	   * @return {Promise} Promise that returns an "answers" object with the user's responses.
	   * @api public
	   */

	  static get prompt() {
	    const fn = (questions, ...rest) => {
	      let enquirer = new this(...rest);
	      let emit = enquirer.emit.bind(enquirer);
	      enquirer.emit = (...args) => {
	        fn.emit(...args);
	        return emit(...args);
	      };
	      return enquirer.prompt(questions);
	    };
	    utils.mixinEmitter(fn, new Events());
	    return fn;
	  }
	}

	utils.mixinEmitter(Enquirer, new Events());
	const prompts = Enquirer.prompts;

	for (let name of Object.keys(prompts)) {
	  let key = name.toLowerCase();

	  let run = options => new prompts[name](options).run();
	  Enquirer.prompt[key] = run;
	  Enquirer[key] = run;

	  if (!Enquirer[name]) {
	    Reflect.defineProperty(Enquirer, name, { get: () => prompts[name] });
	  }
	}

	const define = name => {
	  utils.defineExport(Enquirer, name, () => Enquirer.types[name]);
	};

	define('ArrayPrompt');
	define('AuthPrompt');
	define('BooleanPrompt');
	define('NumberPrompt');
	define('StringPrompt');

	enquirer$1 = Enquirer;
	return enquirer$1;
}

var enquirerExports = requireEnquirer();
var enquirer = /*@__PURE__*/getDefaultExportFromCjs(enquirerExports);

function ansiRegex$1({onlyFirst = false} = {}) {
	// Valid string terminator sequences are BEL, ESC\, and 0x9c
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const pattern = [
		`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

const regex$1 = ansiRegex$1();

function stripAnsi$1(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex$1, '');
}

// Generated code.

function isAmbiguous(x) {
	return x === 0xA1
		|| x === 0xA4
		|| x === 0xA7
		|| x === 0xA8
		|| x === 0xAA
		|| x === 0xAD
		|| x === 0xAE
		|| x >= 0xB0 && x <= 0xB4
		|| x >= 0xB6 && x <= 0xBA
		|| x >= 0xBC && x <= 0xBF
		|| x === 0xC6
		|| x === 0xD0
		|| x === 0xD7
		|| x === 0xD8
		|| x >= 0xDE && x <= 0xE1
		|| x === 0xE6
		|| x >= 0xE8 && x <= 0xEA
		|| x === 0xEC
		|| x === 0xED
		|| x === 0xF0
		|| x === 0xF2
		|| x === 0xF3
		|| x >= 0xF7 && x <= 0xFA
		|| x === 0xFC
		|| x === 0xFE
		|| x === 0x101
		|| x === 0x111
		|| x === 0x113
		|| x === 0x11B
		|| x === 0x126
		|| x === 0x127
		|| x === 0x12B
		|| x >= 0x131 && x <= 0x133
		|| x === 0x138
		|| x >= 0x13F && x <= 0x142
		|| x === 0x144
		|| x >= 0x148 && x <= 0x14B
		|| x === 0x14D
		|| x === 0x152
		|| x === 0x153
		|| x === 0x166
		|| x === 0x167
		|| x === 0x16B
		|| x === 0x1CE
		|| x === 0x1D0
		|| x === 0x1D2
		|| x === 0x1D4
		|| x === 0x1D6
		|| x === 0x1D8
		|| x === 0x1DA
		|| x === 0x1DC
		|| x === 0x251
		|| x === 0x261
		|| x === 0x2C4
		|| x === 0x2C7
		|| x >= 0x2C9 && x <= 0x2CB
		|| x === 0x2CD
		|| x === 0x2D0
		|| x >= 0x2D8 && x <= 0x2DB
		|| x === 0x2DD
		|| x === 0x2DF
		|| x >= 0x300 && x <= 0x36F
		|| x >= 0x391 && x <= 0x3A1
		|| x >= 0x3A3 && x <= 0x3A9
		|| x >= 0x3B1 && x <= 0x3C1
		|| x >= 0x3C3 && x <= 0x3C9
		|| x === 0x401
		|| x >= 0x410 && x <= 0x44F
		|| x === 0x451
		|| x === 0x2010
		|| x >= 0x2013 && x <= 0x2016
		|| x === 0x2018
		|| x === 0x2019
		|| x === 0x201C
		|| x === 0x201D
		|| x >= 0x2020 && x <= 0x2022
		|| x >= 0x2024 && x <= 0x2027
		|| x === 0x2030
		|| x === 0x2032
		|| x === 0x2033
		|| x === 0x2035
		|| x === 0x203B
		|| x === 0x203E
		|| x === 0x2074
		|| x === 0x207F
		|| x >= 0x2081 && x <= 0x2084
		|| x === 0x20AC
		|| x === 0x2103
		|| x === 0x2105
		|| x === 0x2109
		|| x === 0x2113
		|| x === 0x2116
		|| x === 0x2121
		|| x === 0x2122
		|| x === 0x2126
		|| x === 0x212B
		|| x === 0x2153
		|| x === 0x2154
		|| x >= 0x215B && x <= 0x215E
		|| x >= 0x2160 && x <= 0x216B
		|| x >= 0x2170 && x <= 0x2179
		|| x === 0x2189
		|| x >= 0x2190 && x <= 0x2199
		|| x === 0x21B8
		|| x === 0x21B9
		|| x === 0x21D2
		|| x === 0x21D4
		|| x === 0x21E7
		|| x === 0x2200
		|| x === 0x2202
		|| x === 0x2203
		|| x === 0x2207
		|| x === 0x2208
		|| x === 0x220B
		|| x === 0x220F
		|| x === 0x2211
		|| x === 0x2215
		|| x === 0x221A
		|| x >= 0x221D && x <= 0x2220
		|| x === 0x2223
		|| x === 0x2225
		|| x >= 0x2227 && x <= 0x222C
		|| x === 0x222E
		|| x >= 0x2234 && x <= 0x2237
		|| x === 0x223C
		|| x === 0x223D
		|| x === 0x2248
		|| x === 0x224C
		|| x === 0x2252
		|| x === 0x2260
		|| x === 0x2261
		|| x >= 0x2264 && x <= 0x2267
		|| x === 0x226A
		|| x === 0x226B
		|| x === 0x226E
		|| x === 0x226F
		|| x === 0x2282
		|| x === 0x2283
		|| x === 0x2286
		|| x === 0x2287
		|| x === 0x2295
		|| x === 0x2299
		|| x === 0x22A5
		|| x === 0x22BF
		|| x === 0x2312
		|| x >= 0x2460 && x <= 0x24E9
		|| x >= 0x24EB && x <= 0x254B
		|| x >= 0x2550 && x <= 0x2573
		|| x >= 0x2580 && x <= 0x258F
		|| x >= 0x2592 && x <= 0x2595
		|| x === 0x25A0
		|| x === 0x25A1
		|| x >= 0x25A3 && x <= 0x25A9
		|| x === 0x25B2
		|| x === 0x25B3
		|| x === 0x25B6
		|| x === 0x25B7
		|| x === 0x25BC
		|| x === 0x25BD
		|| x === 0x25C0
		|| x === 0x25C1
		|| x >= 0x25C6 && x <= 0x25C8
		|| x === 0x25CB
		|| x >= 0x25CE && x <= 0x25D1
		|| x >= 0x25E2 && x <= 0x25E5
		|| x === 0x25EF
		|| x === 0x2605
		|| x === 0x2606
		|| x === 0x2609
		|| x === 0x260E
		|| x === 0x260F
		|| x === 0x261C
		|| x === 0x261E
		|| x === 0x2640
		|| x === 0x2642
		|| x === 0x2660
		|| x === 0x2661
		|| x >= 0x2663 && x <= 0x2665
		|| x >= 0x2667 && x <= 0x266A
		|| x === 0x266C
		|| x === 0x266D
		|| x === 0x266F
		|| x === 0x269E
		|| x === 0x269F
		|| x === 0x26BF
		|| x >= 0x26C6 && x <= 0x26CD
		|| x >= 0x26CF && x <= 0x26D3
		|| x >= 0x26D5 && x <= 0x26E1
		|| x === 0x26E3
		|| x === 0x26E8
		|| x === 0x26E9
		|| x >= 0x26EB && x <= 0x26F1
		|| x === 0x26F4
		|| x >= 0x26F6 && x <= 0x26F9
		|| x === 0x26FB
		|| x === 0x26FC
		|| x === 0x26FE
		|| x === 0x26FF
		|| x === 0x273D
		|| x >= 0x2776 && x <= 0x277F
		|| x >= 0x2B56 && x <= 0x2B59
		|| x >= 0x3248 && x <= 0x324F
		|| x >= 0xE000 && x <= 0xF8FF
		|| x >= 0xFE00 && x <= 0xFE0F
		|| x === 0xFFFD
		|| x >= 0x1F100 && x <= 0x1F10A
		|| x >= 0x1F110 && x <= 0x1F12D
		|| x >= 0x1F130 && x <= 0x1F169
		|| x >= 0x1F170 && x <= 0x1F18D
		|| x === 0x1F18F
		|| x === 0x1F190
		|| x >= 0x1F19B && x <= 0x1F1AC
		|| x >= 0xE0100 && x <= 0xE01EF
		|| x >= 0xF0000 && x <= 0xFFFFD
		|| x >= 0x100000 && x <= 0x10FFFD;
}

function isFullWidth(x) {
	return x === 0x3000
		|| x >= 0xFF01 && x <= 0xFF60
		|| x >= 0xFFE0 && x <= 0xFFE6;
}

function isWide(x) {
	return x >= 0x1100 && x <= 0x115F
		|| x === 0x231A
		|| x === 0x231B
		|| x === 0x2329
		|| x === 0x232A
		|| x >= 0x23E9 && x <= 0x23EC
		|| x === 0x23F0
		|| x === 0x23F3
		|| x === 0x25FD
		|| x === 0x25FE
		|| x === 0x2614
		|| x === 0x2615
		|| x >= 0x2630 && x <= 0x2637
		|| x >= 0x2648 && x <= 0x2653
		|| x === 0x267F
		|| x >= 0x268A && x <= 0x268F
		|| x === 0x2693
		|| x === 0x26A1
		|| x === 0x26AA
		|| x === 0x26AB
		|| x === 0x26BD
		|| x === 0x26BE
		|| x === 0x26C4
		|| x === 0x26C5
		|| x === 0x26CE
		|| x === 0x26D4
		|| x === 0x26EA
		|| x === 0x26F2
		|| x === 0x26F3
		|| x === 0x26F5
		|| x === 0x26FA
		|| x === 0x26FD
		|| x === 0x2705
		|| x === 0x270A
		|| x === 0x270B
		|| x === 0x2728
		|| x === 0x274C
		|| x === 0x274E
		|| x >= 0x2753 && x <= 0x2755
		|| x === 0x2757
		|| x >= 0x2795 && x <= 0x2797
		|| x === 0x27B0
		|| x === 0x27BF
		|| x === 0x2B1B
		|| x === 0x2B1C
		|| x === 0x2B50
		|| x === 0x2B55
		|| x >= 0x2E80 && x <= 0x2E99
		|| x >= 0x2E9B && x <= 0x2EF3
		|| x >= 0x2F00 && x <= 0x2FD5
		|| x >= 0x2FF0 && x <= 0x2FFF
		|| x >= 0x3001 && x <= 0x303E
		|| x >= 0x3041 && x <= 0x3096
		|| x >= 0x3099 && x <= 0x30FF
		|| x >= 0x3105 && x <= 0x312F
		|| x >= 0x3131 && x <= 0x318E
		|| x >= 0x3190 && x <= 0x31E5
		|| x >= 0x31EF && x <= 0x321E
		|| x >= 0x3220 && x <= 0x3247
		|| x >= 0x3250 && x <= 0xA48C
		|| x >= 0xA490 && x <= 0xA4C6
		|| x >= 0xA960 && x <= 0xA97C
		|| x >= 0xAC00 && x <= 0xD7A3
		|| x >= 0xF900 && x <= 0xFAFF
		|| x >= 0xFE10 && x <= 0xFE19
		|| x >= 0xFE30 && x <= 0xFE52
		|| x >= 0xFE54 && x <= 0xFE66
		|| x >= 0xFE68 && x <= 0xFE6B
		|| x >= 0x16FE0 && x <= 0x16FE4
		|| x === 0x16FF0
		|| x === 0x16FF1
		|| x >= 0x17000 && x <= 0x187F7
		|| x >= 0x18800 && x <= 0x18CD5
		|| x >= 0x18CFF && x <= 0x18D08
		|| x >= 0x1AFF0 && x <= 0x1AFF3
		|| x >= 0x1AFF5 && x <= 0x1AFFB
		|| x === 0x1AFFD
		|| x === 0x1AFFE
		|| x >= 0x1B000 && x <= 0x1B122
		|| x === 0x1B132
		|| x >= 0x1B150 && x <= 0x1B152
		|| x === 0x1B155
		|| x >= 0x1B164 && x <= 0x1B167
		|| x >= 0x1B170 && x <= 0x1B2FB
		|| x >= 0x1D300 && x <= 0x1D356
		|| x >= 0x1D360 && x <= 0x1D376
		|| x === 0x1F004
		|| x === 0x1F0CF
		|| x === 0x1F18E
		|| x >= 0x1F191 && x <= 0x1F19A
		|| x >= 0x1F200 && x <= 0x1F202
		|| x >= 0x1F210 && x <= 0x1F23B
		|| x >= 0x1F240 && x <= 0x1F248
		|| x === 0x1F250
		|| x === 0x1F251
		|| x >= 0x1F260 && x <= 0x1F265
		|| x >= 0x1F300 && x <= 0x1F320
		|| x >= 0x1F32D && x <= 0x1F335
		|| x >= 0x1F337 && x <= 0x1F37C
		|| x >= 0x1F37E && x <= 0x1F393
		|| x >= 0x1F3A0 && x <= 0x1F3CA
		|| x >= 0x1F3CF && x <= 0x1F3D3
		|| x >= 0x1F3E0 && x <= 0x1F3F0
		|| x === 0x1F3F4
		|| x >= 0x1F3F8 && x <= 0x1F43E
		|| x === 0x1F440
		|| x >= 0x1F442 && x <= 0x1F4FC
		|| x >= 0x1F4FF && x <= 0x1F53D
		|| x >= 0x1F54B && x <= 0x1F54E
		|| x >= 0x1F550 && x <= 0x1F567
		|| x === 0x1F57A
		|| x === 0x1F595
		|| x === 0x1F596
		|| x === 0x1F5A4
		|| x >= 0x1F5FB && x <= 0x1F64F
		|| x >= 0x1F680 && x <= 0x1F6C5
		|| x === 0x1F6CC
		|| x >= 0x1F6D0 && x <= 0x1F6D2
		|| x >= 0x1F6D5 && x <= 0x1F6D7
		|| x >= 0x1F6DC && x <= 0x1F6DF
		|| x === 0x1F6EB
		|| x === 0x1F6EC
		|| x >= 0x1F6F4 && x <= 0x1F6FC
		|| x >= 0x1F7E0 && x <= 0x1F7EB
		|| x === 0x1F7F0
		|| x >= 0x1F90C && x <= 0x1F93A
		|| x >= 0x1F93C && x <= 0x1F945
		|| x >= 0x1F947 && x <= 0x1F9FF
		|| x >= 0x1FA70 && x <= 0x1FA7C
		|| x >= 0x1FA80 && x <= 0x1FA89
		|| x >= 0x1FA8F && x <= 0x1FAC6
		|| x >= 0x1FACE && x <= 0x1FADC
		|| x >= 0x1FADF && x <= 0x1FAE9
		|| x >= 0x1FAF0 && x <= 0x1FAF8
		|| x >= 0x20000 && x <= 0x2FFFD
		|| x >= 0x30000 && x <= 0x3FFFD;
}

function validate(codePoint) {
	if (!Number.isSafeInteger(codePoint)) {
		throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
	}
}

function eastAsianWidth(codePoint, {ambiguousAsWide = false} = {}) {
	validate(codePoint);

	if (
		isFullWidth(codePoint)
		|| isWide(codePoint)
		|| (ambiguousAsWide && isAmbiguous(codePoint))
	) {
		return 2;
	}

	return 1;
}

const segmenter = new Intl.Segmenter();

const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;

function stringWidth$1(string, options = {}) {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	const {
		ambiguousIsNarrow = true,
		countAnsiEscapeCodes = false,
	} = options;

	if (!countAnsiEscapeCodes) {
		string = stripAnsi$1(string);
	}

	if (string.length === 0) {
		return 0;
	}

	let width = 0;
	const eastAsianWidthOptions = {ambiguousAsWide: !ambiguousIsNarrow};

	for (const {segment: character} of segmenter.segment(string)) {
		const codePoint = character.codePointAt(0);

		// Ignore control characters
		if (codePoint <= 0x1F || (codePoint >= 0x7F && codePoint <= 0x9F)) {
			continue;
		}

		// Ignore zero-width characters
		if (
			(codePoint >= 0x20_0B && codePoint <= 0x20_0F) // Zero-width space, non-joiner, joiner, left-to-right mark, right-to-left mark
			|| codePoint === 0xFE_FF // Zero-width no-break space
		) {
			continue;
		}

		// Ignore combining characters
		if (
			(codePoint >= 0x3_00 && codePoint <= 0x3_6F) // Combining diacritical marks
			|| (codePoint >= 0x1A_B0 && codePoint <= 0x1A_FF) // Combining diacritical marks extended
			|| (codePoint >= 0x1D_C0 && codePoint <= 0x1D_FF) // Combining diacritical marks supplement
			|| (codePoint >= 0x20_D0 && codePoint <= 0x20_FF) // Combining diacritical marks for symbols
			|| (codePoint >= 0xFE_20 && codePoint <= 0xFE_2F) // Combining half marks
		) {
			continue;
		}

		// Ignore surrogate pairs
		if (codePoint >= 0xD8_00 && codePoint <= 0xDF_FF) {
			continue;
		}

		// Ignore variation selectors
		if (codePoint >= 0xFE_00 && codePoint <= 0xFE_0F) {
			continue;
		}

		// This covers some of the above cases, but we still keep them for performance reasons.
		if (defaultIgnorableCodePointRegex.test(character)) {
			continue;
		}

		// TODO: Use `/\p{RGI_Emoji}/v` when targeting Node.js 20.
		if (emojiRegex$1().test(character)) {
			width += 2;
			continue;
		}

		width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	}

	return width;
}

function widestLine(string) {
	let lineWidth = 0;

	for (const line of string.split('\n')) {
		lineWidth = Math.max(lineWidth, stringWidth$1(line));
	}

	return lineWidth;
}

var cliBoxes$1 = {exports: {}};

var single = {
	topLeft: "┌",
	top: "─",
	topRight: "┐",
	right: "│",
	bottomRight: "┘",
	bottom: "─",
	bottomLeft: "└",
	left: "│"
};
var double = {
	topLeft: "╔",
	top: "═",
	topRight: "╗",
	right: "║",
	bottomRight: "╝",
	bottom: "═",
	bottomLeft: "╚",
	left: "║"
};
var round = {
	topLeft: "╭",
	top: "─",
	topRight: "╮",
	right: "│",
	bottomRight: "╯",
	bottom: "─",
	bottomLeft: "╰",
	left: "│"
};
var bold = {
	topLeft: "┏",
	top: "━",
	topRight: "┓",
	right: "┃",
	bottomRight: "┛",
	bottom: "━",
	bottomLeft: "┗",
	left: "┃"
};
var singleDouble = {
	topLeft: "╓",
	top: "─",
	topRight: "╖",
	right: "║",
	bottomRight: "╜",
	bottom: "─",
	bottomLeft: "╙",
	left: "║"
};
var doubleSingle = {
	topLeft: "╒",
	top: "═",
	topRight: "╕",
	right: "│",
	bottomRight: "╛",
	bottom: "═",
	bottomLeft: "╘",
	left: "│"
};
var classic = {
	topLeft: "+",
	top: "-",
	topRight: "+",
	right: "|",
	bottomRight: "+",
	bottom: "-",
	bottomLeft: "+",
	left: "|"
};
var arrow = {
	topLeft: "↘",
	top: "↓",
	topRight: "↙",
	right: "←",
	bottomRight: "↖",
	bottom: "↑",
	bottomLeft: "↗",
	left: "→"
};
var require$$0 = {
	single: single,
	double: double,
	round: round,
	bold: bold,
	singleDouble: singleDouble,
	doubleSingle: doubleSingle,
	classic: classic,
	arrow: arrow
};

var hasRequiredCliBoxes;

function requireCliBoxes () {
	if (hasRequiredCliBoxes) return cliBoxes$1.exports;
	hasRequiredCliBoxes = 1;
	const cliBoxes = require$$0;

	cliBoxes$1.exports = cliBoxes;
	// TODO: Remove this for the next major release
	cliBoxes$1.exports.default = cliBoxes;
	return cliBoxes$1.exports;
}

var cliBoxesExports = requireCliBoxes();
var cliBoxes = /*@__PURE__*/getDefaultExportFromCjs(cliBoxesExports);

const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;

const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');

const preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;
	let isLastLastCharPreserved = false;

	for (let index = 0; index < string.length; index++) {
		const character = string[index];
		isLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;

		if (isLastCharLower && UPPERCASE.test(character)) {
			string = string.slice(0, index) + '-' + string.slice(index);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			index++;
		} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {
			string = string.slice(0, index - 1) + '-' + string.slice(index - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
		}
	}

	return string;
};

const preserveConsecutiveUppercase = (input, toLowerCase) => {
	LEADING_CAPITAL.lastIndex = 0;

	return input.replaceAll(LEADING_CAPITAL, match => toLowerCase(match));
};

const postProcess = (input, toUpperCase) => {
	SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
	NUMBERS_AND_IDENTIFIER.lastIndex = 0;

	return input
		.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ['_', '-'].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match))
		.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));
};

function camelCase(input, options) {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = {
		pascalCase: false,
		preserveConsecutiveUppercase: false,
		...options,
	};

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	const toLowerCase = options.locale === false
		? string => string.toLowerCase()
		: string => string.toLocaleLowerCase(options.locale);

	const toUpperCase = options.locale === false
		? string => string.toUpperCase()
		: string => string.toLocaleUpperCase(options.locale);

	if (input.length === 1) {
		if (SEPARATORS.test(input)) {
			return '';
		}

		return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
	}

	const hasUpperCase = input !== toLowerCase(input);

	if (hasUpperCase) {
		input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
	}

	input = input.replace(LEADING_SEPARATORS, '');
	input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);

	if (options.pascalCase) {
		input = toUpperCase(input.charAt(0)) + input.slice(1);
	}

	return postProcess(input, toUpperCase);
}

var stringWidth = {exports: {}};

var isFullwidthCodePoint = {exports: {}};

/* eslint-disable yoda */

var hasRequiredIsFullwidthCodePoint;

function requireIsFullwidthCodePoint () {
	if (hasRequiredIsFullwidthCodePoint) return isFullwidthCodePoint.exports;
	hasRequiredIsFullwidthCodePoint = 1;

	const isFullwidthCodePoint$1 = codePoint => {
		if (Number.isNaN(codePoint)) {
			return false;
		}

		// Code points are derived from:
		// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
		if (
			codePoint >= 0x1100 && (
				codePoint <= 0x115F || // Hangul Jamo
				codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
				codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
				// CJK Radicals Supplement .. Enclosed CJK Letters and Months
				(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
				// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
				(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
				// CJK Unified Ideographs .. Yi Radicals
				(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
				// Hangul Jamo Extended-A
				(0xA960 <= codePoint && codePoint <= 0xA97C) ||
				// Hangul Syllables
				(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
				// CJK Compatibility Ideographs
				(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
				// Vertical Forms
				(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
				// CJK Compatibility Forms .. Small Form Variants
				(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
				// Halfwidth and Fullwidth Forms
				(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
				(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
				// Kana Supplement
				(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
				// Enclosed Ideographic Supplement
				(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
				// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
				(0x20000 <= codePoint && codePoint <= 0x3FFFD)
			)
		) {
			return true;
		}

		return false;
	};

	isFullwidthCodePoint.exports = isFullwidthCodePoint$1;
	isFullwidthCodePoint.exports.default = isFullwidthCodePoint$1;
	return isFullwidthCodePoint.exports;
}

var emojiRegex;
var hasRequiredEmojiRegex;

function requireEmojiRegex () {
	if (hasRequiredEmojiRegex) return emojiRegex;
	hasRequiredEmojiRegex = 1;

	emojiRegex = function () {
	  // https://mths.be/emoji
	  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};
	return emojiRegex;
}

var hasRequiredStringWidth;

function requireStringWidth () {
	if (hasRequiredStringWidth) return stringWidth.exports;
	hasRequiredStringWidth = 1;
	const stripAnsi = requireStripAnsi();
	const isFullwidthCodePoint = requireIsFullwidthCodePoint();
	const emojiRegex = requireEmojiRegex();

	const stringWidth$1 = string => {
		if (typeof string !== 'string' || string.length === 0) {
			return 0;
		}

		string = stripAnsi(string);

		if (string.length === 0) {
			return 0;
		}

		string = string.replace(emojiRegex(), '  ');

		let width = 0;

		for (let i = 0; i < string.length; i++) {
			const code = string.codePointAt(i);

			// Ignore control characters
			if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
				continue;
			}

			// Ignore combining characters
			if (code >= 0x300 && code <= 0x36F) {
				continue;
			}

			// Surrogates
			if (code > 0xFFFF) {
				i++;
			}

			width += isFullwidthCodePoint(code) ? 2 : 1;
		}

		return width;
	};

	stringWidth.exports = stringWidth$1;
	// TODO: remove this in the next major version
	stringWidth.exports.default = stringWidth$1;
	return stringWidth.exports;
}

var ansiAlign_1;
var hasRequiredAnsiAlign;

function requireAnsiAlign () {
	if (hasRequiredAnsiAlign) return ansiAlign_1;
	hasRequiredAnsiAlign = 1;

	const stringWidth = requireStringWidth();

	function ansiAlign (text, opts) {
	  if (!text) return text

	  opts = opts || {};
	  const align = opts.align || 'center';

	  // short-circuit `align: 'left'` as no-op
	  if (align === 'left') return text

	  const split = opts.split || '\n';
	  const pad = opts.pad || ' ';
	  const widthDiffFn = align !== 'right' ? halfDiff : fullDiff;

	  let returnString = false;
	  if (!Array.isArray(text)) {
	    returnString = true;
	    text = String(text).split(split);
	  }

	  let width;
	  let maxWidth = 0;
	  text = text.map(function (str) {
	    str = String(str);
	    width = stringWidth(str);
	    maxWidth = Math.max(width, maxWidth);
	    return {
	      str,
	      width
	    }
	  }).map(function (obj) {
	    return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad) + obj.str
	  });

	  return returnString ? text.join(split) : text
	}

	ansiAlign.left = function left (text) {
	  return ansiAlign(text, { align: 'left' })
	};

	ansiAlign.center = function center (text) {
	  return ansiAlign(text, { align: 'center' })
	};

	ansiAlign.right = function right (text) {
	  return ansiAlign(text, { align: 'right' })
	};

	ansiAlign_1 = ansiAlign;

	function halfDiff (maxWidth, curWidth) {
	  return Math.floor((maxWidth - curWidth) / 2)
	}

	function fullDiff (maxWidth, curWidth) {
	  return maxWidth - curWidth
	}
	return ansiAlign_1;
}

var ansiAlignExports = requireAnsiAlign();
var ansiAlign = /*@__PURE__*/getDefaultExportFromCjs(ansiAlignExports);

function ansiRegex({onlyFirst = false} = {}) {
	// Valid string terminator sequences are BEL, ESC\, and 0x9c
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const pattern = [
		`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

const regex = ansiRegex();

function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex, '');
}

const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
[...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value: (red, green, blue) => {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value: hex => {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value: code => {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles;
}

const ansiStyles = assembleStyles();

const ESCAPES = new Set([
	'\u001B',
	'\u009B',
]);

const END_CODE = 39;
const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

const wrapAnsiCode = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = url => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth$1(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => {
	const characters = [...word];

	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth$1(stripAnsi(rows.at(-1)));

	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth$1(character);

		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}

		if (ESCAPES.has(character)) {
			isInsideEscape = true;

			const ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join('');
			isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
		}

		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) {
				isInsideEscape = false;
			}

			continue;
		}

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows.at(-1).length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = string => {
	const words = string.split(' ');
	let last = words.length;

	while (last > 0) {
		if (stringWidth$1(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return string;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode.
//
// 'hard' will never allow a string to take up more than columns characters.
//
// 'soft' allows long words to expand past the column length.
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	let returnValue = '';
	let escapeCode;
	let escapeUrl;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows.at(-1).trimStart();
		}

		let rowLength = stringWidth$1(rows.at(-1));

		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			}

			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}

		// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}

			wrapWord(rows, word, columns);
			continue;
		}

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows.push('');
		}

		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}

		rows[rows.length - 1] += word;
	}

	if (options.trim !== false) {
		rows = rows.map(row => stringVisibleTrimSpacesRight(row));
	}

	const preString = rows.join('\n');
	const pre = [...preString];

	// We need to keep a separate index as `String#slice()` works on Unicode code units, while `pre` is an array of codepoints.
	let preStringIndex = 0;

	for (const [index, character] of pre.entries()) {
		returnValue += character;

		if (ESCAPES.has(character)) {
			const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(preString.slice(preStringIndex)) || {groups: {}};
			if (groups.code !== undefined) {
				const code = Number.parseFloat(groups.code);
				escapeCode = code === END_CODE ? undefined : code;
			} else if (groups.uri !== undefined) {
				escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
			}
		}

		const code = ansiStyles.codes.get(Number(escapeCode));

		if (pre[index + 1] === '\n') {
			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink('');
			}

			if (escapeCode && code) {
				returnValue += wrapAnsiCode(code);
			}
		} else if (character === '\n') {
			if (escapeCode && code) {
				returnValue += wrapAnsiCode(escapeCode);
			}

			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink(escapeUrl);
			}
		}

		preStringIndex += character.length;
	}

	return returnValue;
};

// For each newline, invoke the method separately
function wrapAnsi(string, columns, options) {
	return String(string)
		.normalize()
		.replaceAll('\r\n', '\n')
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
}

const NEWLINE = '\n';
const PAD = ' ';
const NONE = 'none';

const terminalColumns = () => {
	const {env, stdout, stderr} = process$1;

	if (stdout?.columns) {
		return stdout.columns;
	}

	if (stderr?.columns) {
		return stderr.columns;
	}

	if (env.COLUMNS) {
		return Number.parseInt(env.COLUMNS, 10);
	}

	return 80;
};

const getObject = detail => typeof detail === 'number' ? {
	top: detail,
	right: detail * 3,
	bottom: detail,
	left: detail * 3,
} : {
	top: 0,
	right: 0,
	bottom: 0,
	left: 0,
	...detail,
};

const getBorderWidth = borderStyle => borderStyle === NONE ? 0 : 2;

const getBorderChars = borderStyle => {
	const sides = [
		'topLeft',
		'topRight',
		'bottomRight',
		'bottomLeft',
		'left',
		'right',
		'top',
		'bottom',
	];

	let characters;

	// Create empty border style
	if (borderStyle === NONE) {
		borderStyle = {};
		for (const side of sides) {
			borderStyle[side] = '';
		}
	}

	if (typeof borderStyle === 'string') {
		characters = cliBoxes[borderStyle];

		if (!characters) {
			throw new TypeError(`Invalid border style: ${borderStyle}`);
		}
	} else {
		// Ensure retro-compatibility
		if (typeof borderStyle?.vertical === 'string') {
			borderStyle.left = borderStyle.vertical;
			borderStyle.right = borderStyle.vertical;
		}

		// Ensure retro-compatibility
		if (typeof borderStyle?.horizontal === 'string') {
			borderStyle.top = borderStyle.horizontal;
			borderStyle.bottom = borderStyle.horizontal;
		}

		for (const side of sides) {
			if (borderStyle[side] === null || typeof borderStyle[side] !== 'string') {
				throw new TypeError(`Invalid border style: ${side}`);
			}
		}

		characters = borderStyle;
	}

	return characters;
};

const makeTitle = (text, horizontal, alignment) => {
	let title = '';

	const textWidth = stringWidth$1(text);

	switch (alignment) {
		case 'left': {
			title = text + horizontal.slice(textWidth);
			break;
		}

		case 'right': {
			title = horizontal.slice(textWidth) + text;
			break;
		}

		default: {
			horizontal = horizontal.slice(textWidth);

			if (horizontal.length % 2 === 1) { // This is needed in case the length is odd
				horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
				title = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit
			} else {
				horizontal = horizontal.slice(horizontal.length / 2);
				title = horizontal + text + horizontal;
			}

			break;
		}
	}

	return title;
};

const makeContentText = (text, {padding, width, textAlignment, height}) => {
	text = ansiAlign(text, {align: textAlignment});
	let lines = text.split(NEWLINE);
	const textWidth = widestLine(text);

	const max = width - padding.left - padding.right;

	if (textWidth > max) {
		const newLines = [];
		for (const line of lines) {
			const createdLines = wrapAnsi(line, max, {hard: true});
			const alignedLines = ansiAlign(createdLines, {align: textAlignment});
			const alignedLinesArray = alignedLines.split('\n');
			const longestLength = Math.max(...alignedLinesArray.map(s => stringWidth$1(s)));

			for (const alignedLine of alignedLinesArray) {
				let paddedLine;
				switch (textAlignment) {
					case 'center': {
						paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
						break;
					}

					case 'right': {
						paddedLine = PAD.repeat(max - longestLength) + alignedLine;
						break;
					}

					default: {
						paddedLine = alignedLine;
						break;
					}
				}

				newLines.push(paddedLine);
			}
		}

		lines = newLines;
	}

	if (textAlignment === 'center' && textWidth < max) {
		lines = lines.map(line => PAD.repeat((max - textWidth) / 2) + line);
	} else if (textAlignment === 'right' && textWidth < max) {
		lines = lines.map(line => PAD.repeat(max - textWidth) + line);
	}

	const paddingLeft = PAD.repeat(padding.left);
	const paddingRight = PAD.repeat(padding.right);

	lines = lines.map(line => {
		const newLine = paddingLeft + line + paddingRight;

		return newLine + PAD.repeat(width - stringWidth$1(newLine));
	});

	if (padding.top > 0) {
		lines = [...Array.from({length: padding.top}).fill(PAD.repeat(width)), ...lines];
	}

	if (padding.bottom > 0) {
		lines = [...lines, ...Array.from({length: padding.bottom}).fill(PAD.repeat(width))];
	}

	if (height && lines.length > height) {
		lines = lines.slice(0, height);
	} else if (height && lines.length < height) {
		lines = [...lines, ...Array.from({length: height - lines.length}).fill(PAD.repeat(width))];
	}

	return lines.join(NEWLINE);
};

const boxContent = (content, contentWidth, options) => {
	const colorizeBorder = border => {
		const newBorder = options.borderColor ? getColorFunction(options.borderColor)(border) : border;
		return options.dimBorder ? chalk.dim(newBorder) : newBorder;
	};

	const colorizeContent = content => options.backgroundColor ? getBGColorFunction(options.backgroundColor)(content) : content;

	const chars = getBorderChars(options.borderStyle);
	const columns = terminalColumns();
	let marginLeft = PAD.repeat(options.margin.left);

	if (options.float === 'center') {
		const marginWidth = Math.max((columns - contentWidth - getBorderWidth(options.borderStyle)) / 2, 0);
		marginLeft = PAD.repeat(marginWidth);
	} else if (options.float === 'right') {
		const marginWidth = Math.max(columns - contentWidth - options.margin.right - getBorderWidth(options.borderStyle), 0);
		marginLeft = PAD.repeat(marginWidth);
	}

	let result = '';

	if (options.margin.top) {
		result += NEWLINE.repeat(options.margin.top);
	}

	if (options.borderStyle !== NONE || options.title) {
		result += colorizeBorder(marginLeft + chars.topLeft + (options.title ? makeTitle(options.title, chars.top.repeat(contentWidth), options.titleAlignment) : chars.top.repeat(contentWidth)) + chars.topRight) + NEWLINE;
	}

	const lines = content.split(NEWLINE);

	result += lines.map(line => marginLeft + colorizeBorder(chars.left) + colorizeContent(line) + colorizeBorder(chars.right)).join(NEWLINE);

	if (options.borderStyle !== NONE) {
		result += NEWLINE + colorizeBorder(marginLeft + chars.bottomLeft + chars.bottom.repeat(contentWidth) + chars.bottomRight);
	}

	if (options.margin.bottom) {
		result += NEWLINE.repeat(options.margin.bottom);
	}

	return result;
};

const sanitizeOptions = options => {
	// If fullscreen is enabled, max-out unspecified width/height
	if (options.fullscreen && process$1?.stdout) {
		let newDimensions = [process$1.stdout.columns, process$1.stdout.rows];

		if (typeof options.fullscreen === 'function') {
			newDimensions = options.fullscreen(...newDimensions);
		}

		options.width ||= newDimensions[0];

		options.height ||= newDimensions[1];
	}

	// If width is provided, make sure it's not below 1
	options.width &&= Math.max(1, options.width - getBorderWidth(options.borderStyle));

	// If height is provided, make sure it's not below 1
	options.height &&= Math.max(1, options.height - getBorderWidth(options.borderStyle));

	return options;
};

const formatTitle = (title, borderStyle) => borderStyle === NONE ? title : ` ${title} `;

const determineDimensions = (text, options) => {
	options = sanitizeOptions(options);
	const widthOverride = options.width !== undefined;
	const columns = terminalColumns();
	const borderWidth = getBorderWidth(options.borderStyle);
	const maxWidth = columns - options.margin.left - options.margin.right - borderWidth;

	const widest = widestLine(wrapAnsi(text, columns - borderWidth, {hard: true, trim: false})) + options.padding.left + options.padding.right;

	// If title and width are provided, title adheres to fixed width
	if (options.title && widthOverride) {
		options.title = options.title.slice(0, Math.max(0, options.width - 2));
		options.title &&= formatTitle(options.title, options.borderStyle);
	} else if (options.title) {
		options.title = options.title.slice(0, Math.max(0, maxWidth - 2));

		// Recheck if title isn't empty now
		if (options.title) {
			options.title = formatTitle(options.title, options.borderStyle);
			// If the title is larger than content, box adheres to title width
			if (stringWidth$1(options.title) > widest) {
				options.width = stringWidth$1(options.title);
			}
		}
	}

	// If fixed width is provided, use it or content width as reference
	options.width ||= widest;

	if (!widthOverride) {
		if ((options.margin.left && options.margin.right) && options.width > maxWidth) {
			// Let's assume we have margins: left = 3, right = 5, in total = 8
			const spaceForMargins = columns - options.width - borderWidth;
			// Let's assume we have space = 4
			const multiplier = spaceForMargins / (options.margin.left + options.margin.right);
			// Here: multiplier = 4/8 = 0.5
			options.margin.left = Math.max(0, Math.floor(options.margin.left * multiplier));
			options.margin.right = Math.max(0, Math.floor(options.margin.right * multiplier));
			// Left: 3 * 0.5 = 1.5 -> 1
			// Right: 6 * 0.5 = 3
		}

		// Re-cap width considering the margins after shrinking
		options.width = Math.min(options.width, columns - borderWidth - options.margin.left - options.margin.right);
	}

	// Prevent padding overflow
	if (options.width - (options.padding.left + options.padding.right) <= 0) {
		options.padding.left = 0;
		options.padding.right = 0;
	}

	if (options.height && options.height - (options.padding.top + options.padding.bottom) <= 0) {
		options.padding.top = 0;
		options.padding.bottom = 0;
	}

	return options;
};

const isHex = color => color.match(/^#(?:[0-f]{3}){1,2}$/i);
const isColorValid = color => typeof color === 'string' && (chalk[color] ?? isHex(color));
const getColorFunction = color => isHex(color) ? chalk.hex(color) : chalk[color];
const getBGColorFunction = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];

function boxen(text, options) {
	options = {
		padding: 0,
		borderStyle: 'single',
		dimBorder: false,
		textAlignment: 'left',
		float: 'left',
		titleAlignment: 'left',
		...options,
	};

	// This option is deprecated
	if (options.align) {
		options.textAlignment = options.align;
	}

	if (options.borderColor && !isColorValid(options.borderColor)) {
		throw new Error(`${options.borderColor} is not a valid borderColor`);
	}

	if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
		throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);
	}

	options.padding = getObject(options.padding);
	options.margin = getObject(options.margin);

	options = determineDimensions(text, options);

	text = makeContentText(text, options);

	return boxContent(text, options.width, options);
}

var dist = {};

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = process || {}, argv = p.argv || [], env = p.env || {};
	let isColorSupported =
		!(!!env.NO_COLOR || argv.includes("--no-color")) &&
		(!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env.TERM !== "dumb") || !!env.CI);

	let formatter = (open, close, replace = open) =>
		input => {
			let string = "" + input, index = string.indexOf(close, open.length);
			return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
		};

	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index)
		return result + string.substring(cursor)
	};

	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1b[0m", "\x1b[0m"),
			bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
			dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
			italic: f("\x1b[3m", "\x1b[23m"),
			underline: f("\x1b[4m", "\x1b[24m"),
			inverse: f("\x1b[7m", "\x1b[27m"),
			hidden: f("\x1b[8m", "\x1b[28m"),
			strikethrough: f("\x1b[9m", "\x1b[29m"),

			black: f("\x1b[30m", "\x1b[39m"),
			red: f("\x1b[31m", "\x1b[39m"),
			green: f("\x1b[32m", "\x1b[39m"),
			yellow: f("\x1b[33m", "\x1b[39m"),
			blue: f("\x1b[34m", "\x1b[39m"),
			magenta: f("\x1b[35m", "\x1b[39m"),
			cyan: f("\x1b[36m", "\x1b[39m"),
			white: f("\x1b[37m", "\x1b[39m"),
			gray: f("\x1b[90m", "\x1b[39m"),

			bgBlack: f("\x1b[40m", "\x1b[49m"),
			bgRed: f("\x1b[41m", "\x1b[49m"),
			bgGreen: f("\x1b[42m", "\x1b[49m"),
			bgYellow: f("\x1b[43m", "\x1b[49m"),
			bgBlue: f("\x1b[44m", "\x1b[49m"),
			bgMagenta: f("\x1b[45m", "\x1b[49m"),
			bgCyan: f("\x1b[46m", "\x1b[49m"),
			bgWhite: f("\x1b[47m", "\x1b[49m"),

			blackBright: f("\x1b[90m", "\x1b[39m"),
			redBright: f("\x1b[91m", "\x1b[39m"),
			greenBright: f("\x1b[92m", "\x1b[39m"),
			yellowBright: f("\x1b[93m", "\x1b[39m"),
			blueBright: f("\x1b[94m", "\x1b[39m"),
			magentaBright: f("\x1b[95m", "\x1b[39m"),
			cyanBright: f("\x1b[96m", "\x1b[39m"),
			whiteBright: f("\x1b[97m", "\x1b[39m"),

			bgBlackBright: f("\x1b[100m", "\x1b[49m"),
			bgRedBright: f("\x1b[101m", "\x1b[49m"),
			bgGreenBright: f("\x1b[102m", "\x1b[49m"),
			bgYellowBright: f("\x1b[103m", "\x1b[49m"),
			bgBlueBright: f("\x1b[104m", "\x1b[49m"),
			bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
			bgCyanBright: f("\x1b[106m", "\x1b[49m"),
			bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
		}
	};

	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var consts = {};

var hasRequiredConsts;

function requireConsts () {
	if (hasRequiredConsts) return consts;
	hasRequiredConsts = 1;
	var __importDefault = (consts && consts.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(consts, "__esModule", { value: true });
	consts.symbols = consts.isTTY = void 0;
	const node_tty_1 = __importDefault(tty);
	const node_process_1 = __importDefault(process$1);
	/**
	 * This file contains code adapted from the following projects:
	 *
	 * 1. is-unicode-supported (https://github.com/sindresorhus/is-unicode-supported)
	 * 2. cli-spinners (https://github.com/sindresorhus/cli-spinners)
	 * 3. log-symbols (https://github.com/sindresorhus/log-symbols)
	 *
	 * All of the above projects are created by Sindre Sorhus (https://sindresorhus.com)
	 * and are licensed under the MIT License.
	 *
	 * The full text of the MIT License can be found in the LICENSE file in this project's root directory.
	 */
	const isCI = node_process_1.default.env.CI ||
	    node_process_1.default.env.WT_SESSION ||
	    node_process_1.default.env.ConEmuTask === '{cmd::Cmder}' ||
	    node_process_1.default.env.TERM_PROGRAM === 'vscode' ||
	    node_process_1.default.env.TERM === 'xterm-256color' ||
	    node_process_1.default.env.TERM === 'alacritty';
	const isTTY = node_tty_1.default.isatty(1) && node_process_1.default.env.TERM !== 'dumb' && !('CI' in node_process_1.default.env);
	consts.isTTY = isTTY;
	// https://github.com/sindresorhus/is-unicode-supported
	const supportUnicode = node_process_1.default.platform !== 'win32' ? node_process_1.default.env.TERM !== 'linux' : isCI;
	const symbols = {
	    frames: isTTY
	        ? supportUnicode
	            ? // https://github.com/sindresorhus/cli-spinners
	                ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']
	            : ['-', '\\', '|', '/']
	        : ['-'],
	    // https://github.com/sindresorhus/log-symbols/blob/main/index.js
	    tick: supportUnicode ? '✔' : '√',
	    cross: supportUnicode ? '✖' : '×',
	    warn: supportUnicode ? '⚠' : '!!',
	    info: supportUnicode ? 'ℹ' : 'i',
	};
	consts.symbols = symbols;
	return consts;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	var __importDefault = (dist && dist.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist, "__esModule", { value: true });
	dist.createSpinner = createSpinner;
	const picocolors_1 = __importDefault(/*@__PURE__*/ requirePicocolors());
	const consts_1 = requireConsts();
	function getLines(str = '', width = 80) {
	    return str
	        .replace(/\u001b[^m]*?m/g, '')
	        .split('\n')
	        .reduce((col, line) => (col += Math.max(1, Math.ceil(line.length / width))), 0);
	}
	function createSpinner(text = '', opts = {}) {
	    let current = 0, interval = opts.interval || 50, stream = opts.stream || process.stderr, frames = opts.frames && opts.frames.length ? opts.frames : consts_1.symbols.frames, color = opts.color || 'yellow', spinning = false, lines = 0, timer = undefined, getText = (opts = {}) => typeof opts === 'string' ? opts : opts.text || text, getUpdate = (opts = {}) => typeof opts === 'string' ? false : !!opts.update, getColor = (opts = {}) => typeof opts === 'string' || !opts.color ? color : opts.color, getMark = (opts = {}, fallback) => typeof opts === 'string' || !opts.mark ? fallback : opts.mark, mountProcessEvents = () => {
	        process.on('SIGINT', exit);
	        process.on('SIGTERM', exit);
	    }, cleanupProcessEvents = () => {
	        process.off('SIGINT', exit);
	        process.off('SIGTERM', exit);
	    };
	    let spinner = {
	        reset() {
	            current = 0;
	            lines = 0;
	            spinning = false;
	            clearTimeout(timer);
	            timer = undefined;
	            return spinner;
	        },
	        clear() {
	            spinner.write('\x1b[1G');
	            for (let i = 0; i < lines; i++) {
	                i > 0 && spinner.write('\x1b[1A');
	                spinner.write('\x1b[2K\x1b[1G');
	            }
	            lines = 0;
	            return spinner;
	        },
	        write(str, clear = false) {
	            if (clear && consts_1.isTTY)
	                spinner.clear();
	            stream.write(str);
	            return spinner;
	        },
	        render() {
	            let str = `${picocolors_1.default[color](frames[current])} ${text}`;
	            consts_1.isTTY ? spinner.write(`\x1b[?25l`) : (str += '\n');
	            spinner.write(str, true);
	            consts_1.isTTY && (lines = getLines(str, stream.columns));
	            return spinner;
	        },
	        spin() {
	            spinner.render();
	            current = ++current % frames.length;
	            return spinner;
	        },
	        update(opts) {
	            if (typeof opts === 'string') {
	                text = opts;
	            }
	            else {
	                text = opts.text || text;
	                frames = opts.frames && opts.frames.length ? opts.frames : frames;
	                interval = opts.interval || interval;
	                color = opts.color || color;
	            }
	            if (frames.length - 1 < current)
	                current = 0;
	            return spinner;
	        },
	        loop() {
	            consts_1.isTTY && (timer = setTimeout(() => spinner.loop(), interval));
	            return spinner.spin();
	        },
	        start(opts = {}) {
	            timer && spinner.reset();
	            spinning = true;
	            mountProcessEvents();
	            return spinner.update({ text: getText(opts), color: getColor(opts) }).loop();
	        },
	        stop(opts) {
	            spinning = false;
	            clearTimeout(timer);
	            timer = undefined;
	            cleanupProcessEvents();
	            const update = getUpdate(opts);
	            const mark = picocolors_1.default[getColor(opts)](getMark(opts, frames[current]));
	            const text = getText(opts);
	            spinner.write(opts ? `${mark} ${text}${update ? '' : '\n'}` : '', true);
	            return consts_1.isTTY && !update ? spinner.write(`\x1b[?25h`) : spinner;
	        },
	        success(opts = {}) {
	            return spinner.stop({
	                text: getText(opts),
	                mark: getMark(opts, consts_1.symbols.tick),
	                color: 'green',
	                update: getUpdate(opts),
	            });
	        },
	        error(opts = {}) {
	            return spinner.stop({
	                text: getText(opts),
	                mark: getMark(opts, consts_1.symbols.cross),
	                color: 'red',
	                update: getUpdate(opts),
	            });
	        },
	        warn(opts = {}) {
	            return spinner.stop({
	                text: getText(opts),
	                mark: getMark(opts, consts_1.symbols.warn),
	                color: 'yellow',
	                update: getUpdate(opts),
	            });
	        },
	        info(opts = {}) {
	            return spinner.stop({
	                text: getText(opts),
	                mark: getMark(opts, consts_1.symbols.info),
	                color: 'blue',
	                update: getUpdate(opts),
	            });
	        },
	        isSpinning() {
	            return spinning;
	        },
	    };
	    function exit(signal) {
	        if (spinning) {
	            spinner.stop();
	        }
	        process.exit(signal === 'SIGINT' ? 130 : signal === 'SIGTERM' ? 143 : 1);
	    }
	    return spinner;
	}
	return dist;
}

var distExports = requireDist();

/**
 * TUI Engine - Testable UI Logic Separated from Rendering
 * Handles state management and business logic for the Terminal UI
 */


// Recent files storage
const RECENT_FILES_PATH = path$1.join(process.env.HOME || process.env.USERPROFILE, '.datapilot_recent.json');
const MAX_RECENT_FILES = 10;

class TUIEngine {
  constructor(options = {}) {
    this.state = {
      navigationStack: [],
      recentFiles: this.loadRecentFiles(),
      currentSession: null,
      lastAnalysisResults: null,
      demoMode: false
    };
    
    // Dependency injection for testing
    this.dependencies = {
      fs: options.fs || fs,
      path: options.path || path$1,
      parseCSV: options.parseCSV || parseCSV,
      detectColumnTypes: options.detectColumnTypes || detectColumnTypes,
      eda: options.eda || eda,
      integrity: options.integrity || integrity,
      visualize: options.visualize || visualize,
      llmContext: options.llmContext || llmContext,
      KnowledgeBase: options.KnowledgeBase || KnowledgeBase
    };
    
    this.testMode = options.testMode || false;
  }

  // === State Management ===
  
  getState() {
    return { ...this.state };
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
  }
  
  pushNavigation(location) {
    this.state.navigationStack.push(location);
  }
  
  popNavigation() {
    return this.state.navigationStack.pop();
  }

  // === Main Menu Logic ===
  
  getMainMenuChoices() {
    return [
      {
        name: 'analyze',
        message: '📊 Analyze CSV Data',
        hint: '🔍 Smart file discovery and guided analysis'
      },
      {
        name: 'demo',
        message: '🎭 Try Demo Mode',
        hint: '🎯 Experience DataPilot with built-in sample datasets'
      },
      {
        name: 'memory',
        message: '🧠 Manage Memories',
        hint: '🗄️  View, delete, or manage warehouse knowledge'
      },
      {
        name: 'settings',
        message: '⚙️  Settings & Preferences',
        hint: '🛠️  Configure DataPilot behavior and appearance'
      },
      {
        name: 'exit',
        message: '👋 Exit DataPilot',
        hint: '✨ Thanks for exploring data with us!'
      }
    ];
  }
  
  async handleMainMenuAction(action) {
    this.pushNavigation('main');
    
    switch (action) {
      case 'analyze':
        return await this.startGuidedAnalysis();
      case 'demo':
        return await this.startDemo();
      case 'memory':
        return await this.startMemoryManager();
      case 'settings':
        return await this.startSettings();
      case 'exit':
        return { action: 'exit', message: 'Goodbye!' };
      default:
        return { action: 'error', message: `Unknown action: ${action}` };
    }
  }

  // === File Discovery and Selection ===
  
  async discoverCSVFiles() {
    const searchPaths = [
      process.cwd(),
      this.dependencies.path.join(process.cwd(), 'data'),
      this.dependencies.path.join(process.cwd(), 'datasets'),
      this.dependencies.path.join(process.cwd(), 'csv'),
      this.dependencies.path.join(process.cwd(), 'files')
    ];
    
    const csvFiles = [];
    
    for (const searchPath of searchPaths) {
      try {
        if (this.dependencies.fs.existsSync(searchPath)) {
          const files = this.dependencies.fs.readdirSync(searchPath);
          files.forEach(file => {
            if (file.toLowerCase().endsWith('.csv')) {
              const fullPath = this.dependencies.path.join(searchPath, file);
              const stats = this.dependencies.fs.statSync(fullPath);
              csvFiles.push({
                name: file,
                path: fullPath,
                size: this.formatFileSize(stats.size),
                modified: stats.mtime.toLocaleDateString(),
                directory: this.dependencies.path.relative(process.cwd(), searchPath) || '.'
              });
            }
          });
        }
      } catch (error) {
        // Directory not accessible, skip
      }
    }
    
    return csvFiles;
  }
  
  getFileSelectionChoices(csvFiles) {
    const choices = [];
    
    // Recent files section
    if (this.state.recentFiles.length > 0) {
      choices.push({ name: 'recent_header', message: '📁 Recent Files', role: 'separator' });
      this.state.recentFiles.slice(0, 5).forEach(file => {
        if (this.dependencies.fs.existsSync(file)) {
          choices.push({
            name: file,
            message: `📄 ${path$1.basename(file)}`,
            hint: `${path$1.dirname(file)} - Recently used`
          });
        }
      });
    }
    
    // Discovered files section
    if (csvFiles.length > 0) {
      choices.push({ name: 'discovered_header', message: '🔍 Discovered Files', role: 'separator' });
      csvFiles.slice(0, 10).forEach(file => {
        choices.push({
          name: file.path,
          message: `📄 ${file.name}`,
          hint: `${file.directory} - ${file.size} (${file.modified})`
        });
      });
    }
    
    // Manual entry and navigation options
    choices.push({ name: 'separator', message: '─────────────────────', role: 'separator' });
    choices.push({
      name: 'manual',
      message: '📂 Browse for File',
      hint: 'Enter file path manually'
    });
    choices.push({
      name: 'back',
      message: '⬅️  Back to Main Menu',
      hint: 'Return to main menu'
    });
    
    return choices;
  }
  
  async previewFile(filePath) {
    try {
      const records = await this.dependencies.parseCSV(filePath, { quiet: true, header: true });
      const columnTypes = this.dependencies.detectColumnTypes(records);
      
      const preview = {
        path: filePath,
        size: this.dependencies.fs.statSync(filePath).size,
        rows: records.length,
        columns: Object.keys(columnTypes).length,
        sampleData: records.slice(0, 3),
        columnTypes: columnTypes,
        columnNames: Object.keys(columnTypes)
      };
      
      return preview;
    } catch (error) {
      return {
        error: error.message,
        path: filePath
      };
    }
  }

  // === Analysis Types ===
  
  getAnalysisTypeChoices() {
    return [
      {
        name: 'all',
        message: '🚀 Complete Analysis Suite',
        hint: 'Run all analysis types for comprehensive insights'
      },
      {
        name: 'eda',
        message: '📊 Exploratory Data Analysis',
        hint: 'Statistical analysis, distributions, correlations'
      },
      {
        name: 'int',
        message: '🔍 Data Integrity Check',
        hint: 'Quality assessment, validation, completeness'
      },
      {
        name: 'vis',
        message: '📈 Visualization Recommendations',
        hint: 'Chart suggestions, design principles'
      },
      {
        name: 'eng',
        message: '🏗️ Data Engineering Archaeology',
        hint: 'Schema analysis, warehouse design'
      },
      {
        name: 'llm',
        message: '🤖 LLM Context Generation',
        hint: 'AI-ready summaries and insights'
      }
    ];
  }
  
  async runAnalysis(filePath, analysisType, options = {}) {
    this.addToRecentFiles(filePath);
    
    const results = {
      filePath,
      analysisType,
      timestamp: new Date().toISOString(),
      results: {}
    };
    
    try {
      const records = await this.dependencies.parseCSV(filePath, { quiet: true, header: true });
      const columnTypes = this.dependencies.detectColumnTypes(records);
      
      const analysisOptions = {
        ...options,
        preloadedData: { records, columnTypes },
        structuredOutput: this.testMode
      };
      
      switch (analysisType) {
        case 'all':
          results.results.eda = await this.dependencies.eda(records, Object.keys(columnTypes), filePath, analysisOptions);
          results.results.int = await this.dependencies.integrity(records, Object.keys(columnTypes), filePath, analysisOptions);
          results.results.vis = await this.dependencies.visualize(filePath, analysisOptions);
          results.results.eng = await this.dependencies.eda(records, Object.keys(columnTypes), filePath, { ...analysisOptions, command: 'eng' });
          results.results.llm = await this.dependencies.llmContext(filePath, analysisOptions);
          break;
        case 'eda':
          results.results.eda = await this.dependencies.eda(records, Object.keys(columnTypes), filePath, analysisOptions);
          break;
        case 'int':
          results.results.int = await this.dependencies.integrity(records, Object.keys(columnTypes), filePath, analysisOptions);
          break;
        case 'vis':
          results.results.vis = await this.dependencies.visualize(filePath, analysisOptions);
          break;
        case 'eng':
          results.results.eng = await this.dependencies.eda(records, Object.keys(columnTypes), filePath, { ...analysisOptions, command: 'eng' });
          break;
        case 'llm':
          results.results.llm = await this.dependencies.llmContext(filePath, analysisOptions);
          break;
        default:
          throw new Error(`Unknown analysis type: ${analysisType}`);
      }
      
      this.state.lastAnalysisResults = results;
      return results;
      
    } catch (error) {
      results.error = error.message;
      return results;
    }
  }

  // === Demo Mode ===
  
  getDemoDatasets() {
    const demoPath = path$1.join(process.cwd(), 'tests', 'fixtures');
    const datasets = [];
    
    // Only include 2 specific demo datasets as requested
    const allowedDemos = ['boston_housing.csv', 'iris.csv'];
    
    try {
      if (this.dependencies.fs.existsSync(demoPath)) {
        allowedDemos.forEach(filename => {
          const fullPath = path$1.join(demoPath, filename);
          if (this.dependencies.fs.existsSync(fullPath)) {
            datasets.push({
              name: filename.replace('.csv', ''),
              path: fullPath,
              description: this.getDemoDescription(filename)
            });
          }
        });
      }
    } catch (error) {
      // Demo files not available
    }
    
    return datasets;
  }
  
  getDemoDescription(filename) {
    const descriptions = {
      'boston_housing.csv': 'Classic housing dataset with 506 samples and 14 features for regression analysis',
      'iris.csv': 'Famous flower classification dataset with 150 samples and 4 measurements'
    };
    
    return descriptions[filename] || 'Sample dataset for demonstration purposes';
  }
  
  async startDemo() {
    this.state.demoMode = true;
    const datasets = this.getDemoDatasets();
    
    return {
      action: 'demo',
      datasets,
      message: datasets.length > 0 ? 'Demo datasets available' : 'No demo datasets found'
    };
  }

  // === Memory Management ===
  
  async getMemorySummary() {
    const kb = new this.dependencies.KnowledgeBase();
    const knowledge = await kb.load();
    
    const tableCount = Object.keys(knowledge.tables || {}).length;
    const domains = [...new Set(Object.values(knowledge.tables || {}).map(t => t.domain))];
    const totalDebtHours = knowledge.warehouse_metadata?.total_technical_debt_hours || 0;
    
    return {
      tableCount,
      domainCount: domains.length,
      domains,
      totalDebtHours,
      storagePath: '~/.datapilot/archaeology'
    };
  }
  
  async listMemories() {
    const kb = new this.dependencies.KnowledgeBase();
    const knowledge = await kb.load();
    
    const tables = Object.entries(knowledge.tables || {});
    const memories = {};
    
    // Group by domain
    tables.forEach(([name, info]) => {
      const domain = info.domain || 'Unknown';
      if (!memories[domain]) memories[domain] = [];
      memories[domain].push({
        name,
        rows: info.row_count || 0,
        columns: (info.columns || []).length,
        quality: info.quality_score ? `${info.quality_score.toFixed(1)}%` : 'N/A'
      });
    });
    
    return memories;
  }
  
  async deleteMemory(tableName) {
    const kb = new this.dependencies.KnowledgeBase();
    try {
      await kb.deleteTable(tableName);
      return { success: true, message: `Memory for "${tableName}" deleted successfully` };
    } catch (error) {
      return { success: false, message: `Failed to delete memory: ${error.message}` };
    }
  }
  
  async clearAllMemories() {
    const kb = new this.dependencies.KnowledgeBase();
    try {
      await kb.clearAll();
      return { success: true, message: 'All memories cleared successfully' };
    } catch (error) {
      return { success: false, message: `Failed to clear memories: ${error.message}` };
    }
  }
  
  async startMemoryManager() {
    const summary = await this.getMemorySummary();
    return {
      action: 'memory',
      summary,
      message: 'Memory manager initialized'
    };
  }

  // === Guided Analysis Flow ===
  
  async startGuidedAnalysis() {
    const csvFiles = await this.discoverCSVFiles();
    return {
      action: 'analyze',
      csvFiles,
      message: csvFiles.length > 0 ? `Found ${csvFiles.length} CSV files` : 'No CSV files found in common locations'
    };
  }

  // === Utility Methods ===
  
  formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
    return Math.round(bytes / (1024 * 1024)) + ' MB';
  }
  
  loadRecentFiles() {
    try {
      if (this.dependencies.fs.existsSync(RECENT_FILES_PATH)) {
        const data = this.dependencies.fs.readFileSync(RECENT_FILES_PATH, 'utf8');
        return JSON.parse(data).filter(file => this.dependencies.fs.existsSync(file));
      }
    } catch (error) {
      // Invalid recent files, start fresh
    }
    return [];
  }
  
  addToRecentFiles(filePath) {
    const recent = this.loadRecentFiles();
    const filtered = recent.filter(f => f !== filePath);
    filtered.unshift(filePath);
    
    const toSave = filtered.slice(0, MAX_RECENT_FILES);
    this.state.recentFiles = toSave;
    
    try {
      this.dependencies.fs.writeFileSync(RECENT_FILES_PATH, JSON.stringify(toSave, null, 2));
    } catch (error) {
      // Failed to save recent files, continue silently
    }
  }
  
  // === Test Utilities ===
  
  async simulateUserFlow(actions) {
    const results = [];
    
    for (const action of actions) {
      let result;
      
      switch (action.type) {
        case 'main_menu':
          result = await this.handleMainMenuAction(action.choice);
          break;
        case 'file_selection':
          result = { action: 'file_selected', filePath: action.filePath };
          break;
        case 'analysis_type':
          result = await this.runAnalysis(action.filePath, action.analysisType, { testMode: true });
          break;
        case 'memory_action':
          switch (action.memoryAction) {
            case 'list':
              result = await this.listMemories();
              break;
            case 'delete':
              result = await this.deleteMemory(action.tableName);
              break;
            case 'clear':
              result = await this.clearAllMemories();
              break;
            default:
              result = { error: 'Unknown memory action' };
          }
          break;
        default:
          result = { error: `Unknown action type: ${action.type}` };
      }
      
      results.push({ action, result });
    }
    
    return results;
  }


  // === Settings ===
  
  async startSettings() {
    return {
      action: 'settings',
      message: 'Settings initialized',
      options: [
        'Color Theme Selection',
        'Default Analysis Types',
        'Memory Management Preferences',
        'Default File Search Paths',
        'Performance Optimization',
        'Notification Preferences'
      ]
    };
  }
}

/**
 * Interactive Terminal UI Command - Refactored with TUI Engine
 * Fun, colorful, beginner-friendly interface with animations
 * Now separated into logic (TUI_Engine) and rendering (this file)
 */

const { prompt } = enquirer;

// Wrapper for prompts to handle Escape key gracefully
async function safePrompt(config) {
  try {
    return await prompt(config);
  } catch (error) {
    if (error && error.message && (error.message.includes('cancelled') || error.message.includes('Escape'))) {
      throw new Error('cancelled');
    }
    throw error;
  }
}

// Dark-terminal optimized color functions
const safeColors = {
  // Bright colors that work well on dark backgrounds
  primary: (text) => chalk.cyan.bold(text),        // Bright cyan for headings
  secondary: (text) => chalk.white(text),          // White for important text
  accent: (text) => chalk.yellow.bold(text),       // Bold yellow for highlights
  success: (text) => chalk.green.bold(text),       // Bold green for success
  warning: (text) => chalk.yellow(text),           // Yellow for warnings
  danger: (text) => chalk.red.bold(text),          // Bold red for errors
  info: (text) => chalk.blue.bold(text),           // Bold blue for info
  muted: (text) => chalk.gray(text),               // Gray for secondary text
  cyan: (text) => chalk.cyan(text),
  green: (text) => chalk.green.bold(text),
  blue: (text) => chalk.blue.bold(text),
  red: (text) => chalk.red.bold(text),
  yellow: (text) => chalk.yellow.bold(text),
  magenta: (text) => chalk.magenta.bold(text),
  white: (text) => chalk.white(text)
};

// Dark-terminal optimized gradients - no rainbow theme
const gradients = {
  // Remove jarring rainbow, use elegant gradients
  title: (text) => safeColors.primary(text),       // Cyan for titles
  menu: (text) => safeColors.secondary(text),      // White for menu items
  highlight: (text) => safeColors.accent(text),    // Yellow for highlights
  success: (text) => safeColors.success(text),     // Green for success
  warning: (text) => safeColors.warning(text),     // Yellow for warnings
  error: (text) => safeColors.danger(text),        // Red for errors
  info: (text) => safeColors.info(text),           // Blue for info
  subtle: (text) => safeColors.muted(text),        // Gray for subtle text
  accent: (text) => safeColors.accent(text),       // Yellow for accents
  
  // Legacy support (mapped to better colors)
  rainbow: (text) => safeColors.primary(text),     // Replace rainbow with cyan
  ocean: (text) => safeColors.info(text),          // Blue
  sunset: (text) => safeColors.accent(text),       // Yellow
  forest: (text) => safeColors.success(text),      // Green
  fire: (text) => safeColors.danger(text),         // Red
  cosmic: (text) => safeColors.magenta(text),      // Magenta
  cyan: (text) => safeColors.cyan(text),
  green: (text) => safeColors.green(text),
  blue: (text) => safeColors.blue(text),
  red: (text) => safeColors.red(text),
  yellow: (text) => safeColors.yellow(text),
  magenta: (text) => safeColors.magenta(text),
  purple: (text) => safeColors.magenta(text),
  gray: (text) => safeColors.muted(text),
  grey: (text) => safeColors.muted(text),
  white: (text) => safeColors.white(text),
  black: (text) => chalk.black(text)
};

async function interactiveUI() {
  console.clear();
  
  const engine = new TUIEngine();
  
  try {
    // Welcome animation
    await showWelcomeAnimation();
    
    // Main interactive loop
    let running = true;
    while (running) {
      try {
        const action = await showMainMenu(engine);
        
        if (action === 'exit') {
          running = false;
        } else {
          await handleMainMenuAction(engine, action);
        }
      } catch (error) {
        // Handle Escape key press gracefully
        if (error && error.message && error.message.includes('cancelled')) {
          console.log(chalk.yellow('\nOperation cancelled. Returning to main menu...'));
          continue;
        }
        
        console.log(chalk.red('An error occurred:'), error.message);
        try {
          const continueChoice = await safePrompt({
            type: 'confirm',
            name: 'continue',
            message: 'Would you like to continue?',
            initial: true
          });
          
          if (!continueChoice.continue) {
            running = false;
          }
        } catch (continueError) {
          // If user cancels the continue prompt, exit gracefully
          running = false;
        }
      }
    }
    
    // Goodbye animation
    await showGoodbyeAnimation();
    
  } catch (error) {
    console.log(chalk.red('Fatal error in interactive UI:'), error.message);
    process.exit(1);
  }
}

async function showMainMenu(engine) {
  const choices = engine.getMainMenuChoices();
  
  // Clean, professional main menu header
  console.log('\n' + boxen(
    gradients.title('⭐ MAIN MENU ⭐') + '\n' +
    gradients.menu('Choose your data adventure:'),
    {
      padding: { top: 0, bottom: 0, left: 2, right: 2 },
      borderStyle: 'single',
      borderColor: 'cyan',
      textAlignment: 'center'
    }
  ));
  
  const response = await safePrompt({
    type: 'select',
    name: 'action',
    message: gradients.highlight('🚀 What would you like to explore today?'),
    choices: choices
  });
  
  return response.action;
}

async function handleMainMenuAction(engine, action) {
  const result = await engine.handleMainMenuAction(action);
  
  switch (result.action) {
    case 'analyze':
      await showGuidedAnalysis(engine, result);
      break;
    case 'demo':
      await showDemo(engine, result);
      break;
    case 'memory':
      await showMemoryManager(engine, result);
      break;
    case 'settings':
      await showSettings();
      break;
    case 'exit':
      // Exit handled in main loop
      break;
    case 'error':
      console.log(chalk.red('Error:'), result.message);
      break;
  }
}

async function showGuidedAnalysis(engine, analysisResult) {
  console.clear();
  
  // Enhanced guided analysis header
  const analysisHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                  🔍 GUIDED ANALYSIS MODE 🔍                 ║
  ║              Transform CSV data into insights                ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.ocean(analysisHeader));
  console.log();
  
  // Step 1: File selection
  const filePath = await selectFile(engine, analysisResult.csvFiles);
  if (!filePath) return;
  
  // Step 2: File preview
  await showFilePreview(engine, filePath);
  
  // Step 3: Analysis type selection
  const analysisType = await selectAnalysisType(engine);
  
  // Step 4: Run analysis with beautiful loading
  await runAnalysisWithAnimation(engine, filePath, analysisType);
  
  // Step 5: Show results
  await showResults();
  
  await safePrompt({
    type: 'confirm',
    name: 'continue',
    message: '\\nPress Enter to continue...'
  });
}

async function selectFile(engine, csvFiles) {
  const choices = engine.getFileSelectionChoices(csvFiles);
  
  if (choices.length === 0) {
    console.log(chalk.yellow('No CSV files found. Please add some CSV files to your project directory.'));
    return null;
  }
  
  const response = await safePrompt({
    type: 'select',
    name: 'file',
    message: gradients.success('📂 Select a CSV file to analyze:'),
    choices: choices
  });
  
  if (response.file === 'back') {
    return null; // Signal to return to main menu
  }
  
  if (response.file === 'manual') {
    // Manual file entry with better error handling and retry
    let filePath = null;
    let attempts = 0;
    const maxAttempts = 3;
    
    while (!filePath && attempts < maxAttempts) {
      try {
        const manualResponse = await safePrompt({
          type: 'input',
          name: 'path',
          message: attempts > 0 ? 
            gradients.warning(`⚠️  Try again (${maxAttempts - attempts} attempts left):`) :
            gradients.info('Enter the path to your CSV file:'),
          validate: (input) => {
            if (!input.trim()) return 'Please enter a file path';
            if (!fs.existsSync(input)) return 'File does not exist';
            if (!input.toLowerCase().endsWith('.csv')) return 'File must be a CSV file';
            return true;
          }
        });
        filePath = manualResponse.path;
      } catch (error) {
        attempts++;
        if (attempts >= maxAttempts) {
          console.log(gradients.error('❌ Too many failed attempts. Returning to main menu.'));
          return null;
        }
        console.log(gradients.warning(`⚠️  Invalid file path. ${maxAttempts - attempts} attempts remaining.`));
      }
    }
    
    return filePath;
  }
  
  return response.file;
}

async function showFilePreview(engine, filePath) {
  const spinner = distExports.createSpinner('Loading file preview...').start();
  
  try {
    const preview = await engine.previewFile(filePath);
    spinner.success({ text: 'File preview loaded!' });
    
    if (preview.error) {
      console.log(chalk.red('Error reading file:'), preview.error);
      return;
    }
    
    console.log('\\n' + boxen(
      `📄 File: ${chalk.green(path$1.basename(filePath))}\\n` +
      `📏 Size: ${chalk.cyan(engine.formatFileSize(preview.size))}\\n` +
      `📊 Rows: ${chalk.yellow(preview.rows.toLocaleString())}\\n` +
      `📋 Columns: ${chalk.blue(preview.columns)}\\n\\n` +
      `🏷️  Column Types:\\n${preview.columnNames.slice(0, 5).map(col => 
        `  • ${col} (${preview.columnTypes[col]?.type || 'unknown'})`
      ).join('\\n')}` +
      (preview.columnNames.length > 5 ? `\\n  ... and ${preview.columnNames.length - 5} more` : ''),
      {
        padding: 1,
        borderColor: 'green',
        title: '📋 File Preview',
        titleAlignment: 'center'
      }
    ));
    
  } catch (error) {
    spinner.error({ text: 'Failed to load preview: ' + error.message });
  }
}

async function selectAnalysisType(engine) {
  const choices = engine.getAnalysisTypeChoices();
  
  const response = await safePrompt({
    type: 'select',
    name: 'type',
    message: gradients.blue('🔬 What type of analysis would you like?'),
    choices: choices
  });
  
  return response.type;
}

async function runAnalysisWithAnimation(engine, filePath, analysisType) {
  const spinner = distExports.createSpinner('Preparing analysis...').start();
  
  try {
    spinner.update({ text: 'Running analysis...' });
    const results = await engine.runAnalysis(filePath, analysisType);
    
    if (results.error) {
      spinner.error({ text: 'Analysis failed: ' + results.error });
    } else {
      spinner.success({ text: 'Analysis complete!' });
      
      // Display basic results info
      console.log('\\n' + boxen(
        `✅ Analysis completed successfully!\\n` +
        `📊 Type: ${chalk.cyan(analysisType.toUpperCase())}\\n` +
        `📄 File: ${chalk.green(path$1.basename(filePath))}\\n` +
        `⏱️  Time: ${chalk.yellow(new Date(results.timestamp).toLocaleTimeString())}`,
        {
          padding: 1,
          borderColor: 'green',
          title: '🎉 Analysis Results',
          titleAlignment: 'center'
        }
      ));
    }
    
  } catch (error) {
    spinner.error({ text: 'Analysis failed: ' + error.message });
  }
}

async function showDemo(engine, demoResult) {
  console.clear();
  
  // Enhanced demo mode header
  const demoHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                     🎭 DEMO MODE 🎭                        ║
  ║               Try DataPilot with sample data                 ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.fire(demoHeader));
  console.log();
  
  if (demoResult.datasets.length === 0) {
    console.log(chalk.yellow('No demo datasets found. Please ensure test fixtures are available.'));
    await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
    return;
  }
  
  const choices = demoResult.datasets.map(dataset => ({
    name: dataset.path,
    message: `📊 ${dataset.name}`,
    hint: dataset.description
  }));
  
  choices.push({
    name: 'back',
    message: '⬅️  Back to Main Menu',
    hint: 'Return to main menu'
  });
  
  const response = await safePrompt({
    type: 'select',
    name: 'dataset',
    message: gradients.fire('🎯 Choose a demo dataset:'),
    choices: choices
  });
  
  if (response.dataset === 'back') return;
  
  // Run demo analysis
  const analysisType = await selectAnalysisType(engine);
  await runAnalysisWithAnimation(engine, response.dataset, analysisType);
  await showResults();
  
  await safePrompt({
    type: 'confirm',
    name: 'continue',
    message: '\\nPress Enter to continue...'
  });
}

async function showMemoryManager(engine, memoryResult) {
  console.clear();
  
  // Enhanced memory manager header
  const memoryHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                   🧠 MEMORY MANAGER 🧠                     ║
  ║              Manage DataPilot's warehouse knowledge         ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.ocean(memoryHeader));
  console.log();
  
  // Display summary
  console.log(boxen(
    `📊 Tables Analyzed: ${chalk.cyan(memoryResult.summary.tableCount)}\\n` +
    `🏢 Domains Discovered: ${chalk.green(memoryResult.summary.domainCount)}\\n` +
    `💸 Technical Debt: ${chalk.yellow(memoryResult.summary.totalDebtHours + ' hours')}\\n` +
    `📁 Storage Location: ${chalk.gray(memoryResult.summary.storagePath)}`,
    {
      padding: 1,
      borderColor: 'cyan',
      title: '📈 Knowledge Base Summary',
      titleAlignment: 'center'
    }
  ));
  
  console.log();
  
  let managing = true;
  while (managing) {
    const action = await safePrompt({
      type: 'select',
      name: 'action',
      message: gradients.cyan('What would you like to do?'),
      choices: [
        { name: 'list', message: '📋 List All Memories', hint: 'View all analyzed tables and domains' },
        { name: 'view', message: '🔍 View Memory Details', hint: 'Inspect a specific table\'s knowledge' },
        { name: 'delete', message: '🗑️  Delete Memory', hint: 'Remove a specific table from knowledge base' },
        { name: 'clear', message: '💣 Clear All Memories', hint: 'Remove all warehouse knowledge (careful!)' },
        { name: 'export', message: '💾 Export Memories', hint: 'Save current knowledge to a file' },
        { name: 'session', message: '⏱️  Session Memories', hint: 'Manage temporary session-based knowledge' },
        { name: 'back', message: '⬅️  Back to Main Menu', hint: 'Return to main menu' }
      ]
    });
    
    switch (action.action) {
      case 'list':
        await showMemoryList(engine);
        break;
      case 'view':
        await showMemoryDetails();
        break;
      case 'delete':
        await deleteMemory(engine);
        break;
      case 'clear':
        await clearAllMemories(engine);
        break;
      case 'export':
        await exportMemories(engine);
        break;
      case 'session':
        await showSessionMemories();
        break;
      case 'back':
        managing = false;
        break;
    }
  }
}

async function showMemoryList(engine) {
  console.clear();
  
  // Enhanced memory list header
  const memoryListHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                   📋 ALL MEMORIES 📋                       ║
  ║                View your analysis history                    ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.ocean(memoryListHeader));
  console.log();
  
  const memories = await engine.listMemories();
  
  if (Object.keys(memories).length === 0) {
    console.log(chalk.yellow('No memories found. Analyze some CSV files first!'));
  } else {
    Object.entries(memories).forEach(([domain, tables]) => {
      console.log(chalk.cyan(`\\n🏢 ${domain} Domain:`));
      tables.forEach(table => {
        console.log(`  📊 ${chalk.green(table.name)} - ${table.rows} rows × ${table.columns} cols (Quality: ${table.quality})`);
      });
    });
  }
  
  await safePrompt({ type: 'confirm', name: 'continue', message: '\\nPress Enter to continue...' });
}

async function showMemoryDetails(engine) {
  // Implementation would be similar to the original but using engine methods
  console.log(chalk.yellow('Memory details feature - implementation in progress...'));
  await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
}

async function deleteMemory(engine) {
  const memories = await engine.listMemories();
  const allTables = Object.values(memories).flat();
  
  if (allTables.length === 0) {
    console.log(chalk.yellow('No memories to delete!'));
    await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
    return;
  }
  
  const { tableName } = await safePrompt({
    type: 'autocomplete',
    name: 'tableName',
    message: 'Select a table to delete:',
    choices: allTables.map(t => t.name)
  });
  
  const { confirm } = await safePrompt({
    type: 'confirm',
    name: 'confirm',
    message: `Are you sure you want to delete memory for "${tableName}"?`,
    initial: false
  });
  
  if (confirm) {
    const spinner = distExports.createSpinner('Deleting memory...').start();
    const result = await engine.deleteMemory(tableName);
    
    if (result.success) {
      spinner.success({ text: result.message });
    } else {
      spinner.error({ text: result.message });
    }
  } else {
    console.log(chalk.gray('Deletion cancelled.'));
  }
  
  await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
}

async function clearAllMemories(engine) {
  console.log(chalk.red('\\n⚠️  WARNING: This will delete ALL warehouse knowledge!'));
  console.log(chalk.yellow('This action cannot be undone.\\n'));
  
  const { confirmFirst } = await safePrompt({
    type: 'confirm',
    name: 'confirmFirst',
    message: 'Are you absolutely sure you want to clear all memories?',
    initial: false
  });
  
  if (!confirmFirst) {
    console.log(chalk.gray('Clear operation cancelled.'));
    await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
    return;
  }
  
  const { confirmSecond } = await safePrompt({
    type: 'input',
    name: 'confirmSecond',
    message: 'Type "DELETE ALL" to confirm:',
    validate: input => input === 'DELETE ALL' || 'Type exactly "DELETE ALL" to confirm'
  });
  
  if (confirmSecond === 'DELETE ALL') {
    const spinner = distExports.createSpinner('Clearing all memories...').start();
    const result = await engine.clearAllMemories();
    
    if (result.success) {
      spinner.success({ text: result.message });
    } else {
      spinner.error({ text: result.message });
    }
  } else {
    console.log(chalk.gray('Clear operation cancelled.'));
  }
  
  await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
}

async function exportMemories(engine) {
  console.clear();
  
  const exportHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                 💾 EXPORT MEMORIES 💾                      ║
  ║               Save warehouse knowledge to file              ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.title(exportHeader));
  
  try {
    // Get all memories from the engine
    const memories = await engine.listMemories();
    
    if (Object.keys(memories).length === 0) {
      console.log(gradients.warning('\n⚠️  No memories found to export. Analyze some CSV files first!'));
      await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
      return;
    }
    
    // Get export filename from user
    const { filename } = await safePrompt({
      type: 'input',
      name: 'filename',
      message: gradients.info('Enter filename for export (without extension):'),
      initial: `datapilot-memories-${new Date().toISOString().split('T')[0]}`,
      validate: (input) => {
        if (!input.trim()) return 'Please enter a filename';
        // Remove invalid filename characters
        const cleaned = input.trim().replace(/[<>:"/\\|?*]/g, '-');
        return cleaned.length > 0 || 'Please enter a valid filename';
      }
    });
    
    // Clean the filename
    const cleanFilename = filename.trim().replace(/[<>:"/\\|?*]/g, '-');
    const exportPath = `${cleanFilename}.txt`;
    
    const spinner = distExports.createSpinner('Exporting memories...').start();
    
    // Generate export content
    let exportContent = `DataPilot Warehouse Knowledge Export
Generated: ${new Date().toLocaleString()}
═══════════════════════════════════════════════════════════════

MEMORY SUMMARY
──────────────────────────────────────────────────────────────
Total Domains: ${Object.keys(memories).length}
Total Tables: ${Object.values(memories).reduce((total, tables) => total + tables.length, 0)}

`;

    // Export each domain and its tables
    Object.entries(memories).forEach(([domain, tables]) => {
      exportContent += `\n🏢 ${domain.toUpperCase()} DOMAIN
──────────────────────────────────────────────────────────────
Tables in this domain: ${tables.length}

`;
      
      tables.forEach((table, index) => {
        exportContent += `${index + 1}. ${table.name}
   • Rows: ${table.rows?.toLocaleString() || 'Unknown'}
   • Columns: ${table.columns || 'Unknown'}
   • Quality: ${table.quality || 'N/A'}

`;
      });
    });
    
    // Add detailed warehouse knowledge if available
    try {
      const detailedKnowledge = await engine.getDetailedKnowledge();
      if (detailedKnowledge) {
        exportContent += `\nDETAILED WAREHOUSE KNOWLEDGE
──────────────────────────────────────────────────────────────
${detailedKnowledge}

`;
      }
    } catch (error) {
      // Continue without detailed knowledge if not available
    }
    
    exportContent += `\nExport completed at ${new Date().toLocaleString()}
Generated by DataPilot - Your Data Analysis Co-Pilot 🛩️
`;
    
    // Write to file
    fs.writeFileSync(exportPath, exportContent, 'utf8');
    
    spinner.succeed('Memories exported successfully!');
    
    console.log('\n' + boxen(
      gradients.success(`✅ Export Complete!\n\n`) +
      gradients.info(`📁 File saved as: ${exportPath}\n`) +
      gradients.info(`📊 Exported ${Object.keys(memories).length} domains with ${Object.values(memories).reduce((total, tables) => total + tables.length, 0)} tables\n`) +
      gradients.subtle(`💡 You can now share this file or use it for documentation`),
      {
        padding: 1,
        borderColor: 'green',
        title: '💾 Export Summary',
        titleAlignment: 'center'
      }
    ));
    
  } catch (error) {
    console.log(gradients.error(`\n❌ Export failed: ${error.message}`));
  }
  
  await safePrompt({ type: 'confirm', name: 'continue', message: '\nPress Enter to continue...' });
}

async function showSessionMemories() {
  console.clear();
  
  // Enhanced session memories header
  const sessionHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                ⏱️  SESSION MEMORY MANAGER ⏱️                ║
  ║              Temporary analysis contexts (Coming Soon!)      ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.ocean(sessionHeader));
  
  console.log('\\n' + boxen(
    gradients.yellow('🚧 Feature Under Development 🚧\\n\\n') +
    'Session memories will enable:\\n' +
    gradients.green('• 📁 Temporary analysis sessions\\n') +
    gradients.blue('• 🎯 Directory-scoped memories\\n') +
    gradients.cyan('• ⚡ Quick save/load contexts\\n') +
    gradients.magenta('• 🤝 Team knowledge sharing'),
    {
      padding: 1,
      borderStyle: 'round',
      borderColor: 'yellow',
      title: '🔮 Coming Soon',
      titleAlignment: 'center'
    }
  ));
  console.log();
  console.log('Session memories will allow you to:');
  console.log('  • Create temporary analysis sessions');
  console.log('  • Scope memories to specific directories');
  console.log('  • Quick save/load analysis contexts');
  console.log('  • Share knowledge between team members');
  
  await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
}

async function showResults() {
  console.log('\\n' + chalk.green('📊 Analysis results displayed above.'));
  console.log(chalk.gray('(In the actual implementation, results would be shown here)'));
}

// Clean animation functions with proper ASCII art
async function showWelcomeAnimation() {
  // Clear screen and show clean DataPilot ASCII art
  console.clear();
  
  const logo = `
  ██████╗  █████╗ ████████╗ █████╗ ██████╗ ██╗██╗      ██████╗ ████████╗
  ██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗██╔══██╗██║██║     ██╔═══██╗╚══██╔══╝
  ██║  ██║███████║   ██║   ███████║██████╔╝██║██║     ██║   ██║   ██║   
  ██║  ██║██╔══██║   ██║   ██╔══██║██╔═══╝ ██║██║     ██║   ██║   ██║   
  ██████╔╝██║  ██║   ██║   ██║  ██║██║     ██║███████╗╚██████╔╝   ██║   
  ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝ ╚═════╝    ╚═╝   
                      🛩️ Your Data Analysis Co-Pilot 🛩️`;

  console.log(gradients.title(logo));
  
  // Clean welcome message with better styling and proper borders
  console.log('\n' + boxen(
    gradients.title('✨ Welcome to DataPilot Interactive Terminal UI! ✨') + '\n\n' +
    gradients.success('🎯 Perfect for beginners and experts alike') + '\n' +
    gradients.info('🎨 Beautiful insights and visualizations') + '\n' +
    gradients.highlight('🤖 AI-ready analysis generation') + '\n' +
    gradients.accent('🚀 Zero installation, maximum insights') + '\n\n' +
    gradients.subtle('Navigate: ↑↓ arrows | Select: Enter | Exit: Ctrl+C'),
    {
      padding: 1,
      margin: 1,
      borderStyle: 'single',
      borderColor: 'cyan',
      title: '⭐ Interactive Data Analysis Engine ⭐',
      titleAlignment: 'center'
    }
  ));
  
  // Animated loading effect - removed artificial delay
  const spinner = distExports.createSpinner('Initializing DataPilot...').start();
  spinner.success({ text: 'Ready to analyze your data! 🎉' });
  
  console.log();
}

async function showGoodbyeAnimation() {
  console.clear();
  
  const farewellArt = `
  ╔══════════════════════════════════════════════════════════════╗
  ║                    🛩️ DataPilot Signing Off 🛩️                ║
  ╚══════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.sunset(farewellArt));
  
  console.log('\n' + boxen(
    gradients.cyan('Thank you for using DataPilot! 🙏') + '\n\n' +
    gradients.green('🎯 Data insights discovered') + '\n' +
    gradients.blue('📊 Knowledge gained') + '\n' +
    gradients.yellow('🚀 Analysis complete') + '\n\n' +
    gradients.ocean('Come back soon for more data adventures! 📈✨'),
    {
      padding: 1,
      margin: 1,
      borderStyle: 'round',
      borderColor: 'yellow',
      title: '👋 Farewell Message',
      titleAlignment: 'center'
    }
  ));
  
  console.log('\n' + gradients.rainbow('   ▶ Happy analyzing! Keep discovering insights! ◀') + '\n');
}

async function showAboutInfo() {
  console.clear();
  
  const aboutHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                   📋 ABOUT DATAPILOT 📋                    ║
  ║                  Your Data Analysis Co-Pilot                ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.title(aboutHeader));
  
  console.log('\\n' + boxen(
    gradients.cyan('DataPilot v1.1.0\\n\\n') +
    gradients.green('🛩️ Your Data Analysis Co-Pilot\\n') +
    gradients.blue('📊 Comprehensive CSV analysis suite\\n') +
    gradients.yellow('🤖 AI-ready context generation\\n') +
    gradients.magenta('🔍 Data quality & integrity checks\\n') +
    gradients.white('📈 Visualization recommendations\\n') +
    gradients.cyan('🏗️ Data engineering archaeology\\n\\n') +
    gradients.subtle('Built with Node.js + modern CLI tools\\n') +
    gradients.subtle('Open source & actively maintained\\n') +
    gradients.subtle('Created for analysts by analysts'),
    {
      padding: 1,
      borderColor: 'cyan',
      title: '📊 System Information',
      titleAlignment: 'center'
    }
  ));
  
  await safePrompt({ type: 'confirm', name: 'continue', message: '\\nPress Enter to continue...' });
}


async function showSettings(engine, result) {
  console.clear();
  
  // Enhanced settings header
  const settingsHeader = `
  ╔═════════════════════════════════════════════════════════════╗
  ║                ⚙️  SETTINGS & PREFERENCES ⚙️                ║
  ║                Configure DataPilot behavior                  ║
  ╚═════════════════════════════════════════════════════════════╝`;
  
  console.log(gradients.blue(settingsHeader));
  
  console.log('\\n' + boxen(
    gradients.yellow('🛠️  Configuration Options Coming Soon! 🛠️\\n\\n') +
    'Settings will include:\\n' +
    gradients.green('• 🎨 Color Theme Selection\\n') +
    gradients.blue('• 📊 Default Analysis Types\\n') +
    gradients.cyan('• 💾 Memory Management Preferences\\n') +
    gradients.magenta('• 📁 Default File Search Paths\\n') +
    gradients.yellow('• ⚡ Performance Optimization\\n') +
    gradients.red('• 🔔 Notification Preferences'),
    {
      padding: 1,
      borderStyle: 'round',
      borderColor: 'blue',
      title: '⚙️  Customization',
      titleAlignment: 'center'
    }
  ));
  
  console.log();
  
  // Provide actual navigation menu instead of just confirmation
  let inSettings = true;
  while (inSettings) {
    const response = await safePrompt({
      type: 'select',
      name: 'action',
      message: gradients.cyan('What would you like to do?'),
      choices: [
        {
          name: 'themes',
          message: '🎨 Color Themes (Coming Soon)',
          hint: 'Customize DataPilot appearance'
        },
        {
          name: 'defaults',
          message: '📊 Default Analysis Types (Coming Soon)',
          hint: 'Set preferred analysis modes'
        },
        {
          name: 'memory',
          message: '💾 Memory Preferences (Coming Soon)',
          hint: 'Configure knowledge storage'
        },
        {
          name: 'paths',
          message: '📁 File Search Paths (Coming Soon)',
          hint: 'Set default directories'
        },
        {
          name: 'performance',
          message: '⚡ Performance Options (Coming Soon)',
          hint: 'Optimize for your system'
        },
        {
          name: 'about',
          message: '📋 About DataPilot',
          hint: 'Version and system information'
        },
        {
          name: 'back',
          message: '⬅️  Back to Main Menu',
          hint: 'Return to main menu'
        }
      ]
    });
    
    switch (response.action) {
      case 'about':
        await showAboutInfo();
        break;
      case 'back':
        inSettings = false;
        break;
      default:
        console.log(gradients.yellow('\\n⚠️  This feature is coming soon!'));
        await safePrompt({ type: 'confirm', name: 'continue', message: 'Press Enter to continue...' });
        break;
    }
  }
}

// ASCII art banner with version
const VERSION = '1.1.1';
const banner = `
╔═══════════════════════════════════════╗
║          ${chalk.cyan('DataPilot CLI')}              ║
║    ${chalk.gray('Simple & LLM-Ready Analysis')}      ║
║         ${chalk.yellow(`Version ${VERSION}`)}             ║
╚═══════════════════════════════════════╝
`;

console.log(banner);

// Configure program
program
  .name('datapilot')
  .description('CSV analysis tool optimized for LLM consumption')
  .version(VERSION);

// Enhanced file validation with better error messages
function validateFile(filePath) {
  try {
    // Use enhanced path normalization
    const resolvedPath = normalizePath(filePath);
    
    if (!existsSync(resolvedPath)) {
      // Provide helpful error message for common issues
      console.error(chalk.red(`❌ Error: File not found: ${filePath}`));
      
      // Check if it's a path with spaces issue
      if (filePath.includes(' ') && !filePath.startsWith('"')) {
        console.error(chalk.yellow(`💡 Tip: For paths with spaces, use quotes: "${filePath}"`));
      }
      
      // Check if it's a relative path issue
      if (!path$1.isAbsolute(filePath)) {
        const suggestedPath = path$1.resolve(filePath);
        console.error(chalk.yellow(`💡 Tip: Try using the full path: ${suggestedPath}`));
      }
      
      process.exit(1);
    }
    
    if (!filePath.toLowerCase().endsWith('.csv')) {
      console.error(chalk.red(`❌ Error: File must be a CSV file: ${filePath}`));
      console.error(chalk.yellow(`💡 Tip: DataPilot works with CSV files only`));
      process.exit(1);
    }
    
    return resolvedPath;
  } catch (error) {
    console.error(chalk.red(`❌ Error validating file: ${error.message}`));
    process.exit(1);
  }
}

// Progress tracking wrapper for commands
async function runWithProgress(command, filePath, options) {
  const spinner = ora({
    text: 'Initializing analysis...',
    color: 'cyan'
  }).start();
  
  try {
    // Add progress callback to options
    const enhancedOptions = {
      ...options,
      onProgress: (progress, details) => {
        if (progress < 100) {
          spinner.text = `Processing: ${Math.round(progress)}%${details ? ` - ${details}` : ''}`;
        } else {
          spinner.text = 'Finalizing analysis...';
        }
      }
    };
    
    spinner.stop();
    const result = await command(filePath, enhancedOptions);
    // Ensure process exits cleanly after successful completion
    process.exit(0);
    return result;
  } catch (error) {
    spinner.fail(`Analysis failed: ${error.message}`);
    console.error(chalk.red('Analysis failed'));
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

// ALL command - run complete analysis suite
program
  .command('all <file>')
  .description('Run complete analysis suite - all commands in one go')
  .option('-o, --output <path>', 'Save analysis to file')
  .option('-q, --quick', 'Quick mode - skip detailed analyses for speed')
  .option('--no-header', 'CSV file has no header row')
  .option('--encoding <encoding>', 'Force specific encoding (utf8, latin1, etc.)')
  .option('--delimiter <delimiter>', 'Force specific delimiter (comma, semicolon, tab, pipe)')
  .option('--timeout <ms>', 'Set timeout in milliseconds (default: 60000)', '60000')
  .option('--force', 'Continue analysis despite data quality warnings')
  .action(async (file, options) => {
    const filePath = validateFile(file);
    // Convert timeout to number
    if (options.timeout) options.timeout = parseInt(options.timeout);
    await runWithProgress(runAll, filePath, options);
  });

// EDA command
program
  .command('eda <file>')
  .description('Exploratory Data Analysis - comprehensive statistical analysis')
  .option('-o, --output <path>', 'Save analysis to file')
  .option('-q, --quick', 'Quick mode - basic statistics only')
  .option('--no-header', 'CSV file has no header row')
  .option('--encoding <encoding>', 'Force specific encoding (utf8, latin1, etc.)')
  .option('--delimiter <delimiter>', 'Force specific delimiter (comma, semicolon, tab, pipe)')
  .option('--timeout <ms>', 'Set timeout in milliseconds (default: 30000)', '30000')
  .option('--force', 'Continue analysis despite data quality warnings')
  .action(async (file, options) => {
    const filePath = validateFile(file);
    // Convert timeout to number
    if (options.timeout) options.timeout = parseInt(options.timeout);
    await runWithProgress(eda, filePath, options);
  });

// INT command
program
  .command('int <file>')
  .description('Data Integrity Check - find quality issues and inconsistencies')
  .option('-o, --output <path>', 'Save analysis to file')
  .option('--no-header', 'CSV file has no header row')
  .option('--encoding <encoding>', 'Force specific encoding (utf8, latin1, etc.)')
  .option('--delimiter <delimiter>', 'Force specific delimiter (comma, semicolon, tab, pipe)')
  .option('--force', 'Continue analysis despite data quality warnings')
  .action(async (file, options) => {
    const filePath = validateFile(file);
    await runWithProgress(integrity, filePath, options);
  });

// VIS command
program
  .command('vis <file>')
  .description('Visualization Recommendations - what charts would be most insightful')
  .option('-o, --output <path>', 'Save analysis to file')
  .option('--no-header', 'CSV file has no header row')
  .option('--encoding <encoding>', 'Force specific encoding (utf8, latin1, etc.)')
  .option('--delimiter <delimiter>', 'Force specific delimiter (comma, semicolon, tab, pipe)')
  .option('--force', 'Continue analysis despite data quality warnings')
  .action(async (file, options) => {
    const filePath = validateFile(file);
    await runWithProgress(visualize, filePath, options);
  });

// ENG command - Data Archaeology System with subcommands
const eng = program.command('eng');
eng.description('Data Engineering Archaeology - builds collective intelligence about your warehouse');

// Default action for single file (backward compatible)
eng
  .argument('[file]', 'CSV file to analyze')
  .option('-o, --output <path>', 'Save analysis to file')
  .option('--no-header', 'CSV file has no header row')
  .option('--encoding <encoding>', 'Force specific encoding (utf8, latin1, etc.)')
  .option('--delimiter <delimiter>', 'Force specific delimiter (comma, semicolon, tab, pipe)')
  .option('--force', 'Continue analysis despite data quality warnings')
  .action(async (file, options) => {
    if (file) {
      const filePath = validateFile(file);
      await runWithProgress(engineering, filePath, options);
    } else {
      // Show help if no file provided
      eng.help();
    }
  });

// Subcommand: analyze multiple files
eng
  .command('analyze <files...>')
  .description('Analyze multiple CSV files and detect relationships')
  .option('--no-header', 'CSV files have no header row')
  .option('--encoding <encoding>', 'Force specific encoding for all files')
  .option('--delimiter <delimiter>', 'Force specific delimiter for all files')
  .option('--force', 'Continue analysis despite data quality warnings')
  .action(async (files, options) => {
    const { glob } = await Promise.resolve().then(function () { return index; });
    console.log(chalk.blue('🏛️  Starting multi-file warehouse analysis...\n'));
    
    // Process all files (including glob patterns)
    const allFiles = [];
    for (const pattern of files) {
      if (pattern.includes('*')) {
        try {
          // Handle Windows paths in glob patterns
          const normalizedPattern = os$1.platform() === 'win32' 
            ? pattern.replace(/\\/g, '/')
            : pattern;
          const matches = await glob(normalizedPattern, { nodir: true });
          allFiles.push(...matches.filter(f => f.endsWith('.csv')));
        } catch (error) {
          console.error(chalk.red(`Error with pattern ${pattern}: ${error.message}`));
        }
      } else {
        allFiles.push(pattern);
      }
    }
    
    // Validate all files
    const filePaths = [];
    for (const file of allFiles) {
      try {
        const validated = validateFile(file);
        filePaths.push(validated);
      } catch (error) {
        console.error(chalk.red(`Skipping invalid file: ${file}`));
      }
    }
    
    if (filePaths.length === 0) {
      console.error(chalk.red('❌ No valid CSV files found'));
      process.exit(1);
    }
    
    console.log(chalk.green(`✓ Found ${filePaths.length} CSV files to analyze\n`));
    
    // Analyze each file with progress
    for (const filePath of filePaths) {
      console.log(chalk.cyan(`\nAnalyzing ${basename(filePath)}...`));
      
      const spinner = ora({
        text: 'Processing...',
        color: 'cyan'
      }).start();
      
      try {
        await engineering(filePath, { 
          ...options, 
          quiet: true, 
          autoSave: true,
          onProgress: (progress) => {
            spinner.text = `Processing: ${Math.round(progress)}%`;
          }
        });
        spinner.succeed(`Completed ${basename(filePath)}`);
      } catch (error) {
        spinner.fail(`Failed: ${error.message}`);
        console.error(chalk.red('Analysis failed'));
        if (error.stack) {
          console.error(error.stack);
        }
        process.exit(1);
      }
    }
    
    // Show relationships and generate report
    console.log(chalk.green('\n✅ All files analyzed!'));
    console.log(chalk.blue('\nGenerating warehouse map and relationships...\n'));
    await engineering(null, { showMap: true });
  });

// Subcommand: save insights
eng
  .command('save <table> [insights]')
  .description('Save LLM insights for a table (can pipe from stdin)')
  .action(async (table, insights) => {
    let finalInsights = insights;
    
    // If no insights provided, try to read from stdin
    if (!insights && !process.stdin.isTTY) {
      const chunks = [];
      for await (const chunk of process.stdin) {
        chunks.push(chunk);
      }
      finalInsights = Buffer.concat(chunks).toString().trim();
    }
    
    if (!finalInsights) {
      console.error(chalk.red('❌ Error: Please provide insights either as argument or via stdin'));
      console.log('\nExamples:');
      console.log('  datapilot eng save orders "PURPOSE: Transaction fact table..."');
      console.log('  echo "PURPOSE: Transaction fact table..." | datapilot eng save orders');
      process.exit(1);
    }
    
    await engineering(null, { saveInsights: [table, finalInsights] });
  });

// Subcommand: generate report
eng
  .command('report')
  .description('Generate comprehensive warehouse report from all analyses')
  .option('-o, --output <path>', 'Save report to file')
  .action(async (options) => {
    await engineering(null, { compileKnowledge: true, ...options });
  });

// Subcommand: show map
eng
  .command('map')
  .description('Display warehouse domain map')
  .action(async () => {
    await engineering(null, { showMap: true });
  });

// LLM command
program
  .command('llm <file>')
  .description('LLM Context Generation - perfect summary for AI analysis')
  .option('-o, --output <path>', 'Save analysis to file')
  .option('--no-header', 'CSV file has no header row')
  .option('--encoding <encoding>', 'Force specific encoding (utf8, latin1, etc.)')
  .option('--delimiter <delimiter>', 'Force specific delimiter (comma, semicolon, tab, pipe)')
  .option('--timeout <ms>', 'Set timeout in milliseconds (default: 60000)', '60000')
  .option('--force', 'Continue analysis despite data quality warnings')
  .option('--comprehensive <bool>', 'Use comprehensive analysis (default: true)', 'true')
  .action(async (file, options) => {
    const filePath = validateFile(file);
    // Convert timeout to number
    if (options.timeout) options.timeout = parseInt(options.timeout);
    // Convert comprehensive to boolean
    if (options.comprehensive) options.comprehensive = options.comprehensive === 'true';
    await runWithProgress(llmContext, filePath, options);
  });

// UI command - Interactive Terminal Interface
program
  .command('ui')
  .description('🎨 Interactive UI - Fun, colorful, beginner-friendly interface')
  .action(async () => {
    // Check terminal capabilities
    if (process.platform === 'win32' && !process.env.WT_SESSION) {
      console.log(chalk.yellow('⚠️  Note: For best experience on Windows, use Windows Terminal'));
    }
    await interactiveUI();
  });

// Help text with enhanced examples
program.on('--help', () => {
  console.log('');
  console.log(chalk.cyan('Examples:'));
  console.log('  $ datapilot all data.csv                    # Run complete analysis');
  console.log('  $ datapilot all "C:\\My Data\\sales.csv"      # Path with spaces (use quotes)');
  console.log('  $ datapilot all data.csv -o analysis.txt    # Save to file');
  console.log('  $ datapilot all data.csv --quick            # Quick mode');
  console.log('  $ datapilot eda sales.csv --encoding latin1 # Force encoding');
  console.log('  $ datapilot int data.csv --delimiter ";"    # Force delimiter');
  console.log('');
  console.log(chalk.cyan('Data Archaeology Workflow:'));
  console.log('  1. Analyze all tables: datapilot eng analyze *.csv');
  console.log('  2. Copy LLM prompts and get insights from your AI');
  console.log('  3. Save insights: datapilot eng save <table> "<insights>"');
  console.log('  4. Generate report: datapilot eng report');
  console.log('');
  console.log(chalk.cyan('Common Options:'));
  console.log('  -o, --output <path>      Save analysis to file');
  console.log('  -q, --quick              Quick mode - skip detailed analyses');
  console.log('  --no-header              CSV has no header row');
  console.log('  --encoding <type>        Force encoding (utf8, latin1, utf16le)');
  console.log('  --delimiter <char>       Force delimiter (comma, semicolon, tab, pipe)');
  console.log('  --timeout <ms>           Set timeout in milliseconds (default: 30s for EDA, 60s for LLM)');
  console.log('  --force                  Continue analysis despite data quality warnings');
  console.log('  --comprehensive          Use comprehensive analysis for LLM mode (default: true)');
  console.log('');
  console.log(chalk.cyan('Troubleshooting:'));
  console.log('  • For paths with spaces, use quotes: "C:\\My Folder\\data.csv"');
  console.log('  • For encoding issues, try: --encoding latin1');
  console.log('  • For delimiter issues, try: --delimiter ";"');
  console.log('  • For large files, quick mode is recommended: --quick');
  console.log('  • If analysis hangs, try: --timeout 120000 (2 minutes)');
  console.log('  • For data quality issues, try: --force');
  console.log('');
  console.log(chalk.gray('Output:'));
  console.log(chalk.gray('  All commands produce verbose text output optimized for'));
  console.log(chalk.gray('  copying into ChatGPT, Claude, or any other LLM.'));
});

// Enhanced error handling
process.on('uncaughtException', (error) => {
  console.error(chalk.red('\n❌ Unexpected error:'), error.message);
  
  // Provide helpful suggestions based on error type
  if (error.message.includes('ENOENT')) {
    console.error(chalk.yellow('💡 File not found. Check the file path and try again.'));
  } else if (error.message.includes('EACCES')) {
    console.error(chalk.yellow('💡 Permission denied. Check file permissions.'));
  } else if (error.message.includes('encoding')) {
    console.error(chalk.yellow('💡 Try specifying encoding: --encoding latin1'));
  } else if (error.message.includes('memory')) {
    console.error(chalk.yellow('💡 Out of memory. Try --quick mode or process smaller files.'));
  }
  
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error(chalk.red('\n❌ Unhandled promise rejection:'), reason);
  process.exit(1);
});

// Parse arguments
program.parse(process.argv);

// Show help if no command provided
if (!process.argv.slice(2).length) {
  program.outputHelp();
}

var balancedMatch;
var hasRequiredBalancedMatch;

function requireBalancedMatch () {
	if (hasRequiredBalancedMatch) return balancedMatch;
	hasRequiredBalancedMatch = 1;
	balancedMatch = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    if(a===b) {
	      return [ai, bi];
	    }
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}
	return balancedMatch;
}

var braceExpansion;
var hasRequiredBraceExpansion;

function requireBraceExpansion () {
	if (hasRequiredBraceExpansion) return braceExpansion;
	hasRequiredBraceExpansion = 1;
	var balanced = requireBalancedMatch();

	braceExpansion = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m) return [str];

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  if (/\$$/.test(m.pre)) {    
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre+ '{' + m.body + '}' + post[k];
	      expansions.push(expansion);
	    }
	  } else {
	    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	    var isSequence = isNumericSequence || isAlphaSequence;
	    var isOptions = m.body.indexOf(',') >= 0;
	    if (!isSequence && !isOptions) {
	      // {a},b}
	      if (m.post.match(/,.*\}/)) {
	        str = m.pre + '{' + m.body + escClose + m.post;
	        return expand(str);
	      }
	      return [str];
	    }

	    var n;
	    if (isSequence) {
	      n = m.body.split(/\.\./);
	    } else {
	      n = parseCommaParts(m.body);
	      if (n.length === 1) {
	        // x{{a,b}}y ==> x{a}y x{b}y
	        n = expand(n[0], false).map(embrace);
	        if (n.length === 1) {
	          return post.map(function(p) {
	            return m.pre + n[0] + p;
	          });
	        }
	      }
	    }

	    // at this point, n is the parts, and we know it's not a comma set
	    // with a single entry.
	    var N;

	    if (isSequence) {
	      var x = numeric(n[0]);
	      var y = numeric(n[1]);
	      var width = Math.max(n[0].length, n[1].length);
	      var incr = n.length == 3
	        ? Math.abs(numeric(n[2]))
	        : 1;
	      var test = lte;
	      var reverse = y < x;
	      if (reverse) {
	        incr *= -1;
	        test = gte;
	      }
	      var pad = n.some(isPadded);

	      N = [];

	      for (var i = x; test(i, y); i += incr) {
	        var c;
	        if (isAlphaSequence) {
	          c = String.fromCharCode(i);
	          if (c === '\\')
	            c = '';
	        } else {
	          c = String(i);
	          if (pad) {
	            var need = width - c.length;
	            if (need > 0) {
	              var z = new Array(need + 1).join('0');
	              if (i < 0)
	                c = '-' + z + c.slice(1);
	              else
	                c = z + c;
	            }
	          }
	        }
	        N.push(c);
	      }
	    } else {
	      N = [];

	      for (var j = 0; j < n.length; j++) {
	        N.push.apply(N, expand(n[j], false));
	      }
	    }

	    for (var j = 0; j < N.length; j++) {
	      for (var k = 0; k < post.length; k++) {
	        var expansion = pre + N[j] + post[k];
	        if (!isTop || isSequence || expansion)
	          expansions.push(expansion);
	      }
	    }
	  }

	  return expansions;
	}
	return braceExpansion;
}

var braceExpansionExports = requireBraceExpansion();
var expand = /*@__PURE__*/getDefaultExportFromCjs(braceExpansionExports);

const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};

/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};

// parse a single path portion
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark$1 = '[^/]';
// * => any number of characters
const star$1 = qmark$1 + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark$1 + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || false
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star$1 +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star$1;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark$1;
                hasMagic = true;
                continue;
            }
            re += regExpEscape$1(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}

/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};

const minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform$2 = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
const sep = defaultPlatform$2 === 'win32' ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform$2;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            return pp.filter(p => p !== GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof Stream ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
class Minipass extends EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}

const realpathSync = realpathSync$1.native;
const defaultFS = {
    lstatSync,
    readdir: readdir$1,
    readdirSync,
    readlinkSync,
    realpathSync,
    promises: {
        lstat,
        readdir,
        readlink,
        realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ?
    defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = -16;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH = 0b0010_0000_0000;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 0b0011_1111_1111;
const entToType = (s) => s.isFile() ? IFREG
    : s.isDirectory() ? IFDIR
        : s.isSymbolicLink() ? IFLNK
            : s.isCharacterDevice() ? IFCHR
                : s.isBlockDevice() ? IFBLK
                    : s.isSocket() ? IFSOCK
                        : s.isFIFO() ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
class ResolveCache extends LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
class ChildrenCache extends LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
        return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     *
     * @deprecated
     */
    get path() {
        return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ?
            this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= -17;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.isCWD)
            return '';
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.isCWD)
            return '';
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return (this.isUnknown() ? 'Unknown'
            : this.isDirectory() ? 'Directory'
                : this.isFile() ? 'File'
                    : this.isSymbolicLink() ? 'SymbolicLink'
                        : this.isFIFO() ? 'FIFO'
                            : this.isCharacterDevice() ? 'CharacterDevice'
                                : this.isBlockDevice() ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
                                        : 'Unknown');
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase ?
            this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.realpathSync()?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR)
            t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === 'ENOENT')
            ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp, '$1\\');
        return rootPath === compare;
    }
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = fileURLToPath(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map(e => e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else if (withFileTypes) {
            return entry.readdirSync();
        }
        else {
            return entry.readdirSync().map(e => e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
const PathScurry = process.platform === 'win32' ? PathScurryWin32
    : process.platform === 'darwin' ? PathScurryDarwin
        : PathScurryPosix;

// this is just a very light wrapper around 2 arrays with an offset index
const isPatternList = (pl) => pl.length >= 1;
const isGlobList = (gl) => gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */
class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
            throw new TypeError('empty pattern list');
        }
        if (!isGlobList(globList)) {
            throw new TypeError('empty glob list');
        }
        if (globList.length !== patternList.length) {
            throw new TypeError('mismatched pattern list and glob list lengths');
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError('index out of range');
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [p0, p1, p2, p3, ''].join('/');
                const g = [g0, g1, g2, g3, ''].join('/');
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
            else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + '/';
                const g = g1 + '/';
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
        return typeof this.#patternList[this.#index] === 'string';
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
        return (this.#globString =
            this.#globString ||
                (this.#index === 0 ?
                    this.isAbsolute() ?
                        this.#globList[0] + this.#globList.slice(1).join('/')
                        : this.#globList.join('/')
                    : this.#globList.slice(this.#index).join('/')));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
        if (this.#rest !== undefined)
            return this.#rest;
        if (!this.hasMore())
            return (this.#rest = null);
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined ?
            this.#isUNC
            : (this.#isUNC =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    pl[0] === '' &&
                    pl[1] === '' &&
                    typeof pl[2] === 'string' &&
                    !!pl[2] &&
                    typeof pl[3] === 'string' &&
                    !!pl[3]);
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined ?
            this.#isDrive
            : (this.#isDrive =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    this.length > 1 &&
                    typeof pl[0] === 'string' &&
                    /^[a-z]:$/i.test(pl[0]));
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined ?
            this.#isAbsolute
            : (this.#isAbsolute =
                (pl[0] === '' && pl.length > 1) ||
                    this.isDrive() ||
                    this.isUNC());
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
        const p = this.#patternList[0];
        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
            p
            : '';
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
        return !(this.#index === 0 ||
            !this.isGlobstar() ||
            !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
            return false;
        this.#followGlobstar = false;
        return true;
    }
}

// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode
const defaultPlatform$1 = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * Class used to process ignored patterns
 */
class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform$1, }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true,
        };
        for (const ign of ignored)
            this.add(ign);
    }
    add(ign) {
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        const mm = new Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
            const parsed = mm.set[i];
            const globParts = mm.globParts[i];
            /* c8 ignore start */
            if (!parsed || !globParts) {
                throw new Error('invalid pattern object');
            }
            // strip off leading ./ portions
            // https://github.com/isaacs/node-glob/issues/570
            while (parsed[0] === '.' && globParts[0] === '.') {
                parsed.shift();
                globParts.shift();
            }
            /* c8 ignore stop */
            const p = new Pattern(parsed, globParts, 0, this.platform);
            const m = new Minimatch(p.globString(), this.mmopts);
            const children = globParts[globParts.length - 1] === '**';
            const absolute = p.isAbsolute();
            if (absolute)
                this.absolute.push(m);
            else
                this.relative.push(m);
            if (children) {
                if (absolute)
                    this.absoluteChildren.push(m);
                else
                    this.relativeChildren.push(m);
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || '.';
        const relatives = `${relative}/`;
        for (const m of this.relative) {
            if (m.match(relative) || m.match(relatives))
                return true;
        }
        for (const m of this.absolute) {
            if (m.match(fullpath) || m.match(fullpaths))
                return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + '/';
        const relative = (p.relative() || '.') + '/';
        for (const m of this.relativeChildren) {
            if (m.match(relative))
                return true;
        }
        for (const m of this.absoluteChildren) {
            if (m.match(fullpath))
                return true;
        }
        return false;
    }
}

// synchronous utility for filtering entries and calculating subwalks
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache =
            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined ?
                    this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith('.')) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                }
                else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    }
                    else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === 'string' &&
                // dots and empty were handled already
                rp !== '..' &&
                rp !== '' &&
                rp !== '.') {
                this.testString(e, rp, rest.rest(), absolute);
            }
            else if (rp === '..') {
                /* c8 ignore start */
                const ep = e.parent || e;
                /* c8 ignore stop */
                this.subwalks.add(ep, rest);
            }
            else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
}

/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new Ignore([ignore], opts)
    : Array.isArray(ignore) ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
            if (!this.includeChildMatches &&
                typeof this.#ignore.add !== 'function') {
                const m = 'cannot ignore child matches, ignore lacks add() method.';
                throw new Error(m);
            }
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return (e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)) ?
            e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        // we know we have an ignore if this is false, but TS doesn't
        if (!this.includeChildMatches && this.#ignore?.add) {
            const ign = `${e.relativePosix()}/**`;
            this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
                '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
}
class GlobWalker extends GlobUtil {
    matches = new Set();
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej) => {
            this.walkCB(this.path, this.patterns, () => {
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                }
                else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, () => {
            if (this.signal?.aborted)
                throw this.signal.reason;
        });
        return this.matches;
    }
}
class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new Minipass({
            signal: this.signal,
            objectMode: true,
        });
        this.results.on('drain', () => this.resume());
        this.results.on('resume', () => this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
            this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(() => {
                this.walkCB(target, this.patterns, () => this.results.end());
            });
        }
        else {
            this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
    }
}

// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const defaultPlatform = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * An object that can perform glob pattern traversals.
 */
class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
        /* c8 ignore start */
        if (!opts)
            throw new TypeError('glob options required');
        /* c8 ignore stop */
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = '';
        }
        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
            opts.cwd = fileURLToPath(opts.cwd);
        }
        this.cwd = opts.cwd || '';
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth =
            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error('cannot set absolute and withFileTypes:true');
        }
        if (typeof pattern === 'string') {
            pattern = [pattern];
        }
        this.windowsPathsNoEscape =
            !!opts.windowsPathsNoEscape ||
                opts.allowWindowsEscape ===
                    false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map(p => p.replace(/\\/g, '/'));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError('base matching requires globstar');
            }
            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined &&
                opts.nocase !== opts.scurry.nocase) {
                throw new Error('nocase option contradicts provided scurry option');
            }
        }
        else {
            const Scurry = opts.platform === 'win32' ? PathScurryWin32
                : opts.platform === 'darwin' ? PathScurryDarwin
                    : opts.platform ? PathScurryPosix
                        : PathScurry;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs,
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug,
        };
        const mms = this.pattern.map(p => new Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
            const g = globParts[i];
            /* c8 ignore start */
            if (!g)
                throw new Error('invalid pattern object');
            /* c8 ignore stop */
            return new Pattern(set, g, 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...(await new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walk()),
        ];
    }
    walkSync() {
        return [
            ...new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walkSync(),
        ];
    }
    stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).stream();
    }
    streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}

/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */
const hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
        pattern = [pattern];
    }
    for (const p of pattern) {
        if (new Minimatch(p, options).hasMagic())
            return true;
    }
    return false;
};

function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
}
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
const streamSync = globStreamSync;
const stream = Object.assign(globStream, { sync: globStreamSync });
const iterateSync = globIterateSync;
const iterate = Object.assign(globIterate, {
    sync: globIterateSync,
});
const sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync,
});
const glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape,
});
glob.glob = glob;

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Glob: Glob,
	Ignore: Ignore,
	escape: escape,
	glob: glob,
	globIterate: globIterate,
	globIterateSync: globIterateSync,
	globStream: globStream,
	globStreamSync: globStreamSync,
	globSync: globSync,
	hasMagic: hasMagic,
	iterate: iterate,
	iterateSync: iterateSync,
	stream: stream,
	streamSync: streamSync,
	sync: sync,
	unescape: unescape
});
